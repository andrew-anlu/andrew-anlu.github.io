
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>安路的技术博客</title>
  <meta name="author" content="安路">

  
  <meta name="description" content="Carthage官网已经针对cocopods和carthage进行了详细的说明： ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andrew-anlu.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="安路的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">安路的技术博客</a></h1>
  
    <h2>Nothing in life is to be feared. It is only to be understood</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://andrew-anlu.github.io" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andrew-anlu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">使用Carthage管理ios依赖</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-28T15:55:02+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>3:55 pm</span></time>
        
           | <a href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/Carthage/Carthage.git">Carthage</a>官网已经针对cocopods和carthage进行了详细的说明：</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/22/ip-tcp-he-http/">IP TCP 和HTTP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-22T10:04:46+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:04 am</span></time>
        
           | <a href="/blog/2016/11/22/ip-tcp-he-http/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当app和服务器进行通信的额时候，大多数情况下，都是采用http协议。http最初是为web浏览器而定制的，如果在浏览器输入 <code>http://www.baidu.com</code>。浏览器就会通过http协议和baidu所对应的服务器进行通信。</p>

<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Application Layer -- e.g. HTTP
</span><span class='line'>----
</span><span class='line'>Transport Layer -- e.g. TCP
</span><span class='line'>----
</span><span class='line'>Internet Layer -- e.g. IP
</span><span class='line'>----
</span><span class='line'>Link Layer -- e.g. IEEE 802.2</span></code></pre></td></tr></table></div></figure>


<p>所谓的<a href="https://en.wikipedia.org/wiki/OSI_model">OSI(Open Systems Interconnnection),开放式系统互联</a>模型定义了七层结构。本文会关注应用层(application layer)传输层(transport layer)和网络层(internet layer),他们分别代表了典型的HTTP的应用的HTTP,TCP,以及IP.在ip之下的是数据连接和物理层级，比如像Ethernet的实现之类的东西</p>

<p>如上文所述，我们只关注应用层，传输层和网络层部分，更确切的说，着重探讨一种特殊的混合模式：基于IP的TCP,以及基于TCP实现的HTTP.这就是我们每天使用的app的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的HTTP问题产生的原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只是HTTP一种，HTTP之所以被广泛使用的原因是其非常稳定，易用，即便是防火墙一般也是允许HTTP协议穿透的。</p>

<p>接下来，我们从最低的一层谈起，说说IP网络协议。</p>

<h3>IP网络协议(IP_Internet Protocol)</h3>

<p>TCP/IP 中的Ip是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议(Internet Protocol)</a>的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP实现了分组交换网络，在协议下，机器被叫做主机(host)，IP协议明确了host之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制的数据，其中包含了发送源主机和目标主机的信息。IP网络负责源主机和目标主机之间的数据包传输。IP协议的特点是best effort(尽力服务，其目标是提供有效服务并尽力传输)。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包</p>

<p>IP网络中的主机都配有自己的地址，被称为IP地址。每个数据包中都包含了源主机和目标主机的IP地址，IP协议负责路径计算，即IP数据包在网络中的传输时，数据包所经过的灭一个主机几点都会读取数据包中的目标主机地址信息，以便选择朝着什么地方传输数据包</p>

<p>今天，绝大多数的数据包仍旧是IPv4的，每一个IPV4的地址的长度是32位的，常见采用dotted-decimal(点分十进制)表示法，具体形式如下：198.51.100.42</p>

<p>新的IPv6标准也正在逐渐推广中。它有更大的地址空间：长度为128位，这使得数据包在网络中传输中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，注入网络地址转换等问题也迎刃而解。IPv6的表示形式为:八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2>IP Header</h2>

<p>一个ip数据包通常包含header（报头信息）和payload（有效载荷）</p>

<p>payload中的内容即是要传输的真正信息，而header承载的是与传输数据有关的元数据(metadata)</p>

<h3>IPV4 Header</h3>

<p>ipv4的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IPv4 Header Format
</span><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |IHL        |DSCP            |ECN  |Total Length                                   |
</span><span class='line'> 4        32     |Identification                                |Flags   |Fragment Offset                       |
</span><span class='line'> 8        64     |Time To Live           |Protocol              |Header Checksum                                |
</span><span class='line'>12        96     |Source IP Address                                                                             |
</span><span class='line'>16       128     |Destination IP Address                                                                        |
</span><span class='line'>20       160     |Options (if IHL &gt; 5)                                                                          |</span></code></pre></td></tr></table></div></figure>


<p>header长度为20字节（不包含极少用到的可选信息）</p>

<p>header信息中最关键的是源和目标IP地址，除此之外，版本信息是4，代表ipv4.protocol(协议区)代表payload采用的传输协议。TCP的协议号是6.Total Length(总长度区)表明了header加payload整个数据包的大小</p>

<h3>Ipv6 Header</h3>

<p>ipv6的地址长度为128位，IPv6的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |Traffic Class         |Flow Label                                                 |
</span><span class='line'> 4        32     |Payload Length                                |Next Header            |Hop Limit              |
</span><span class='line'> 8        64     |Source Address                                                                                |
</span><span class='line'>12        96     |                                                                                              |
</span><span class='line'>16       128     |                                                                                              |
</span><span class='line'>20       160     |                                                                                              |
</span><span class='line'>24       192     |Destination Address                                                                           |
</span><span class='line'>28       224     |                                                                                              |
</span><span class='line'>32       256     |                                                                                              |
</span><span class='line'>36       288     |                                                                                              |</span></code></pre></td></tr></table></div></figure>


<p>Ipv6 header采用固定长度40字节。经过多年来对Ipv4使用的总结，如今Ipv6的header信息简化了很多。</p>

<p>除了源和目标地址这种必备信息外，IPv6提供专门的next header区域来指明紧跟header的数据是什么。也就是说，Ipv6允许在数据包中将header链接起来，每一个被链接的Ipv6 header 都会有一个next header 字段，直到到达实际的payload数据，比如说，当next header的值为6(TCP的协议号)时，数据包的其它信息就是tcp协议要传输的数据</p>

<h2>Fragmentation(数据分片)</h2>

<p>由于底部链路层对所传输的数据帧有最大长度限制，所以有时候IPV4需要对所传数据包进行分片。具体表现为，如果数据包尺寸超过了索要经过的数据链路层的最大传输限制，路由就会对数据包进行分片，当分片数据到达目标主机后，可以根据分片信息进行数据重组。当然，数据发送源有权决定路由是否启用对传输数据包进行分片，加入所传输的数据超过了输送限制，又禁止了路由分片，发送源会收到<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>的数据帧超长报告信息</p>

<p>在Ipv6中，如果数据包超限制，路由会直接丢弃数据包并且向发送源回传ICMP6的数据帧超长报告信息。源和目标两端会基于这个特性进行<a href="https://en.wikipedia.org/wiki/Path_MTU">路径MTU发现</a>，以此寻找两端之间最大传输单元所在的路由，找到MTU路由后，仅当上层数据包的最小payload确实超过了MTU,IPV6才会进行分片传输，对于IPV6下的tCp来说，这不会造成什么问题。</p>

<h2>TCP-传输控制协议(Transmission Control Protocol)</h2>

<p>TCP层位于IP层之上，是最受欢迎的因特网通讯协议之一，人们通常用TCP/IP来泛指整个因特网协议族。</p>

<p>刚刚提到，IP协议允许两个主机之间传送单一的数据包，为了保证对所传送数据包达到尽力服务的目的，最终的传输结果可能是数据包乱序，重复甚至丢包。</p>

<p>TCP是基于IP 层的协议。但是TCP是可靠地，有序的，有错误检查机制的基于字节流传输的协议。这样当两个设备上的应用通过TCP来传递数据的时候，总能够保证目标接收方收到的数据的顺序和内容与发送方所发出的是一致的。TCP做的这些事看起来很平常，但是比起IP层的粗犷处理方式已经是显著的进步了。</p>

<p>应用程序之间可以通过TCP建立链接，TCP建立的是双向连接，通信双方可以同时进行数据的传输。连接的双方都不需要操心数据是否分块，或者是否采用了尽力服务等。TCP会确保所传输的数据的正确性，即接受方收到的数据与发出方的数据一致。</p>

<p>HTTP是典型的TCP应用，用户浏览器(应用1)与web服务器(应用2)建立连接后，浏览器可以通过连接发送服务请求，web服务器可以通过同样的连接请求作出响应。</p>

<p>同一个host主机上可以有多个应用同时使用TCP协议。TCP用不同的端口来区分应用，作为连接的两端，发送源和接收目标分别拥有自己的IP地址和端口号，凭借这样一对IP地址和端口号，就可以唯一标识一个连接。</p>

<p>使用HTTPS的web服务器会监听443端口，浏览器作为发送源会启用一个临时端口结合自己的IP地址与目标服务器对应的端口和IP地址建立TCP连接。</p>

<p>TCP在IPv4和Ipv6上是无差别运行的。所以如果ipv4和protocol活IPv6的Next Header的协议号被设置为6，表示执行TCP协议。</p>

<h2>TCP Segments (TCP 报文段)</h2>

<p>主机之间传输的数据流一般会先被分块，再转为为TCP报文段，最终会生成IP数据包中的payload的载荷数据</p>

<p>每个TCP报文段都有header信息和对应的载荷payload.payload信息就是待传输的数据块。TCP报文段的header信息中主要包含的是源和目标端口号，至于说源和目标的IP地址信息则已经包含在IP header信息中了。</p>

<p>TCP的报文段header信息中还有报文序列号，确认号等其他一些用于管理连接的信息。</p>

<p>所谓序列号信息，其实就是为每个报文段分配的唯一编号，第一个报文段的序列号是随机的，比如1721092979，其后的每一个报文段的序列号都以此号为基础以此加1，1721092980，1721092981 等等。至于确认号，是目标端反馈给源的确认信息，通知源目前已经接到那些报文段了。由于TCP是双向的，所以数据和确认信息发送也都是双向的。</p>

<h2>TCP连接</h2>

<p>连接管理是TCP的核心功能之一，而且协议需要解决由于IP层采用不可靠传输引发的一系列复杂问题。下面会分别介绍TCP的连接简历，数据传输以及连接终止的详细过程。</p>

<p>TCP连接全过程的状态变化是复杂的，但是大多数情况下还是比较简单的。</p>

<h3>连接建立</h3>

<p>TCP连接都是简历在两个主机之间的。所以，每个连接建立过程中都存在两个角色：一端（例如web服务器）监听连接，另一端(例如应用)主动连接正在监听的一端(web服务器).服务器端的这种监听行为被称为passive open(被动打开)。客户端主动连接服务器的行为称为active open(主动打开)</p>

<p>TCP会通过三次握手来完成连接建立，具体过程是这样的：</p>

<ol>
<li>客户端首先向服务器端发送一个SYn包和一个随机序列号A</li>
<li>服务器端收到回回复客户端一个SYn_ACK包以及各一个确认号（用于确认收到SYN）A+1,同时再发送一个随机序列号B</li>
<li>客户端收到后会发送一个ACK包以及确认号（用于确认收到SYN-ACK）B+1和序列号A+1给服务端</li>
</ol>


<p>SYN是Synchronize sequence numbers（同步序列号）的缩写。两端在传递数据时，所传递的每个TCP报文段都有一个序列号。就是利用这种机制，TCP可以确保分块传输的数据包最终都已正确的个数和顺序抵达目标端。在正式传输开始之前，源和目标端需要同步确认第一个报文的序列号。</p>

<p>ACK 是acknowledgment(确认)的缩写。当某一端接到了报文包后，通过回传已报文序列号来确认接收到报文这件事。</p>

<p>运行如下语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -4 http://www.apple.com/contact/</span></code></pre></td></tr></table></div></figure>


<p>这是通过<code>curl</code>命令与www.apple.com 的 80端口创建一个TCPl连接</p>

<p>www.apple.com所在服务器23.63.125.15（注意，整个 IP 不是固定的）会监听80端口。我们自己的IP地址是<code>10.0.1.6</code>，启用的临时端口52181(这个端口是从可用端口中随机选择的)。利用tcpdump(1)输出的三次握手过程是这样的、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15
</span><span class='line'>18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0
</span><span class='line'>18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0
</span><span class='line'>18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里的信息量很大，下面要逐个分析一下：</p>

<p>最左边的是系统时间。当执行命令的时间是晚上18:31。后面的IP代表的是这些都是IP协议数据包。</p>

<p>接下来看这段10.0.1.6.52181 > 23.63.125.15.80，这一对是源和目标端的IP地址+端口。第一行和第三行是客户端发向服务端的信息，第二行是服务端发向客户端的。tcpdump会自动把端口号加到IP地址后头，比如 10.0.1.6.52181 表示 IP 地址为 10.0.1.6，端口号为 52181。</p>

<p><code>Flags</code>表示TCP报文段header信息中的一些缩写标识：<code>S</code>代表SYN,<code>.</code>代表ACK,<code>P</code>代表PUSH,F是FIN.还有一些其他的标识，这边就不罗列了。注意上面三行Flags中先是携带SYN,接着是SYN-ACK,最后是ACK,这就是三次握手确认的全过程。</p>

<p>另外，第一行中客户端发送了一个随机序列号1721092979（就是上文中所说的A）给服务器，第二行展示的是服务器回传给客户端的确认号<code>1721092980 (A+1)</code>和一个随机序列号 673593777 (B).最后在第三行，客户端将自己的确认号 673593778 (B+1) 发送给服务端.</p>

<h2>其他选项</h2>

<p>当然，在连接建立过程中还会配置一些其他信息。比如第一行中客户端发送的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol]</span></code></pre></td></tr></table></div></figure>


<p>还有第二行服务端发送的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1]</span></code></pre></td></tr></table></div></figure>


<p>其中<code>TS val / ecr</code>是TCP用来创建RTT 往返时间(round-trip time)的。TS val 是发送方的时间戳，ECR 是相应应答时间戳，通常情况下就是发送方收到的最后时间戳。TCP以RTT作为其拥塞控制算法 (congestion-control algorithms) 的依据</p>

<p>连接的两端都发送 sackOK.这样会启用选择性确认(Selective Acknowledagement)机制，使连接双方能够确认收到的字节返回。一般情况下，确认机制只是确认接受方已收到的数据的字节总数。</p>

<p><code>mss</code>选项声明了最大报文长度，表示接收端希望接收的单个报文的最大长度。wscale是窗口放大因子。</p>

<h2>数据传输</h2>

<p>一旦建立了连接，双方就可以互发数据了。发送端所发出的每个报文段都有一个序列号，这个序列号与当下已传送的字节总数有关。接收端会针对已接收的数据包向源端发送确认报文，确认信息同样是由报文header所携带的ACK</p>

<p>假设现在传送的信息是除最后一个报文5字节外，其它都是10字节。具体是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>host A sends segment with seq 10
</span><span class='line'>host A sends segment with seq 20
</span><span class='line'>host A sends segment with seq 30    host B sends segment with ack 10
</span><span class='line'>host A sends segment with seq 35    host B sends segment with ack 20
</span><span class='line'>                                    host B sends segment with ack 30
</span><span class='line'>                                    host B sends segment with ack 35</span></code></pre></td></tr></table></div></figure>


<p>整个机制是双向运转的，A主机会持续的发送数据包。B收到数据包后会向A发送确认信息。A发送数据包的过程不需要等待B的确认。</p>

<p>TCP将流量控制和其它一系列复杂机制结合起来进行拥塞控制。需要处理以下问题：针对丢失的报文采用重发机制，同时还需要动态的调整发送报文的频率。</p>

<p>流量控制的原则是发送方发送数据的速度不能比接收方处理数据的速度快。接收方，也就是所谓的接收窗口会告知发送方自身接收窗口数据缓冲区的大小。从上面tcpdump的输出看，窗口大小是 <code>win 65535</code>,<code>wscale</code>（窗口放大因子）是4.这些数字的意思是说：<code>10.0.1.6</code>主机的接收窗口大小是4＊64 kB = 256 kB,<code>23.63.125.15</code>主机的<code>win</code>是<code>14480</code>,<code>wscale</code>是1，接收窗口约为14kb.总之，不管哪一方作为数据接收方，都会向对方通报自己的接收窗口的大小。</p>

<p>拥塞控制要更负责一些，所有拥塞控制的目标都是要计算出当前网络中数据传输的最佳速率。所谓最佳速率就是要达到一种微妙的平衡。一方面，是希望速度越快越好，另一方面，速度快意味着数据传输多，这样处理性能会打打打折甚至崩溃。而这种超负荷崩溃是分组交换网络的固有特点。当负载过大，数据包之间会产生拥塞，直接导致丢包率急速上升。</p>

<p>拥塞控制还需要充分考虑对流量的影响。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部IP协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估RTT往返时间，然后基于RTT去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致TCP需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP连接往往会是短暂而低效的。在简历连接的初期，TCP协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况作出实时的合理的评估。</p>

<p>之前展示了客户单和服务端之间交换的三段报文，再看看关于连接的其它信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.150955 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [P.], seq 1721092980:1721093065, ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 85
</span><span class='line'>18:31:29.161213 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], ack 1721093065, win 7240, options [nop,nop,TS val 1433256633 ecr 743929773], length 0</span></code></pre></td></tr></table></div></figure>


<p>客户端<code>10.0.1.6</code>发送的第一段报文长度是85 bytes(http请求)。由于在上一个报文发送后没有收到来自服务端的信息，所以ACK确认号值不变。</p>

<p>服务端 <code>23.63.125.15</code>只是对接收客户端的数据进行确认回复，没有向客户端发送数据，所以length为0，由于当前连接是采用选择性确认，所以序列号和确认好之间的字节长度从1721092980到1721093065，也就是85 bytes.接收方发送的ACK确认号是1721093065,这代表目前已接收的数据确认累计到1721093065字节了。至于说为什么数字会如此之大，这要说道初次握手时发出的随机数，数字的范围和那个初始数字是相关的。</p>

<p>这种模式会一直持续到全部数据传送完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.189335 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673593778:673595226, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190280 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673595226:673596674, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190350 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673596674, win 8101, options [nop,nop,TS val 743929811 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190597 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673596674:673598122, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190601 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673598122:673599570, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190614 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673599570:673601018, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190616 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673601018:673602466, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190617 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673602466:673603914, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190619 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673603914:673605362, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190621 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673605362:673606810, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190679 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673599570, win 8011, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190683 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673602466, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190688 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190703 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190743 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673606810, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190870 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673606810:673608258, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.198582 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [P.], seq 673608258:673608401, ack 1721093065, win 7240, options [nop,nop,TS val 1433256670 ecr 743929811], length 143
</span><span class='line'>18:31:29.198672 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608401, win 8183, options [nop,nop,TS val 743929819 ecr 1433256660], length </span></code></pre></td></tr></table></div></figure>


<h2>终止连接</h2>

<p>最终连接会终止(或结束)，连接的每一端都会发送FIN标识给另一端来声明结束传输，接着另一端会对收到的FIN进行通知，当连接两端均发送完各自FIN和做出相应的确认后，连接将会彻底关闭：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.199029 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [F.], seq 1721093065, ack 673608401, win 8192, options [nop,nop,TS val 743929819 ecr 1433256660], length 0
</span><span class='line'>18:31:29.208416 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [F.], seq 673608401, ack 1721093066, win 7240, options [nop,nop,TS val 1433256680 ecr 743929819], length 0
</span><span class='line'>18:31:29.208493 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608402, win 8192, options [nop,nop,TS val 743929828 ecr 1433256680], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里值得注意的是第二行，<code>23.63.125.15</code>发送了FIN，同时在这个报文信息中还对第一行中的另一端发送的FIN予以ACK(以.代表)确认。</p>

<h2>HTTP-超文本传输协议（Hypertext Transfer Protocol）</h2>

<p>1989年，Tim Berners lee 在<a href="https://en.wikipedia.org/wiki/CERN">CERN</a>担任软件咨询师的时候，开发了一套程序，奠定了万维网的基础。HyperText Transform Protocol（超文本转移协议，即HTTP）,是用于从WWW服务器传输超文件到本地浏览器的传送协议。<a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 定义了今天普通使用的一个版本:HTTP 1.1</p>

<h3>请求与响应</h3>

<p>HTTP采用简单的请求和响应机制，在safari输入<code>http://www.apple.com</code>时，会向www.apple.com所在的服务器发送一个http请求。服务器会在对请求作出一个响应，将请求结果信息返回给Safari.</p>

<p>每一个请求都有一个对应的响应信息。请求和响应遵从同样的格式，第一行是请求行或者响应状态行，接下来是header信息，header信息之后会有一个空行。空行之后是body请求信息体</p>

<h3>一个简答请求</h3>

<p>当safari加载html页面<a href="http://www.objc.io/about.html">http://www.objc.io/about.html</a>的时候，先是发送HTTP请求到<code>www.objc.io</code>,请求的内容是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /about.html HTTP/1.1
</span><span class='line'>Host: www.objc.io
</span><span class='line'>Accept-Encoding: gzip, deflate
</span><span class='line'>Connection: keep-alive
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.74.9 (KHTML, like Gecko) Version/7.0.2 Safari/537.74.9
</span><span class='line'>Referer: http://www.objc.io/
</span><span class='line'>DNT: 1
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>第一样是请求行，它包含三部分信息：动作，资源信息，还有HTTP的版本</p>

<p>本例中，动作是GET,所谓动作也就是常说的HTTP请求方法， 资源信息表明所请求的资源。例子中的资源信息是 /about.html,这表示我们想get服务器的在/about.html位置中的文档。当前HTTP版本是HTTP/1.1</p>

<p>接下来10行是HTTP header信息。跟着是一行空行。例子中请求没有body信息。</p>

<p>header的作用是向服务器传递一些额外的辅助信息，它的内容比较宽泛，维基百科中又<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">常用HTTP header关键字</a>信息的清单。例子中的header信息:<code>Host: www.objc.io</code>表示告诉服务器，本次请求的服务器名称是什么。这样可以让同一个服务器处理针对多个域名的请求。</p>

<p>下面是一些常见的header信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>服务器可能具备返回多种媒体类型的能力，Accept表示safari希望接收的媒体格式类型，text/html是胡亮媒体，也被称为MIME类型或者是内容类型(Content-TYpes).<code>q=0.9</code>表示Safari对给定媒体类型的优先级要求。Accept_Lanaguage 代表Safari希望接收的自然语言清单。这回要求服务器尽可能的根据清单要求去匹配相应的语言。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept-Encoding: gzip, deflate</span></code></pre></td></tr></table></div></figure>


<p>通过这个header,Safari告诉服务器可以对响应boday做压缩处理，如果header信息中没有设置压缩标识，那么服务器就必须返回没有压缩过的信息。压缩可以大大减少数据的传输量，在文本信息(比如HTML)中尤为明显。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"</span></code></pre></td></tr></table></div></figure>


<p>这两行信息表明Safari已经对请求结果做过缓存，如果服务器上的请求内容在2月10号以后发生过变化或者是etag与<code>a54907f38b306fe3ae4f32c003ddd507</code>不匹配，这就表示请求结果与当前缓存信息不一致，需要服务器返回最新的请求结果。</p>

<p>user-agent 是告知服务器当前发送请求的客户端类型。</p>

<h3>一个简单响应</h3>

<p>作为上面的请求的响应，服务器的返回是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 304 Not Modified
</span><span class='line'>Connection: keep-alive
</span><span class='line'>Date: Mon, 03 Mar 2014 21:09:45 GMT
</span><span class='line'>Cache-Control: max-age=3600
</span><span class='line'>ETag: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Last-Modified: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>Age: 6
</span><span class='line'>X-Cache: Hit from cloudfront
</span><span class='line'>Via: 1.1 eb67cb25620df959ba21a943fbc49ef6.cloudfront.net (CloudFront)
</span><span class='line'>X-Amz-Cf-Id: dDSBgR86EKBemW6el-pBI9kAnuYJEaPQYEqGmBnilD12CbixCuZYVQ==</span></code></pre></td></tr></table></div></figure>


<p>第一行是状态航，它包括HTTP版本，状态码(204)和状态信息</p>

<p>HTTP定义了一系列状态码，他们各有用途，本利中的304表示所请求的信息自上次访问以来没有变化</p>

<p>响应中没有包含body信息。也就说服务器通知客户端：你的版本已经是最新的了，可以直接使用当前缓存信息</p>

<h3>关闭缓存</h3>

<p>用curl 发送一个请求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% curl http://www.apple.com/hotnews/ &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p><code>curl</code>没有使用本地缓存，整个请求会是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /hotnews/ HTTP/1.1
</span><span class='line'>User-Agent: curl/7.30.0
</span><span class='line'>Host: www.apple.com
</span><span class='line'>Accept: */*</span></code></pre></td></tr></table></div></figure>


<p>这个请求与之前Safari发的请求很类似，但是curl请求的header信息中没有<code>If-None-Match</code>,所以服务器必须将请求结果返回。</p>

<p>此处<code>curl</code>头信息中声明的<code>Accept: */*</code>表示可以接收任何媒体类型。</p>

<p>来自www.apple.com的响应：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 200 OK
</span><span class='line'>Server: Apache
</span><span class='line'>Content-Type: text/html; charset=UTF-8
</span><span class='line'>Cache-Control: max-age=424
</span><span class='line'>Expires: Mon, 03 Mar 2014 21:57:55 GMT
</span><span class='line'>Date: Mon, 03 Mar 2014 21:50:51 GMT
</span><span class='line'>Content-Length: 12342
</span><span class='line'>Connection: keep-alive
</span><span class='line'>
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US"&gt;
</span><span class='line'>&lt;head&gt;
</span><span class='line'>    &lt;meta charset="utf-8" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>后面还会有一些，现在收到的响应里body中包含了HTML文档信息</p>

<p>Apple服务器响应的状态码是200,这是标准的表示HTTP请求成功的状态码。</p>

<p>服务器同时还告知响应媒体类型是 <code>text/html</code>;字符集<code>charset=utf-t</code>；内容长度：<code>Content-length:12342</code>,还代表了body信息的大小</p>

<h2>HTTPS-安全的HTTP</h2>

<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>(安全传输层协议，TLS)是一种基于TCP的加密协议，它支持两件事情：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于TLS的HTTP请求就是HTTPS</p>

<p>用https去替代http,在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。</p>

<h3>TLS 1.2</h3>

<p>如果服务器支持的话，你应该讲<code>TLSMinmumSupportedProtocol</code>设置为<code>kTLSProtocol12</code>,以要求使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2"><code>TLS1.2</code></a>版本，这能有效的防御<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a></p>

<h2>证书锁定(Certificate Pinning)</h2>

<p>如果不确定数据接收方的身份，那么即便对所传输数据进行加密也没什么意义。服务器的证书可以表明服务器的身份，只允许好持有某个特定证书的一方建立连接，就是<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">证书锁定</a></p>

<p>如果一个客户端通过TLS和服务器建立连接，操作系统会验证服务器证书的有效性。当然，有很多手段可以绕开这个校验，最直接的是在iOS设备上安装证书并且将其设置为可信的，这种情况下，实施<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">中间人攻击</a>也不是什么难事。</p>

<p>可以使用证书锁定来规避这种风险。当监理TLS连接后，应立即检查服务器的证书，不仅要验证证书的有效性，还需要确定证书和其持有者是否匹配。考到应用和服务器需要同时升级证书的要求，这种方式比较适合应用在访问自家服务器的情况下。</p>

<p>为了实现证书锁定，在建立连接的过程中需要对服务器进行信任检查，每当通过NSURLSession创建了连接，<code>NSUrlSession</code>的代理就会收到一个
<code>-URLSession:didReceiveChallenge:completionHandler:</code>的调用。传递的参数<code>NSURLAuthenticationChallenge</code>有一个属性<code>protectionSpace</code>，它是<code>NSURLProtectionSpace</code>的实例，它有一个<code>serverTrust</code>属性。</p>

<p><code>serverTrust</code>是一个<code>SecTrustRef</code>对象，<code>Security</code>框架提供了很多方法用于验证<code>SecTrustRef</code>。<code>AFNetworking</code>项目中的<code>AFSecurityPolicy</code>就是一个不错的使用。一如既往的提醒大家，如果要自己构建全验证相关的代码，请一定要认真做好代码审查，千万不要再出现诸如<code>goto fail</code>这类bug</p>

<h2>综合讨论</h2>

<p>现在大家多IP，TCP，和http的工作原理有了一定的了解了。下面说说还可以做些什么</p>

<h3>有效地使用连接</h3>

<p>TCP连接容易在两个时点出现问题：初始设置，以及通过连接传输的最后一部分报文</p>

<h3>建立连接</h3>

<p>连接设置可能会非常耗时，正如前文所说，TCPj建立连接的过程中需要进行三次握手，这个过程中本身没有太多的数据需要传递，但是，对于移动网络来说，从手机端向服务器端发送一个数据包普遍需要250ms,也就是四分之一秒。推及到三次握手，也就是说在还没有传送任何数据之前，光建立连接就花费了750ms</p>

<p>https的情况更夸张，由于Https是基于TLS的http,而http又基于TCP,TCP连接就要执行三次握手，然后到了TLS层还会再握手三次，估算一下，建立一个HTTPS连接的耗时只要是创建一个https连接的两倍。如果RTT时间是500ms(假设单程250ms)，HTTPS建立连接累计总耗时1.5秒</p>

<p>不管建立连接后传递多少数据，建立连接本身都太过耗时了。</p>

<p>另一个影响TCP连接的因素是传送大规模的数据。如果要在网络情况未知的条件下传送报文，TCP需要侦测当前网络的能力。换句话说，TCP得花费一定的事件去计算此网络最佳传输速率。上文提到过，TCP需要逐步调整以便找到最佳速度。这种算法成为<a href="https://en.wikipedia.org/wiki/Slow-start">慢启动</a>。还有一点值得注意，慢启动策略在那些数据链路层传输质量较差的网络环境中的表现更差，无线网络就是典型的例子</p>

<h3>结束连接</h3>

<p>另一个问题主要存在于数据传输的最后阶段。每当客户端发起HTTP请求某些资源的时候，服务器会持续的向客户端发送TCP报文数据，客户端收到数据后会给服务器反馈ACK报文数据，客户端收到数据后会给服务器反馈ACK确认信息。假如某个报文在传输过程中发生丢包，那么服务器也就不会收到该包的确认ACK.一旦服务器发现现有数据包没有ACK反馈，就会触发快速重传。</p>

<p>每当某个数据包丢失，数据接收方在收到下个数据包后发出的确认ACK与所接收的前一个数据包的确认ACK相同。那么数据发送方自然就会收到重复的ACK.除了报文丢失，还有很多网络状况会导致重复ACK的问题。一般情况下，如果数据发送方连续收到3个重复的ACK就会立即进行快速重发</p>

<p>这所导致的问题将发生在数据传输的收尾阶段。如果发送方完成数据发送，接受方自然会停止发送ACK确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包丢失问题的（以为不会收到三个相同的确认ACK,所以不能界定传输丢包），在常规的网络环境下，四个数据包相当于5.7kb的数据规模。总之，在这最后的5.7kb的传输过程中，快速重发机制是无效的。针对这种情况，TCP会启用其它机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>

<h3>长连接和管线化</h3>

<p>HTTP有两种策略来解决这些问题，最简单的是<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP持久连接(persistent connection)</a>，也被称为长连接。具体就是,每当HTTP完成一组请求-响应后，还会继续复用相同的TCP连接。而HTTPS会复用同样的TLS连接：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>第二部就是利用了<a href="https://en.wikipedia.org/wiki/Http_pipelining">HTTP管线</a>处理，即允许客户端利用同样的连接并行发送多个请求，也就是说无需等待上一个请求的响应完成可以发下一个请求。这表示能同时处理请求和响应，请求处理的顺序采用先进先出的原则，响应结果会按照请求发出的顺序依次返回给客户端</p>

<p>稍微简化一下，看起来会是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>client sends HTTP request 4 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>                            &lt;- server sends HTTP response 4
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>注意，服务器发出的响应是实时的，不会等到接收完全请求才处理。</p>

<p>可以利用这个特点来提升TCP的效率，只需要在简建立连接初始阶段执行握手，而后一直复用同样的连接。这样TCP就可以最大限度的利用带宽，此种情况下，拥塞控制也会随之提升。因为快速重复机制无法处理的最末四个报文丢失情况只会发生在使用本地连接的最后一个请求-响应中，而不是像之前那样每一个请求-响应都需要建立自己的连接，每个连接中都可能出现最后四个报文丢失的问题。</p>

<p>HTTP管线化对高网络延迟连接的通讯性能提升尤为显著，在你的iPhone没有通过wifi访问网络的时候，此类网络连接就属于高延迟范畴。实际上，有调差显示，在移动网络环境下，<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>的通讯性能并不优于HTTP管线。</p>

<p><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>指明，在与同一个服务器通讯的时候，如果启用了http管线，建议启用两个连接。按照说明所述，这样能获得最优的响应效率，能最大限度避免拥塞，增加更多的连接也不会再对性能有什么明显改善。</p>

<p>遗憾的是，还有相当多的服务器不支持管线话，由于这个原因，HTTP管线在<code>NSURlSession</code>中默认是关闭的，如果想要开启HTTP管线，需要将<code>NSURLSessionConfiguration</code>中的<code>HTTPShouldUsePipelining</code>设置为YES.另外，建议服务器最好还是支持管线化</p>

<h3>超时处理</h3>

<p>我们都有在网络不太好的情况下使用app的经历，很多app大概15s左右就会结束请求并且反馈一个超时信息，这种设计其实是很不好有的。应该给用户一个他们理解的友好提示，比如：“你好，现在网络状态不太好，你需要多等一会”。但是即便网络状况良好，只要连接还在，TCP都会保证将请求发出去并且会一直等待响应的返回，只是时间长短问题。</p>

<p>从另一个角度来说，在较慢的网络中，请求-响应的RTT时间可能会有17秒。如果15秒就决定终止请求，就算用户有足够的耐心，他们也没积水等到想要的操作结果，反过来，如果我们给出用户响应的提示信息，而他们又刚好愿意多等一会，用户可能会更喜欢使用这样的应用。</p>

<p>一直以来都有一种误解，用重发请求来解决上面的问题，注意，这不是问题的关键，因为TCP有自己的重复机制。</p>

<p>正确的处理方式应该是：没放发起一个请求的时候，同时启动一个10秒计时器，如果请求在10秒之内返回，就把计时器关掉。如果超过10秒，可以给用户一个提示：“网络不好请稍后”。我建议再给用户一个取消按钮，让他们可以自行选择等待还是取消请求，当然提示信息的具体内容和是否配备取消按钮，这个可以视各app的情况去决定。总而言之，开发者最好不要直接替用户做决定，比如直接终止他们的请求。</p>

<p>只要连接双方的IP地址是不变的，可用的，连接就一定是活跃的。如果把iPhone从wifi连接切换到3G网络，这样连接就会变得不可用，因为的IP地址发生了变化，基于原IP地址创建的路由自然是失效的。</p>

<h2>缓存</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/16/reactiveswiftru-men/">ReactiveSwift入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-16T10:29:29+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:29 am</span></time>
        
           | <a href="/blog/2016/11/16/reactiveswiftru-men/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Signal</h2>

<p>一个signal类型的实例，代表了一个有时序的并且可以被观察(类似订阅)的事件流。</p>

<p>信号通常被用来表示正在进行中的事件流，比如通知，用户输入等。用户（或者只要能造成事件的东西）产生的事件发送或者被接受，事件就被传递到信号上，并且被推送(push-Driven)到任何观察者哪里，并且所有观察者都是同时收到这些事件。</p>

<p>如果你想访问一系列的事件，就必须观察一个信号，观察一个信号并不会触发任何副作用，可以这样理解。信号是由生产者生产和推动的，消费者（观察者）是不会对事件的生命周期有任何影响。在观察一个信号时，发送了什么事件，只能对这个事件操作，因为信号是由时序的，不能随机的访问其他事件。</p>

<p>信号可以通过原函数去操作，比如filter,map,reduce,也可以同时操作多个信号如zip,这些原函数只在nextEvents生效（也就是对complete,failure等不生效）</p>

<p>在一个信号的生命周期里，可以发送无数次的NextEvents事件，直到他们被终结，类似compleye,Failed,InterRupper.终止事件没有数据值，所以他们必须被单独处理。</p>

<h2>Subscription</h2>

<p>一个信号通常被用来表示正在进行中的事件流，有时候他们被叫做热信号，这意味着订阅者可以错过一些在它订阅前发送的事件。订阅一个信号不会触发任何副作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>20
</span><span class='line'>21
</span><span class='line'>22
</span><span class='line'>23
</span><span class='line'>24
</span><span class='line'>25
</span><span class='line'>26
</span><span class='line'>27
</span><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    // Signal.pipe is a way to manually control a signal. the returned observer can be used to send values to the signal
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nonerror&gt;.pipe()
</span><span class='line'>    let subscriber1 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to the signal")
</span><span class='line'>    print("\(observer)")
</span><span class='line'>    signal.observe(subscriber1)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    // subscriber1 will receive the value
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    print("Subscriber 2 subscribes to the signal")
</span><span class='line'>    // Notice how nothing happens at this moment, i.e. subscriber2 does not receive the previously sent value
</span><span class='line'>    signal.observe(subscriber2)
</span><span class='line'>    print("Send value `20` on the signal")
</span><span class='line'>    // Notice that now, subscriber1 and subscriber2 will receive the value
</span><span class='line'>    observer.sendNext(20)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to the signal
</span><span class='line'>Observer&lt;int, nonerror&gt;(action: (Function))
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber 1 received 10
</span><span class='line'>Subscriber 2 subscribes to the signal
</span><span class='line'>Send value `20` on the signal
</span><span class='line'>Subscriber 1 received 20
</span><span class='line'>Subscriber 2 received 20&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>因为Swift有泛型的存在，这样的话我们可以把Signal当做任何数据类型的容器，而不是像OC中利用上帝类型Id，更加方便传递数据</p>

<p>首先我们通过Signal.pipe()创建了一个信号和一个观察者。</p>

<p>奇怪的是，在RACOC部分中，我们很少主动创建观察者，我们通常直接订阅信号就可以。</p>

<p>在Swift中，通过pipe创建的信号是个热信号，类似于OC中的RACSubject系列，在RACSubject继承自RACSiganl又继承RACStream，RACStream是一个Monad,它可以代表数据和数据的一系列的操作如map,flatterMap,bind</p>

<p>RACSubject又遵守了RACSubscriber协议，这个协议定义了可以发送数据的操作。</p>

<p>所以RACSubject即是一个信号，又是一个观察者。</p>

<p>在Swift部分的实现中，Signal并没有实现发送数据的方法。所以它需要一个内部的Observer去发送数据。所以它被pipe直接返回。</p>

<p>在外部我们需要自己实例化一个Observer观察者。去订阅事件。</p>

<p>可能在你查看Pipe的实现的时候并不好理解。把尾随闭包补全相对好理解点。</p>

<p>做个总结：</p>

<ul>
<li>RACOC中：RACSubject = RACSignal + RACSubscriper，在订阅的时候，订阅者被放在了RACSubject内部存放，我们只需要去关注订阅的block实现即可。</li>
<li>RACSwift中:Signal 仅仅就是一个信号，所以需要一个内部观察者去充当发送数据的工具。外部的订阅需要自己手动实例观察者</li>
<li>热信号：由于pipe方法返回的是热信号，所以一个订阅者会错过在订阅之前发送的事件
*</li>
</ul>


<h3>empty</h3>

<p>空信号直接发送一个interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptySignal = Signal&lt;int, nonerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, nonerror&gt;(
</span><span class='line'>    failed: { _ in print("error not called") },
</span><span class='line'>    completed: { print("completed not called") },
</span><span class='line'>    interrupted: { print("interrupted called") },
</span><span class='line'>    next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptySignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>interrupted called&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Never</h3>

<p>一个Never信号不会发送任何事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverSignal = Signal&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        interrupted: { print("interrupted not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverSignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>uniqueValues唯一值</h3>

<p>仅从集合中发送一次相同事件&ndash;类似与arrayQueue变成了Setqueue</p>

<p>注意：这会造成被发送的值被保留下来，用于以后发送的时候来检查是否重复，你可以编写一个函数来过滤重复值，这样可以减少内存消耗。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>scopedExample("`uniqueValues`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let uniqueSignal = signal.uniqueValues()
</span><span class='line'>    uniqueSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(5)
</span><span class='line'>}
</span><span class='line'>--- `uniqueValues` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2
</span><span class='line'>Subscriber received 3
</span><span class='line'>Subscriber received 4
</span><span class='line'>Subscriber received 5&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每一个发送的值转换成新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let mappedSignal = signal.map { $0 * 2 }
</span><span class='line'>    mappedSignal.observe(subscriber)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber received 20&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error值变成新的error值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>        let userInfo = [NSLocalizedDescriptionKey: "??"]
</span><span class='line'>        let code = error.code + 10000
</span><span class='line'>        let mappedError = NSError(domain: "com.reactivecocoa.errordomain", code: code, userInfo: userInfo)
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nserror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, nserror&gt;(failed: { print("Subscriber received error: \($0)") } )
</span><span class='line'>    let mappedErrorSignal = signal.mapError { (error:NSError) -&gt; NSError in
</span><span class='line'>        return mappedError
</span><span class='line'>    }
</span><span class='line'>    mappedErrorSignal.observe(subscriber)
</span><span class='line'>    print("Send error `NSError(domain: \"com.reactivecocoa.errordomain\", code: 4815, userInfo: nil)` on the signal")
</span><span class='line'>    observer.sendFailed(NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil))
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Send error `NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil)` on the signal
</span><span class='line'>Subscriber received error: Error Domain=com.reactivecocoa.errordomain Code=14815 "??" UserInfo={NSLocalizedDescription=??}&lt;/int, nserror&gt;&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>用于过滤一些值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    // subscriber will only receive events with values greater than 12
</span><span class='line'>    let filteredSignal = signal.filter { $0 &gt; 12 ? true : false }
</span><span class='line'>    filteredSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    observer.sendNext(11)
</span><span class='line'>    observer.sendNext(12)
</span><span class='line'>    observer.sendNext(13)
</span><span class='line'>    observer.sendNext(14)
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>Subscriber received 13
</span><span class='line'>Subscriber received 14&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>在发送的值为可选类型中：如果有值，把值解包，如果是nil丢弃掉</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int?, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int?` and observer is of type `Int`, given we're unwrapping
</span><span class='line'>    // non-`nil` values
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let ignoreNilSignal = signal.ignoreNil()
</span><span class='line'>    ignoreNilSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(nil)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 3&lt;/int, noerror&gt;&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num)只取前num此值得信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let takeSignal = signal.take(2)
</span><span class='line'>    takeSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect</h3>

<p>在发送complete事件之后，观察者会收到一个由之前事件组成的数组</p>

<p>注意：如果在发送complete事件的时候，没有任何事件发送，观察者会收到一个空的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int` and observer is of type `[Int]` given we're "collecting"
</span><span class='line'>    // `Int` values for the lifetime of the signal
</span><span class='line'>    let subscriber = Observer&lt;[Int], NoError&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let collectSignal = signal.collect()
</span><span class='line'>    collectSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendCompleted()
</span><span class='line'>}
</span><span class='line'>--- `collect` ---
</span><span class='line'>Subscriber received [1, 2, 3, 4]&lt;/int, noerror&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h2>SignalProducer</h2>

<p>一个信号发生器，是SignalProducer类型的实例，它可以创建信号(signals)并施加副作用（side effects）</p>

<p>信号发生器用来表示操作或者任务，比如网络请求，每一次对它的调用start()将会生成一个新的潜在操作，并允许调用者观察它的结果，还有一个startWithSignal()方法，会给出产生的信号，允许在必要的情况下监听多次。</p>

<p>根据start()方法的动作方式，被同一个信号发生器生成的信号可能会有不同的事件顺序或版本，甚至事件流完全不一样！和普通的信号不同，在观察者连接上之前，信号发生器不会开始工作（也就没有事件会生成），并且在每一个新的监听器连接上时其工作都会重新开始一个单独的工作流。</p>

<p>启动一个信号发生器会返回一个销毁器(disposable)，它可用来打断或取消被生成信号的工作</p>

<p>和信号一样，信号生成器可以通过map,filter等原函数操作，使用lift方法，所有信号的原函数可以被提升成为以信号生成器为对象的操作，除此以外，还有一些用来控制何时与如何启动信号生成器的原函数，比如times.</p>

<p>通过lift函数可以让热信号转变为冷信号。</p>

<h3>Subscription</h3>

<p>一个信号生成器代表了一种可以在需要的时候才被启动的操作（不像signal是自启动的），这种信号是冷信号，在刚开始这个信号的状态也为冷（未激活），既然是冷信号，那么就意味着这一个观察者不会错过任何被信号生成器发出的值。</p>

<p>补充：像signal是创建的时候状态为cold(理解为未激活)，被订阅时状态为hot(理解为激活)</p>

<p>但是冷信号和热信号与状态为冷热是两个不同的概念，冷信号会带来副作用，热信号不会</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    let producer = SignalProducer&lt;int, noerror&gt; { observer, _ in
</span><span class='line'>        print("New subscription, starting operation")
</span><span class='line'>        observer.sendNext(1)
</span><span class='line'>        observer.sendNext(2)
</span><span class='line'>    }
</span><span class='line'>    let subscriber1 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to producer")
</span><span class='line'>    producer.start(subscriber1)
</span><span class='line'>    print("Subscriber 2 subscribes to producer")
</span><span class='line'>    // Notice, how the producer will start the work again
</span><span class='line'>    producer.start(subscriber2)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 1 received 1
</span><span class='line'>Subscriber 1 received 2
</span><span class='line'>Subscriber 2 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 2 received 1
</span><span class='line'>Subscriber 2 received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>像不像是RACDynamicSignal的创建方式，这不过不同与Sinal的是，这里的发送信号的观察者是在内部通过Signal.pipe()生成的，不需要外部创建。</p>

<p>SignalProduce是冷信号，任何一个订阅者/观察者都不会错过任何事件</p>

<p>start方类似Signal的 signal.observe()方法，只不过Signal的方法只有一个作用，就是关联一个观察者，而SignalProduce的start方法还多了一个激活信号的功能</p>

<h3>Empty</h3>

<p>一个会立即调用complete事件的信号生成器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `empty`
</span><span class='line'> A producer for a Signal that will immediately complete without sending
</span><span class='line'> any values.
</span><span class='line'> */
</span><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptyProducer = SignalProducer&lt;int, noerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed called") },
</span><span class='line'>        interrupted: { print("interrupted called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptyProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>Signal调用的是interrup方法，暂时不知道为什么，可能是为了区分语义吧，Signal是有时序的，SignalProduce是没有时序的。</p>

<h3>Never</h3>

<p>一个什么都不会发送的信号器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `never`
</span><span class='line'> A producer for a Signal that never sends any events to its observers.
</span><span class='line'> */
</span><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverProducer = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>buffer</h3>

<p>创建一个事件队列可以回放已经发送的事件</p>

<p>当一个值被发送的时候，它会被放进缓冲区内，如果缓冲区已经溢出，就会丢弃旧的值</p>

<p>这些被缓存的值将会被保留，直到这个信号被终结，当一个信号启动的时候，如果队列里没有任何值，所有被发送的新值都会被自动转发到观察者那里，直到管着着收到一个终止事件。</p>

<p>当一个终止事件被发送到队列中，观察者不会再收到任何值，并且这个事件不会被计算buffer的缓冲区大小，所以没有缓存的值都会被丢弃。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`buffer`") {
</span><span class='line'>    let (producer, observer) = SignalProducer&lt;int, noerror&gt;.buffer(2)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    var values: [Int] = []
</span><span class='line'>    producer.start { event in
</span><span class='line'>        switch event {
</span><span class='line'>        case let .Next(value):
</span><span class='line'>            values.append(value)
</span><span class='line'>        default:
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print(values)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    print(values)
</span><span class='line'>    let subscriber = Observer&lt;int,noerror&gt;(next:{ bufferdValue in
</span><span class='line'>        print("\(bufferdValue)")
</span><span class='line'>    })
</span><span class='line'>    producer.start(subscriber)
</span><span class='line'>}
</span><span class='line'>--- `buffer` ---
</span><span class='line'>[2, 3]
</span><span class='line'>[2, 3, 4]
</span><span class='line'>3
</span><span class='line'>4&lt;/int,noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithSignal</h3>

<p>通过Producer返回一个Signal,当闭包调用时返回signal开始发送事件</p>

<p>闭包返回一个Disponsable，可以用来中断Signal或者完成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithSignal`") {
</span><span class='line'>    var started = false
</span><span class='line'>    var value: Int?
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .on(next: {
</span><span class='line'>            value = $0
</span><span class='line'>        })
</span><span class='line'>        .startWithSignal { signal, disposable in
</span><span class='line'>            print(signal)
</span><span class='line'>            print(value) // nil
</span><span class='line'>        }
</span><span class='line'>    print(value)
</span><span class='line'>}
</span><span class='line'>--- `startWithSignal` ---
</span><span class='line'>ReactiveCocoa.Signal&lt;swift.int, result.noerror&gt;
</span><span class='line'>nil
</span><span class='line'>Optional(42)&lt;/swift.int, result.noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithNext</h3>

<p>通过信号生成器创建一个信号，并且给这个信号内部直接构建一个观察者，在指定的闭包中会直接订阅next事件。</p>

<p>返回一个Disposable,可以中断这个信号，中断之后这个闭包不会再被调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithNext`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithNext` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个订阅只能接受next事件</p>

<h3>startWithCompleted</h3>

<p>同startWithNext，只不过只能接受complete事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithCompleted`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithCompleted {
</span><span class='line'>            print("completed called")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithCompleted` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithFailed</h3>

<p>同startWithNext， 只不过只能接受Failer事件事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithFailed`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "example", code: 42, userInfo: nil))
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithFailed` ---
</span><span class='line'>Error Domain=example Code=42 "(null)"&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithInterrupted</h3>

<p>同startWithNext,只不过只能接受interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithInterrupted`") {
</span><span class='line'>    let disposable = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>        .startWithInterrupted {
</span><span class='line'>            print("interrupted called")
</span><span class='line'>        }
</span><span class='line'>    disposable.dispose()
</span><span class='line'>}
</span><span class='line'>--- `startWithInterrupted` ---
</span><span class='line'>interrupted called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>lift</h3>

<p>这个相对难理解点，大致类似于RAC_OC部分中的bind函数，monad中bind函数</p>

<p>可以理解为所有的原函数都是通过lift去实现的，借用中间信号来实现一系列的信号变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`lift`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    let transform: Signal&lt;int, noerror&gt; -&gt; Signal&lt;int, noerror&gt; = { signal in
</span><span class='line'>        counter = 42
</span><span class='line'>        return signal
</span><span class='line'>    }
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 0)
</span><span class='line'>        .lift(transform)
</span><span class='line'>        .startWithNext { _ in
</span><span class='line'>            print(counter)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `lift` ---
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每个值都转换为新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 1)
</span><span class='line'>        .map { $0 + 41 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error转换为新的error</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "mapError", code: 42, userInfo: nil))
</span><span class='line'>        .mapError { Error.Example($0.description) }
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Example("Error Domain=mapError Code=42 \"(null)\"")&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>过滤不符合条件的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .filter { $0 &gt; 3}
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num) 只取前几次的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .take(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>1
</span><span class='line'>2&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>observeOn</h3>

<p>在指定调度器上分发事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `observeOn`
</span><span class='line'> Forwards all events onto the given scheduler, instead of whichever
</span><span class='line'> scheduler they originally arrived upon.
</span><span class='line'> */
</span><span class='line'>scopedExample("`observeOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let completion = { print("is main thread? \(NSThread.currentThread().isMainThread)") }
</span><span class='line'>    if #available(OSX 10.10, *) {
</span><span class='line'>    baseProducer
</span><span class='line'>        .observeOn(QueueScheduler(qos: QOS_CLASS_DEFAULT, name: "test"))
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>    }
</span><span class='line'>    baseProducer
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>}
</span><span class='line'>--- `observeOn` ---
</span><span class='line'>is main thread? true&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h2>collect</h2>

<p>在发送完成的时候将一系列的值聚合为一个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect()`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect()` ---
</span><span class='line'>[1, 2, 3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(count:)</h3>

<p>在发送数据的时候（不需要发送complete）的时候将一系列的值聚合为数组，数组的长度为count,如果有很多数据，将会返回多个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(count:)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>        observer.sendNext(5)
</span><span class='line'>//            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect(count: 2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(count:)` ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(predicate:) matching values inclusively</h3>

<p>通过谓词将一系列的值聚合为一个数组，注意在发送complete时候，如果前面只剩下一个值，就不需要聚合（因为没有其它元素和最后一个元素聚合），直接返回一个只有一个元素的数组。如果没有数据则返回一个空数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values inclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>//            observer.sendNext(1)
</span><span class='line'>//            observer.sendNext(2)
</span><span class='line'>//            observer.sendNext(3)
</span><span class='line'>//            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values in values.reduce(0, combine: +) == 3 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values inclusively ---
</span><span class='line'>[]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>尝试打开注释看看会有什么结果</p>

<h3>collect(predicate:) matching values exclusively</h3>

<p>和上一个不同的是，如果谓词成功就把之前的聚合在一起，可以理解为把成功的界限当做分隔符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values exclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendNext(5)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values, next in next == 3 || next == 5  }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values exclusively ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4] // 3满足了条件所以被分开
</span><span class='line'>[5] // 5也是&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>combineLatestWith</h3>

<p>将第一个信号生成器的values和被聚合信号生成器的最后一个值聚合为一个元组</p>

<p>新产生的信号生成器不会发送任何值，只是转发，任何一个原来的信号被中断，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combineLatestWith`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let producer2 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>    producer1
</span><span class='line'>        .combineLatestWith(producer2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combineLatestWith` ---
</span><span class='line'>(1, 2)
</span><span class='line'>(2, 2)
</span><span class='line'>(3, 2)
</span><span class='line'>(4, 2)&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skip</h3>

<p>skip（num），跳过num此发送的事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skip`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    producer1
</span><span class='line'>        .skip(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skip` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>materialize</h3>

<p>将被发送的值(value)编程Event,允许他们被修改。还句话说，允许他们被修改，把一个值变成一个Monad</p>

<p>当收到一个complete或者Failure事件，这个新的信号生成器，会发送事件并且结束。当收到一个interrupted事件，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`materialize`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .materialize()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `materialize` ---
</span><span class='line'>NEXT 1
</span><span class='line'>NEXT 2
</span><span class='line'>NEXT 3
</span><span class='line'>NEXT 4
</span><span class='line'>COMPLETED
</span><span class='line'>// 注意 value  如果不做materialize就是Int类型</span></code></pre></td></tr></table></div></figure>


<h3>sampleOn</h3>

<p>当sampler（被操作的信号生成器）发送任何事件的时候，都转发原来信号生成器的最后一个值</p>

<p>如果当一个sampler启动时，当前的值没有被观察者，没有任何事情发生</p>

<p>新产生的信号生成器从源信号生成器哪里发送数据，如果两个信号生成器任何一个complete或者interrupt,新产生的都会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `sampleOn`
</span><span class='line'> Forwards the latest value from `self` whenever `sampler` sends a Next
</span><span class='line'> event.
</span><span class='line'> If `sampler` fires before a value has been observed on `self`, nothing
</span><span class='line'> happens.
</span><span class='line'> Returns a producer that will send values from `self`, sampled (possibly
</span><span class='line'> multiple times) by `sampler`, then complete once both input producers have
</span><span class='line'> completed, or interrupt if either input producer is interrupted.
</span><span class='line'> */
</span><span class='line'>scopedExample("`sampleOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let sampledOnProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>        .map { _ in () }
</span><span class='line'>    let newProduce = baseProducer
</span><span class='line'>        .sampleOn(sampledOnProducer)
</span><span class='line'>      newProduce  .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `sampleOn` ---
</span><span class='line'>4
</span><span class='line'>4&lt;/int, noerror&gt;&lt;/int, noerror&gt;
</span><span class='line'>sampler发送的2次值都被变换成baseProduce 的comlete前的最后一个值</span></code></pre></td></tr></table></div></figure>


<h3>combinePrevious</h3>

<p>向前合并，没法送一个值就结合历史发送数据的最后一个构造成一个新的元组返回。在第一个发送时由于没有历史数据，所以combinePrevious传递了一个默认值。当做第一次的合并。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combinePrevious`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .combinePrevious(42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combinePrevious` ---
</span><span class='line'>(42, 1) // 第一次没有历史记录默认值是42
</span><span class='line'>(1, 2) // 第二次默认记录是1
</span><span class='line'>(2, 3)
</span><span class='line'>(3, 4)&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>scan</h3>

<p>类似reduce,将值聚合为一个新的值，每次聚合都保留结果作为下次的默认值，首次需给出默认值</p>

<p>每次聚合都会发送这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`scan`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .scan(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `scan` ---
</span><span class='line'>1
</span><span class='line'>3
</span><span class='line'>6
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>reduce</h3>

<p>和scan类似，区别为reduce只发送聚合后的值并且立即结束</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`reduce`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .reduce(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `reduce` ---
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skipRepeats</h3>

<p>跳过表达式里返回true的值，第一个值不会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipRepeats` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>4
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<h3>skipWhile</h3>

<p>对每个值都去做判断，知道返回false,之前的值会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipWhile` ---
</span><span class='line'>1  // 到1 返回false  之前的值被忽略掉
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeUntilReplacement</h3>

<p>在被替换的信号发生器发送信号之后，发送被替换的信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeUntilReplacement`") {
</span><span class='line'>    let (replacementSignal, incomingReplacementObserver) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt; { incomingObserver, _ in
</span><span class='line'>        incomingObserver.sendNext(1)
</span><span class='line'>        incomingObserver.sendNext(2)
</span><span class='line'>        incomingObserver.sendNext(3)
</span><span class='line'>// 下面被替换的信号生成器发送了事件，之后就不再发送baseProducer的事件了
</span><span class='line'>// 相当于被替换了
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>        incomingObserver.sendNext(4)
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>    }
</span><span class='line'>    let producer = baseProducer.takeUntilReplacement(replacementSignal)
</span><span class='line'>    producer.startWithNext { value in
</span><span class='line'>        print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `takeUntilReplacement` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>42
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeLast</h3>

<p>在发送complete事件后只取count此数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeLast`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .takeLast(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>只取了2次数据
</span><span class='line'>--- `takeLast` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>如果发送的事件是可选类型，解包这些可选类型，并且丢弃nil值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    SignalProducer&lt;int?, noerror&gt;(values: [ nil, 1, 2, nil, 3, 4, nil ])
</span><span class='line'>        .ignoreNil()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>zipWith</h3>

<p>压缩信号生成器，只有再两个信号都有数据发送之后，新的信号生成器才会发送数据</p>

<p>新的数据被组合为元组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`zipWith`") {
</span><span class='line'>    let baseProducer = SignalProducer(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let zippedProducer = SignalProducer(values: [ 42, 43 ])
</span><span class='line'>    baseProducer
</span><span class='line'>        .zipWith(zippedProducer)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `zipWith` ---
</span><span class='line'>(1, 42)
</span><span class='line'>(2, 43)</span></code></pre></td></tr></table></div></figure>


<p>后面应为第二个没有数据了，所以不会再聚合了</p>

<h3>times</h3>

<p>time(count)重复发送count数据，每次重复必须上次发送完成事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`times`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    SignalProducer&lt;(), NoError&gt; { observer, disposable in
</span><span class='line'>            counter += 1
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .times(42)
</span><span class='line'>        .start()
</span><span class='line'>    print(counter)
</span><span class='line'>}
</span><span class='line'>--- `times` ---
</span><span class='line'>42</span></code></pre></td></tr></table></div></figure>


<h3>retry</h3>

<p>如果收到失败事件重试retry(count)次</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`retry`") {
</span><span class='line'>    var tries = 0
</span><span class='line'>    SignalProducer&lt;int, nserror&gt; { observer, disposable in
</span><span class='line'>            if tries == 0 {
</span><span class='line'>                tries += 1
</span><span class='line'>                observer.sendFailed(NSError(domain: "retry", code: 0, userInfo: nil))
</span><span class='line'>            } else {
</span><span class='line'>                observer.sendNext(42)
</span><span class='line'>                observer.sendCompleted()
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        .retry(1)
</span><span class='line'>        .startWithResult { result in
</span><span class='line'>            print(result)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `retry` ---
</span><span class='line'>.Success(42)&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<p>当第一个信号发送complete时，第二个信号被替换成信号发送线路上，如果有任何失败事件，后面的就替换失败。</p>

<p>第一个信号发送的所有事件都会被忽略</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160726/1469505056118233.png" alt="1" /></p>

<h3>flatMap</h3>

<p>将收到的每个事件都映射为新的Product,然后摊平，如果原来的producer发送失败，新产生也得立即失败</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMap(.Latest)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .flatMap(.Latest) { SignalProducer(value: $0 + 3) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMap(.Latest)` ---
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>flatMapError</h3>

<p>把收到的failer事件映射为新的Producer,并且摊平它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "flatMapError", code: 42, userInfo: nil))
</span><span class='line'>        .flatMapError { SignalProducer&lt;int, noerror&gt;(value: $0.code) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMapError` ---</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/11/swift-package-managerru-men/">Swift Package Manager入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-11T14:09:18+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:09 pm</span></time>
        
           | <a href="/blog/2016/11/11/swift-package-managerru-men/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>大部分语言都有官方的代码分配解决方案，幸好苹果也在开发替代<a href="https://cocoapods.org/">Cocoapods</a>和<a href="https://github.com/Carthage/Carthage">Carthage</a>的管理工具，<a href="https://swift.org/package-manager/#conceptual-overview">Swift Package Manager</a>(Swift包管理器，下面我们简称SPM)就是一个用来管理Swift代码的分配的官方工具，它为Swift编译系统集成了自动进行下载，编译和连接依赖的过程</p>

<p>目前，SPM还处于早起阶段，现在仅仅支持OS X和linux系统，尚不支持Ios,watchOS以及tvOS平台，但未来很大希望会支持上述平台。</p>

<h2>概念概述</h2>

<p>在swift中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外那些部分是代码是可以被访问控制的。</p>

<p>一个程序可以将它所有代码聚合到一个模块中，也可以将它作为依赖关系导入到其他模块，除了少量系统提供的模块，像OS X中的Darwin或者 Linux中的Glibc等大多数依赖需要代码被下载或者内置才能被使用。</p>

<p>当你将编写额解决待定问题的代码独立成一个模块时，这段代码可以在其他情况下呗重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的app或者一个天气的app里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p>

<p>一个包由Swift源文件和一个清单文件组成，这个清单文件称为<code>Package.swift</code>,定义包或者它的内容使用<code>PackageDescription</code>模块。</p>

<p>一个包邮一个或者多个目标，每个目标制定一个铲平并且可能声明一个后者多个依赖。</p>

<p>一个目标可能构建一个库或者一个可执行文件作为其产品。库是包含可以被其它Swift代码导入的模块。可执行文件是一段可以被操作系统运行的程序</p>

<p>目标依赖是指保重代码必须添加的模块。依赖由包资源的绝对或者相对URL和一些可以被使用的包的版本要求所组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成一个依赖的相关图。包管理器下载和编译所需要满足整个依赖相关图的一切。</p>

<h2>开源Swift入门</h2>

<ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85Swift">下载和安装Swift</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8REPL">使用REPL</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">使用编译系统</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95%E5%99%A8">使用LLDB调试器</a></li>
</ul>


<p>关于使用REPL和LLDB调试器的内容具体可以参阅官方文档<a href="https://swift.org/getting-started/#using-the-repl">使用REPL</a>和<a href="https://swift.org/getting-started/#using-the-lldb-debugger">使用LLDB调试器</a></p>

<h2><a name = "下载和安装Swift"></a>下载和安装Swift</h2>

<p>刚开始下载和安装swift需要下载并安装编译器和其它必备组件，进入到 <a href="https://swift.org/download/#releases">https://swift.org/download/#releases</a>按目标平台的说明进行。</p>

<p>下载完成后，点击按步骤安装就可以</p>

<p>在OS X上下载工具链的默认地址是:<code>/Library/Developer/Toolchains</code>.接着，我们可以输入以下命令导出编译路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>首先需要安装clang:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install clang</span></code></pre></td></tr></table></div></figure>


<p>如果你在Linux上安装的Swift工具链在系统根目录以外的目录，你需要使用你安装Swift的实际路径来运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/path/to/Swift/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>导出路径之后，你可以通过输入 swift 命令并传入 &ndash;version 标志来校验你是否运行了 Swift 的预期版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift --version
</span><span class='line'>Apple Swift version 3.0-dev (LLVM ..., Clang ..., Swift ...)</span></code></pre></td></tr></table></div></figure>


<p>在版本号的后缀 -dev 用来表明它是一个开发的编译，而不是一个发布的版本</p>

<h2><a name = "使用REPL"></a>使用REPL</h2>

<h2><a name = "使用编译系统"></a>使用编译系统</h2>

<p>Swift编译系统为编译库，可执行文件和不同工程之间共享代码提供了基本的约定。</p>

<p>创建一个新的Swift包，首先创建并进入到一个新的目录命令为Hello:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Hello
</span><span class='line'>$ cd Hello</span></code></pre></td></tr></table></div></figure>


<p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件，如果清单文件为空，那包管理器将会使用常规默认的方式来编译包，创建一个空的清空文件使用命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch Package.swift</span></code></pre></td></tr></table></div></figure>


<p>当使用默认方式时，包管理器预计将包含在Source/子目录下的所有源代码。创建方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Sources</span></code></pre></td></tr></table></div></figure>


<h3>编译可执行文件</h3>

<p>默认方式下，目录中包含一个文件称为<code>main.swift</code>将会将文件编译成与包名称相同的二进制可执行文件。</p>

<p>在这个例子中，包将生成一个可以输出<code>hello world</code>的可执行文件为 <em>hello</em></p>

<p>在<em>Source/</em>目录下创建一个命名为<code>main.swift</code>的文件，并使用你喜欢的任意一种编译器输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print("Hello, world!")</span></code></pre></td></tr></table></div></figure>


<p>返回到 Hello 目录中，通过运行 swift build 命令来编译包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build</span></code></pre></td></tr></table></div></figure>


<p>当命令完成之后，编译产品将会出现在 .build 目录中。通过如下命令运行 Hello 程序:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ .build/debug/Hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<p>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code>然后直接用<code>print(_:)</code>替换执行调用的内容。</p>

<h3>多了源文件协作</h3>

<p>在<code>Sources/</code>目录下创建一个新文件命名为<code>Greeter.swift</code>然后输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(name: String) {
</span><span class='line'>  print("Hello, \(name)!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>sayHello(_:)</code>方法带一个单一的字符串参数，然后在前面打印一个"hello",后面跟着函数参数单词"World".</p>

<p>现在打开<code>main.swift</code>，然后替换原来的内容为下面代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if Process.arguments.count != 2 {
</span><span class='line'>    print("Usage: hello NAME")
</span><span class='line'>} else {
</span><span class='line'>    let name = Process.arguments[1]
</span><span class='line'>    sayHello(name)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>跟之前的硬编码不同，<code>main.swift</code>现在从命令行参数中读取。替代之前直接调用<code>print(_:)</code>，<code>main.swift</code>现在调用<code>sayHello(_:)</code>方法，因为这个方法是<code>Hello</code>模块的一部分，所以不需要使用到<code>import</code>语句。</p>

<p>运行<code>swift build</code>并尝试<code>Hello</code>的新版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/Hello 'whoami'</span></code></pre></td></tr></table></div></figure>


<p>目前为止，你已经能够运用开源Swift来运行一些你想要的程序了。接下来我们就可以进入正题开始入手SPM.</p>

<h3>快速入门实例</h3>

<p>在本章节中，我们简单地学会了编译一个"`Hello world"程序。</p>

<p>为了了解SPM究竟能做什么，我们来看一下下面这个由4个独立的包组成的例子:</p>

<ul>
<li><a href="https://github.com/marklin2012/O2PlayingCard.git">O2PlayingCard</a>-定义了O2PlayingCard ， O2Suit ， O2Rank ， 3个类型</li>
<li><a href="https://github.com/marklin2012/O2FisherYates.git">O2FisherYates</a>-定义了 shuffle() 和 shuffleInPlace() 方法实现的扩展</li>
<li><a href="https://github.com/marklin2012/O2DeckOfPlayingCards.git">O2DeckOfPlayingCards</a>-定义了一个 O2Deck 类型对 O2PlayingCard 值得数据进行洗牌和抽牌。</li>
<li><a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer</a>-定义了一个用来创建 O2DeckOfPlayingCards 进行洗牌和抽出前10个卡片的可执行文件。</li>
</ul>


<p>你可以从<a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer from GitHub </a>编译并运行完整例子，然后运行如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd O2Dealer
</span><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/O2Dealer</span></code></pre></td></tr></table></div></figure>


<h3>创建一个库包</h3>

<p>我们将从创建一个代表一副标准的52张扑克牌的模块开始。 O2PlayingCard 模块定义了 由 O2Suit 枚举值（Clubs, Diamonds, Hearts, spades）和 O2Rank 枚举值（Ace, Two, Three, …, Jack, Queen, King）组成的 O2PlayingCard 类。各个类的核心代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum O2Rank : Int {
</span><span class='line'>    case Ace = 1
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public enum O2Suit: String {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public struct O2PlayingCard {
</span><span class='line'>    let rank: O2Rank
</span><span class='line'>    let suit: O2Suit
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，一个包包括位于Source/的源文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2PlayingCard
</span><span class='line'>├── Sources
</span><span class='line'>│   ├── O2PlayingCard.swift
</span><span class='line'>│   ├── O2Rank.swift
</span><span class='line'>│   └── O2Suit.swift
</span><span class='line'>└── Package.swift</span></code></pre></td></tr></table></div></figure>


<p>由于<code>O2PlayingCard</code>模块并不会生成可执行文件，这里应该成为库。库表示被编译成一个可以被其它包导入的模块的包，默认情况下，库模块公开所有位于<code>Sources/</code>目录下的源代码中声明的公共类型的方法。</p>

<p>运行 swift build 开始启动 Swift 编译的过程。如果一切进行顺利，将会在 .build/debug 目录下生成 O2PlayingCard.build 目录。</p>

<p>接下来，我们在<code>Package.swift</code>文件中定义包名，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>  name: "O2PlayingCard"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>然后我们只要将<code>O2PlayingCard</code>提交到Github上，并且给他发布一个Release版本即可完成该库包，这里可以自己手动添加一个<code>.gitignore</code>文件，忽略掉<code>/.build</code>，因为我们的包是不需要包括生成的编译结果的内容的。</p>

<h2>使用编译配置语句</h2>

<p>下一个即将编译的模块是<code>O2FisherYates</code>.跟之前<code>O2PlayingCard</code>有所不同，该模块没有定义新的类，取而代之的是该模块拓展了一个已经存在的特殊的<code>CollectionType</code>和<code>MutableCollectionType</code>接口协议，用来添加<code>shuffle()</code>方法和对应的<code>shuffleInPlace()</code>方法。</p>

<p>在 OS X 中，系统模块是 Darwin , 提供的函数是 arc4random_uniform(_:) 。在 Linux 中， 系统模块是 Glibc ， 提供的函数是 random() ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if os(Linux)
</span><span class='line'>  import Glibc
</span><span class='line'>#else
</span><span class='line'>  import Darwin.C
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>public extension Collection {
</span><span class='line'>  func shuffle() -&gt; [Generator.Element] {
</span><span class='line'>    var array = Array(self)
</span><span class='line'>    array.shuffleInPlace()
</span><span class='line'>    
</span><span class='line'>    return array
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public extension MutableCollection where Index == Int {
</span><span class='line'>  mutating func shuffleInPlace() {
</span><span class='line'>    guard count &gt; 1 else { return }
</span><span class='line'>    v 
</span><span class='line'>    for i in 0..&lt;count - 1 {
</span><span class='line'>      #if os(Linux)
</span><span class='line'>        let j = Int(random() % (count - i)) + i
</span><span class='line'>      #else
</span><span class='line'>        let j = Int(arc4random_uniform(UInt32(count - i))) + i
</span><span class='line'>      #endif
</span><span class='line'>      guard i != j else { continue }
</span><span class='line'>      swap(&self[i], &self[j])
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的步骤和前面的类似，编译通过后上传到GitHub,发布Release版本。</p>

<h3>导入依赖</h3>

<p><code>O2DeckOfPlayingCards</code>包把前两个包聚合到一起：它定义了一个<code>O2PlayingCard</code>数组中使用<code>O2FisherYates</code>的<code>shuffle()</code>方法的Deck类型。</p>

<p>为了使用 O2FisherYates 和 O2PlayingCards 模块， O2DeckOfPlayingCards 包必须在 Package.Swift 清单中将上述模块声明为依赖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>    name: "O2DeckOfPlayingCards",
</span><span class='line'>    dependencies: [
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2PlayingCard.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2FisherYates.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>    ]
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>每个依赖都需要指定一个源URL和版本号，源URL是指允许当前用户解析到对应的Git仓库。版本号遵循 <a href="http://semver.org/lang/zh-CN/">语义化版本号 2.0.0</a> 的约定,用来决定检出或者使用哪个Git标签版本来建立依赖。对于<code>FisherYates</code>和<code>PlayingCard</code>这两个依赖来说， 最新的将要被使用的主版本号为1.</p>

<p>当你运行<code>swift build</code>命令时，包管理器将会下载所有的依赖，并将它们编译成静态库，再把它们链接到包模块中。这样将会使<code>O2DeckOfPlayingCards</code>可以访问依赖import语句的模块的公共成员</p>

<p>你可以看到这些资源被下载到你工程根目录的 Packages 目录下，并且会生成编译产品在你工程根目录的 .build 目录下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2DeckOfPlayingcards
</span><span class='line'>├── .build
</span><span class='line'>│   └── debug
</span><span class='line'>│       ├── O2DeckOfPlayingCards.build
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftdoc
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftmodule
</span><span class='line'>│       ├── O2FisherYates.build
</span><span class='line'>│       ├── O2FisherYates.swiftdoc
</span><span class='line'>│       ├── O2FisherYates.swiftmodule
</span><span class='line'>│       ├── O2PlayingCard.build
</span><span class='line'>│       ├── O2PlayingCard.swiftdoc
</span><span class='line'>│       └── O2PlayingCard.swiftmodule
</span><span class='line'>└── Packages
</span><span class='line'>    └── O2FisherYates-1.0.0
</span><span class='line'>    │   ├── Package.swift
</span><span class='line'>    │   ├── README.md
</span><span class='line'>    │   └── Sources
</span><span class='line'>    └── O2Playingcard-1.0.1
</span><span class='line'>        ├── Package.swift
</span><span class='line'>        ├── README.md
</span><span class='line'>        └── Sources</span></code></pre></td></tr></table></div></figure>


<p><code>Package</code>目录包含了被复制的包依赖的所有仓库，这样将使你能修改源代码并直接推送这些修改到它们的源，而不需要再对每个包在单独进行复制。</p>

<p>Swift是一门先进的语言，SPM的社区也在不断地完善中。在swift开源之后，我们很容可以看到它的潜力，看来掌握这门语言必将是一个大趋势。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/07/ioszhong-de-re-qi-dong/">iOS中的热修复</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-07T16:46:54+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:46 pm</span></time>
        
           | <a href="/blog/2016/11/07/ioszhong-de-re-qi-dong/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>背景需求</h2>

<h3>为什么我们需要热修复</h3>

<ul>
<li>工作中容易犯错，bug难以避免</li>
<li>开发和测试人力有限</li>
<li>苹果AppStore审核周期太长，一旦出现严重bug难以快速上线新版本</li>
</ul>


<h2>JSPatch简介</h2>

<p>JSPatch诞生于2015年5月，最初是腾讯广研高级ios开发@bang的人格项目。它能够使用JavaScripit调用Objective-C的原声接口，从而动态植入代码来替换旧代码，以实现修复线上bug.</p>

<h2>JSPatch与wax对比</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3d1af75ebfe7de01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最关键的是JSpath可实现方法粒度的线上代码替换，能修复一切代码引起的bug.而Wax无法实现。</p>

<h2>JSPatch实现原理</h2>

<h3>基础原理</h3>

<p>Objective-C是动态语言，具有运行时特性，该特性可通过类名称和方法名的字符换获取该类和该方法，并实例化调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class class = NSClassFromString(“UIViewController");
</span><span class='line'>id viewController = [[class alloc] init];  
</span><span class='line'>SEL selector = NSSelectorFromString(“viewDidLoad");
</span><span class='line'>[viewController performSelector:selector];</span></code></pre></td></tr></table></div></figure>


<p>也可以替换某个类的方法为新的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void newViewDidLoad(id slf, SEL sel) {}
</span><span class='line'>class_replaceMethod(class, selector, newViewDidLoad, @"");</span></code></pre></td></tr></table></div></figure>


<p>还可以注册一个类，为类添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
</span><span class='line'>objc_registerClassPair(cls);
</span><span class='line'>class_addMethod(cls, selector, implement, typedesc);</span></code></pre></td></tr></table></div></figure>


<h3>JavaScript调用</h3>

<p>我们可以用JavaScript对象定义一个Objective-C类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  __isCls: 1,
</span><span class='line'>  __clsName: "UIView"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在OC执行JS脚本前，通过正则把所有方法调用都改成__c()函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView.alloc().init()
</span><span class='line'>-&gt;
</span><span class='line'>UIView.__c('alloc')().__c('init')()</span></code></pre></td></tr></table></div></figure>


<p>给JS对象基类Object的prototype加上c成员，这样所有对象都可以调用到c,根据当前对象类型判断进行不同操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Object.prototype.__c = function(methodName) {
</span><span class='line'>  if (!this.__obj && !this.__clsName) return this[methodName].bind(this);
</span><span class='line'>  var self = this
</span><span class='line'>  return function(){
</span><span class='line'>    var args = Array.prototype.slice.call(arguments)
</span><span class='line'>    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>互传消息</h2>

<p>JS和OC是通过JavaScriptCore互传消息的。OC端在启动JSPatch引擎会创建一个JSContext实例，JSContext是js代码的执行环境，可以给JSContext添加方法。JS通过调用JSContext定义的方法把数据传给OC,OC通过返回值传回给JS.调用这种方法，它的参数/返回值 javaScripotCore都会自动转换，OC里的NSArray,NSdictionary
,NSString,NSNumber,NSBlock会分别转为JS端的数组/对象/字符串/数字/函数类型  对于一个自定义ID对象，JavaScriptCore会把这个自定义对象的指针传给JS,这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象声明周期的管理，如果JS有变量引用时，这个OC对象引用计数就加1，JS变量的引用释放了就减一，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>

<h2>方法替换</h2>

<ol>
<li>把UIViewContrller的 <code>-viewWillAppear:</code>方法通过<code>class_replaceMethod()</code>接口指向<code>_objc_msgForward</code>,这是一个全局IMP,OC调用方法不存在时都会转发到这个IMP上，这里直接把方法替换成这个IMP,这样调用这个方法时就会走到<code>-forwardInvocation:</code></li>
<li>为UIViewController添加<code>-ORIGviewWillAppear:</code>和<code>-_JPviewWillAppear:</code>两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数</li>
<li>改写UIViewController的<code>-forwardInvocation:</code>方法为自定义实现。一旦OC里调用UIViewController的<code>-viewWillAppear:</code>方法，经过上面的处理会把这个调用转发到<code>forwardInvocation:</code>，这时已经组装好了一个NSInvocation,包含了这个调用的参数。在这里把参数从NSInvocation反解出来，待着参数调用删除新增加的方法<code>-JPviewWillAppear:</code>,在这个新方法里获取到参数传给JS,调用JS的实现函数，整个调用过程就结束了，整个过程图示如下：</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-d079409a185f394c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最后一个问题，我们把UIViewController的<code>-forwardInvocation:</code>方法的实现给替换掉了，如果程序里挣得有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现了做个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程</p>

<h2>JSPatch代码示例</h2>

<p>jspatch在oc上的调用十分简单</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
</span><span class='line'>[JPEngine startEngine]; 
</span><span class='line'>NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; 
</span><span class='line'>NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; 
</span><span class='line'>[JPEngine evaluateScript:script];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>一个JavaScript修复Objective-C的bug的示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation JPTableViewController
</span><span class='line'>
</span><span class='line'>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
</span><span class='line'>  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
</span><span class='line'>  [self.navigationController pushViewController:ctrl];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上述代码中取数组元素出可能会超出数组范围导致crash.如果在项目里引用了JSPatch,就可以发JS脚本修复这个bug:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defineClass("JPTableViewController", {
</span><span class='line'>  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
</span><span class='line'>    var row = indexPath.row()
</span><span class='line'>    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
</span><span class='line'>      var content = self.dataArr()[row];
</span><span class='line'>      var ctrl = JPViewController.alloc().initWithContent(content);
</span><span class='line'>      self.navigationController().pushViewController(ctrl);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}, {})</span></code></pre></td></tr></table></div></figure>


<h2>热修复的解决方案</h2>

<ol>
<li><p>版本更新策略</p></li>
<li><p>考虑到下一个提交的App版本已经修复了上一个版本的bug,所以不同的App版本对应的补丁肯定也不同，同一个App版本下，可以出现递增的补丁版本</p></li>
<li>补丁为全量更新，即最新的版本补丁包括旧版的补丁的内容，更新后新版补丁覆盖旧版补丁</li>
<li>补丁分为可选补丁和必选补丁，必选补丁用于重大bug的修复，如果不更新必须补丁则App无法继续使用。如下图2中，补丁版本v1234对应各自版本的用户，补丁v3为必须更新，补丁v1,v2,v4为可选补丁，则v1,v2必须更新到v4才可使用；而v3的哟过户可先使用，同事后台静默更新到v4</li>
</ol>


<h2>安全策略</h2>

<p>安全问题在于JS脚本可能被中间人攻击替换代码。可采取一下三种方法</p>

<ol>
<li>对称加密： 如zip的加密压缩，Aes等加密算法。优点是简单，缺点是安全性低，易被破解。若客户端被反编译，密码字段泄露，则完全破解。</li>
<li><a href="HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82">HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82</a></li>
<li>RSA校验：安全性高，部署简单</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-14723080a9823ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>详细校验步骤如下：</p>

<ol>
<li>服务器计算出脚本文件的MD5值，作为这个文件的数字签名</li>
<li>服务器通过私钥加密算出的MD5值，得到一个加密后的md5值</li>
<li>把脚本文件和加密后的md5值一起发给客户端</li>
<li>客户端拿到加密后的md5值，通过保存在客户端的公钥解密</li>
<li>客户端计算脚本文件的md5值</li>
<li>对比第 4/5 步的两个md5值(分别是客户端和服务器端计算出来的MD5值)，若相等则通过校验</li>
</ol>


<h2>客户端策略</h2>

<p>客户端具体策略如下图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3f5d0d89e0b3833d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<ol>
<li>用户打开App时，同步进行本地补丁的加载</li>
<li>用户打开App时，后台进程发起异步网络请求，获取服务器中当前App版本所对应的最新补丁版本和必须的补丁版本</li>
<li>获取补丁版本的请求回来后，跟本地的补丁版本进行对比</li>
<li>如果本地补丁版本小于必须版本，则提示用户，展示下载补丁界面，进行进程同步的补丁下载。下载完成后重新加载App和最新补丁，再进入App</li>
<li>如果本地补丁版本不小于必须版本，但小于最新版本，则进入App,不影响用户操作。同时进行后台进程异步静默下载，下载后补丁保存在本地，下次App启动时再加载最新补丁。</li>
<li>如果版本为最新，则进入App</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">iOS中常见的面试题二</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-04T20:22:42+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:22 pm</span></time>
        
           | <a href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>如何进行真机调试</h2>

<ol>
<li>首先需要钥匙串创建一个钥匙(key)</li>
<li>将钥匙串上传到官网，获取ios Development证书</li>
<li>创建APP Id即我们应用程序中的BundleId</li>
<li>添加Device ID 即 UDID;</li>
<li>通过勾选前面所创建的证书：App ID, Deveice id</li>
<li>生成mobileProvision文件</li>
<li>先决条件：申请开发者账号 99美刀</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">Ios中常见的面试题及答案</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-03T17:50:01+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>5:50 pm</span></time>
        
           | <a href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>ios中深拷贝和浅拷贝</h2>

<p>在ios开发中，经常涉及到深拷贝和浅拷贝的问题，针对深拷贝和浅拷贝，为了方便大家的理解，专门总结如下:</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">自定义UICollectionViewLayout</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-28T14:34:50+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:34 pm</span></time>
        
           | <a href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>UICollectionView，自从ios6之后就被引入到开发中，现在已经变成了最流程的UI元素之一，它最吸引人的特性就是将数据和布局进行分离，依靠分离的数据元素去处理布局，这个布局对象是决定占位元素和视图的元素。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">Ios10 UICollectionView 新特性</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-24T10:35:36+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:35 am</span></time>
        
           | <a href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>关于ios 10 UIcolelctionView的新特性，主要还是体现在如下三个方面</p>

<ol>
<li>顺滑的滑动体验</li>
<li>针对self=sizing的改进</li>
<li>Interactive recording重排</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/17/ios10-usernotifications/">Ios10 UserNotifications</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-17T09:53:08+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:53 am</span></time>
        
           | <a href="/blog/2016/10/17/ios10-usernotifications/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ios10以前杂乱的和通知相关的API都被统一了，现在开发者可以使用独立的UserNotificaitons.framework来集中管理和使用iOS系统中通知的功能。在此基础上，Apple还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知UI等一系列功能。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/17/ios10-usernotifications/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>
	QQ群
</h1>
   <br/>
	<p>欢迎加入swift学习交流群:252710124</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">使用Carthage管理ios依赖</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/22/ip-tcp-he-http/">IP TCP 和HTTP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/16/reactiveswiftru-men/">ReactiveSwift入门</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/11/swift-package-managerru-men/">Swift Package Manager入门</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/07/ioszhong-de-re-qi-dong/">iOS中的热修复</a>
      </li>
    
  </ul>
</section>
<section>
	<h1>文章分类</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/cocoapods/'>cocoapods (1)</a></li>
<li class='category'><a href='/blog/categories/git/'>git (3)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (29)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (2)</a></li>
<li class='category'><a href='/blog/categories/nodejs/'>nodejs (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (21)</a></li>
<li class='category'><a href='/blog/categories/xcode/'>xcode (1)</a></li>

	</ul>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andrew-anlu">@andrew-anlu</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andrew-anlu',
            count: 3,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/Andrewswift1987?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/Andrewswift1987">My Delicious Bookmarks &raquo;</a></p>
</section>

 <section>
      <h1>访客统计</h1>
      <br/>
    <a href="http://info.flagcounter.com/Bkif"><img src="http://s01.flagcounter.com/count2/Bkif/bg_ffffff/txt_000000/border_CCCCCC/columns_3/maxflags_10/viewers_0/labels_1/pageviews_1/flags_1/percent_0/" alt="Free counters!" border="0"></a>
    </section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;">
  <a href="#" onclick="goTop();return false;"><img src="http://7xsn4e.com2.z0.glb.clouddn.com/top.png" border=0 alt="返回顶部" width="50" height="50"></a>
</div>
<script src="/javascripts/top.js" type="text/javascript"></script>
<!--返回顶部结束-->


<p>
  Copyright &copy; 2016 - 安路 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>



</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'Andrewswift1987';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
