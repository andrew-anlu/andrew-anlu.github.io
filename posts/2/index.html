
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>安路的技术博客</title>
  <meta name="author" content="安路">

  
  <meta name="description" content="在swift3中，GCD的语法已经全面修改，变得更加swift化了。 ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andrew-anlu.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="安路的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">安路的技术博客</a></h1>
  
    <h2>Nothing in life is to be feared. It is only to be understood</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://andrew-anlu.github.io" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andrew-anlu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/12/14/swift3-gcd/">swift3-GCD</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-12-14T16:05:13+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:05 pm</span></time>
        
           | <a href="/blog/2016/12/14/swift3-gcd/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/12/14/swift3-gcd/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在swift3中，<a href="https://developer.apple.com/reference/dispatch">GCD</a>的语法已经全面修改，变得更加swift化了。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/12/14/swift3-gcd/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">使用Carthage管理ios依赖</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-28T15:55:02+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>3:55 pm</span></time>
        
           | <a href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/Carthage/Carthage.git">Carthage</a>官网已经针对cocopods和carthage进行了详细的说明：</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/22/ip-tcp-he-http/">IP TCP 和HTTP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-22T10:04:46+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:04 am</span></time>
        
           | <a href="/blog/2016/11/22/ip-tcp-he-http/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当app和服务器进行通信的额时候，大多数情况下，都是采用http协议。http最初是为web浏览器而定制的，如果在浏览器输入 <code>http://www.baidu.com</code>。浏览器就会通过http协议和baidu所对应的服务器进行通信。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/22/ip-tcp-he-http/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/16/reactiveswiftru-men/">ReactiveSwift入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-16T10:29:29+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:29 am</span></time>
        
           | <a href="/blog/2016/11/16/reactiveswiftru-men/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>Signal</h2>

<p>一个signal类型的实例，代表了一个有时序的并且可以被观察(类似订阅)的事件流。</p>

<p>信号通常被用来表示正在进行中的事件流，比如通知，用户输入等。用户（或者只要能造成事件的东西）产生的事件发送或者被接受，事件就被传递到信号上，并且被推送(push-Driven)到任何观察者哪里，并且所有观察者都是同时收到这些事件。</p>

<p>如果你想访问一系列的事件，就必须观察一个信号，观察一个信号并不会触发任何副作用，可以这样理解。信号是由生产者生产和推动的，消费者（观察者）是不会对事件的生命周期有任何影响。在观察一个信号时，发送了什么事件，只能对这个事件操作，因为信号是由时序的，不能随机的访问其他事件。</p>

<p>信号可以通过原函数去操作，比如filter,map,reduce,也可以同时操作多个信号如zip,这些原函数只在nextEvents生效（也就是对complete,failure等不生效）</p>

<p>在一个信号的生命周期里，可以发送无数次的NextEvents事件，直到他们被终结，类似compleye,Failed,InterRupper.终止事件没有数据值，所以他们必须被单独处理。</p>

<h2>Subscription</h2>

<p>一个信号通常被用来表示正在进行中的事件流，有时候他们被叫做热信号，这意味着订阅者可以错过一些在它订阅前发送的事件。订阅一个信号不会触发任何副作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>20
</span><span class='line'>21
</span><span class='line'>22
</span><span class='line'>23
</span><span class='line'>24
</span><span class='line'>25
</span><span class='line'>26
</span><span class='line'>27
</span><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    // Signal.pipe is a way to manually control a signal. the returned observer can be used to send values to the signal
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nonerror&gt;.pipe()
</span><span class='line'>    let subscriber1 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to the signal")
</span><span class='line'>    print("\(observer)")
</span><span class='line'>    signal.observe(subscriber1)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    // subscriber1 will receive the value
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    print("Subscriber 2 subscribes to the signal")
</span><span class='line'>    // Notice how nothing happens at this moment, i.e. subscriber2 does not receive the previously sent value
</span><span class='line'>    signal.observe(subscriber2)
</span><span class='line'>    print("Send value `20` on the signal")
</span><span class='line'>    // Notice that now, subscriber1 and subscriber2 will receive the value
</span><span class='line'>    observer.sendNext(20)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to the signal
</span><span class='line'>Observer&lt;int, nonerror&gt;(action: (Function))
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber 1 received 10
</span><span class='line'>Subscriber 2 subscribes to the signal
</span><span class='line'>Send value `20` on the signal
</span><span class='line'>Subscriber 1 received 20
</span><span class='line'>Subscriber 2 received 20&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>因为Swift有泛型的存在，这样的话我们可以把Signal当做任何数据类型的容器，而不是像OC中利用上帝类型Id，更加方便传递数据</p>

<p>首先我们通过Signal.pipe()创建了一个信号和一个观察者。</p>

<p>奇怪的是，在RACOC部分中，我们很少主动创建观察者，我们通常直接订阅信号就可以。</p>

<p>在Swift中，通过pipe创建的信号是个热信号，类似于OC中的RACSubject系列，在RACSubject继承自RACSiganl又继承RACStream，RACStream是一个Monad,它可以代表数据和数据的一系列的操作如map,flatterMap,bind</p>

<p>RACSubject又遵守了RACSubscriber协议，这个协议定义了可以发送数据的操作。</p>

<p>所以RACSubject即是一个信号，又是一个观察者。</p>

<p>在Swift部分的实现中，Signal并没有实现发送数据的方法。所以它需要一个内部的Observer去发送数据。所以它被pipe直接返回。</p>

<p>在外部我们需要自己实例化一个Observer观察者。去订阅事件。</p>

<p>可能在你查看Pipe的实现的时候并不好理解。把尾随闭包补全相对好理解点。</p>

<p>做个总结：</p>

<ul>
<li>RACOC中：RACSubject = RACSignal + RACSubscriper，在订阅的时候，订阅者被放在了RACSubject内部存放，我们只需要去关注订阅的block实现即可。</li>
<li>RACSwift中:Signal 仅仅就是一个信号，所以需要一个内部观察者去充当发送数据的工具。外部的订阅需要自己手动实例观察者</li>
<li>热信号：由于pipe方法返回的是热信号，所以一个订阅者会错过在订阅之前发送的事件
*</li>
</ul>


<h3>empty</h3>

<p>空信号直接发送一个interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptySignal = Signal&lt;int, nonerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, nonerror&gt;(
</span><span class='line'>    failed: { _ in print("error not called") },
</span><span class='line'>    completed: { print("completed not called") },
</span><span class='line'>    interrupted: { print("interrupted called") },
</span><span class='line'>    next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptySignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>interrupted called&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Never</h3>

<p>一个Never信号不会发送任何事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverSignal = Signal&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        interrupted: { print("interrupted not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverSignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>uniqueValues唯一值</h3>

<p>仅从集合中发送一次相同事件&ndash;类似与arrayQueue变成了Setqueue</p>

<p>注意：这会造成被发送的值被保留下来，用于以后发送的时候来检查是否重复，你可以编写一个函数来过滤重复值，这样可以减少内存消耗。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>scopedExample("`uniqueValues`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let uniqueSignal = signal.uniqueValues()
</span><span class='line'>    uniqueSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(5)
</span><span class='line'>}
</span><span class='line'>--- `uniqueValues` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2
</span><span class='line'>Subscriber received 3
</span><span class='line'>Subscriber received 4
</span><span class='line'>Subscriber received 5&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每一个发送的值转换成新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let mappedSignal = signal.map { $0 * 2 }
</span><span class='line'>    mappedSignal.observe(subscriber)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber received 20&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error值变成新的error值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>        let userInfo = [NSLocalizedDescriptionKey: "??"]
</span><span class='line'>        let code = error.code + 10000
</span><span class='line'>        let mappedError = NSError(domain: "com.reactivecocoa.errordomain", code: code, userInfo: userInfo)
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nserror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, nserror&gt;(failed: { print("Subscriber received error: \($0)") } )
</span><span class='line'>    let mappedErrorSignal = signal.mapError { (error:NSError) -&gt; NSError in
</span><span class='line'>        return mappedError
</span><span class='line'>    }
</span><span class='line'>    mappedErrorSignal.observe(subscriber)
</span><span class='line'>    print("Send error `NSError(domain: \"com.reactivecocoa.errordomain\", code: 4815, userInfo: nil)` on the signal")
</span><span class='line'>    observer.sendFailed(NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil))
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Send error `NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil)` on the signal
</span><span class='line'>Subscriber received error: Error Domain=com.reactivecocoa.errordomain Code=14815 "??" UserInfo={NSLocalizedDescription=??}&lt;/int, nserror&gt;&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>用于过滤一些值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    // subscriber will only receive events with values greater than 12
</span><span class='line'>    let filteredSignal = signal.filter { $0 &gt; 12 ? true : false }
</span><span class='line'>    filteredSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    observer.sendNext(11)
</span><span class='line'>    observer.sendNext(12)
</span><span class='line'>    observer.sendNext(13)
</span><span class='line'>    observer.sendNext(14)
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>Subscriber received 13
</span><span class='line'>Subscriber received 14&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>在发送的值为可选类型中：如果有值，把值解包，如果是nil丢弃掉</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int?, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int?` and observer is of type `Int`, given we're unwrapping
</span><span class='line'>    // non-`nil` values
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let ignoreNilSignal = signal.ignoreNil()
</span><span class='line'>    ignoreNilSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(nil)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 3&lt;/int, noerror&gt;&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num)只取前num此值得信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let takeSignal = signal.take(2)
</span><span class='line'>    takeSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect</h3>

<p>在发送complete事件之后，观察者会收到一个由之前事件组成的数组</p>

<p>注意：如果在发送complete事件的时候，没有任何事件发送，观察者会收到一个空的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int` and observer is of type `[Int]` given we're "collecting"
</span><span class='line'>    // `Int` values for the lifetime of the signal
</span><span class='line'>    let subscriber = Observer&lt;[Int], NoError&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let collectSignal = signal.collect()
</span><span class='line'>    collectSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendCompleted()
</span><span class='line'>}
</span><span class='line'>--- `collect` ---
</span><span class='line'>Subscriber received [1, 2, 3, 4]&lt;/int, noerror&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h2>SignalProducer</h2>

<p>一个信号发生器，是SignalProducer类型的实例，它可以创建信号(signals)并施加副作用（side effects）</p>

<p>信号发生器用来表示操作或者任务，比如网络请求，每一次对它的调用start()将会生成一个新的潜在操作，并允许调用者观察它的结果，还有一个startWithSignal()方法，会给出产生的信号，允许在必要的情况下监听多次。</p>

<p>根据start()方法的动作方式，被同一个信号发生器生成的信号可能会有不同的事件顺序或版本，甚至事件流完全不一样！和普通的信号不同，在观察者连接上之前，信号发生器不会开始工作（也就没有事件会生成），并且在每一个新的监听器连接上时其工作都会重新开始一个单独的工作流。</p>

<p>启动一个信号发生器会返回一个销毁器(disposable)，它可用来打断或取消被生成信号的工作</p>

<p>和信号一样，信号生成器可以通过map,filter等原函数操作，使用lift方法，所有信号的原函数可以被提升成为以信号生成器为对象的操作，除此以外，还有一些用来控制何时与如何启动信号生成器的原函数，比如times.</p>

<p>通过lift函数可以让热信号转变为冷信号。</p>

<h3>Subscription</h3>

<p>一个信号生成器代表了一种可以在需要的时候才被启动的操作（不像signal是自启动的），这种信号是冷信号，在刚开始这个信号的状态也为冷（未激活），既然是冷信号，那么就意味着这一个观察者不会错过任何被信号生成器发出的值。</p>

<p>补充：像signal是创建的时候状态为cold(理解为未激活)，被订阅时状态为hot(理解为激活)</p>

<p>但是冷信号和热信号与状态为冷热是两个不同的概念，冷信号会带来副作用，热信号不会</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    let producer = SignalProducer&lt;int, noerror&gt; { observer, _ in
</span><span class='line'>        print("New subscription, starting operation")
</span><span class='line'>        observer.sendNext(1)
</span><span class='line'>        observer.sendNext(2)
</span><span class='line'>    }
</span><span class='line'>    let subscriber1 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to producer")
</span><span class='line'>    producer.start(subscriber1)
</span><span class='line'>    print("Subscriber 2 subscribes to producer")
</span><span class='line'>    // Notice, how the producer will start the work again
</span><span class='line'>    producer.start(subscriber2)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 1 received 1
</span><span class='line'>Subscriber 1 received 2
</span><span class='line'>Subscriber 2 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 2 received 1
</span><span class='line'>Subscriber 2 received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>像不像是RACDynamicSignal的创建方式，这不过不同与Sinal的是，这里的发送信号的观察者是在内部通过Signal.pipe()生成的，不需要外部创建。</p>

<p>SignalProduce是冷信号，任何一个订阅者/观察者都不会错过任何事件</p>

<p>start方类似Signal的 signal.observe()方法，只不过Signal的方法只有一个作用，就是关联一个观察者，而SignalProduce的start方法还多了一个激活信号的功能</p>

<h3>Empty</h3>

<p>一个会立即调用complete事件的信号生成器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `empty`
</span><span class='line'> A producer for a Signal that will immediately complete without sending
</span><span class='line'> any values.
</span><span class='line'> */
</span><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptyProducer = SignalProducer&lt;int, noerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed called") },
</span><span class='line'>        interrupted: { print("interrupted called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptyProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>Signal调用的是interrup方法，暂时不知道为什么，可能是为了区分语义吧，Signal是有时序的，SignalProduce是没有时序的。</p>

<h3>Never</h3>

<p>一个什么都不会发送的信号器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `never`
</span><span class='line'> A producer for a Signal that never sends any events to its observers.
</span><span class='line'> */
</span><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverProducer = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>buffer</h3>

<p>创建一个事件队列可以回放已经发送的事件</p>

<p>当一个值被发送的时候，它会被放进缓冲区内，如果缓冲区已经溢出，就会丢弃旧的值</p>

<p>这些被缓存的值将会被保留，直到这个信号被终结，当一个信号启动的时候，如果队列里没有任何值，所有被发送的新值都会被自动转发到观察者那里，直到管着着收到一个终止事件。</p>

<p>当一个终止事件被发送到队列中，观察者不会再收到任何值，并且这个事件不会被计算buffer的缓冲区大小，所以没有缓存的值都会被丢弃。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`buffer`") {
</span><span class='line'>    let (producer, observer) = SignalProducer&lt;int, noerror&gt;.buffer(2)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    var values: [Int] = []
</span><span class='line'>    producer.start { event in
</span><span class='line'>        switch event {
</span><span class='line'>        case let .Next(value):
</span><span class='line'>            values.append(value)
</span><span class='line'>        default:
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print(values)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    print(values)
</span><span class='line'>    let subscriber = Observer&lt;int,noerror&gt;(next:{ bufferdValue in
</span><span class='line'>        print("\(bufferdValue)")
</span><span class='line'>    })
</span><span class='line'>    producer.start(subscriber)
</span><span class='line'>}
</span><span class='line'>--- `buffer` ---
</span><span class='line'>[2, 3]
</span><span class='line'>[2, 3, 4]
</span><span class='line'>3
</span><span class='line'>4&lt;/int,noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithSignal</h3>

<p>通过Producer返回一个Signal,当闭包调用时返回signal开始发送事件</p>

<p>闭包返回一个Disponsable，可以用来中断Signal或者完成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithSignal`") {
</span><span class='line'>    var started = false
</span><span class='line'>    var value: Int?
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .on(next: {
</span><span class='line'>            value = $0
</span><span class='line'>        })
</span><span class='line'>        .startWithSignal { signal, disposable in
</span><span class='line'>            print(signal)
</span><span class='line'>            print(value) // nil
</span><span class='line'>        }
</span><span class='line'>    print(value)
</span><span class='line'>}
</span><span class='line'>--- `startWithSignal` ---
</span><span class='line'>ReactiveCocoa.Signal&lt;swift.int, result.noerror&gt;
</span><span class='line'>nil
</span><span class='line'>Optional(42)&lt;/swift.int, result.noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithNext</h3>

<p>通过信号生成器创建一个信号，并且给这个信号内部直接构建一个观察者，在指定的闭包中会直接订阅next事件。</p>

<p>返回一个Disposable,可以中断这个信号，中断之后这个闭包不会再被调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithNext`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithNext` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个订阅只能接受next事件</p>

<h3>startWithCompleted</h3>

<p>同startWithNext，只不过只能接受complete事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithCompleted`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithCompleted {
</span><span class='line'>            print("completed called")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithCompleted` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithFailed</h3>

<p>同startWithNext， 只不过只能接受Failer事件事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithFailed`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "example", code: 42, userInfo: nil))
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithFailed` ---
</span><span class='line'>Error Domain=example Code=42 "(null)"&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithInterrupted</h3>

<p>同startWithNext,只不过只能接受interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithInterrupted`") {
</span><span class='line'>    let disposable = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>        .startWithInterrupted {
</span><span class='line'>            print("interrupted called")
</span><span class='line'>        }
</span><span class='line'>    disposable.dispose()
</span><span class='line'>}
</span><span class='line'>--- `startWithInterrupted` ---
</span><span class='line'>interrupted called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>lift</h3>

<p>这个相对难理解点，大致类似于RAC_OC部分中的bind函数，monad中bind函数</p>

<p>可以理解为所有的原函数都是通过lift去实现的，借用中间信号来实现一系列的信号变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`lift`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    let transform: Signal&lt;int, noerror&gt; -&gt; Signal&lt;int, noerror&gt; = { signal in
</span><span class='line'>        counter = 42
</span><span class='line'>        return signal
</span><span class='line'>    }
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 0)
</span><span class='line'>        .lift(transform)
</span><span class='line'>        .startWithNext { _ in
</span><span class='line'>            print(counter)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `lift` ---
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每个值都转换为新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 1)
</span><span class='line'>        .map { $0 + 41 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error转换为新的error</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "mapError", code: 42, userInfo: nil))
</span><span class='line'>        .mapError { Error.Example($0.description) }
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Example("Error Domain=mapError Code=42 \"(null)\"")&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>过滤不符合条件的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .filter { $0 &gt; 3}
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num) 只取前几次的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .take(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>1
</span><span class='line'>2&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>observeOn</h3>

<p>在指定调度器上分发事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `observeOn`
</span><span class='line'> Forwards all events onto the given scheduler, instead of whichever
</span><span class='line'> scheduler they originally arrived upon.
</span><span class='line'> */
</span><span class='line'>scopedExample("`observeOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let completion = { print("is main thread? \(NSThread.currentThread().isMainThread)") }
</span><span class='line'>    if #available(OSX 10.10, *) {
</span><span class='line'>    baseProducer
</span><span class='line'>        .observeOn(QueueScheduler(qos: QOS_CLASS_DEFAULT, name: "test"))
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>    }
</span><span class='line'>    baseProducer
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>}
</span><span class='line'>--- `observeOn` ---
</span><span class='line'>is main thread? true&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h2>collect</h2>

<p>在发送完成的时候将一系列的值聚合为一个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect()`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect()` ---
</span><span class='line'>[1, 2, 3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(count:)</h3>

<p>在发送数据的时候（不需要发送complete）的时候将一系列的值聚合为数组，数组的长度为count,如果有很多数据，将会返回多个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(count:)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>        observer.sendNext(5)
</span><span class='line'>//            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect(count: 2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(count:)` ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(predicate:) matching values inclusively</h3>

<p>通过谓词将一系列的值聚合为一个数组，注意在发送complete时候，如果前面只剩下一个值，就不需要聚合（因为没有其它元素和最后一个元素聚合），直接返回一个只有一个元素的数组。如果没有数据则返回一个空数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values inclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>//            observer.sendNext(1)
</span><span class='line'>//            observer.sendNext(2)
</span><span class='line'>//            observer.sendNext(3)
</span><span class='line'>//            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values in values.reduce(0, combine: +) == 3 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values inclusively ---
</span><span class='line'>[]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>尝试打开注释看看会有什么结果</p>

<h3>collect(predicate:) matching values exclusively</h3>

<p>和上一个不同的是，如果谓词成功就把之前的聚合在一起，可以理解为把成功的界限当做分隔符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values exclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendNext(5)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values, next in next == 3 || next == 5  }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values exclusively ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4] // 3满足了条件所以被分开
</span><span class='line'>[5] // 5也是&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>combineLatestWith</h3>

<p>将第一个信号生成器的values和被聚合信号生成器的最后一个值聚合为一个元组</p>

<p>新产生的信号生成器不会发送任何值，只是转发，任何一个原来的信号被中断，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combineLatestWith`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let producer2 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>    producer1
</span><span class='line'>        .combineLatestWith(producer2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combineLatestWith` ---
</span><span class='line'>(1, 2)
</span><span class='line'>(2, 2)
</span><span class='line'>(3, 2)
</span><span class='line'>(4, 2)&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skip</h3>

<p>skip（num），跳过num此发送的事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skip`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    producer1
</span><span class='line'>        .skip(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skip` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>materialize</h3>

<p>将被发送的值(value)编程Event,允许他们被修改。还句话说，允许他们被修改，把一个值变成一个Monad</p>

<p>当收到一个complete或者Failure事件，这个新的信号生成器，会发送事件并且结束。当收到一个interrupted事件，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`materialize`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .materialize()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `materialize` ---
</span><span class='line'>NEXT 1
</span><span class='line'>NEXT 2
</span><span class='line'>NEXT 3
</span><span class='line'>NEXT 4
</span><span class='line'>COMPLETED
</span><span class='line'>// 注意 value  如果不做materialize就是Int类型</span></code></pre></td></tr></table></div></figure>


<h3>sampleOn</h3>

<p>当sampler（被操作的信号生成器）发送任何事件的时候，都转发原来信号生成器的最后一个值</p>

<p>如果当一个sampler启动时，当前的值没有被观察者，没有任何事情发生</p>

<p>新产生的信号生成器从源信号生成器哪里发送数据，如果两个信号生成器任何一个complete或者interrupt,新产生的都会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `sampleOn`
</span><span class='line'> Forwards the latest value from `self` whenever `sampler` sends a Next
</span><span class='line'> event.
</span><span class='line'> If `sampler` fires before a value has been observed on `self`, nothing
</span><span class='line'> happens.
</span><span class='line'> Returns a producer that will send values from `self`, sampled (possibly
</span><span class='line'> multiple times) by `sampler`, then complete once both input producers have
</span><span class='line'> completed, or interrupt if either input producer is interrupted.
</span><span class='line'> */
</span><span class='line'>scopedExample("`sampleOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let sampledOnProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>        .map { _ in () }
</span><span class='line'>    let newProduce = baseProducer
</span><span class='line'>        .sampleOn(sampledOnProducer)
</span><span class='line'>      newProduce  .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `sampleOn` ---
</span><span class='line'>4
</span><span class='line'>4&lt;/int, noerror&gt;&lt;/int, noerror&gt;
</span><span class='line'>sampler发送的2次值都被变换成baseProduce 的comlete前的最后一个值</span></code></pre></td></tr></table></div></figure>


<h3>combinePrevious</h3>

<p>向前合并，没法送一个值就结合历史发送数据的最后一个构造成一个新的元组返回。在第一个发送时由于没有历史数据，所以combinePrevious传递了一个默认值。当做第一次的合并。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combinePrevious`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .combinePrevious(42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combinePrevious` ---
</span><span class='line'>(42, 1) // 第一次没有历史记录默认值是42
</span><span class='line'>(1, 2) // 第二次默认记录是1
</span><span class='line'>(2, 3)
</span><span class='line'>(3, 4)&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>scan</h3>

<p>类似reduce,将值聚合为一个新的值，每次聚合都保留结果作为下次的默认值，首次需给出默认值</p>

<p>每次聚合都会发送这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`scan`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .scan(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `scan` ---
</span><span class='line'>1
</span><span class='line'>3
</span><span class='line'>6
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>reduce</h3>

<p>和scan类似，区别为reduce只发送聚合后的值并且立即结束</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`reduce`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .reduce(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `reduce` ---
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skipRepeats</h3>

<p>跳过表达式里返回true的值，第一个值不会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipRepeats` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>4
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<h3>skipWhile</h3>

<p>对每个值都去做判断，知道返回false,之前的值会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipWhile` ---
</span><span class='line'>1  // 到1 返回false  之前的值被忽略掉
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeUntilReplacement</h3>

<p>在被替换的信号发生器发送信号之后，发送被替换的信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeUntilReplacement`") {
</span><span class='line'>    let (replacementSignal, incomingReplacementObserver) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt; { incomingObserver, _ in
</span><span class='line'>        incomingObserver.sendNext(1)
</span><span class='line'>        incomingObserver.sendNext(2)
</span><span class='line'>        incomingObserver.sendNext(3)
</span><span class='line'>// 下面被替换的信号生成器发送了事件，之后就不再发送baseProducer的事件了
</span><span class='line'>// 相当于被替换了
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>        incomingObserver.sendNext(4)
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>    }
</span><span class='line'>    let producer = baseProducer.takeUntilReplacement(replacementSignal)
</span><span class='line'>    producer.startWithNext { value in
</span><span class='line'>        print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `takeUntilReplacement` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>42
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeLast</h3>

<p>在发送complete事件后只取count此数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeLast`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .takeLast(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>只取了2次数据
</span><span class='line'>--- `takeLast` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>如果发送的事件是可选类型，解包这些可选类型，并且丢弃nil值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    SignalProducer&lt;int?, noerror&gt;(values: [ nil, 1, 2, nil, 3, 4, nil ])
</span><span class='line'>        .ignoreNil()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>zipWith</h3>

<p>压缩信号生成器，只有再两个信号都有数据发送之后，新的信号生成器才会发送数据</p>

<p>新的数据被组合为元组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`zipWith`") {
</span><span class='line'>    let baseProducer = SignalProducer(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let zippedProducer = SignalProducer(values: [ 42, 43 ])
</span><span class='line'>    baseProducer
</span><span class='line'>        .zipWith(zippedProducer)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `zipWith` ---
</span><span class='line'>(1, 42)
</span><span class='line'>(2, 43)</span></code></pre></td></tr></table></div></figure>


<p>后面应为第二个没有数据了，所以不会再聚合了</p>

<h3>times</h3>

<p>time(count)重复发送count数据，每次重复必须上次发送完成事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`times`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    SignalProducer&lt;(), NoError&gt; { observer, disposable in
</span><span class='line'>            counter += 1
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .times(42)
</span><span class='line'>        .start()
</span><span class='line'>    print(counter)
</span><span class='line'>}
</span><span class='line'>--- `times` ---
</span><span class='line'>42</span></code></pre></td></tr></table></div></figure>


<h3>retry</h3>

<p>如果收到失败事件重试retry(count)次</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`retry`") {
</span><span class='line'>    var tries = 0
</span><span class='line'>    SignalProducer&lt;int, nserror&gt; { observer, disposable in
</span><span class='line'>            if tries == 0 {
</span><span class='line'>                tries += 1
</span><span class='line'>                observer.sendFailed(NSError(domain: "retry", code: 0, userInfo: nil))
</span><span class='line'>            } else {
</span><span class='line'>                observer.sendNext(42)
</span><span class='line'>                observer.sendCompleted()
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        .retry(1)
</span><span class='line'>        .startWithResult { result in
</span><span class='line'>            print(result)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `retry` ---
</span><span class='line'>.Success(42)&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<p>当第一个信号发送complete时，第二个信号被替换成信号发送线路上，如果有任何失败事件，后面的就替换失败。</p>

<p>第一个信号发送的所有事件都会被忽略</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160726/1469505056118233.png" alt="1" /></p>

<h3>flatMap</h3>

<p>将收到的每个事件都映射为新的Product,然后摊平，如果原来的producer发送失败，新产生也得立即失败</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMap(.Latest)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .flatMap(.Latest) { SignalProducer(value: $0 + 3) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMap(.Latest)` ---
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>flatMapError</h3>

<p>把收到的failer事件映射为新的Producer,并且摊平它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "flatMapError", code: 42, userInfo: nil))
</span><span class='line'>        .flatMapError { SignalProducer&lt;int, noerror&gt;(value: $0.code) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMapError` ---</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/11/swift-package-managerru-men/">Swift Package Manager入门</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-11T14:09:18+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:09 pm</span></time>
        
           | <a href="/blog/2016/11/11/swift-package-managerru-men/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>大部分语言都有官方的代码分配解决方案，幸好苹果也在开发替代<a href="https://cocoapods.org/">Cocoapods</a>和<a href="https://github.com/Carthage/Carthage">Carthage</a>的管理工具，<a href="https://swift.org/package-manager/#conceptual-overview">Swift Package Manager</a>(Swift包管理器，下面我们简称SPM)就是一个用来管理Swift代码的分配的官方工具，它为Swift编译系统集成了自动进行下载，编译和连接依赖的过程</p>

<p>目前，SPM还处于早起阶段，现在仅仅支持OS X和linux系统，尚不支持Ios,watchOS以及tvOS平台，但未来很大希望会支持上述平台。</p>

<h2>概念概述</h2>

<p>在swift中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外那些部分是代码是可以被访问控制的。</p>

<p>一个程序可以将它所有代码聚合到一个模块中，也可以将它作为依赖关系导入到其他模块，除了少量系统提供的模块，像OS X中的Darwin或者 Linux中的Glibc等大多数依赖需要代码被下载或者内置才能被使用。</p>

<p>当你将编写额解决待定问题的代码独立成一个模块时，这段代码可以在其他情况下呗重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的app或者一个天气的app里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p>

<p>一个包由Swift源文件和一个清单文件组成，这个清单文件称为<code>Package.swift</code>,定义包或者它的内容使用<code>PackageDescription</code>模块。</p>

<p>一个包邮一个或者多个目标，每个目标制定一个铲平并且可能声明一个后者多个依赖。</p>

<p>一个目标可能构建一个库或者一个可执行文件作为其产品。库是包含可以被其它Swift代码导入的模块。可执行文件是一段可以被操作系统运行的程序</p>

<p>目标依赖是指保重代码必须添加的模块。依赖由包资源的绝对或者相对URL和一些可以被使用的包的版本要求所组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成一个依赖的相关图。包管理器下载和编译所需要满足整个依赖相关图的一切。</p>

<h2>开源Swift入门</h2>

<ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85Swift">下载和安装Swift</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8REPL">使用REPL</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">使用编译系统</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95%E5%99%A8">使用LLDB调试器</a></li>
</ul>


<p>关于使用REPL和LLDB调试器的内容具体可以参阅官方文档<a href="https://swift.org/getting-started/#using-the-repl">使用REPL</a>和<a href="https://swift.org/getting-started/#using-the-lldb-debugger">使用LLDB调试器</a></p>

<h2><a name = "下载和安装Swift"></a>下载和安装Swift</h2>

<p>刚开始下载和安装swift需要下载并安装编译器和其它必备组件，进入到 <a href="https://swift.org/download/#releases">https://swift.org/download/#releases</a>按目标平台的说明进行。</p>

<p>下载完成后，点击按步骤安装就可以</p>

<p>在OS X上下载工具链的默认地址是:<code>/Library/Developer/Toolchains</code>.接着，我们可以输入以下命令导出编译路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>首先需要安装clang:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install clang</span></code></pre></td></tr></table></div></figure>


<p>如果你在Linux上安装的Swift工具链在系统根目录以外的目录，你需要使用你安装Swift的实际路径来运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/path/to/Swift/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>导出路径之后，你可以通过输入 swift 命令并传入 &ndash;version 标志来校验你是否运行了 Swift 的预期版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift --version
</span><span class='line'>Apple Swift version 3.0-dev (LLVM ..., Clang ..., Swift ...)</span></code></pre></td></tr></table></div></figure>


<p>在版本号的后缀 -dev 用来表明它是一个开发的编译，而不是一个发布的版本</p>

<h2><a name = "使用REPL"></a>使用REPL</h2>

<h2><a name = "使用编译系统"></a>使用编译系统</h2>

<p>Swift编译系统为编译库，可执行文件和不同工程之间共享代码提供了基本的约定。</p>

<p>创建一个新的Swift包，首先创建并进入到一个新的目录命令为Hello:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Hello
</span><span class='line'>$ cd Hello</span></code></pre></td></tr></table></div></figure>


<p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件，如果清单文件为空，那包管理器将会使用常规默认的方式来编译包，创建一个空的清空文件使用命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch Package.swift</span></code></pre></td></tr></table></div></figure>


<p>当使用默认方式时，包管理器预计将包含在Source/子目录下的所有源代码。创建方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Sources</span></code></pre></td></tr></table></div></figure>


<h3>编译可执行文件</h3>

<p>默认方式下，目录中包含一个文件称为<code>main.swift</code>将会将文件编译成与包名称相同的二进制可执行文件。</p>

<p>在这个例子中，包将生成一个可以输出<code>hello world</code>的可执行文件为 <em>hello</em></p>

<p>在<em>Source/</em>目录下创建一个命名为<code>main.swift</code>的文件，并使用你喜欢的任意一种编译器输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print("Hello, world!")</span></code></pre></td></tr></table></div></figure>


<p>返回到 Hello 目录中，通过运行 swift build 命令来编译包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build</span></code></pre></td></tr></table></div></figure>


<p>当命令完成之后，编译产品将会出现在 .build 目录中。通过如下命令运行 Hello 程序:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ .build/debug/Hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<p>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code>然后直接用<code>print(_:)</code>替换执行调用的内容。</p>

<h3>多了源文件协作</h3>

<p>在<code>Sources/</code>目录下创建一个新文件命名为<code>Greeter.swift</code>然后输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(name: String) {
</span><span class='line'>  print("Hello, \(name)!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>sayHello(_:)</code>方法带一个单一的字符串参数，然后在前面打印一个"hello",后面跟着函数参数单词"World".</p>

<p>现在打开<code>main.swift</code>，然后替换原来的内容为下面代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if Process.arguments.count != 2 {
</span><span class='line'>    print("Usage: hello NAME")
</span><span class='line'>} else {
</span><span class='line'>    let name = Process.arguments[1]
</span><span class='line'>    sayHello(name)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>跟之前的硬编码不同，<code>main.swift</code>现在从命令行参数中读取。替代之前直接调用<code>print(_:)</code>，<code>main.swift</code>现在调用<code>sayHello(_:)</code>方法，因为这个方法是<code>Hello</code>模块的一部分，所以不需要使用到<code>import</code>语句。</p>

<p>运行<code>swift build</code>并尝试<code>Hello</code>的新版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/Hello 'whoami'</span></code></pre></td></tr></table></div></figure>


<p>目前为止，你已经能够运用开源Swift来运行一些你想要的程序了。接下来我们就可以进入正题开始入手SPM.</p>

<h3>快速入门实例</h3>

<p>在本章节中，我们简单地学会了编译一个"`Hello world"程序。</p>

<p>为了了解SPM究竟能做什么，我们来看一下下面这个由4个独立的包组成的例子:</p>

<ul>
<li><a href="https://github.com/marklin2012/O2PlayingCard.git">O2PlayingCard</a>-定义了O2PlayingCard ， O2Suit ， O2Rank ， 3个类型</li>
<li><a href="https://github.com/marklin2012/O2FisherYates.git">O2FisherYates</a>-定义了 shuffle() 和 shuffleInPlace() 方法实现的扩展</li>
<li><a href="https://github.com/marklin2012/O2DeckOfPlayingCards.git">O2DeckOfPlayingCards</a>-定义了一个 O2Deck 类型对 O2PlayingCard 值得数据进行洗牌和抽牌。</li>
<li><a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer</a>-定义了一个用来创建 O2DeckOfPlayingCards 进行洗牌和抽出前10个卡片的可执行文件。</li>
</ul>


<p>你可以从<a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer from GitHub </a>编译并运行完整例子，然后运行如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd O2Dealer
</span><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/O2Dealer</span></code></pre></td></tr></table></div></figure>


<h3>创建一个库包</h3>

<p>我们将从创建一个代表一副标准的52张扑克牌的模块开始。 O2PlayingCard 模块定义了 由 O2Suit 枚举值（Clubs, Diamonds, Hearts, spades）和 O2Rank 枚举值（Ace, Two, Three, …, Jack, Queen, King）组成的 O2PlayingCard 类。各个类的核心代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum O2Rank : Int {
</span><span class='line'>    case Ace = 1
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public enum O2Suit: String {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public struct O2PlayingCard {
</span><span class='line'>    let rank: O2Rank
</span><span class='line'>    let suit: O2Suit
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，一个包包括位于Source/的源文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2PlayingCard
</span><span class='line'>├── Sources
</span><span class='line'>│   ├── O2PlayingCard.swift
</span><span class='line'>│   ├── O2Rank.swift
</span><span class='line'>│   └── O2Suit.swift
</span><span class='line'>└── Package.swift</span></code></pre></td></tr></table></div></figure>


<p>由于<code>O2PlayingCard</code>模块并不会生成可执行文件，这里应该成为库。库表示被编译成一个可以被其它包导入的模块的包，默认情况下，库模块公开所有位于<code>Sources/</code>目录下的源代码中声明的公共类型的方法。</p>

<p>运行 swift build 开始启动 Swift 编译的过程。如果一切进行顺利，将会在 .build/debug 目录下生成 O2PlayingCard.build 目录。</p>

<p>接下来，我们在<code>Package.swift</code>文件中定义包名，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>  name: "O2PlayingCard"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>然后我们只要将<code>O2PlayingCard</code>提交到Github上，并且给他发布一个Release版本即可完成该库包，这里可以自己手动添加一个<code>.gitignore</code>文件，忽略掉<code>/.build</code>，因为我们的包是不需要包括生成的编译结果的内容的。</p>

<h2>使用编译配置语句</h2>

<p>下一个即将编译的模块是<code>O2FisherYates</code>.跟之前<code>O2PlayingCard</code>有所不同，该模块没有定义新的类，取而代之的是该模块拓展了一个已经存在的特殊的<code>CollectionType</code>和<code>MutableCollectionType</code>接口协议，用来添加<code>shuffle()</code>方法和对应的<code>shuffleInPlace()</code>方法。</p>

<p>在 OS X 中，系统模块是 Darwin , 提供的函数是 arc4random_uniform(_:) 。在 Linux 中， 系统模块是 Glibc ， 提供的函数是 random() ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if os(Linux)
</span><span class='line'>  import Glibc
</span><span class='line'>#else
</span><span class='line'>  import Darwin.C
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>public extension Collection {
</span><span class='line'>  func shuffle() -&gt; [Generator.Element] {
</span><span class='line'>    var array = Array(self)
</span><span class='line'>    array.shuffleInPlace()
</span><span class='line'>    
</span><span class='line'>    return array
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public extension MutableCollection where Index == Int {
</span><span class='line'>  mutating func shuffleInPlace() {
</span><span class='line'>    guard count &gt; 1 else { return }
</span><span class='line'>    v 
</span><span class='line'>    for i in 0..&lt;count - 1 {
</span><span class='line'>      #if os(Linux)
</span><span class='line'>        let j = Int(random() % (count - i)) + i
</span><span class='line'>      #else
</span><span class='line'>        let j = Int(arc4random_uniform(UInt32(count - i))) + i
</span><span class='line'>      #endif
</span><span class='line'>      guard i != j else { continue }
</span><span class='line'>      swap(&self[i], &self[j])
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的步骤和前面的类似，编译通过后上传到GitHub,发布Release版本。</p>

<h3>导入依赖</h3>

<p><code>O2DeckOfPlayingCards</code>包把前两个包聚合到一起：它定义了一个<code>O2PlayingCard</code>数组中使用<code>O2FisherYates</code>的<code>shuffle()</code>方法的Deck类型。</p>

<p>为了使用 O2FisherYates 和 O2PlayingCards 模块， O2DeckOfPlayingCards 包必须在 Package.Swift 清单中将上述模块声明为依赖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>    name: "O2DeckOfPlayingCards",
</span><span class='line'>    dependencies: [
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2PlayingCard.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2FisherYates.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>    ]
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>每个依赖都需要指定一个源URL和版本号，源URL是指允许当前用户解析到对应的Git仓库。版本号遵循 <a href="http://semver.org/lang/zh-CN/">语义化版本号 2.0.0</a> 的约定,用来决定检出或者使用哪个Git标签版本来建立依赖。对于<code>FisherYates</code>和<code>PlayingCard</code>这两个依赖来说， 最新的将要被使用的主版本号为1.</p>

<p>当你运行<code>swift build</code>命令时，包管理器将会下载所有的依赖，并将它们编译成静态库，再把它们链接到包模块中。这样将会使<code>O2DeckOfPlayingCards</code>可以访问依赖import语句的模块的公共成员</p>

<p>你可以看到这些资源被下载到你工程根目录的 Packages 目录下，并且会生成编译产品在你工程根目录的 .build 目录下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2DeckOfPlayingcards
</span><span class='line'>├── .build
</span><span class='line'>│   └── debug
</span><span class='line'>│       ├── O2DeckOfPlayingCards.build
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftdoc
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftmodule
</span><span class='line'>│       ├── O2FisherYates.build
</span><span class='line'>│       ├── O2FisherYates.swiftdoc
</span><span class='line'>│       ├── O2FisherYates.swiftmodule
</span><span class='line'>│       ├── O2PlayingCard.build
</span><span class='line'>│       ├── O2PlayingCard.swiftdoc
</span><span class='line'>│       └── O2PlayingCard.swiftmodule
</span><span class='line'>└── Packages
</span><span class='line'>    └── O2FisherYates-1.0.0
</span><span class='line'>    │   ├── Package.swift
</span><span class='line'>    │   ├── README.md
</span><span class='line'>    │   └── Sources
</span><span class='line'>    └── O2Playingcard-1.0.1
</span><span class='line'>        ├── Package.swift
</span><span class='line'>        ├── README.md
</span><span class='line'>        └── Sources</span></code></pre></td></tr></table></div></figure>


<p><code>Package</code>目录包含了被复制的包依赖的所有仓库，这样将使你能修改源代码并直接推送这些修改到它们的源，而不需要再对每个包在单独进行复制。</p>

<p>Swift是一门先进的语言，SPM的社区也在不断地完善中。在swift开源之后，我们很容可以看到它的潜力，看来掌握这门语言必将是一个大趋势。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/07/ioszhong-de-re-qi-dong/">iOS中的热修复</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-07T16:46:54+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:46 pm</span></time>
        
           | <a href="/blog/2016/11/07/ioszhong-de-re-qi-dong/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>背景需求</h2>

<h3>为什么我们需要热修复</h3>

<ul>
<li>工作中容易犯错，bug难以避免</li>
<li>开发和测试人力有限</li>
<li>苹果AppStore审核周期太长，一旦出现严重bug难以快速上线新版本</li>
</ul>


<h2>JSPatch简介</h2>

<p>JSPatch诞生于2015年5月，最初是腾讯广研高级ios开发@bang的人格项目。它能够使用JavaScripit调用Objective-C的原声接口，从而动态植入代码来替换旧代码，以实现修复线上bug.</p>

<h2>JSPatch与wax对比</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3d1af75ebfe7de01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最关键的是JSpath可实现方法粒度的线上代码替换，能修复一切代码引起的bug.而Wax无法实现。</p>

<h2>JSPatch实现原理</h2>

<h3>基础原理</h3>

<p>Objective-C是动态语言，具有运行时特性，该特性可通过类名称和方法名的字符换获取该类和该方法，并实例化调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class class = NSClassFromString(“UIViewController");
</span><span class='line'>id viewController = [[class alloc] init];  
</span><span class='line'>SEL selector = NSSelectorFromString(“viewDidLoad");
</span><span class='line'>[viewController performSelector:selector];</span></code></pre></td></tr></table></div></figure>


<p>也可以替换某个类的方法为新的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void newViewDidLoad(id slf, SEL sel) {}
</span><span class='line'>class_replaceMethod(class, selector, newViewDidLoad, @"");</span></code></pre></td></tr></table></div></figure>


<p>还可以注册一个类，为类添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
</span><span class='line'>objc_registerClassPair(cls);
</span><span class='line'>class_addMethod(cls, selector, implement, typedesc);</span></code></pre></td></tr></table></div></figure>


<h3>JavaScript调用</h3>

<p>我们可以用JavaScript对象定义一个Objective-C类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  __isCls: 1,
</span><span class='line'>  __clsName: "UIView"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在OC执行JS脚本前，通过正则把所有方法调用都改成__c()函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView.alloc().init()
</span><span class='line'>-&gt;
</span><span class='line'>UIView.__c('alloc')().__c('init')()</span></code></pre></td></tr></table></div></figure>


<p>给JS对象基类Object的prototype加上c成员，这样所有对象都可以调用到c,根据当前对象类型判断进行不同操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Object.prototype.__c = function(methodName) {
</span><span class='line'>  if (!this.__obj && !this.__clsName) return this[methodName].bind(this);
</span><span class='line'>  var self = this
</span><span class='line'>  return function(){
</span><span class='line'>    var args = Array.prototype.slice.call(arguments)
</span><span class='line'>    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>互传消息</h2>

<p>JS和OC是通过JavaScriptCore互传消息的。OC端在启动JSPatch引擎会创建一个JSContext实例，JSContext是js代码的执行环境，可以给JSContext添加方法。JS通过调用JSContext定义的方法把数据传给OC,OC通过返回值传回给JS.调用这种方法，它的参数/返回值 javaScripotCore都会自动转换，OC里的NSArray,NSdictionary
,NSString,NSNumber,NSBlock会分别转为JS端的数组/对象/字符串/数字/函数类型  对于一个自定义ID对象，JavaScriptCore会把这个自定义对象的指针传给JS,这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象声明周期的管理，如果JS有变量引用时，这个OC对象引用计数就加1，JS变量的引用释放了就减一，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>

<h2>方法替换</h2>

<ol>
<li>把UIViewContrller的 <code>-viewWillAppear:</code>方法通过<code>class_replaceMethod()</code>接口指向<code>_objc_msgForward</code>,这是一个全局IMP,OC调用方法不存在时都会转发到这个IMP上，这里直接把方法替换成这个IMP,这样调用这个方法时就会走到<code>-forwardInvocation:</code></li>
<li>为UIViewController添加<code>-ORIGviewWillAppear:</code>和<code>-_JPviewWillAppear:</code>两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数</li>
<li>改写UIViewController的<code>-forwardInvocation:</code>方法为自定义实现。一旦OC里调用UIViewController的<code>-viewWillAppear:</code>方法，经过上面的处理会把这个调用转发到<code>forwardInvocation:</code>，这时已经组装好了一个NSInvocation,包含了这个调用的参数。在这里把参数从NSInvocation反解出来，待着参数调用删除新增加的方法<code>-JPviewWillAppear:</code>,在这个新方法里获取到参数传给JS,调用JS的实现函数，整个调用过程就结束了，整个过程图示如下：</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-d079409a185f394c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最后一个问题，我们把UIViewController的<code>-forwardInvocation:</code>方法的实现给替换掉了，如果程序里挣得有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现了做个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程</p>

<h2>JSPatch代码示例</h2>

<p>jspatch在oc上的调用十分简单</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
</span><span class='line'>[JPEngine startEngine]; 
</span><span class='line'>NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; 
</span><span class='line'>NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; 
</span><span class='line'>[JPEngine evaluateScript:script];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>一个JavaScript修复Objective-C的bug的示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation JPTableViewController
</span><span class='line'>
</span><span class='line'>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
</span><span class='line'>  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
</span><span class='line'>  [self.navigationController pushViewController:ctrl];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上述代码中取数组元素出可能会超出数组范围导致crash.如果在项目里引用了JSPatch,就可以发JS脚本修复这个bug:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defineClass("JPTableViewController", {
</span><span class='line'>  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
</span><span class='line'>    var row = indexPath.row()
</span><span class='line'>    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
</span><span class='line'>      var content = self.dataArr()[row];
</span><span class='line'>      var ctrl = JPViewController.alloc().initWithContent(content);
</span><span class='line'>      self.navigationController().pushViewController(ctrl);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}, {})</span></code></pre></td></tr></table></div></figure>


<h2>热修复的解决方案</h2>

<ol>
<li><p>版本更新策略</p></li>
<li><p>考虑到下一个提交的App版本已经修复了上一个版本的bug,所以不同的App版本对应的补丁肯定也不同，同一个App版本下，可以出现递增的补丁版本</p></li>
<li>补丁为全量更新，即最新的版本补丁包括旧版的补丁的内容，更新后新版补丁覆盖旧版补丁</li>
<li>补丁分为可选补丁和必选补丁，必选补丁用于重大bug的修复，如果不更新必须补丁则App无法继续使用。如下图2中，补丁版本v1234对应各自版本的用户，补丁v3为必须更新，补丁v1,v2,v4为可选补丁，则v1,v2必须更新到v4才可使用；而v3的哟过户可先使用，同事后台静默更新到v4</li>
</ol>


<h2>安全策略</h2>

<p>安全问题在于JS脚本可能被中间人攻击替换代码。可采取一下三种方法</p>

<ol>
<li>对称加密： 如zip的加密压缩，Aes等加密算法。优点是简单，缺点是安全性低，易被破解。若客户端被反编译，密码字段泄露，则完全破解。</li>
<li><a href="HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82">HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82</a></li>
<li>RSA校验：安全性高，部署简单</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-14723080a9823ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>详细校验步骤如下：</p>

<ol>
<li>服务器计算出脚本文件的MD5值，作为这个文件的数字签名</li>
<li>服务器通过私钥加密算出的MD5值，得到一个加密后的md5值</li>
<li>把脚本文件和加密后的md5值一起发给客户端</li>
<li>客户端拿到加密后的md5值，通过保存在客户端的公钥解密</li>
<li>客户端计算脚本文件的md5值</li>
<li>对比第 4/5 步的两个md5值(分别是客户端和服务器端计算出来的MD5值)，若相等则通过校验</li>
</ol>


<h2>客户端策略</h2>

<p>客户端具体策略如下图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3f5d0d89e0b3833d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<ol>
<li>用户打开App时，同步进行本地补丁的加载</li>
<li>用户打开App时，后台进程发起异步网络请求，获取服务器中当前App版本所对应的最新补丁版本和必须的补丁版本</li>
<li>获取补丁版本的请求回来后，跟本地的补丁版本进行对比</li>
<li>如果本地补丁版本小于必须版本，则提示用户，展示下载补丁界面，进行进程同步的补丁下载。下载完成后重新加载App和最新补丁，再进入App</li>
<li>如果本地补丁版本不小于必须版本，但小于最新版本，则进入App,不影响用户操作。同时进行后台进程异步静默下载，下载后补丁保存在本地，下次App启动时再加载最新补丁。</li>
<li>如果版本为最新，则进入App</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">iOS中常见的面试题二</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-04T20:22:42+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:22 pm</span></time>
        
           | <a href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>如何进行真机调试</h2>

<ol>
<li>首先需要钥匙串创建一个钥匙(key)</li>
<li>将钥匙串上传到官网，获取ios Development证书</li>
<li>创建APP Id即我们应用程序中的BundleId</li>
<li>添加Device ID 即 UDID;</li>
<li>通过勾选前面所创建的证书：App ID, Deveice id</li>
<li>生成mobileProvision文件</li>
<li>先决条件：申请开发者账号 99美刀</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">Ios中常见的面试题及答案</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-03T17:50:01+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>5:50 pm</span></time>
        
           | <a href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>ios中深拷贝和浅拷贝</h2>

<p>在ios开发中，经常涉及到深拷贝和浅拷贝的问题，针对深拷贝和浅拷贝，为了方便大家的理解，专门总结如下:</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">自定义UICollectionViewLayout</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-28T14:34:50+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:34 pm</span></time>
        
           | <a href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>UICollectionView，自从ios6之后就被引入到开发中，现在已经变成了最流程的UI元素之一，它最吸引人的特性就是将数据和布局进行分离，依靠分离的数据元素去处理布局，这个布局对象是决定占位元素和视图的元素。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">Ios10 UICollectionView 新特性</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-24T10:35:36+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:35 am</span></time>
        
           | <a href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>关于ios 10 UIcolelctionView的新特性，主要还是体现在如下三个方面</p>

<ol>
<li>顺滑的滑动体验</li>
<li>针对self=sizing的改进</li>
<li>Interactive recording重排</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>
	QQ群
</h1>
   <br/>
	<p>欢迎加入swift学习交流群:252710124</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/09/03/webstormde-shi-yong/">webStorm的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/01/06/swift3-associatedtypeyong-fa/">Swift3-associatedtype用法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/23/iosde-hou-tai-mo-shi/">iOS的后台模式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/">使用Core Location和MapView进行路线规划</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/dao-che-ru-ku-ji-qiao/">倒车入库技巧</a>
      </li>
    
  </ul>
</section>
<section>
	<h1>文章分类</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/cocoapods/'>cocoapods (1)</a></li>
<li class='category'><a href='/blog/categories/git/'>git (3)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (29)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (2)</a></li>
<li class='category'><a href='/blog/categories/nodejs/'>nodejs (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (26)</a></li>
<li class='category'><a href='/blog/categories/swift3/'>swift3 (1)</a></li>
<li class='category'><a href='/blog/categories/xcode/'>xcode (1)</a></li>
<li class='category'><a href='/blog/categories/前端/'>前端 (1)</a></li>
<li class='category'><a href='/blog/categories/汽车/'>汽车 (4)</a></li>

	</ul>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andrew-anlu">@andrew-anlu</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andrew-anlu',
            count: 3,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/Andrewswift1987?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/Andrewswift1987">My Delicious Bookmarks &raquo;</a></p>
</section>

 <section>
      <h1>访客统计</h1>
      <br/>
    <a href="http://info.flagcounter.com/Bkif"><img src="http://s01.flagcounter.com/count2/Bkif/bg_ffffff/txt_000000/border_CCCCCC/columns_3/maxflags_10/viewers_0/labels_1/pageviews_1/flags_1/percent_0/" alt="Free counters!" border="0"></a>
    </section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - 安路 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'Andrewswift1987';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
