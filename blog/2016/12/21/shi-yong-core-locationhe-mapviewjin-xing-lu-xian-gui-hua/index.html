
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>使用Core Location和MapView进行路线规划 - 安路的技术博客</title>
  <meta name="author" content="安路">

  
  <meta name="description" content="开始 下载开始工程 并且打开ProcrastinatorsRevenge.xcodeproj,编译运行，界面效果如下: 第一个屏幕是输入文本框，设置开始和终止地点，点击Route it,App将会跳转到第二个页面，开始规划路线图。 使用MapKit和Coreloaction 官方文档中对Core &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="安路的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">安路的技术博客</a></h1>
  
    <h2>Nothing in life is to be feared. It is only to be understood</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://andrew-anlu.github.io" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andrew-anlu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">使用Core Location和MapView进行路线规划</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-12-21T16:04:20+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>4:04 pm</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>开始</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/11/ProcrastinatorsRevenge-starter.zip">下载开始工程</a></p>

<p>并且打开<code>ProcrastinatorsRevenge.xcodeproj</code>,编译运行，界面效果如下:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/starter_screenshots1.png" alt="1" /></p>

<!--more-->


<p>第一个屏幕是输入文本框，设置开始和终止地点，点击<code>Route it</code>,App将会跳转到第二个页面，开始规划路线图。</p>

<h2>使用MapKit和Coreloaction</h2>

<p>官方文档中对Core Loaction的描述是这样的:&ldquo;Core location框架让你决定当前的坐标或者或者当前的方位通过使用设备"，你将要用Core Location的特性去填充用户的开始点，Core Location能翻译坐标的经纬度为用户能够看得懂的地址信息。在MapView中，使用MapItem类的<code>CLGeocoder</code>类将会完成这个教程的第一部分。</p>

<p>在这个教程的第二部分，你将要从<code>CLGeocoder</code>返回的<code>CLPlacemark</code>中转为一个<code>MKPlacemark</code>，然后把<code>MKPlacemark</code>转换为一个<code>MKMapItem</code>。你将要使用<code>MKMapItems</code>去运行一个<code>MKDirectionsRequest</code>，这个最终将会返回一个<code>MKRoute</code>对象。</p>

<p>关系如下-><code>CLGeocoder &gt; CLPlacemark &gt; MKPlacemark &gt; MKMapItem &gt; MKDirectionsRequest &gt; MKRoute.</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/ef1905fa6eccb7e1cd85141d065d49f8.jpg-320x320.gif" alt="1" /></p>

<h2>通过CoreLocation获取当前的坐标信息</h2>

<p>在<code>ViewController.swift</code>中，添加如下代码，替换<code>viewDidLoad</code>已经存在的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let locationManager = CLLocationManager()
</span><span class='line'> 
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  originalTopMargin = topMarginConstraint.constant
</span><span class='line'>  // 2
</span><span class='line'>  locationManager.delegate = self
</span><span class='line'>  locationManager.requestWhenInUseAuthorization()
</span><span class='line'>  // 3
</span><span class='line'>  if CLLocationManager.locationServicesEnabled() {
</span><span class='line'>    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
</span><span class='line'>    locationManager.requestLocation()
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>让我们说说每一步都做了什么:</p>

<ol>
<li>你定义了一个全局常量<code>locationManager</code></li>
<li>在<code>ViewDidLoad</code>中，设置location manager的代理，当用户打开App的时候，询问用户是否允许访问用户地理位置的权限，这个弹出框第一次将会显示，当用户做出响应之后，这个框就不会再出现了。</li>
<li>一旦用户定位服务开启，设置这个<code>CLLocationManager’s</code>的定位精度信息，请求当前坐标</li>
</ol>


<p>编译运行你的程序，你是否弹出了提示框让你授权地理定位信息呢？</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/reaction_faces___confused_by_awesomesauceuk-d4od42z.png" alt="1" /></p>

<p>这是因为你还有一件事情需要完成，那就是权限问题，你需要提供原因为你的请求。
打开<code>Supoorting Files&gt;info.plist</code>，按如下步骤进行设置:</p>

<ol>
<li>添加<code>NSLocationWhenInUseUsageDescription</code>作为<code>Key</code>在 Information Property List中</li>
<li>让这个<code>Type</code>为<code>String</code>类型</li>
<li>设置这个<code>Value</code>值去向用户展示，解释为什么你需要访问他们的地理信息：“请运行我们访问你的当前坐标信息，这样我们就能自动填充你的开始和结束地点了”</li>
</ol>


<blockquote><p><code>注意:</code>
<em>.requestWhenInUseAuthorization()</em> 让这个app访问当前的用户地理信息，当这个App是在使用的时候</p>

<p>*.requestAlwaysAuthorization() * 当这个app不管是在前台还是后台的时候.这个app都能访问用户的地理信息，</p></blockquote>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/plist.png" alt="1" /></p>

<p>编译运行你的app,这次提示框将会显示:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/LocationAuthorization.png" alt="1" /></p>

<p>点击<code>Allow</code>,这个location Manager现在将会访问到你的地理坐标</p>

<p>下一步，你将要创建<code>CLGeocoder</code>去解码当前的坐标信息。解码过程就是把获取到的地理坐标，比如经纬度，转换成我们能看的懂得地理位置信息，比如长江道第三大街33号</p>

<p>在<code>ViewConroller.swift</code>的底部，添加如下代码，<code>locationManager(_:didUpdateLocations:locations:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CLGeocoder().reverseGeocodeLocation(locations.last!,
</span><span class='line'>  completionHandler: {(placemarks:[CLPlacemark]?, error:NSError?) -&gt; Void in
</span><span class='line'>  if let placemarks = placemarks {
</span><span class='line'>    let placemark = placemarks[0]
</span><span class='line'>  }
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p><code>reverseGeocodeLocation(_:completionHandler:)</code>将会返回一组<code>placemarks</code>，对于多数的<code>geocoding</code>结果来说，这个数组仅仅是包含一个元素;很少的情况，一个单独的地点能返回多个地理位置附近的信息。在这个例子中，我们获取第一个placemark,即：placemarks[0],将会满足需求。</p>

<p>你可以可以停止更新坐标信息，当你发现了一个适当的placemark的时候。</p>

<p>现在你通过用户的地理位置已经找到对应地理坐标的<code>CLPlacemark</code>，你需要去联想其它跟他相关的地理数据信息，通过用户输入的文本框中的位置。为了实现这个，当用户输入一个单独的值的时候，通过swift的元组结构值去匹配多个值。</p>

<p>在<code>ViewDidLoad</code>中，添加下面的全局变量去匹配每个<code>UITextField</code>响应的<code>MKMapItem</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var locationTuples: [(textField: UITextField!, mapItem: MKMapItem?)]!</span></code></pre></td></tr></table></div></figure>


<p>对用户的坐标信息，你将要存储<code>MKMapItems</code>而不是<code>CLPlacemarks</code>，这个类型你最终将会用在初始化<code>MKDirectionsRequest</code>上，用来计算路径规划。</p>

<p>在<code>ViewDidLoad</code>中，添加如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>locationTuples = [(sourceField, nil), (destinationField1, nil), (destinationField2, nil)]</span></code></pre></td></tr></table></div></figure>


<p>这里，你定义了一个数组，里面包含了元组,每个元组都包含了一个文本框和一个为空的 MKMapItem的值，这个值最终会被和文本框绑定到一起。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/happy-thumbs-up.png" alt="1" /></p>

<p>在<code>locationManager(_:didUpdateLocations:location:)</code>方法中，添加如下代码片段，在<code>reverseGeocodeLocation(_:completionHandler:)</code>的完成回调方法中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.locationTuples[0].mapItem = MKMapItem(placemark:
</span><span class='line'>  MKPlacemark(coordinate: placemark.location!.coordinate,
</span><span class='line'>  addressDictionary: placemark.addressDictionary as! [String:AnyObject]?))</span></code></pre></td></tr></table></div></figure>


<p>添加了一个<code>MKMapItem</code>代表用户当前的地理位置作为<code>locationTuples</code>的第一个元组对象。</p>

<p>下一步，在ViewController中添加下面的函数 ，去把location data中的地理信息提取出来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func formatAddressFromPlacemark(placemark: CLPlacemark) -&gt; String {
</span><span class='line'>  return (placemark.addressDictionary!["FormattedAddressLines"] as! 
</span><span class='line'>    [String]).joinWithSeparator(", ")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>formatAddressFromPlacemark(_:)</code>从<code>CLPlacemark's</code>地址字典中通过<code>FormattedAddressLines</code>key提取一组地址信息，然后每两个元素之间用逗号连接起来组成一个新的字符串。</p>

<p>滑动到<code>locationManager(_:didUpdateLocations:locations:)</code>方法，在self.locationTuples[0].mapItem初始化后添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.sourceField.text = self.formatAddressFromPlacemark(placemark)</span></code></pre></td></tr></table></div></figure>


<p>这将设置UItextField为一个新地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.enterButtonArray.filter{$0.tag == 1}.first!.selected = true</span></code></pre></td></tr></table></div></figure>


<p>在开始工程中，按钮的选择文本是提前设置好的，按钮的tag是按照顺序设置的，每个<code>Enter</code>按钮都和页面<code>enterButtonArray</code>建立了连接关系，上面的代码找到 tag=1的 <code>Enter</code>按钮，并且每个UItextField也是按照顺序设置的tag，和按钮是一一对应的。</p>

<p>所以按钮的状态为选中时的文本会变为<code>✓</code>。</p>

<p>编译运行你的APP，假如当前坐标是:Apple HQ,你的文本框中的文本将会是:<code>Apple Inc., 2 Infinite Loop, Cupertino, CA 95014-2083, United States</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Apple_source.png" alt="1" /></p>

<p>在模拟器中，修改当前的坐标 <code>select Debug &gt; Location &gt; Custom location…:</code>
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Menu_bar-700x374.png" alt="1" /></p>

<p>输入坐标信息:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/CustomLocation-e1437159760381.png" alt="1" /></p>

<p><code>Latitude: 29.049186, Longitude: -95.45384</code></p>

<p>编译运行程序，这个文本框中将会显示:<code>05 Any Way St, Lake Jackson, TX, 77566-4198, United States
</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Any_Way_source.png" alt="1" /></p>

<p>下一步，你需要用户正确的输入地址，然后通过文本框中的值获取关联的地理位置信息，通过创建<code>MKMapItems</code>来获取。</p>

<h2>用户调用CoreLoaction过程</h2>

<p>在<code>ViewController.swift</code>中，更新<code>addressEntered(_:)</code>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@IBAction func addressEntered(sender: UIButton) {
</span><span class='line'>  view.endEditing(true)
</span><span class='line'>  // 1
</span><span class='line'>  let currentTextField = locationTuples[sender.tag-1].textField
</span><span class='line'>  // 2
</span><span class='line'>  CLGeocoder().geocodeAddressString(currentTextField.text!,
</span><span class='line'>    completionHandler: {(placemarks: [CLPlacemark]?, error: NSError?) -&gt; Void in
</span><span class='line'>    if let placemarks = placemarks {
</span><span class='line'> 
</span><span class='line'>    } else {
</span><span class='line'> 
</span><span class='line'>    }
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你添加的代码做的工作如下:</p>

<ol>
<li>在interface builder中，每个<code>Enter</code>按钮都有一个tag,从上到下依次为1,2,3.你可以通过sender.tag来找到是那个text field.(UItextField的tag和Enter按钮的tag是一一对应的)</li>
<li>通过<code>CLGeocoder's geocodeAddressString(_:completionHandler:).</code>去解码地理坐标</li>
</ol>


<p>不像<code>reverseGeocodeLocation(_:completionHandler:), geocodeAddressString(_:completionHandler:)</code>，经常会返回多个<code>CLPlacemark</code>信息，在文本中输入的值经常不是仅仅匹配一个值。幸运的是，我们创建一个Tableview来显示多个数据信息，当用户选择了一项之后我们就会返回一个<code>CLPlacemarks</code></p>

<p>看一下<code>AddressTableView.swift.</code>这个类，你应该很清楚<code>tableView(_:numberOfRowsInSection:)</code>和<code>tableView(_:cellForRowAtIndexPath:),</code>代理方法的作用，你将要使用在顶部定义的全局变量<code>address</code>数组去填充这个tableview.</p>

<p>在<code>ViewController</code>中添加如下的函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showAddressTable(addresses: [String]) {
</span><span class='line'>  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds,
</span><span class='line'>    style: UITableViewStyle.Plain)
</span><span class='line'>  addressTableView.addresses = addresses
</span><span class='line'>  addressTableView.delegate = addressTableView
</span><span class='line'>  addressTableView.dataSource = addressTableView
</span><span class='line'>  view.addSubview(addressTableView)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过方法<code>geocodeAddressString(_:completionHandler:).</code>返回一组<code>CLPlacemarks</code>数据。这里你创建一个AddressTable，并且设置了数据源<code>addresses</code>数组，数组中包含的元素就是<code>CLPlacemarks</code></p>

<p>回到<code>addressEntered(_:)</code>方法中，在<code>if let placemarks = placemarks</code>回调函数<code>geocodeAddressString(_:completionHandler:)‘s</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var addresses = [String]()
</span><span class='line'>for placemark in placemarks {
</span><span class='line'>  addresses.append(self.formatAddressFromPlacemark(placemark))
</span><span class='line'>}
</span><span class='line'>self.showAddressTable(addresses)</span></code></pre></td></tr></table></div></figure>


<p>你看到了属性<code>placemarks</code>，遍历访问并且把地址追加到Addresses数组中。最后把<code>addresses</code>作为参数传递给<code>self.showAddressTable</code></p>

<p>当在第一屏幕的文本框中输入地址，并且点击<code>Enter</code>按钮，就会跳转到一个页面，让你选择具体是那个地址:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/OysterCreekTable.png" alt="1" /></p>

<p>当你选择了其中了一个地址之后，会发生什么呢？这个table将会消失。好了，让我去实现它</p>

<p>当你选择另一个地址之后，你想要自动的设置选择的文本去填充第一屏幕中的文本框中的值，更新查询到的locations数组，并且设置相关的<code>MKMapItem</code>,并且设置<code>Enter</code>按钮的选中状态。</p>

<p>更新<code>showAddressTable(_:)</code>方法在<code>ViewController.swift</code>中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showAddressTable(addresses: [String], textField: UITextField,
</span><span class='line'>  placemarks: [CLPlacemark], sender: UIButton) {
</span><span class='line'> 
</span><span class='line'>  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds, style: UITableViewStyle.Plain)
</span><span class='line'>  addressTableView.addresses = addresses
</span><span class='line'>  addressTableView.currentTextField = textField
</span><span class='line'>  addressTableView.placemarkArray = placemarks
</span><span class='line'>  addressTableView.mainViewController = self
</span><span class='line'>  addressTableView.sender = sender
</span><span class='line'>  addressTableView.delegate = addressTableView
</span><span class='line'>  addressTableView.dataSource = addressTableView
</span><span class='line'>  view.addSubview(addressTableView)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里，你通过当前的文本框字段，数组placemarks,和当前的<code>ViewController.swift</code>的实例 创建一个AddressTableView。</p>

<p>在<code>geocodeAddressString(_:completionHandler:)</code>方法中，更新<code>showAddressTable(_:)</code>的参数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.showAddressTable(addresses, textField: currentTextField,
</span><span class='line'>    placemarks: placemarks, sender: sender)</span></code></pre></td></tr></table></div></figure>


<p>在查询不到地址的情况下，应该马上弹出提示框:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>self.showAlert("Address not found.")</span></code></pre></td></tr></table></div></figure>


<p>如果<code>geocodeAddressString(_:completionHandler:)</code>没有返回任何placemarks,你应该显示一个error:</p>

<p>下一步，在表格的点击方法<code>tableView(_:didSelectRowAtIndexPath:)</code>中，加入代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>if addresses.count &gt; indexPath.row {
</span><span class='line'>  // 2
</span><span class='line'>  currentTextField.text = addresses[indexPath.row]
</span><span class='line'>  // 3
</span><span class='line'>  let mapItem = MKMapItem(placemark:
</span><span class='line'>    MKPlacemark(coordinate: placemarkArray[indexPath.row].location!.coordinate,
</span><span class='line'>    addressDictionary: placemarkArray[indexPath.row].addressDictionary
</span><span class='line'>    as! [String:AnyObject]?))
</span><span class='line'>  mainViewController.locationTuples[currentTextField.tag-1].mapItem = mapItem
</span><span class='line'>  // 4
</span><span class='line'>  sender.selected = true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面解释代码的意思:</p>

<ol>
<li>当addresses的数量是大于当前行的索引的时候,表格的最后一行将会显示:<code>None of the above</code></li>
<li>更新当前的文本框中的值为选择的地址</li>
<li>使用placemark去创建创建<code>MKMapItem</code>，placemark是通过获取当前行创建的。根据当前文本框的tag获取<code>mainViewController's locationTuples</code>中的mapitem,并且设置它</li>
<li>设置当前<code>Enter</code>为选中状态</li>
</ol>


<p>编译运行，在<code>Stop#1</code>中输入地址，点击<code>Enter</code>，然后选择正确的地址，这个文本框中的值，地址元组(location tuple arra)，还有<code>Enter</code>按钮将会自动更新:
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Two_entries.png" alt="1" /></p>

<p><em>Addresses updated. (Checkmarks et al.)</em></p>

<p>在<code>ViewController.swift</code>中你还有一部分工作需要完成。</p>

<p>更新代码在<code>textField(_:shouldChangeCharactersInRange:replacementString:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func textField(textField: UITextField,
</span><span class='line'>  shouldChangeCharactersInRange range: NSRange,
</span><span class='line'>  replacementString string: String) -&gt; Bool {
</span><span class='line'> 
</span><span class='line'>  enterButtonArray.filter{$0.tag == textField.tag}.first!.selected = false
</span><span class='line'>  locationTuples[textField.tag-1].mapItem = nil
</span><span class='line'>  return true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户编辑了文本框，你将要设置MKMapItem失效，因为MKMapItem是不再需要，这样用户就可以重新选择正确的地址。</p>

<p>下一步，更新<code>swapFields(_:)</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>swap(&destinationField1.text, &destinationField2.text)
</span><span class='line'>    swap(&locationTuples[1].mapItem, &locationTuples[2].mapItem)
</span><span class='line'>    swap(&self.enterButtonArray.filter{$0.tag == 2}.first!.isSelected, &self.enterButtonArray.filter{$0.tag == 3}.first!.isSelected)</span></code></pre></td></tr></table></div></figure>


<p>当用户点击<code>↑↓</code>，你需要交换两个文本框的值，还有在数组<code>locationTuples</code>对应的MKMapItems</p>

<p>在<code>ViewController</code>类中，找到<code>getDirections(_:)</code>方法，覆盖<code>shouldPerformSegueWithIdentifier(_:sender:)</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func shouldPerformSegueWithIdentifier(identifier: String, sender: AnyObject?) -&gt; Bool {
</span><span class='line'>  if locationTuples[0].mapItem == nil ||
</span><span class='line'>    (locationTuples[1].mapItem == nil && locationTuples[2].mapItem == nil) {
</span><span class='line'>    showAlert("Please enter a valid starting point and at least one destination.")
</span><span class='line'>    return false
</span><span class='line'>  } else {
</span><span class='line'>    return true
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在<code>ViewDidload:</code>中对<code>locationsArray</code>进行设置，它是一个只读的属性，当你访问它的时候，它会从<code>locationTuples</code>中过滤<code>mapItem</code>不为nil的元素.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var locationsArray: [(textField: UITextField!, mapItem: MKMapItem?)] {
</span><span class='line'>  var filtered = locationTuples.filter({ $0.mapItem != nil })
</span><span class='line'>  filtered += [filtered.first!]
</span><span class='line'>  return filtered
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>filtered += [filtered.first!]</code>拷贝元组中的第一个元素的值作为这个数组的最后一个元素。</p>

<p>在<code>prepareForSegue(_:sender:):</code>中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
</span><span class='line'>  var directionsViewController = segue.destinationViewController as! DirectionsViewController
</span><span class='line'>  directionsViewController.locationArray = locationsArray
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个传递的参数<code>locationsArray</code>将会在下一个View controller中用到</p>

<p>现在切换到<code>DirectionsViewController.swift</code>，去开始路径规划吧.</p>

<h2>在MapKit中进行路径规划</h2>

<p>现在，你已经知道了addresses,你将要创建一个<code>MKDirections</code>对象，调用<code>calculateDirectionsWithCompletionHandler(_:)</code>设置开始坐标和结束坐标就可以开始路径规划了.</p>

<p>在DirectionsViewController中添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func calculateSegmentDirections(index: Int) {
</span><span class='line'>  // 1
</span><span class='line'>  let request: MKDirectionsRequest = MKDirectionsRequest()
</span><span class='line'>  request.source = locationArray[index].mapItem
</span><span class='line'>  request.destination = locationArray[index+1].mapItem
</span><span class='line'>  // 2
</span><span class='line'>  request.requestsAlternateRoutes = true
</span><span class='line'>  // 3
</span><span class='line'>  request.transportType = .Automobile
</span><span class='line'>  // 4
</span><span class='line'>  let directions = MKDirections(request: request)
</span><span class='line'>  directions.calculateDirectionsWithCompletionHandler ({
</span><span class='line'>    (response: MKDirectionsResponse?, error: NSError?) in
</span><span class='line'>    if let routeResponse = response?.routes {
</span><span class='line'> 
</span><span class='line'>    } else if let _ = error {
</span><span class='line'> 
</span><span class='line'>    }
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>创建一个<code>MKDirectionsRequest</code>，通过索引获取<code>locationArray</code>对应的mapItem,设置MKDirectionsRequest的开始坐标为这个mapitem,设置索引的下一个(index+1)为这个请求的目的地坐标</li>
<li>设置<code>requestsAlternateRoutes</code>为true,请求从源目标到目的地所有可能的路径</li>
<li>设置交通方式为 汽车驾驶,其它几个可能的方式为:步行，所有,公交车等</li>
<li>通过<code>MKDirectionsRequest</code>初始化<code>MKDirections</code>，然后调用<code>calculateDirectionsWithCompletionHandler</code>获取到一个<code>MKDirectionsResponse</code>，这会包含一组<code>MKRoutes</code>数据</li>
</ol>


<p>如果<code>calculateDirectionsWithCompletionHandler(_:)</code>没有返回任何routes,而是返回一个错误，那么<code>else if let _ = error</code>代码将会执行，添加这个代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alert = UIAlertController(title: nil,
</span><span class='line'>  message: "Directions not available.", preferredStyle: .Alert)
</span><span class='line'>let okButton = UIAlertAction(title: "OK",
</span><span class='line'>  style: .Cancel) { (alert) -&gt; Void in
</span><span class='line'>  self.navigationController?.popViewControllerAnimated(true)
</span><span class='line'>}
</span><span class='line'>alert.addAction(okButton)
</span><span class='line'>self.presentViewController(alert, animated: true,
</span><span class='line'>  completion: nil)</span></code></pre></td></tr></table></div></figure>


<p>假设<code>MKRoutes</code>是找到了，在第一个<code>if let</code>声明中<code>calculateDirectionsWithCompletionHandler(_:)</code>将会执行，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>let quickestRouteForSegment: MKRoute =
</span><span class='line'>  routeResponse.sort({$0.expectedTravelTime &lt;
</span><span class='line'>  $1.expectedTravelTime})[0]</span></code></pre></td></tr></table></div></figure>


<p>这里你按照 到达的时间 进行排序，用时最短的时间将会排在第一个，这对你的路线规划来说是有好处的。
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/troll-troll-dad-dance-jump.png" alt="2" /></p>

<p>但是，你仍然需要计算多个路径在每两个地点之间。</p>

<p>首先，更新<code>calculateSegmentDirections(_:)</code>参数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func calculateSegmentDirections(index: Int,
</span><span class='line'>  time: NSTimeInterval, routes: [MKRoute]) {</span></code></pre></td></tr></table></div></figure>


<p><code>calculateSegmentDirections(_:time:routes:)</code>现在接受一个数组和一个 NSTimeInterval 参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>// 1
</span><span class='line'>var timeVar = time
</span><span class='line'>var routeVar = routes
</span><span class='line'>//2
</span><span class='line'>routesVar.append(quickestRouteForSegment)
</span><span class='line'>// 3
</span><span class='line'>timeVar += quickestRouteForSegment.expectedTravelTime
</span><span class='line'>// 4
</span><span class='line'>if index+2 &lt; self.locationArray.count {
</span><span class='line'>  self.calculateSegmentDirections(index+1, time: timeVar, routes: routesVar)
</span><span class='line'>} else {
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>创建两个变量，一个是timeVar,一个是routeVar</li>
<li>为当前的分段路线routesVar添加最快的路径规划</li>
<li>在timeVar中添加路径规划的预计到达时间</li>
<li>当你当前的索引加上最后两个值后没有超过<code>location array</code>数量值，递归调用自身方法<code>calculateSegmentDirections(_:time:routes:)</code>，传递索引+1,当前的time和路径values.</li>
</ol>


<p>现在回到<code>viewDidLoad</code>中，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addActivityIndicator()
</span><span class='line'>calculateSegmentDirections(0, time: 0, routes: [])</span></code></pre></td></tr></table></div></figure>


<p>这个代码添加一个转子activity indicator,当路径规划开始计算的时候，然后调用<code>calculateSegmentDirections(_:time:routes:)</code>去计算路径，从locationArray第一个索引开始，初始化时间为0,初始化一个空的路径数组</p>

<p>然后回到<code>calculateDirectionsWithCompletionHandler(_:)</code>中，在<code>else</code>的回调函数判断中，在<code>if index+2 &lt; self.locationArray.count</code>的下面添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.hideActivityIndicator()</span></code></pre></td></tr></table></div></figure>


<p>当计算完所有的路径规划后，隐藏转子</p>

<h2>在MKMapIVew中添加MKRoutes</h2>

<p>为了去规划每一个<code>MKMapView</code>在MKMapView中，你需要在<code>DirectionsViewController</code>添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func plotPolyline(route: MKRoute) {
</span><span class='line'>  // 1
</span><span class='line'>  mapView.addOverlay(route.polyline)
</span><span class='line'>  // 2
</span><span class='line'>  if mapView.overlays.count == 1 {
</span><span class='line'>    mapView.setVisibleMapRect(route.polyline.boundingMapRect,
</span><span class='line'>      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
</span><span class='line'>      animated: false)
</span><span class='line'>  }
</span><span class='line'>  // 3
</span><span class='line'>  else {
</span><span class='line'>    let polylineBoundingRect =  MKMapRectUnion(mapView.visibleMapRect,
</span><span class='line'>      route.polyline.boundingMapRect)
</span><span class='line'>    mapView.setVisibleMapRect(polylineBoundingRect,
</span><span class='line'>      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
</span><span class='line'>      animated: false)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>plotPolyline(_:)</code>做的工作如下:</p>

<ol>
<li>添加<code>MKRoute</code>到地图上，作为一个覆盖层</li>
<li>如果规划的路径仅仅是一个覆盖层，设置地图的可见区域足够大足以填充整个覆盖层，外边缘留出10个点的间距</li>
<li>如果规划的路径不是一个，设置地图的可见区域为新的和旧的的区域的联合，外边缘留出10个点的间距</li>
</ol>


<p>下一步，更新<code>mapView(_:rendererForOverlay:)</code>方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func mapView(mapView: MKMapView,
</span><span class='line'>  rendererForOverlay overlay: MKOverlay) -&gt; MKOverlayRenderer! {
</span><span class='line'> 
</span><span class='line'>  let polylineRenderer = MKPolylineRenderer(overlay: overlay)
</span><span class='line'>  if (overlay is MKPolyline) {
</span><span class='line'>    if mapView.overlays.count == 1 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.blueColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    } else if mapView.overlays.count == 2 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.greenColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    } else if mapView.overlays.count == 3 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.redColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    }
</span><span class='line'>    polylineRenderer.lineWidth = 5
</span><span class='line'>  }
</span><span class='line'>  return polylineRenderer
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>给每一个路径路段设置不同的颜色</p>

<p>在<code>calculateSegmentDirections(_:time:routes:)</code>添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showRoute(routes: [MKRoute]) {
</span><span class='line'>  for i in 0..&lt;routes.count {
</span><span class='line'>    plotPolyline(routes[i])
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数循环所有的<code>MKRoute</code>，添加覆盖层到地图上。</p>

<p>在方法<code>calculateDirectionsWithCompletionHandler(_:)</code>中，调用<code>showRoute(_:)</code>方法。在<code>else</code>block中你调用的<code>self.hideActivityIndicator():</code>的代码上面调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.showRoute(routesVar)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，输入地址然后点击<code>Route it</code>,路线规划将要出现在地图上:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Map_Route.png" alt="1" /></p>

<p>下一步，你要打印路线的每一步路径信息到<code>DirectionsTable</code>上</p>

<h2>打印MKRoute的路径信息</h2>

<p><code>DirectionsTable.swift</code>包含一个全局的数组<code>directionsArray</code>,是一个包含元组的数组(string,string,MKRoute).这两个字符串是开始地址和结束地址，最后一个MKRoute，是路径的信息。</p>

<p>滑动页面到<code>UITableViewDataSource</code>的扩展方法中，在代理方法<code>numberOfSectionsInTableView(_:)</code>设置返回的数量，这个表格将要包含一个section为存储在<code>directionsArray</code>中每一个route。</p>

<p>这样你的<code>DirectionsTable</code>的每一个section就会为route呈现一个不同的分段.</p>

<p>代理方法<code>tableView(_:numberOfRowsInSection:)</code>将会返回<code>MKRouteSteps</code>的数量，比如:<code>directionsArray[section].route.</code></p>

<p>从开始地点到目的地一共有多少步.</p>

<p>在<code>tableView(_:cellForRowAtIndexPath:)</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let steps = directionsArray[indexPath.section].route.steps
</span><span class='line'>// 2
</span><span class='line'>let step = steps[indexPath.row]
</span><span class='line'>// 3
</span><span class='line'>let instructions = step.instructions
</span><span class='line'>// 4
</span><span class='line'>let distance = step.distance.miles()
</span><span class='line'>// 5
</span><span class='line'>cell.textLabel?.text = "\(indexPath.row+1). \(instructions) - \(distance) miles"</span></code></pre></td></tr></table></div></figure>


<p>在每一行中，你打印<code>MKRouteStep</code>的说明信息和距离等:</p>

<ol>
<li>通过当前的section的值，得到<code>MKRoute</code>,然后通过<code>MKRoute</code>获取<code>MKRouteSteps</code>的数组</li>
<li>从steps的数组中，访问<code>MKRouteStep</code>的对象通过当前行。</li>
<li>获取step的说明信息</li>
<li>获取step的距离信息，在<code>CLLocationDistance</code>的扩展方法中，定义了一个miles()方法，通过这个方法把距离转为 米 单位 。</li>
<li>设置label显示出每一步的说明信息和距离</li>
</ol>


<p>现在，你可以使用<code>UITableViewDelegate</code>的扩展方法去显示开始地点和结束地点的信息。可以在每一个section中的header中显示开始地址，在footer中显示结束地点。</p>

<p>在<code>tableView(_:viewForHeaderInSection:)</code>添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>label.text = "SEGMENT #\(section+1)\n\nStarting point: \(directionsArray[section].startingAddress)\n"
</span></code></pre></td></tr></table></div></figure>


<p>这个头部view包含了开始地址:</p>

<p>在<code>tableView(_:viewForFooterInSection:)</code>中添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let route = directionsArray[section].route
</span><span class='line'>// 2
</span><span class='line'>let time = route.expectedTravelTime.formatted()
</span><span class='line'>// 3
</span><span class='line'>let miles = route.distance.miles()
</span><span class='line'>//4
</span><span class='line'>label.text = "Ending point: \(directionsArray[section].endingAddress)\n\nDistance: \(miles) miles\n\nExpected Travel Time: \(time)"</span></code></pre></td></tr></table></div></figure>


<ol>
<li>得到当前的section route</li>
<li>从NSTimeInterval的扩展中，通过<code>formatted()</code>格式化<code>expectedTravelTime</code>,<code>formatted()</code>方法通过<code>NSDateComponentsFormatter</code>吧<code>NSTimeInterval</code>转为<em>时分秒</em>的格式</li>
<li>通过<code>CLLocationDistance</code>格式化距离</li>
<li>让表格的label显示结束地址，距离和期望到达时间信息</li>
</ol>


<p>现在回到<code>DirectionsViewController</code>中，添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func displayDirections(directionsArray: [(startingAddress: String, 
</span><span class='line'>  endingAddress: String, route: MKRoute)]) {
</span><span class='line'>  directionsTableView.directionsArray = directionsArray
</span><span class='line'>  directionsTableView.delegate = directionsTableView
</span><span class='line'>  directionsTableView.dataSource = directionsTableView
</span><span class='line'>  directionsTableView.reloadData()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更新<code>showRoute(_:):</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> func showRoute(routes: [MKRoute]) {
</span><span class='line'>  var directionsArray = [(startingAddress: String, endingAddress: String, route: MKRoute)]()
</span><span class='line'>  for i in 0..&lt;routes.count {
</span><span class='line'>    plotPolyline(routes[i])
</span><span class='line'>   let item = ((locationArray[i].textField?.text)!,
</span><span class='line'>                        (locationArray[i+1].textField?.text)!, routes[i]) as TupleRouteItem
</span><span class='line'> //(startingAddress: String, endingAddress: String, route: MKRoute)
</span><span class='line'>    directionsArray.append(item)
</span><span class='line'>  }
</span><span class='line'>  displayDirections(directionsArray)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于每一个路径规划，你都添加了开始地址和结束地址，然后添加<code>MKRoute</code>到directionsArray数组中</p>

<p>下一步，你需要更新<code>totalTimeLabel</code>去显示总的期望达到时间。总的时间需要通过可变参数在<code>calculateSegmentDirections(_:time:routes:).</code>方法中计算出来。</p>

<p>所以更新<code>showRoute(_:)</code>方法，添加一个<code>NSTimeInterval</code>参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showRoute(routes: [MKRoute], time: NSTimeInterval) {</span></code></pre></td></tr></table></div></figure>


<p>在<code>DirectionsViewController</code>类中添加如下方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printTimeToLabel(time: NSTimeInterval) {
</span><span class='line'>  var timeString = time.formatted()
</span><span class='line'>  totalTimeLabel.text = "Total Time: \(timeString)"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该方法在totalTimeLabel中显示出来总共时间</p>

<p>最后在函数的末尾，调用<code>printTimeToLabel(_:)</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>printTimeToLabel(time)</span></code></pre></td></tr></table></div></figure>


<p>编译运行:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Route_2.png" alt="1" /></p>

<h2>下载工程</h2>

<p><a href="">最终工程</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">安路</span></span>

      




<time class='entry-date' datetime='2016-12-21T16:04:20+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>4:04 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/swift/'>swift</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  

<!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->
<br><br>
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2052593"></script>
<!-- UY END -->

</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/12/21/dao-che-ru-ku-ji-qiao/" title="Previous Post: 倒车入库技巧">&laquo; 倒车入库技巧</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/12/23/iosde-hou-tai-mo-shi/" title="Next Post: iOS的后台模式">iOS的后台模式 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
<h1>
	QQ群
</h1>
   <br/>
	<p>欢迎加入swift学习交流群:252710124</p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/12/23/iosde-hou-tai-mo-shi/">iOS的后台模式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/">使用Core Location和MapView进行路线规划</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/dao-che-ru-ku-ji-qiao/">倒车入库技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/19/yong-corelocationshi-xian-di-li-wei-lan/">用CoreLocation实现-地理围栏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/15/mapkitjiao-cheng-qi-bu/">MapKit教程:起步</a>
      </li>
    
  </ul>
</section>
<section>
	<h1>文章分类</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/cocoapods/'>cocoapods (1)</a></li>
<li class='category'><a href='/blog/categories/git/'>git (3)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (29)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (2)</a></li>
<li class='category'><a href='/blog/categories/nodejs/'>nodejs (2)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (25)</a></li>
<li class='category'><a href='/blog/categories/xcode/'>xcode (1)</a></li>
<li class='category'><a href='/blog/categories/汽车/'>汽车 (4)</a></li>

	</ul>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andrew-anlu">@andrew-anlu</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andrew-anlu',
            count: 3,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/Andrewswift1987?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/Andrewswift1987">My Delicious Bookmarks &raquo;</a></p>
</section>

 <section>
      <h1>访客统计</h1>
      <br/>
    <a href="http://info.flagcounter.com/Bkif"><img src="http://s01.flagcounter.com/count2/Bkif/bg_ffffff/txt_000000/border_CCCCCC/columns_3/maxflags_10/viewers_0/labels_1/pageviews_1/flags_1/percent_0/" alt="Free counters!" border="0"></a>
    </section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;">
  <a href="#" onclick="goTop();return false;"><img src="http://7xsn4e.com2.z0.glb.clouddn.com/top.png" border=0 alt="返回顶部" width="50" height="50"></a>
</div>
<script src="/javascripts/top.js" type="text/javascript"></script>
<!--返回顶部结束-->


<p>
  Copyright &copy; 2016 - 安路 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>



</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'Andrewswift1987';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/';
        var disqus_url = 'http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
