
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>深入理解RunLoop - 安路的技术博客</title>
  <meta name="author" content="安路">

  
  <meta name="description" content="RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等. RunLoop的概念 一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="安路的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">安路的技术博客</a></h1>
  
    <h2>追求卓越成功就会在不经意追上你</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://andrew-anlu.github.io" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andrew-anlu.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">深入理解RunLoop</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-03-29T17:29:43+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:29 pm</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://andrew-anlu.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loop() {
</span><span class='line'>    initialize();
</span><span class='line'>    do {
</span><span class='line'>        var message = get_next_message();
</span><span class='line'>        process_message(message);
</span><span class='line'>    } while (message != quit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
</span><span class='line'>static CFMutableDictionaryRef loopsDic;
</span><span class='line'>/// 访问 loopsDic 时的锁
</span><span class='line'>static CFSpinLock_t loopsLock;
</span><span class='line'>  
</span><span class='line'>/// 获取一个 pthread 对应的 RunLoop。
</span><span class='line'>CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
</span><span class='line'>    OSSpinLockLock(&loopsLock);
</span><span class='line'>     
</span><span class='line'>    if (!loopsDic) {
</span><span class='line'>        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
</span><span class='line'>        loopsDic = CFDictionaryCreateMutable();
</span><span class='line'>        CFRunLoopRef mainLoop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    /// 直接从 Dictionary 里获取。
</span><span class='line'>    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
</span><span class='line'>     
</span><span class='line'>    if (!loop) {
</span><span class='line'>        /// 取不到时，创建一个
</span><span class='line'>        loop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, thread, loop);
</span><span class='line'>        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
</span><span class='line'>        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    OSSpinLockUnLock(&loopsLock);
</span><span class='line'>    return loop;
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetMain() {
</span><span class='line'>    return _CFRunLoopGet(pthread_main_thread_np());
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetCurrent() {
</span><span class='line'>    return _CFRunLoopGet(pthread_self());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
</span><span class='line'>    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
</span><span class='line'>    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
</span><span class='line'>    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
</span><span class='line'>    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
</span><span class='line'>    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
</span><span class='line'>    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __CFRunLoopMode {
</span><span class='line'>    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
</span><span class='line'>    CFMutableSetRef _sources0;    // Set
</span><span class='line'>    CFMutableSetRef _sources1;    // Set
</span><span class='line'>    CFMutableArrayRef _observers; // Array
</span><span class='line'>    CFMutableArrayRef _timers;    // Array
</span><span class='line'>    ...
</span><span class='line'>};
</span><span class='line'>  
</span><span class='line'>struct __CFRunLoop {
</span><span class='line'>    CFMutableSetRef _commonModes;     // Set
</span><span class='line'>    CFMutableSetRef _commonModeItems; // Set
</span><span class='line'>    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
</span><span class='line'>    CFMutableSetRef _modes;           // Set
</span><span class='line'>    ...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
</span><span class='line'>CFRunLoopRunInMode(CFStringRef modeName, ...);</span></code></pre></td></tr></table></div></figure>


<p>Mode暴露的管理Mode Item的有下面几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</span><span class='line'>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoop {
</span><span class='line'>    current mode = kCFRunLoopDefaultMode
</span><span class='line'>    common modes = {
</span><span class='line'>        UITrackingRunLoopMode
</span><span class='line'>        kCFRunLoopDefaultMode
</span><span class='line'>    }
</span><span class='line'>  
</span><span class='line'>    common mode items = {
</span><span class='line'>  
</span><span class='line'>        // source0 (manual)
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = _UIApplicationHandleEventQueue}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventSignalCallback }}
</span><span class='line'>        CFRunLoopSource {order = 0, {
</span><span class='line'>            callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>  
</span><span class='line'>        // source1 (mach port)
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 17923}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 12039}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 16647}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 2407,
</span><span class='line'>            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1c03,
</span><span class='line'>            callout = __IOHIDEventSystemClientAvailabilityCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1b03,
</span><span class='line'>            callout = __IOHIDEventSystemClientQueueCallback}}
</span><span class='line'>        CFRunLoopSource {order = 1, {port = 1903,
</span><span class='line'>            callout = __IOMIGMachPortPortCallback}}
</span><span class='line'>  
</span><span class='line'>        // Ovserver
</span><span class='line'>        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
</span><span class='line'>            callout = _UIGestureRecognizerUpdateObserver}
</span><span class='line'>        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _afterCACommitHandler}
</span><span class='line'>        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>  
</span><span class='line'>        // Timer
</span><span class='line'>        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
</span><span class='line'>            next fire date = 453098071 (-4421.76019 @ 96223387169499),
</span><span class='line'>            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
</span><span class='line'>    },
</span><span class='line'>  
</span><span class='line'>    modes ＝ {
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = 0, {
</span><span class='line'>                    callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = {
</span><span class='line'>                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
</span><span class='line'>                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>            )},
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventSignalCallback}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventCallback}}
</span><span class='line'>            },
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>         
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = (null),
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    /// 1. 通知Observers，即将进入RunLoop
</span><span class='line'>    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
</span><span class='line'>    do {
</span><span class='line'>  
</span><span class='line'>        /// 2. 通知 Observers: 即将触发 Timer 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
</span><span class='line'>        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 4. 触发 Source0 (非基于port的) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 6. 通知Observers，即将进入休眠
</span><span class='line'>        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 7. sleep to wait msg.
</span><span class='line'>        mach_msg() -&gt; mach_msg_trap();
</span><span class='line'>         
</span><span class='line'>  
</span><span class='line'>        /// 8. 通知Observers，线程被唤醒
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被Timer唤醒的，回调Timer
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
</span><span class='line'>        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>    } while (...);
</span><span class='line'>  
</span><span class='line'>    /// 10. 通知Observers，即将退出RunLoop
</span><span class='line'>    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFSocket
</span><span class='line'>CFNetwork       -&gt;ASIHttpRequest
</span><span class='line'>NSURLConnection -&gt;AFNetworking
</span><span class='line'>NSURLSession    -&gt;AFNetworking2, Alamofire</span></code></pre></td></tr></table></div></figure>


<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        [[NSThread currentThread] setName:@"AFNetworking"];
</span><span class='line'>        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
</span><span class='line'>        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
</span><span class='line'>        [runLoop run];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>+ (NSThread *)networkRequestThread {
</span><span class='line'>    static NSThread *_networkRequestThread = nil;
</span><span class='line'>    static dispatch_once_t oncePredicate;
</span><span class='line'>    dispatch_once(&oncePredicate, ^{
</span><span class='line'>        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
</span><span class='line'>        [_networkRequestThread start];
</span><span class='line'>    });
</span><span class='line'>    return _networkRequestThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start {
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    if ([self isCancelled]) {
</span><span class='line'>        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    } else if ([self isReady]) {
</span><span class='line'>        self.state = AFOperationExecutingState;
</span><span class='line'>        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    }
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">安路</span></span>

      




<time class='entry-date' datetime='2016-03-29T17:29:43+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:29 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>ios</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  

<!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->
<br><br>
<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2052593"></script>
<!-- UY END -->

</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/03/27/nsurlsessionxiang-jie/" title="Previous Post: NSUrlSession详解">&laquo; NSUrlSession详解</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/04/04/uistackviewjie-shao/" title="Next Post: UIStackView介绍">UIStackView介绍 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/19/ioszhong-de-duo-ren-wu/">Ios中的多任务</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/15/asyndisplaykitru-men-pian/">AsynDisplayKit入门篇</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/04/tong-guo-%5B%3F%5D-ge-demoxiang-jie-uistackview/">通过一个Demo详解UIStackView</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/04/uistackviewjie-shao/">UIStackView介绍</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/29/shen-ru-li-jie-runloop/">深入理解RunLoop</a>
      </li>
    
  </ul>
</section>
<section>
	<h1>文章分类</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/cocoapods/'>cocoapods (1)</a></li>
<li class='category'><a href='/blog/categories/git/'>git (3)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (12)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>mac (1)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/swift/'>swift (9)</a></li>

	</ul>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/andrew-anlu">@andrew-anlu</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'andrew-anlu',
            count: 3,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/Andrewswift1987?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/Andrewswift1987">My Delicious Bookmarks &raquo;</a></p>
</section>

 <section>
      <h1>访客统计</h1>
      <br/>
    <a href="http://info.flagcounter.com/Bkif"><img src="http://s01.flagcounter.com/count2/Bkif/bg_ffffff/txt_000000/border_CCCCCC/columns_3/maxflags_10/viewers_0/labels_1/pageviews_1/flags_1/percent_0/" alt="Free counters!" border="0"></a>
    </section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:180px; bottom:150px; z-index:100; text-align:center; background-color:transparent; cursor:pointer;">
  <a href="#" onclick="goTop();return false;"><img src="http://7xsn4e.com2.z0.glb.clouddn.com/top.png" border=0 alt="返回顶部" width="50" height="50"></a>
</div>
<script src="/javascripts/top.js" type="text/javascript"></script>
<!--返回顶部结束-->


<p>
  Copyright &copy; 2016 - 安路 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>



</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'Andrewswift1987';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/';
        var disqus_url = 'http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
