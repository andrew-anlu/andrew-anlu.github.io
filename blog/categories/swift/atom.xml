<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2017-01-07T14:00:59+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS的后台模式]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/23/iosde-hou-tai-mo-shi/"/>
    <updated>2016-12-23T14:32:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/23/iosde-hou-tai-mo-shi</id>
    <content type="html"><![CDATA[<p>回到2010年ios4时代，苹果就已经推出了多任务.</p>

<!--more-->


<p>用户和开发者们经常抱怨ios的多任务系统允许做什么呢</p>

<p>苹果已经限制了用户使用后台操作，也许这些操作是用来提高用户体验的，或者是延长电池的使用寿命。</p>

<p>你的App仅仅是允许在后台运行而已。在一些特殊的情况下,这些包括:播放音频，获取地理位置，从服务器获取最新的数据。</p>

<p>如果你的任务不是这些类别中的一个，那么后台模式不适合你。</p>

<p>如果你利用后台模式做了一些其它的工作或者任务来欺骗系统，在你提交AppStore时，有可能会被拒绝上架，所以要慎重。</p>

<h2>起步</h2>

<p>在开始工程之前，你可以快速浏览一下看看后台模式能够做什么？在xcode8中，你可以看到在你的app target中，有个一<code>Capabilities</code>的tab页，打开之后有一个列表:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/EnableBackgroundCapability-650x355.png" alt="1" /></p>

<ol>
<li>在<code>Project Navigato</code>中选择一个工程</li>
<li>选择app target</li>
<li>选择 <code>Capabilities</code>tab</li>
<li>打开<code>Background Modes</code>开关</li>
</ol>


<p>在后台模式中，你将要研究4中方式来做后台进程的工作:</p>

<ul>
<li>播放音频:在app进入后台模式中，仍然能够播放音频文件</li>
<li>地理坐标更新:当设备坐标位置该改变的时候，这个App能够更新坐标</li>
<li>加载一定长度的任务:在<code>whatever</code>的案例中，App在有限的时间内，可以运行任意的代码</li>
<li>后台获取数据:定时更新内容</li>
</ul>


<p>如果你仅仅是对其中一个或者多个感兴趣，你可以跳过其它的介绍；</p>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/09/TheBackgrounder-rev3-Starter.zip">下载开始工程</a>,</p>

<p>编译运行工程，你会看到有4个tab,每个代表一个后台模式:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-StarterProjectTabs.png" alt="2" /></p>

<blockquote><p>注意:</p>

<p>为了展现全部的效果，你将要使用真正的设备去测试，经验之谈，假如你忘记去设置配置文件，这个app在模拟器的后台模式下是一直运行的。然而，当你切换到真机的时候，它将不再工作。所以最好用真机去测试。</p></blockquote>

<h2>Playing Audio</h2>

<p>首先，音频播放。</p>

<p>这里有几种方式在IOS设备上去播放音频，大部分他们要求提供回调的实现方法去提供更多的音频数据去播放、</p>

<p>如果你想从一个二进制文件中播放一个音频，你可以连接网络，在连接后的回调处理方法中提供持续的音频数据。</p>

<p>当你激活Audio进入后台模式后，你的ios设备将会继续回调，甚至你的app不是当前激活的状态。这就对了&ndash;这个 audoi background模式是一个自动虚拟的，你仅仅需要去激活它并且提供基础实施去适当的处理它.</p>

<p>在这一章中，你将要回顾下app播放器，验证下后台模式是否工作正常，确保这个audio可以在后台模式下工作的能力，证明他是可以在工作的</p>

<p>打开<code>AudioViewController.swift</code>文件，</p>

<p>这个App使用了<code>AVQueuePlayer</code>去顺序播放歌曲，这个View Controller监听播放器的<code>currentItem</code>.</p>

<p>当这个app是处于激活状态的时候，这个music title label将会显示，当这个app处于后台模式中的时候，它将在控制台打印出标题，这个文本显示信息在后台模式的时候将会更新。重点是当你的app在后台的时候，是否能继续收到回调信息。</p>

<p>编译运行你的app:
<img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AudioScreen.png" alt="1" /></p>

<p>现在点击<code>Play</code>,音乐就会开始了.</p>

<p>测试下后台模式，如果你是在真机上测试的，请点击Home按钮，此时音乐停止了，为什么呢?这里还有一件重要的事情没有做</p>

<p>对于大多数的后台模式而言，（"whatever"模式是个特殊），你需要确保在进入后台模式后，你的代码依然能够运行。</p>

<p>回到xcode,做下面的事情:</p>

<ol>
<li>点击工程的<code>Project Navigator</code></li>
<li>点击<code>TheBackgrounder</code>target</li>
<li>点击<code>Capabilities</code>标签页</li>
<li>找到<code>Background Mode</code>并且打开开关</li>
<li>选择<code>Audio, AirPlay and Picture in Picture.</code></li>
</ol>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableAudioInBG.png" alt="1" /></p>

<p>再次编译运行，重复刚才的操作，此时在后台模式下，你就能听到音乐继续在播放了。</p>

<p>你应该能在控制台看到这个更新时间，证明你的代码甚至在后台模式下依然在工作</p>

<p>wow,如果你已经有一个音乐播放器了，在后台模式下播放是很简单的。</p>

<h2>收到地址坐标更新</h2>

<p>当你的定位是在后台模式下，你的app将会收到用户地址定位的更新的代理消息，在后台模式下，你可以控制定位更新的精度，甚至可以改变这个精度。</p>

<p>第二个tab页就是关于定位更新的。打开<code>LocationViewController.swift</code>,和audio example例子很像，这个定位更新的后台模式是很容易去实现的，假如你之前做过定位相关的工作。</p>

<p>在这个控制器里，你将会找到<code>CLLocationManager</code>，为了收到定位消息你需要配置<code>CLLocationManager</code>实例，在这个案例中，当你打开屏幕上的UISwitch开关，你的app定位监听就会打开，定位服务将会收到App在地图上放置的大头针。当你的app是在后台模式下的时候，你将会看到在控制台上看到有日志输出。</p>

<p>在<code>CLLocationManager</code>实例中，一行重要的代码是调用<code>requestAlwaysAuthorization ()</code>,这是一个请求权限的提示在ios8后，它会弹出一个权限的提示框，并且在后台收到定位信息。</p>

<p>这个同样需要在xcode中进行设置，选择<code>Location updates</code>，让ios系统知道你的app在后台模式下想要继续收到定位更新的信息</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableLocationInBG.png" alt="1" /></p>

<p>在选择了刚才的checobox之后，ios8要求你必须在你的<code>info.plist</code>中设置一个key,去解释用户为什么需要在后台模式下进行定位更新，如果你不做这个设置，你的定位请求将会失败。</p>

<ul>
<li>在xcode中选择一个工程</li>
<li>在<code>TheBackgrounder</code>target中，选择info tab 页</li>
<li>选择已经存在的行</li>
<li>点击<code>+</code>按钮去添加一个新key</li>
<li>添加key的名字为:<code>Privacy – Location Always Usage Description</code></li>
<li>type -> string</li>
</ul>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AddLocationPrivacyMessage.png" alt="1" /></p>

<p>现在，编译运行你的工程，把页面上的switch开关打开</p>

<p>当你是第一次操作的时候，你将会收到一个弹出的提示框，是关于你的定位权限的，点击<code>Allow</code>,并且步行走出你所在的大楼或者建筑物，你将会看到你的定位正在更新，甚至在模拟器上也会看到</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-AllowLocationAccess.png" alt="1" /></p>

<p>过一会，你将会看到如下:
<img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-LocationUpdatesOnMap.png" alt="2" /></p>

<p>如果你的app是在后台模式下，你将会看到app更新坐标的日志信息。再次打开你的app,你将会发现你的地图上已经为你的地址坐标布满了大头针。</p>

<p>如果你是用模拟器进行测试的，你可以这样设置:<code>Debug \ Location menu:</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DebugLocationSimulation.png" alt="1" /></p>

<p>尝试设置location为<code>Freeway Drive</code>,然后点击home按钮，你将会看到驾驶在加利福利亚高速公路上的路线的坐标信息，以及你的进度信息都会作为日志打印到控制台上。</p>

<pre><code>App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time
App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time
App is backgrounded. New location is %@ &lt;+37.33500926,-122.03272188&gt; +/- 5.00m (speed 7.74 mps / course 246.09) @ 9/5/16, 10:20:07 PM Mountain Standard Time
</code></pre>

<p>是不是很容易，让我们点击第三个tab,开始学习第三种后台模式</p>

<h2>请求有限时间的任务</h2>

<p>这个后台模式是被叫做<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW3"> Executing a Finite-Length Task in the Background</a></p>

<p>技术上说，这个算不上后台模式，你不需要在你的app上设置后台模式的类型在<code>Capabilities</code>菜单中，代替的是，它仅仅是一个api,当你的app处于后台模式下的时候，运行任意的代码。</p>

<p>在过去，这个模式经常用来完成上传和下载的工作，系统大概提供10分钟来完成这些任务。</p>

<p>但是如果网络很慢，进程不能按时完成怎么办呢？这会让你的app很尴尬，你不得不做些错误的处理工作使得事情看起来合乎情理。因为这个原因，苹果引进了<code>NSURLSession</code></p>

<p>尽管<code>NSURLSession</code>不是后台模式这个主题的介绍范围之内，但是<code>NSURLSession</code>具有稳健的后台处理机制，假如你正在下载一个很大的文，甚至设备重启之后，它都有下载文件完的强大的能力。如果你要学习NSURlSession，<a href="https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started">请查看这个教程</a></p>

<p>这个案例介绍的后台模式是：当你运行很长的任务需要长时间的后台执行代码，比如渲染或者写一个视频文件到相机里面&hellip;.这些都是很耗时的操作</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2013/04/Whatever_cheers.png" alt="1" /></p>

<p>这个当然仅仅是一个例子，你的代码可以是任意的，你可以使用这些api去做更多美好的事情：执行很冗长的运算，过滤图片，渲染3D效果&hellip;.whatever!</p>

<p>你的想象是有限的，无论什么都是可以做的。</p>

<p>你的app在后台运行的时间长短是靠ios系统决定的，不是你我能左右的。这里不能保证能完成指定的工作，但是你可以通过<code>UIApplication</code>的<code>backgroundTimeRemaining</code>属性来检查工作。这个将会告诉你在后台运行了多久.</p>

<p>一般来说，通过观察者模式你只有3分钟的时间，再次，这个不能保证这个api给你一个准确的时间数字-所以你不经仅仅依赖这个数字，你可能得到的结果是5分钟也有可能是5秒，所以你的app可以准备做些什么&hellip;.</p>

<p>打开<code>WhateverViewController.swift</code>，这个控制器将要书序计算Fibonacci 数字，并且展示这个结果。假如你挂起这个app在这个设备上，这个计算将要停止，当这个app再次被激活的时候，数字才会再次收集。</p>

<p>你的任务就是创建一个后台任务，当程序进入后台的时候依然能够运行计算</p>

<p>你首先要添加一个属性在<code>WhateverViewController</code>中:</p>

<pre><code>var backgroundTask: UIBackgroundTaskIdentifier = UIBackgroundTaskInvalid
</code></pre>

<p>这个属性是被用于在后台模式下任务的identify.</p>

<p>下面添加下面的方法在<code>WhateverViewController</code></p>

<pre><code>func registerBackgroundTask() {
  backgroundTask = UIApplication.shared.beginBackgroundTask { [weak self] in
    self?.endBackgroundTask()
  }
  assert(backgroundTask != UIBackgroundTaskInvalid)
}

func endBackgroundTask() {
  print("Background task ended.")
  UIApplication.shared.endBackgroundTask(backgroundTask)
  backgroundTask = UIBackgroundTaskInvalid
}
</code></pre>

<p><code>registerBackgroundTask()</code>告诉iOS你需要更多的时间去计算，无论你是在后台做什么工作。当这个调用过后，如果你的app是在后台，它就会需要获取CPU的时间，直到你调用<code>endBackgroundTask()</code>去终止后台任务</p>

<p>好了，如果在后台运行了一段时间后，你不调用<code>endBackgroundTask()</code>，iOS将要调用默认的闭包<code>beginBackgroundTask(expirationHandler:)</code>去给你一个机会去执行停止的代码。所以，这是一个非常好的地方去调用<code>endBackgroundTask()</code>，告诉iOS系统你做完工作了。</p>

<p>如果你不这样做，继续执行代码，那么你的app将会被强行终止</p>

<p>现在，你需要更新<code>didTapPlayPause(_:)</code>中的代码，去注册后台模式并且结束它。这里有两行注释的代码，你需要在下面添加一些代码:</p>

<p>调用<code>registerBackgroundTask()</code>在<code>register background task</code>注视下:</p>

<pre><code>// register background task
registerBackgroundTask()
</code></pre>

<p>当计算开始的时候<code>registerBackgroundTask()</code>将会被调用，所以你能继续在后台模式下计算</p>

<p>现在，在<code>end background task</code>注视下添加下面代码:</p>

<pre><code>// end background task
if backgroundTask != UIBackgroundTaskInvalid {
  endBackgroundTask()
}
</code></pre>

<p>现在当你不再需要额外的CPU时间的时候，你可以调用<code>endBackgroundTask()</code>去停止计算。</p>

<p>你每次调用<code>beginBackgroundTask(expirationHandler:).</code>方法的时候，再次调用<code>endBackgroundTask()</code>，这是很重要的。</p>

<p>如果你调用<code>beginBackgroundTaskWithExpirationHandler(_:)</code>两次，而调用<code>endBackgroundTask()</code>仅仅一次。你此时依然能够获取到CPU时间，直到你在第二个后台任务中第二次调用了<code>endBackgroundTask()</code>.</p>

<p>这也就是为什么你需要<code>backgroundTask</code></p>

<p>现在更新<code>calculateNextNumber()</code>方法，添加两个展现<code>application’s</code>状态的判断:</p>

<pre><code>switch UIApplication.shared.applicationState {
case .active:
  resultsLabel.text = resultsMessage
case .background:
  print("App is backgrounded. Next number = \(resultsMessage)")
  print("Background time remaining = \(UIApplication.shared.backgroundTimeRemaining) seconds")
case .inactive:
  break
}
</code></pre>

<p>这个label将要在Application是激活状态的时候更新，当你这个applicaton是在后台模式的时候，消息将会被打印。</p>

<p>说明新的计算结果是什么，并且进入后台模式多长时间</p>

<p>编译运行,点击第三个tab</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-RunningWhatever.png" alt="1" /></p>

<p>点击<code>Play</code>按钮你将要看到app的计算结果，现在点击home按钮，然后观察xcode的控制台，你将要看到app依然在更新数字。</p>

<p>大部分时间，这个时间将会开始在180(180秒=3分钟)，下降在5秒。</p>

<p>如果你等待这个时间去过期，当你到达5秒的时候（根据条件的不同，可能会到达另外一个值）,这个过期block将会被调用，你的app将会什么都打印而停止。此时，当你返回App,这个时间计时器将会再次开启，整个行为将会继续。</p>

<p>这个有一个bug，假设你的app是在后台模式，等待直到系统分配的时间过期。在这个案例中，你的app将要调用过期的回调函数<code>endBackgroundTask()</code>,因此结束需要后台时间。</p>

<p>如果这个时候你返回App,这个time将要继续开启，你拿上离开这个App(进入后台)，你将不会获取后台执行的时间。</p>

<p>为什么？因为没有在过期和返回后台模式之间 调用<code>beginBackgroundTaskWithExpirationHandler(_:)</code></p>

<p>如何解决这个问题呢？这里有几个方式去解决，其中之一就是使用状态改变的时候发送通知</p>

<p>修复这个bug,首先，添加一个新的方法命名为<code>reinstateBackgroundTask().</code></p>

<pre><code>func reinstateBackgroundTask() {
  if updateTimer != nil &amp;&amp; (backgroundTask == UIBackgroundTaskInvalid) {
    registerBackgroundTask()
  }
}
</code></pre>

<p>当进入后台模式并且后台任务不是不可用的状态，&amp;时间计时器不是nil,你需要重置这个状态。在这个案例中，你仅仅需要去调用<code>registerBackgroundTask().</code></p>

<p>现在覆盖<code>viewDidLoad()</code>，添加如下代码:</p>

<pre><code>
override func viewDidLoad() {
  super.viewDidLoad()
  NotificationCenter.default.addObserver(self, selector: #selector(reinstateBackgroundTask), name: NSNotification.Name.UIApplicationDidBecomeActive, object: nil)
}
</code></pre>

<p>这个新设计的方法就是当你Application再次激活的时候调用</p>

<p>当你订阅这个通知的时候，你应该想到什么时候去取消订阅通知，使用 析构函数<code>deinit</code>去实现。</p>

<pre><code>deinit {
  NotificationCenter.default.removeObserver(self)
}
</code></pre>

<p>好了，运行测试.</p>

<p>你发现你可以在后台模式做些你想做的事情了。</p>

<p>在后台模式的最后一个模式中，我们将讨论:<code>Background Fetching</code></p>

<h2>Background Fetch 后台获取</h2>

<p>后台获取模式在iOS7的时候已经引进了，它会让你的App在规定的时间出现，并且用最少的电量去呈现最新的信息。</p>

<p>假如你想在你的App中实现一个新的请求，以前的做法是,你可能会用在<code>viewWillAppear(_:).</code>中获取新数据。</p>

<p>这个解决方案的问题在于，你的用户看着老数据几分钟之后，这是新数据请求到之后就会覆盖老数据。这会让用户产生疑惑。如果当用户一打开App的时候就是新数据，这样不是更好的用户体验吗？</p>

<p>这就是为什么我们需要后台获取数据的模式。</p>

<p>系统用户使用模式去决定什么时候是最好的实际去进行后台请求，例如，假如你的用户在每天早上的9点打开App,那么你的后台任务应该在之前去请求数据，系统将会决定最好的时机去决定请求数据</p>

<p>为了实现后台请求数据，这里有三件事需要做:</p>

<ol>
<li>在你的xcode的工程中，打开<code>Capabilities</code>选项，检查是否选择了<code>Background fetch</code></li>
<li>使用<code>setMinimumBackgroundFetchInterval(_:)</code>去设置适当的请求时间</li>
<li>在你的app的代理方法中实现<code>application(_:performFetchWithCompletionHandler:</code></li>
</ol>


<p>正如方法名字所示，后台模式通常包含请求信息从一个外部的来源中，比如网络服务。</p>

<p>因为后台模式的这个目的，在当前时间你不会进行网络请求，这个简单将会让你理解每个请求都是在后台模式下完成，而且完全不用担心用外部的服务去测试它。</p>

<p>为了和上个后台模式（一定请求时间的后台任务）做比较，当你进行后台请求数据的时候你仅仅有几分钟的操作-你有最大30秒的时间，如果时间更短则更好。</p>

<p>如果你需要通过这个模式下载比较大的资源文件，那么你需要使用<code>NSURLSession‘s</code>后台传输服务</p>

<p>好了，打开<code>FetchViewController.swift</code>。</p>

<p><code>fetch(_:)</code>方法将会从一些外部服务中获取一些数据，（这些数据可能是json或者XML）.这可能需要几秒去请求和解析数据，当这个进程是完毕的时候，你的回调函数开始执行。稍后你将会知道为什么这是重要的。</p>

<p><code>updateUI()</code>将会显示格式化后的时间，这个<code>guard</code>声明江淮确保<code>updateLabel</code>不为nil,确实被加载了。</p>

<p><code>time</code>是一个可选类型，所以它开始不用设置值，刚开始显示的信息为:<code>Not updated yet</code></p>

<p>当视图第一次被加载的时候，这个时候你还没有进行后台请求数据。你直接去调用<code>updateUI()</code>，这个时候label显示<code>Not yet updated</code>.当更新按钮被点击的时候，它会在执行一个请求，请求完成时候更新UI</p>

<p>编译运行后的效果如下:
<img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-FetchNotUpdated.png" alt="1" /></p>

<p>然而，这个时候，后台请求数据模式还不能用</p>

<p>在你的app的<code>Capabilities</code>tab页中，第一步就是确保你的后台模式<code>background fetching</code>是处于选中状态，如图:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-EnableBackgroundFetch.png" alt="1" /></p>

<p>现在，打开<code>AppDelegate.swift</code>，在<code>application(_:didFinishLaunchingWithOptions:):</code>中添加如下代码:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIApplication.shared.setMinimumBackgroundFetchInterval(UIApplicationBackgroundFetchIntervalMinimum)&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>这个后台请求要求设置最小的间隔调用时间，默认的间隔时间是`UIApplicationBackgroundFetchIntervalNever `
</span><span class='line'>比如：当你用户退出或者不想去更新数据了，你也可以设置一个指定的间隔时间。那么系统就会一直处于等待状态直到到达你设定的规定时间。
</span><span class='line'>
</span><span class='line'>当心不要设置这个间隔时间太短了，因为频繁的请求可能会非常耗电。
</span><span class='line'>
</span><span class='line'>在快到达到你设置的时间之前，系统一直处于等待状态。一般来说，`UIApplicationBackgroundFetchIntervalMinimum `默认属性值就可以了。
</span><span class='line'>
</span><span class='line'>最后，为了确保后台请求能够成功你必须实现`application(_:performFetchWithCompletionHandler:).`,添加如下代码:
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;// Support for background fetch
</span><span class='line'>func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {
</span><span class='line'>  if let tabBarController = window?.rootViewController as? UITabBarController,
</span><span class='line'>         let viewControllers = tabBarController.viewControllers
</span><span class='line'>  {
</span><span class='line'>    for viewController in viewControllers {
</span><span class='line'>      if let fetchViewController = viewController as? FetchViewController {
</span><span class='line'>        fetchViewController.fetch {
</span><span class='line'>          fetchViewController.updateUI()
</span><span class='line'>          completionHandler(.newData)
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>首先，你需要获得一个<code>FetchViewContoller</code>,下一步，转换<code>rootViewController</code>为<code>UITabBarController</code>,并不是每一个RootViewController都是<code>UITabBarController</code>,所以这里用<code>?</code>。</p>

<p>但是在我们这个App中，这样转换从不会失败。</p>

<p>下一步，你循环这个tab bar controller中所有的ViewController,最后找到<code>FetchViewController</code>,这个App中，你知道最后一个就是FetchViewController，你可以硬编码。但是通过循环的话，会是你的代码更加强健。万一你哪一天想要删除或者添加某个controller了</p>

<p>当完成的时候，你调用<code>fetch(_:)</code>方法，你更新UI更新调用<code>completionHandler</code>闭包，传递一个参数<code>. newData</code>,在操作的最后调用这个闭包，这步操作是很重要的。你指定了在请求数据的过程中会发生什么 做为第一个参数。可能的值为<code>.newData</code>,<code>. noData</code> ,<code>.failed</code></p>

<p>为了简单起见，这个教程总是指定<code>.newData</code>，这样每次请求都不会失败，每次请求都会由不同的数据。</p>

<p>iOS能够使用这个值让后台请求模式变得更好理解。系统知道这这个关键点去留下一个App快照,这样就能在App切换开关的时候以卡片的形式展现出来。</p>

<h2>测试后台请求数据模型</h2>

<p>后台请求数据的测试方式之一就是做下来等待直到系统决定去做调用。这样很浪费时间。</p>

<p>幸运的是，xcode有一种方式去模拟后台请求，这里有两种情景你需要去测试，一种是当你的App处于后台模式的时候，另外一种就是当你的App刚刚激活的时候。第一种方式是很容易的，仅仅选一下菜单就可以</p>

<ul>
<li>在一个真机上运行</li>
<li>如果是模拟器，找到 <code>Fetch tab</code></li>
<li>注意此时的消息是"Not yet updated"</li>
<li>在xcode的<code>Debug</code>菜单中，选择<code>Simulate Background Fetch</code></li>
</ul>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SimulateBGFetch.png" alt="1" /></p>

<ul>
<li>这个App将会进入后台模式，xcode进入调试模式，</li>
</ul>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ContinueDebugger.png" alt="1" /></p>

<ul>
<li>然后回到这个App上</li>
<li>注意这个时间已经更新了。</li>
</ul>


<p>其它的方式测试就是从一个挂起状态到恢复状态。这里有个可选项让你加载你的app直接进入挂起状态。你想测试这个半成品最好使用一个新的scheme.Xcode配置它很容易。</p>

<p>首先选择<code>Manage Schemes</code>菜单:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-SelectScheme.png" alt="1" /></p>

<p>下一步，选择一个scheme,然后设置中的菜单选择<code>Duplicate</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-DuplicateScheme.png" alt="1" /></p>

<p>最后，重命名你的scheme的名称，比如<code>Background Fetch</code>,选择<code>Launch due to a background fetch event</code>：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/BM-ConfigureNewScheme.png" alt="1" /></p>

<p>使用这个scheme运行你的App,你将会注意到这个App不会打开，但是一直是挂起状态，现在手动加载它进入到<code>Fetch</code>tab页，你将会看到已经执行了更新操作。页面上不再是<code>Not yet updated</code></p>

<p>使用后台请求数据的方式会让你的用户毫无感觉的获取最新的内容。</p>

<h2>下载完整工程</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2016/09/TheBackgrounder-Final.zip">下载完整工程</a></p>

<p>如果你想阅读苹果的官方文档关于后台模式的，请打开<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1">Background Execution</a>.这个文档解释了所有的后台运行模式。</p>

<p>其中有趣的一个篇章是讨论<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW8">being a responsible background app</a>，这个里面是一些详情，当你释放你的App在后台运行的时候，你应该知道哪些详情是否和你的App相关。</p>

<p>最后，如果你计划在后台模式下通过网络传输比较大的文件，请学习<a href="https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started">NSURLSession</a></p>

<p>thanks!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Core Location和MapView进行路线规划]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/"/>
    <updated>2016-12-21T16:04:20+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua</id>
    <content type="html"><![CDATA[<h2>开始</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/11/ProcrastinatorsRevenge-starter.zip">下载开始工程</a></p>

<p>并且打开<code>ProcrastinatorsRevenge.xcodeproj</code>,编译运行，界面效果如下:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/starter_screenshots1.png" alt="1" /></p>

<!--more-->


<p>第一个屏幕是输入文本框，设置开始和终止地点，点击<code>Route it</code>,App将会跳转到第二个页面，开始规划路线图。</p>

<h2>使用MapKit和Coreloaction</h2>

<p>官方文档中对Core Loaction的描述是这样的:&ldquo;Core location框架让你决定当前的坐标或者或者当前的方位通过使用设备"，你将要用Core Location的特性去填充用户的开始点，Core Location能翻译坐标的经纬度为用户能够看得懂的地址信息。在MapView中，使用MapItem类的<code>CLGeocoder</code>类将会完成这个教程的第一部分。</p>

<p>在这个教程的第二部分，你将要从<code>CLGeocoder</code>返回的<code>CLPlacemark</code>中转为一个<code>MKPlacemark</code>，然后把<code>MKPlacemark</code>转换为一个<code>MKMapItem</code>。你将要使用<code>MKMapItems</code>去运行一个<code>MKDirectionsRequest</code>，这个最终将会返回一个<code>MKRoute</code>对象。</p>

<p>关系如下-><code>CLGeocoder &gt; CLPlacemark &gt; MKPlacemark &gt; MKMapItem &gt; MKDirectionsRequest &gt; MKRoute.</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/ef1905fa6eccb7e1cd85141d065d49f8.jpg-320x320.gif" alt="1" /></p>

<h2>通过CoreLocation获取当前的坐标信息</h2>

<p>在<code>ViewController.swift</code>中，添加如下代码，替换<code>viewDidLoad</code>已经存在的代码</p>

<pre><code>// 1
let locationManager = CLLocationManager()

override func viewDidLoad() {
  super.viewDidLoad()
  originalTopMargin = topMarginConstraint.constant
  // 2
  locationManager.delegate = self
  locationManager.requestWhenInUseAuthorization()
  // 3
  if CLLocationManager.locationServicesEnabled() {
    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
    locationManager.requestLocation()
  }
}
</code></pre>

<p>让我们说说每一步都做了什么:</p>

<ol>
<li>你定义了一个全局常量<code>locationManager</code></li>
<li>在<code>ViewDidLoad</code>中，设置location manager的代理，当用户打开App的时候，询问用户是否允许访问用户地理位置的权限，这个弹出框第一次将会显示，当用户做出响应之后，这个框就不会再出现了。</li>
<li>一旦用户定位服务开启，设置这个<code>CLLocationManager’s</code>的定位精度信息，请求当前坐标</li>
</ol>


<p>编译运行你的程序，你是否弹出了提示框让你授权地理定位信息呢？</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/reaction_faces___confused_by_awesomesauceuk-d4od42z.png" alt="1" /></p>

<p>这是因为你还有一件事情需要完成，那就是权限问题，你需要提供原因为你的请求。
打开<code>Supoorting Files&gt;info.plist</code>，按如下步骤进行设置:</p>

<ol>
<li>添加<code>NSLocationWhenInUseUsageDescription</code>作为<code>Key</code>在 Information Property List中</li>
<li>让这个<code>Type</code>为<code>String</code>类型</li>
<li>设置这个<code>Value</code>值去向用户展示，解释为什么你需要访问他们的地理信息：“请运行我们访问你的当前坐标信息，这样我们就能自动填充你的开始和结束地点了”</li>
</ol>


<blockquote><p><code>注意:</code>
<em>.requestWhenInUseAuthorization()</em> 让这个app访问当前的用户地理信息，当这个App是在使用的时候</p>

<p>*.requestAlwaysAuthorization() * 当这个app不管是在前台还是后台的时候.这个app都能访问用户的地理信息，</p></blockquote>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/plist.png" alt="1" /></p>

<p>编译运行你的app,这次提示框将会显示:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/LocationAuthorization.png" alt="1" /></p>

<p>点击<code>Allow</code>,这个location Manager现在将会访问到你的地理坐标</p>

<p>下一步，你将要创建<code>CLGeocoder</code>去解码当前的坐标信息。解码过程就是把获取到的地理坐标，比如经纬度，转换成我们能看的懂得地理位置信息，比如长江道第三大街33号</p>

<p>在<code>ViewConroller.swift</code>的底部，添加如下代码，<code>locationManager(_:didUpdateLocations:locations:):</code></p>

<pre><code>CLGeocoder().reverseGeocodeLocation(locations.last!,
  completionHandler: {(placemarks:[CLPlacemark]?, error:NSError?) -&gt; Void in
  if let placemarks = placemarks {
    let placemark = placemarks[0]
  }
})
</code></pre>

<p><code>reverseGeocodeLocation(_:completionHandler:)</code>将会返回一组<code>placemarks</code>，对于多数的<code>geocoding</code>结果来说，这个数组仅仅是包含一个元素;很少的情况，一个单独的地点能返回多个地理位置附近的信息。在这个例子中，我们获取第一个placemark,即：placemarks[0],将会满足需求。</p>

<p>你可以可以停止更新坐标信息，当你发现了一个适当的placemark的时候。</p>

<p>现在你通过用户的地理位置已经找到对应地理坐标的<code>CLPlacemark</code>，你需要去联想其它跟他相关的地理数据信息，通过用户输入的文本框中的位置。为了实现这个，当用户输入一个单独的值的时候，通过swift的元组结构值去匹配多个值。</p>

<p>在<code>ViewDidLoad</code>中，添加下面的全局变量去匹配每个<code>UITextField</code>响应的<code>MKMapItem</code>：</p>

<pre><code>var locationTuples: [(textField: UITextField!, mapItem: MKMapItem?)]!
</code></pre>

<p>对用户的坐标信息，你将要存储<code>MKMapItems</code>而不是<code>CLPlacemarks</code>，这个类型你最终将会用在初始化<code>MKDirectionsRequest</code>上，用来计算路径规划。</p>

<p>在<code>ViewDidLoad</code>中，添加如下:</p>

<pre><code>locationTuples = [(sourceField, nil), (destinationField1, nil), (destinationField2, nil)]
</code></pre>

<p>这里，你定义了一个数组，里面包含了元组,每个元组都包含了一个文本框和一个为空的 MKMapItem的值，这个值最终会被和文本框绑定到一起。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/happy-thumbs-up.png" alt="1" /></p>

<p>在<code>locationManager(_:didUpdateLocations:location:)</code>方法中，添加如下代码片段，在<code>reverseGeocodeLocation(_:completionHandler:)</code>的完成回调方法中:</p>

<pre><code>self.locationTuples[0].mapItem = MKMapItem(placemark:
  MKPlacemark(coordinate: placemark.location!.coordinate,
  addressDictionary: placemark.addressDictionary as! [String:AnyObject]?))
</code></pre>

<p>添加了一个<code>MKMapItem</code>代表用户当前的地理位置作为<code>locationTuples</code>的第一个元组对象。</p>

<p>下一步，在ViewController中添加下面的函数 ，去把location data中的地理信息提取出来</p>

<pre><code>func formatAddressFromPlacemark(placemark: CLPlacemark) -&gt; String {
  return (placemark.addressDictionary!["FormattedAddressLines"] as! 
    [String]).joinWithSeparator(", ")
}
</code></pre>

<p><code>formatAddressFromPlacemark(_:)</code>从<code>CLPlacemark's</code>地址字典中通过<code>FormattedAddressLines</code>key提取一组地址信息，然后每两个元素之间用逗号连接起来组成一个新的字符串。</p>

<p>滑动到<code>locationManager(_:didUpdateLocations:locations:)</code>方法，在self.locationTuples[0].mapItem初始化后添加如下代码:</p>

<pre><code>self.sourceField.text = self.formatAddressFromPlacemark(placemark)
</code></pre>

<p>这将设置UItextField为一个新地址。</p>

<pre><code>self.enterButtonArray.filter{$0.tag == 1}.first!.selected = true
</code></pre>

<p>在开始工程中，按钮的选择文本是提前设置好的，按钮的tag是按照顺序设置的，每个<code>Enter</code>按钮都和页面<code>enterButtonArray</code>建立了连接关系，上面的代码找到 tag=1的 <code>Enter</code>按钮，并且每个UItextField也是按照顺序设置的tag，和按钮是一一对应的。</p>

<p>所以按钮的状态为选中时的文本会变为<code>✓</code>。</p>

<p>编译运行你的APP，假如当前坐标是:Apple HQ,你的文本框中的文本将会是:<code>Apple Inc., 2 Infinite Loop, Cupertino, CA 95014-2083, United States</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Apple_source.png" alt="1" /></p>

<p>在模拟器中，修改当前的坐标 <code>select Debug &gt; Location &gt; Custom location…:</code>
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Menu_bar-700x374.png" alt="1" /></p>

<p>输入坐标信息:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/CustomLocation-e1437159760381.png" alt="1" /></p>

<p><code>Latitude: 29.049186, Longitude: -95.45384</code></p>

<p>编译运行程序，这个文本框中将会显示:<code>05 Any Way St, Lake Jackson, TX, 77566-4198, United States
</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Any_Way_source.png" alt="1" /></p>

<p>下一步，你需要用户正确的输入地址，然后通过文本框中的值获取关联的地理位置信息，通过创建<code>MKMapItems</code>来获取。</p>

<h2>用户调用CoreLoaction过程</h2>

<p>在<code>ViewController.swift</code>中，更新<code>addressEntered(_:)</code>代码:</p>

<pre><code>@IBAction func addressEntered(sender: UIButton) {
  view.endEditing(true)
  // 1
  let currentTextField = locationTuples[sender.tag-1].textField
  // 2
  CLGeocoder().geocodeAddressString(currentTextField.text!,
    completionHandler: {(placemarks: [CLPlacemark]?, error: NSError?) -&gt; Void in
    if let placemarks = placemarks {

    } else {

    }
  })
}
</code></pre>

<p>你添加的代码做的工作如下:</p>

<ol>
<li>在interface builder中，每个<code>Enter</code>按钮都有一个tag,从上到下依次为1,2,3.你可以通过sender.tag来找到是那个text field.(UItextField的tag和Enter按钮的tag是一一对应的)</li>
<li>通过<code>CLGeocoder's geocodeAddressString(_:completionHandler:).</code>去解码地理坐标</li>
</ol>


<p>不像<code>reverseGeocodeLocation(_:completionHandler:), geocodeAddressString(_:completionHandler:)</code>，经常会返回多个<code>CLPlacemark</code>信息，在文本中输入的值经常不是仅仅匹配一个值。幸运的是，我们创建一个Tableview来显示多个数据信息，当用户选择了一项之后我们就会返回一个<code>CLPlacemarks</code></p>

<p>看一下<code>AddressTableView.swift.</code>这个类，你应该很清楚<code>tableView(_:numberOfRowsInSection:)</code>和<code>tableView(_:cellForRowAtIndexPath:),</code>代理方法的作用，你将要使用在顶部定义的全局变量<code>address</code>数组去填充这个tableview.</p>

<p>在<code>ViewController</code>中添加如下的函数:</p>

<pre><code>func showAddressTable(addresses: [String]) {
  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds,
    style: UITableViewStyle.Plain)
  addressTableView.addresses = addresses
  addressTableView.delegate = addressTableView
  addressTableView.dataSource = addressTableView
  view.addSubview(addressTableView)
}
</code></pre>

<p>通过方法<code>geocodeAddressString(_:completionHandler:).</code>返回一组<code>CLPlacemarks</code>数据。这里你创建一个AddressTable，并且设置了数据源<code>addresses</code>数组，数组中包含的元素就是<code>CLPlacemarks</code></p>

<p>回到<code>addressEntered(_:)</code>方法中，在<code>if let placemarks = placemarks</code>回调函数<code>geocodeAddressString(_:completionHandler:)‘s</code>中，添加如下代码:</p>

<pre><code>var addresses = [String]()
for placemark in placemarks {
  addresses.append(self.formatAddressFromPlacemark(placemark))
}
self.showAddressTable(addresses)
</code></pre>

<p>你看到了属性<code>placemarks</code>，遍历访问并且把地址追加到Addresses数组中。最后把<code>addresses</code>作为参数传递给<code>self.showAddressTable</code></p>

<p>当在第一屏幕的文本框中输入地址，并且点击<code>Enter</code>按钮，就会跳转到一个页面，让你选择具体是那个地址:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/OysterCreekTable.png" alt="1" /></p>

<p>当你选择了其中了一个地址之后，会发生什么呢？这个table将会消失。好了，让我去实现它</p>

<p>当你选择另一个地址之后，你想要自动的设置选择的文本去填充第一屏幕中的文本框中的值，更新查询到的locations数组，并且设置相关的<code>MKMapItem</code>,并且设置<code>Enter</code>按钮的选中状态。</p>

<p>更新<code>showAddressTable(_:)</code>方法在<code>ViewController.swift</code>中:</p>

<pre><code>func showAddressTable(addresses: [String], textField: UITextField,
  placemarks: [CLPlacemark], sender: UIButton) {

  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds, style: UITableViewStyle.Plain)
  addressTableView.addresses = addresses
  addressTableView.currentTextField = textField
  addressTableView.placemarkArray = placemarks
  addressTableView.mainViewController = self
  addressTableView.sender = sender
  addressTableView.delegate = addressTableView
  addressTableView.dataSource = addressTableView
  view.addSubview(addressTableView)
}
</code></pre>

<p>这里，你通过当前的文本框字段，数组placemarks,和当前的<code>ViewController.swift</code>的实例 创建一个AddressTableView。</p>

<p>在<code>geocodeAddressString(_:completionHandler:)</code>方法中，更新<code>showAddressTable(_:)</code>的参数:</p>

<pre><code>self.showAddressTable(addresses, textField: currentTextField,
    placemarks: placemarks, sender: sender)
</code></pre>

<p>在查询不到地址的情况下，应该马上弹出提示框:</p>

<pre><code>
self.showAlert("Address not found.")
</code></pre>

<p>如果<code>geocodeAddressString(_:completionHandler:)</code>没有返回任何placemarks,你应该显示一个error:</p>

<p>下一步，在表格的点击方法<code>tableView(_:didSelectRowAtIndexPath:)</code>中，加入代码:</p>

<pre><code>// 1
if addresses.count &gt; indexPath.row {
  // 2
  currentTextField.text = addresses[indexPath.row]
  // 3
  let mapItem = MKMapItem(placemark:
    MKPlacemark(coordinate: placemarkArray[indexPath.row].location!.coordinate,
    addressDictionary: placemarkArray[indexPath.row].addressDictionary
    as! [String:AnyObject]?))
  mainViewController.locationTuples[currentTextField.tag-1].mapItem = mapItem
  // 4
  sender.selected = true
}
</code></pre>

<p>下面解释代码的意思:</p>

<ol>
<li>当addresses的数量是大于当前行的索引的时候,表格的最后一行将会显示:<code>None of the above</code></li>
<li>更新当前的文本框中的值为选择的地址</li>
<li>使用placemark去创建创建<code>MKMapItem</code>，placemark是通过获取当前行创建的。根据当前文本框的tag获取<code>mainViewController's locationTuples</code>中的mapitem,并且设置它</li>
<li>设置当前<code>Enter</code>为选中状态</li>
</ol>


<p>编译运行，在<code>Stop#1</code>中输入地址，点击<code>Enter</code>，然后选择正确的地址，这个文本框中的值，地址元组(location tuple arra)，还有<code>Enter</code>按钮将会自动更新:
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Two_entries.png" alt="1" /></p>

<p><em>Addresses updated. (Checkmarks et al.)</em></p>

<p>在<code>ViewController.swift</code>中你还有一部分工作需要完成。</p>

<p>更新代码在<code>textField(_:shouldChangeCharactersInRange:replacementString:):</code></p>

<pre><code>func textField(textField: UITextField,
  shouldChangeCharactersInRange range: NSRange,
  replacementString string: String) -&gt; Bool {

  enterButtonArray.filter{$0.tag == textField.tag}.first!.selected = false
  locationTuples[textField.tag-1].mapItem = nil
  return true
}
</code></pre>

<p>当用户编辑了文本框，你将要设置MKMapItem失效，因为MKMapItem是不再需要，这样用户就可以重新选择正确的地址。</p>

<p>下一步，更新<code>swapFields(_:)</code>方法:</p>

<pre><code>
swap(&amp;destinationField1.text, &amp;destinationField2.text)
    swap(&amp;locationTuples[1].mapItem, &amp;locationTuples[2].mapItem)
    swap(&amp;self.enterButtonArray.filter{$0.tag == 2}.first!.isSelected, &amp;self.enterButtonArray.filter{$0.tag == 3}.first!.isSelected)
</code></pre>

<p>当用户点击<code>↑↓</code>，你需要交换两个文本框的值，还有在数组<code>locationTuples</code>对应的MKMapItems</p>

<p>在<code>ViewController</code>类中，找到<code>getDirections(_:)</code>方法，覆盖<code>shouldPerformSegueWithIdentifier(_:sender:)</code>：</p>

<pre><code>override func shouldPerformSegueWithIdentifier(identifier: String, sender: AnyObject?) -&gt; Bool {
  if locationTuples[0].mapItem == nil ||
    (locationTuples[1].mapItem == nil &amp;&amp; locationTuples[2].mapItem == nil) {
    showAlert("Please enter a valid starting point and at least one destination.")
    return false
  } else {
    return true
  }
}
</code></pre>

<p>在<code>ViewDidload:</code>中对<code>locationsArray</code>进行设置，它是一个只读的属性，当你访问它的时候，它会从<code>locationTuples</code>中过滤<code>mapItem</code>不为nil的元素.</p>

<pre><code>var locationsArray: [(textField: UITextField!, mapItem: MKMapItem?)] {
  var filtered = locationTuples.filter({ $0.mapItem != nil })
  filtered += [filtered.first!]
  return filtered
}
</code></pre>

<p><code>filtered += [filtered.first!]</code>拷贝元组中的第一个元素的值作为这个数组的最后一个元素。</p>

<p>在<code>prepareForSegue(_:sender:):</code>中:</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
  var directionsViewController = segue.destinationViewController as! DirectionsViewController
  directionsViewController.locationArray = locationsArray
}
</code></pre>

<p>这个传递的参数<code>locationsArray</code>将会在下一个View controller中用到</p>

<p>现在切换到<code>DirectionsViewController.swift</code>，去开始路径规划吧.</p>

<h2>在MapKit中进行路径规划</h2>

<p>现在，你已经知道了addresses,你将要创建一个<code>MKDirections</code>对象，调用<code>calculateDirectionsWithCompletionHandler(_:)</code>设置开始坐标和结束坐标就可以开始路径规划了.</p>

<p>在DirectionsViewController中添加如下代码:</p>

<pre><code>func calculateSegmentDirections(index: Int) {
  // 1
  let request: MKDirectionsRequest = MKDirectionsRequest()
  request.source = locationArray[index].mapItem
  request.destination = locationArray[index+1].mapItem
  // 2
  request.requestsAlternateRoutes = true
  // 3
  request.transportType = .Automobile
  // 4
  let directions = MKDirections(request: request)
  directions.calculateDirectionsWithCompletionHandler ({
    (response: MKDirectionsResponse?, error: NSError?) in
    if let routeResponse = response?.routes {

    } else if let _ = error {

    }
  })
}
</code></pre>

<p>上面的代码做的工作如下:</p>

<ol>
<li>创建一个<code>MKDirectionsRequest</code>，通过索引获取<code>locationArray</code>对应的mapItem,设置MKDirectionsRequest的开始坐标为这个mapitem,设置索引的下一个(index+1)为这个请求的目的地坐标</li>
<li>设置<code>requestsAlternateRoutes</code>为true,请求从源目标到目的地所有可能的路径</li>
<li>设置交通方式为 汽车驾驶,其它几个可能的方式为:步行，所有,公交车等</li>
<li>通过<code>MKDirectionsRequest</code>初始化<code>MKDirections</code>，然后调用<code>calculateDirectionsWithCompletionHandler</code>获取到一个<code>MKDirectionsResponse</code>，这会包含一组<code>MKRoutes</code>数据</li>
</ol>


<p>如果<code>calculateDirectionsWithCompletionHandler(_:)</code>没有返回任何routes,而是返回一个错误，那么<code>else if let _ = error</code>代码将会执行，添加这个代码:</p>

<pre><code>let alert = UIAlertController(title: nil,
  message: "Directions not available.", preferredStyle: .Alert)
let okButton = UIAlertAction(title: "OK",
  style: .Cancel) { (alert) -&gt; Void in
  self.navigationController?.popViewControllerAnimated(true)
}
alert.addAction(okButton)
self.presentViewController(alert, animated: true,
  completion: nil)
</code></pre>

<p>假设<code>MKRoutes</code>是找到了，在第一个<code>if let</code>声明中<code>calculateDirectionsWithCompletionHandler(_:)</code>将会执行，添加如下代码:</p>

<pre><code>
let quickestRouteForSegment: MKRoute =
  routeResponse.sort({$0.expectedTravelTime &lt;
  $1.expectedTravelTime})[0]
</code></pre>

<p>这里你按照 到达的时间 进行排序，用时最短的时间将会排在第一个，这对你的路线规划来说是有好处的。
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/troll-troll-dad-dance-jump.png" alt="2" /></p>

<p>但是，你仍然需要计算多个路径在每两个地点之间。</p>

<p>首先，更新<code>calculateSegmentDirections(_:)</code>参数:</p>

<pre><code>func calculateSegmentDirections(index: Int,
  time: NSTimeInterval, routes: [MKRoute]) {
</code></pre>

<p><code>calculateSegmentDirections(_:time:routes:)</code>现在接受一个数组和一个 NSTimeInterval 参数</p>

<pre><code>
// 1
var timeVar = time
var routeVar = routes
//2
routesVar.append(quickestRouteForSegment)
// 3
timeVar += quickestRouteForSegment.expectedTravelTime
// 4
if index+2 &lt; self.locationArray.count {
  self.calculateSegmentDirections(index+1, time: timeVar, routes: routesVar)
} else {

}
</code></pre>

<ol>
<li>创建两个变量，一个是timeVar,一个是routeVar</li>
<li>为当前的分段路线routesVar添加最快的路径规划</li>
<li>在timeVar中添加路径规划的预计到达时间</li>
<li>当你当前的索引加上最后两个值后没有超过<code>location array</code>数量值，递归调用自身方法<code>calculateSegmentDirections(_:time:routes:)</code>，传递索引+1,当前的time和路径values.</li>
</ol>


<p>现在回到<code>viewDidLoad</code>中，添加如下代码：</p>

<pre><code>addActivityIndicator()
calculateSegmentDirections(0, time: 0, routes: [])
</code></pre>

<p>这个代码添加一个转子activity indicator,当路径规划开始计算的时候，然后调用<code>calculateSegmentDirections(_:time:routes:)</code>去计算路径，从locationArray第一个索引开始，初始化时间为0,初始化一个空的路径数组</p>

<p>然后回到<code>calculateDirectionsWithCompletionHandler(_:)</code>中，在<code>else</code>的回调函数判断中，在<code>if index+2 &lt; self.locationArray.count</code>的下面添加:</p>

<pre><code>self.hideActivityIndicator()
</code></pre>

<p>当计算完所有的路径规划后，隐藏转子</p>

<h2>在MKMapIVew中添加MKRoutes</h2>

<p>为了去规划每一个<code>MKMapView</code>在MKMapView中，你需要在<code>DirectionsViewController</code>添加如下方法:</p>

<pre><code>func plotPolyline(route: MKRoute) {
  // 1
  mapView.addOverlay(route.polyline)
  // 2
  if mapView.overlays.count == 1 {
    mapView.setVisibleMapRect(route.polyline.boundingMapRect,
      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
      animated: false)
  }
  // 3
  else {
    let polylineBoundingRect =  MKMapRectUnion(mapView.visibleMapRect,
      route.polyline.boundingMapRect)
    mapView.setVisibleMapRect(polylineBoundingRect,
      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
      animated: false)
  }
}
</code></pre>

<p><code>plotPolyline(_:)</code>做的工作如下:</p>

<ol>
<li>添加<code>MKRoute</code>到地图上，作为一个覆盖层</li>
<li>如果规划的路径仅仅是一个覆盖层，设置地图的可见区域足够大足以填充整个覆盖层，外边缘留出10个点的间距</li>
<li>如果规划的路径不是一个，设置地图的可见区域为新的和旧的的区域的联合，外边缘留出10个点的间距</li>
</ol>


<p>下一步，更新<code>mapView(_:rendererForOverlay:)</code>方法</p>

<pre><code>func mapView(mapView: MKMapView,
  rendererForOverlay overlay: MKOverlay) -&gt; MKOverlayRenderer! {

  let polylineRenderer = MKPolylineRenderer(overlay: overlay)
  if (overlay is MKPolyline) {
    if mapView.overlays.count == 1 {
      polylineRenderer.strokeColor =
        UIColor.blueColor().colorWithAlphaComponent(0.75)
    } else if mapView.overlays.count == 2 {
      polylineRenderer.strokeColor =
        UIColor.greenColor().colorWithAlphaComponent(0.75)
    } else if mapView.overlays.count == 3 {
      polylineRenderer.strokeColor =
        UIColor.redColor().colorWithAlphaComponent(0.75)
    }
    polylineRenderer.lineWidth = 5
  }
  return polylineRenderer
}
</code></pre>

<p>给每一个路径路段设置不同的颜色</p>

<p>在<code>calculateSegmentDirections(_:time:routes:)</code>添加:</p>

<pre><code>func showRoute(routes: [MKRoute]) {
  for i in 0..&lt;routes.count {
    plotPolyline(routes[i])
  }
}
</code></pre>

<p>这个函数循环所有的<code>MKRoute</code>，添加覆盖层到地图上。</p>

<p>在方法<code>calculateDirectionsWithCompletionHandler(_:)</code>中，调用<code>showRoute(_:)</code>方法。在<code>else</code>block中你调用的<code>self.hideActivityIndicator():</code>的代码上面调用</p>

<pre><code>self.showRoute(routesVar)
</code></pre>

<p>编译运行，输入地址然后点击<code>Route it</code>,路线规划将要出现在地图上:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Map_Route.png" alt="1" /></p>

<p>下一步，你要打印路线的每一步路径信息到<code>DirectionsTable</code>上</p>

<h2>打印MKRoute的路径信息</h2>

<p><code>DirectionsTable.swift</code>包含一个全局的数组<code>directionsArray</code>,是一个包含元组的数组(string,string,MKRoute).这两个字符串是开始地址和结束地址，最后一个MKRoute，是路径的信息。</p>

<p>滑动页面到<code>UITableViewDataSource</code>的扩展方法中，在代理方法<code>numberOfSectionsInTableView(_:)</code>设置返回的数量，这个表格将要包含一个section为存储在<code>directionsArray</code>中每一个route。</p>

<p>这样你的<code>DirectionsTable</code>的每一个section就会为route呈现一个不同的分段.</p>

<p>代理方法<code>tableView(_:numberOfRowsInSection:)</code>将会返回<code>MKRouteSteps</code>的数量，比如:<code>directionsArray[section].route.</code></p>

<p>从开始地点到目的地一共有多少步.</p>

<p>在<code>tableView(_:cellForRowAtIndexPath:)</code>中，添加如下代码:</p>

<pre><code>// 1
let steps = directionsArray[indexPath.section].route.steps
// 2
let step = steps[indexPath.row]
// 3
let instructions = step.instructions
// 4
let distance = step.distance.miles()
// 5
cell.textLabel?.text = "\(indexPath.row+1). \(instructions) - \(distance) miles"
</code></pre>

<p>在每一行中，你打印<code>MKRouteStep</code>的说明信息和距离等:</p>

<ol>
<li>通过当前的section的值，得到<code>MKRoute</code>,然后通过<code>MKRoute</code>获取<code>MKRouteSteps</code>的数组</li>
<li>从steps的数组中，访问<code>MKRouteStep</code>的对象通过当前行。</li>
<li>获取step的说明信息</li>
<li>获取step的距离信息，在<code>CLLocationDistance</code>的扩展方法中，定义了一个miles()方法，通过这个方法把距离转为 米 单位 。</li>
<li>设置label显示出每一步的说明信息和距离</li>
</ol>


<p>现在，你可以使用<code>UITableViewDelegate</code>的扩展方法去显示开始地点和结束地点的信息。可以在每一个section中的header中显示开始地址，在footer中显示结束地点。</p>

<p>在<code>tableView(_:viewForHeaderInSection:)</code>添加如下代码:</p>

<pre><code>label.text = "SEGMENT #\(section+1)\n\nStarting point: \(directionsArray[section].startingAddress)\n"
</code></pre>

<p>这个头部view包含了开始地址:</p>

<p>在<code>tableView(_:viewForFooterInSection:)</code>中添加如下代码:</p>

<pre><code>// 1
let route = directionsArray[section].route
// 2
let time = route.expectedTravelTime.formatted()
// 3
let miles = route.distance.miles()
//4
label.text = "Ending point: \(directionsArray[section].endingAddress)\n\nDistance: \(miles) miles\n\nExpected Travel Time: \(time)"
</code></pre>

<ol>
<li>得到当前的section route</li>
<li>从NSTimeInterval的扩展中，通过<code>formatted()</code>格式化<code>expectedTravelTime</code>,<code>formatted()</code>方法通过<code>NSDateComponentsFormatter</code>吧<code>NSTimeInterval</code>转为<em>时分秒</em>的格式</li>
<li>通过<code>CLLocationDistance</code>格式化距离</li>
<li>让表格的label显示结束地址，距离和期望到达时间信息</li>
</ol>


<p>现在回到<code>DirectionsViewController</code>中，添加如下方法:</p>

<pre><code>func displayDirections(directionsArray: [(startingAddress: String, 
  endingAddress: String, route: MKRoute)]) {
  directionsTableView.directionsArray = directionsArray
  directionsTableView.delegate = directionsTableView
  directionsTableView.dataSource = directionsTableView
  directionsTableView.reloadData()
}
</code></pre>

<p>更新<code>showRoute(_:):</code>方法:</p>

<pre><code> func showRoute(routes: [MKRoute]) {
  var directionsArray = [(startingAddress: String, endingAddress: String, route: MKRoute)]()
  for i in 0..&lt;routes.count {
    plotPolyline(routes[i])
   let item = ((locationArray[i].textField?.text)!,
                        (locationArray[i+1].textField?.text)!, routes[i]) as TupleRouteItem
 //(startingAddress: String, endingAddress: String, route: MKRoute)
    directionsArray.append(item)
  }
  displayDirections(directionsArray)
}
</code></pre>

<p>对于每一个路径规划，你都添加了开始地址和结束地址，然后添加<code>MKRoute</code>到directionsArray数组中</p>

<p>下一步，你需要更新<code>totalTimeLabel</code>去显示总的期望达到时间。总的时间需要通过可变参数在<code>calculateSegmentDirections(_:time:routes:).</code>方法中计算出来。</p>

<p>所以更新<code>showRoute(_:)</code>方法，添加一个<code>NSTimeInterval</code>参数</p>

<pre><code>func showRoute(routes: [MKRoute], time: NSTimeInterval) {
</code></pre>

<p>在<code>DirectionsViewController</code>类中添加如下方法</p>

<pre><code>func printTimeToLabel(time: NSTimeInterval) {
  var timeString = time.formatted()
  totalTimeLabel.text = "Total Time: \(timeString)"
}
</code></pre>

<p>该方法在totalTimeLabel中显示出来总共时间</p>

<p>最后在函数的末尾，调用<code>printTimeToLabel(_:)</code></p>

<pre><code>printTimeToLabel(time)
</code></pre>

<p>编译运行:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Route_2.png" alt="1" /></p>

<h2>下载工程</h2>

<p><a href="">最终工程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用CoreLocation实现-地理围栏]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/19/yong-corelocationshi-xian-di-li-wei-lan/"/>
    <updated>2016-12-19T14:58:38+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/19/yong-corelocationshi-xian-di-li-wei-lan</id>
    <content type="html"><![CDATA[<p>地理围栏就是当你的手机设备进入或者离开某个区域的时候进行消息提醒,它会让你的程序变得更cool,设想一下，当你离开家，或者靠近一家你喜欢的商场附近时，能够及时给你发送最新的或者最优惠的信息。</p>

<!--more-->


<p>在这个教程中，你将会学会如何用region监听区域，这个工程是采用swift3语言实现的。</p>

<p>为了练习，你将要创建一个位置点去提醒app调用地理围栏进行提醒，假想它们就是现实世界中的位置坐标。好了，让我们开始吧。</p>

<h2>开始</h2>

<p>下载这个<a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Geotify-Starter-1.zip">开始工程</a>,这个工程提供了简单的在地图上添加/删除 地图注解(Annotation)的方法</p>

<p>编译运行程序，你将会看到一个空白的地图:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoInitial-281x500.png" alt="1" /></p>

<p>点击<code>+</code>按钮，去添加一个新的地理围栏，首先会打开一个新的页面，你可以设置你想要的位置坐标，点击<code>Add</code>就添加到了地图上，并且大头针显示</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLooking-Around-281x500.png" alt="2" /></p>

<p>这个<code>radius</code>代表指定地点的半径范围，单位是米
<code>note</code>在导航过程中，能够展示你想要展示的任何内容。</p>

<p>这个App也能够设置触发提醒方式，当用户进入或者离开某个区域的时候，进行提醒。</p>

<p>对radius设置1000，并且设置note为<code>Say Hi to Tim!</code>,选择触发类型为<code>Upon Entry</code>,然后点击<code>Add</code></p>

<p>然后你将要看到的地理围栏已经出来了一个新的大头针在地图上，下面还有一个圆形的渲染图层</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/Geo-Say-Hi-281x500.png" alt="2" /></p>

<p>点击这个大头针，将会显示详细信息，比如提示信息和半径大小，不要点击左边的删除按钮，因为点击之后这个地理围栏信息将会被删除掉从地图上和内存中</p>

<blockquote><p><em>注意:</em>
所有的地理围栏的信息都存储到了NSUserDefaults中</p></blockquote>

<h2>设置 Location Manager和权限</h2>

<p>你添加到地图上的地理围栏仅仅是能看的，但是不能进行消息提醒。</p>

<p>你将要修复这个通过core location来进行监听</p>

<p>打开<code>GeotificationsViewController.swift</code>，然后在类的顶部定义一个常量实例<code>CLLocationManager</code>:</p>

<pre><code>class GeotificationsViewController: UIViewController {

  @IBOutlet weak var mapView: MKMapView!

  var geotifications = [Geotification]()
  let locationManager = CLLocationManager() // Add this statement

  ...
}
</code></pre>

<p>下一步，替换<code>viewDidLoad()</code>中为下面的代码:</p>

<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  // 1
  locationManager.delegate = self
  // 2
  locationManager.requestAlwaysAuthorization()
  // 3
  loadAllGeotifications()
}
</code></pre>

<p>我们解析下代码:</p>

<ol>
<li>设置locationManager的代理，只有设置了代理，相关的代理方法才会被调用</li>
<li>你调用了<code>requestAlwaysAuthorization()</code>方法，它会调用一个提示，"Always"总是允许使用定位服务，因为App一直需要拥有<code>Always</code>权限去进行地理围栏的监听，直到这个app不在运行的时候，就不再需要这个权限了。在info.plist中已经设置了消息去告诉用户当请求定位信息时必须设置key:<code>NSLocationAlwaysUsageDescription</code></li>
<li>调用<code>loadAllGeotifications()</code>，转换存储在<code>NSUserDefaults</code>中的地理围栏的信息，然后加载它们，这个方法加载地图上所有的地理围栏和大头针的数据</li>
</ol>


<p>当app设置了用户权限之后，界面上将会显示<code>NSLocationAlwaysUsageDescription</code>提示，一个友好的提示为什么app需要请求用户的地理坐标。这个key是强制性假如你使用定位服务的话，如果这个key没有的话，系统将会忽略程序请求并且终止定位服务</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationWhenNotUsing-281x500.png" alt="2" /></p>

<p>OK，你已经设置好了app的请求权限，点击<code>Allow</code>去允许<code>location manager</code>在合适的时机调用代理方法</p>

<p>在你实现地理围栏的提醒之前，这里有个小的问题你必须解决：用户的当前坐标没有展示在地图上，这个特性是不能实现的，你必须手动的点击左上角的那个定位按钮，才能定位到当前用户的地理坐标。</p>

<p>幸运的是，修复这个是很容易的-在你允许了app获取权限之后，仅仅需要点下那个定位按钮</p>

<p>在<code>GeotificationsViewController.swift</code>，添加<code>CLLocationManagerDelegate</code>的扩展如下:</p>

<pre><code>extension GeotificationsViewController: CLLocationManagerDelegate {
  func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
    mapView.showsUserLocation = (status == .authorizedAlways)
  }
}
</code></pre>

<p>不管什么时候用户的权限状态改变的时候，location manager都会调用<code>locationManager(_:didChangeAuthorizationStatus:)</code>代理方法。假如用户授权app去使用当前定位服务，在你初始化好后locationManager,并且设置了代理之后，这个方法将会被调用</p>

<p>这个方法是个理想的地方去检查这个app是否被授权，如果是，你将能确保mapView展示当前用户的坐标</p>

<p>编译运行这个app,如果你用真机测试，你将会在mapView中看到当前的坐标；如果你运行在模拟器上，点击 <code>Debug\Location\Apple</code> 来查看地图上的标记</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationFar-281x500.png" alt="1" /></p>

<p>放大地方，你看到的将会是这样:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationZoomed-281x500.png" alt="1" /></p>

<h2>注册你自己的地理围栏</h2>

<p>当你的location manager配置好了之后，下一步就是允许你的app去注册一个地理围栏用来被监听</p>

<p>在你的app中，你的地理围栏的信息是被存储为<code>Geotification</code>模型，在你注册为被监听之前，core Location 请求每一个地理围栏去返回一个<code>CLCircularRegion</code>实例。为了去处理这个请求，你将要创建一个helper方法，然后从指定的<code>Geotification</code>对象中返回一个  <code>CLCircularRegion</code></p>

<p>打开<code>GeotificationsViewController.swift</code>，然后在主体代码中添加如下方法:</p>

<pre><code>func region(withGeotification geotification: Geotification) -&gt; CLCircularRegion {
  // 1
  let region = CLCircularRegion(center: geotification.coordinate, radius: geotification.radius, identifier: geotification.identifier)
  // 2
  region.notifyOnEntry = (geotification.eventType == .onEntry)
  region.notifyOnExit = !region.notifyOnEntry
  return region
}
</code></pre>

<p>上面的方法做的工作如下：</p>

<ol>
<li>你用地理围栏的坐标进行<code>CLCircularRegion</code>的初始化，这个地理围栏的半径和identifier允许ios去判断注册的地理围栏的距离，这个初始化是很简单的，<code>Geotification</code>模型已经包含了要请求的属性。</li>
<li><code>CLCircularRegion</code>实例也需要设置两个BOOL值得属性，<code>notifyOnEntry</code>和<code>notifyOnExit</code>,这是两个标识，当设备进入或者离开指定的地理围栏的时候，定义的地理围栏的回调事件将会被触发，你也可以为你的每个地理围栏设计去响应一个消息通知，你可以设置一个是true,另外一个是false,前提是你需要使用<code>Geotification</code>实体的枚举值</li>
</ol>


<p>下一步，当用户添加坐标的时候，你需要一个方法去开始监听这个地理围栏</p>

<p>添加下面的方法在<code>GeotificationsViewController</code>：</p>

<pre><code>func startMonitoring(geotification: Geotification) {
  // 1
  if !CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) {
    showAlert(withTitle:"Error", message: "Geofencing is not supported on this device!")
    return
  }
  // 2
  if CLLocationManager.authorizationStatus() != .authorizedAlways {
    showAlert(withTitle:"Warning", message: "Your geotification is saved but will only be activated once you grant Geotify permission to access the device location.")
  }
  // 3
  let region = self.region(withGeotification: geotification)
  // 4
  locationManager.startMonitoring(for: region)
}
</code></pre>

<p>让我们一步一步讲解上面的方法:</p>

<ol>
<li><code>isMonitoringAvailableForClass(_:)</code>方法决定我们的设备是否支持监听地理围栏，假如不能够监听，程序将会返回并且弹出一个提示框进行提醒。</li>
<li>下一步，你检查当前权限的状态，确保这个app已经被授权去请求用户的定位服务，加入这个app没有被授权，这个设备将不会接受到地理围栏的任何提示信息。然而，在这个案例中，你将要始终允许用户去保存地理围栏信息，因为当你的app没有权限的时候，core loaction会让你注册地理围栏。当用户权限给这个app的时候，监听这些地理围栏将会自动开启</li>
<li>在之前定义的方法中，你创建一个<code>CLCircularRegion</code>实例从指定的(geotification)中。</li>
<li>最后，你用Core Location注册监听<code>CLCircularRegion</code>实例</li>
</ol>


<p>当用户删除地理围栏的时候，你同样需要停止监听</p>

<p>在<code>GeotificationsViewController.swift</code>中，添加如下方法:</p>

<pre><code>func stopMonitoring(geotification: Geotification) {
  for region in locationManager.monitoredRegions {
    guard let circularRegion = region as? CLCircularRegion, circularRegion.identifier == geotification.identifier else { continue }
    locationManager.stopMonitoring(for: circularRegion)
  }
}
</code></pre>

<p>这个方法执行调用<code>locationManager</code>去停止监听<code>CLCircularRegion</code>通过<code>geotification</code>对象去判断</p>

<p>现在你已经完成了开始和停止的方法，当你不管什么时候添加和删除geotification,你将会调用到这两个方法</p>

<p>首先，在<code>GeotificationsViewController.swift</code>中找到<code>addGeotificationViewController(_:didAddCoordinate)</code>方法，这个方法是一个代理方法，在创建geotification的时候调用；</p>

<p>当创建一个新的新的<code>Geotification</code>通过 AddGeotificationsViewController，同时更新mapView和<code>geotifications</code>的集合，然后调用<code>saveAllGeotifications()</code>进行数据保存，最新的数据是被保存到<code>NSUserDefaults</code>中。</p>

<p>现在，替换为下面的代码:</p>

<pre><code>func addGeotificationViewController(controller: AddGeotificationViewController, didAddCoordinate coordinate: CLLocationCoordinate2D, radius: Double, identifier: String, note: String, eventType: EventType) {
  controller.dismiss(animated: true, completion: nil)
  // 1
  let clampedRadius = min(radius, locationManager.maximumRegionMonitoringDistance)
  let geotification = Geotification(coordinate: coordinate, radius: clampedRadius, identifier: identifier, note: note, eventType: eventType)
  add(geotification: geotification)
  // 2
  startMonitoring(geotification: geotification)
  saveAllGeotifications()
}
</code></pre>

<ol>
<li>你调用了location manager的<code>maximumRegionMonitoringDistance</code>属性和半径值进行比较，如果半径值超过了这个属性值，则获取该属性值，反之则取半径值，这是重要的一点，因为任何大于最大值的半径将会引发监听程序失败</li>
<li>用core location对新创建的geotification进行监听，通过调用<code>startMonitoringGeotification(_:)</code>方法，参数为<code>geofence</code></li>
</ol>


<p>通过这些代码，这个注册的App是有能力去进行监听，然而，有一个限制，作为地理围栏是和系统资源共享的，Core loaction要求每个设备最多只能注册20个地理围栏。</p>

<p>添加如下代码在<code>updateGeotificationsCount()</code>方法中:</p>

<pre><code>func updateGeotificationsCount() {
  title = "Geotifications (\(geotifications.count))"
  navigationItem.rightBarButtonItem?.isEnabled = (geotifications.count &lt; 20)  // Add this line
}
</code></pre>

<p>这行代码意义就是当数量达到限制数量值得时候，导航栏的<code>Add</code>按钮将会变成<code>不可用</code>状态</p>

<p>最后，让我们处理删除地理围栏的操作，这个函数是在<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>这个代理方法中进行处理的，当用户点击每一个annotationView的左边的<code>delete</code>按钮的时候，将调用删除地理围栏的处理函数</p>

<p>添加停止监听的方法在<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>代理方法调用的时候：</p>

<pre><code>func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
  // Delete geotification
  let geotification = view.annotation as! Geotification
  stopMonitoring(geotification: geotification)   // Add this statement
  removeGeotification(geotification)
  saveAllGeotifications()
}
</code></pre>

<p>添加声明去停止监听地理围栏通过传递<code>geotification</code>参数，在删除之前，请先改变<code>NSUserDefaults</code>中存储的值</p>

<p>通过这个方法，你的App可以停止监听地理围栏。</p>

<p>编译运行，你不会看到任何改变，但是这个App已经注册成了地理围栏的监听并且可以监听该区域，然而，它还不能响应任何的地理围栏的监听事件，不要着急-那就是你下一步需要做的事情.</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/These_eyes.png" alt="1" /></p>

<h2>响应地理围栏的事件</h2>

<p>你将要实现一些当发生错误时的代理方法，当发生错误的时候这些代理将会被调用.</p>

<p>在<code>GeotificationsViewController.swift</code>中，添加CLLocationManagerDelegate的代理方法：</p>

<pre><code>func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error) {
  print("Monitoring failed for region with identifier: \(region!.identifier)")
}

func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
  print("Location Manager failed with the following error: \(error)")
}
</code></pre>

<p>这些代理方法仅仅是打印一些日志信息，当location manager发生错误的时候</p>

<p>下一步，打开<code>AppDelegate.swif</code>，在这里你将要添加一些代理用来处理和响应当设备进入或者离开事件</p>

<p>首先你需要导入<code>Corelocation</code>框架</p>

<pre><code>import CoreLocation
</code></pre>

<p>确保在AppDelegate的顶端中有<code>CLLocationManager</code>的实例：</p>

<pre><code>class AppDelegate: UIResponder, UIApplicationDelegate {
  var window: UIWindow?

  let locationManager = CLLocationManager() // Add this statement
  ...
}
</code></pre>

<p>替换<code>application(_:didFinishLaunchingWithOptions:)</code>中的实现:
<code>
func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool {
  locationManager.delegate = self
  locationManager.requestAlwaysAuthorization()
  return true
}
</code></p>

<p>你设置你的AppDelegate去接收地理围栏的事件，你可能好奇，“为什么我要用AppDelegate去替换ViewController呢?”</p>

<p>注册了一个地理围栏随时都在监听，包括当这个App停止运行的时候。假如这个设备是在App停止运行的时候去触发，ios将会自动进入后台运行模式，这使得AppDelegate是一个理想的地方去处理这个事件，这个时候ViewController可能不会被加载。</p>

<p>现在你可能还会好奇，“新创建的<code>CLLocationManager</code>实例是如何知道去监听地理围栏的呢?”</p>

<p>你的app注册的地理围栏是很容易去监听的，所以不会担心你的locaion Manager是什么地方初始化的。</p>

<p>现在你只需要实现代理方法去响应地位围栏的事件信息，在你做这些之前，你将要创建一个方法去处理地理围栏的事件。</p>

<p>添加下面的方法在AppDelegate.swift中</p>

<pre><code>func handleEvent(forRegion region: CLRegion!) {
  print("Geofence triggered!")
}
</code></pre>

<p>在这个方法中，传递一个CLRegion参数，并且打印一个日志声明，稍后你将会实现这个事件处理。</p>

<p>下一步，在AppDelegate.swift的扩展中，添加下面的代理方法:</p>

<pre><code>extension AppDelegate: CLLocationManagerDelegate {

  func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
    if region is CLCircularRegion {
      handleEvent(forRegion: region)
    }
  }

  func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
    if region is CLCircularRegion {
      handleEvent(forRegion: region)
    }
  }
}
</code></pre>

<p>当你的设备进入<code>CLRegion</code>区域时，<code>locationManager(_:didEnterRegion:)</code>方法将会被调用，当你离开该区域时，<code>locationManager(_:didExitRegion:)</code>方法将会被调用</p>

<p>两个方法都会返回<code>CLRegion</code>，你需要去检查并且确保它是<code>CLCircularRegion</code>，因为返回有可能是<code>CLBeaconRegion</code>，假如你的App使用iBeacons来进行监听的。</p>

<p>假如你的region属于<code>CLCircularRegion</code>返回之内，你将会调用<code>handleRegionEvent(_:)</code></p>

<p>现在你的App是能收到地理围栏的事件了，你要准备去测试它的准备性，如果这个不足以让你兴奋，因为在这个教程的第一次测试，你想要看到一些结果;</p>

<p>测试你的App最精确的方式是用真机，添加一些地理围栏并且进行走路或者驾驶汽车测试，然而，现在做这些有些不明智，因为你不能去验证打印的日志信息当用真机改变了地理位置之后，另外，在你提交一个大头针之前，它不能很好的保证App的工作。</p>

<p>幸运的是，这里有一个更容易的方式去做这个，你不用离开你舒适的家。</p>

<p>Xcode允许你包含一个WayPoint文件在你工程中，你能用Monique去测试地点位置。很幸运吧，你在你工程中导入这个文件即可。</p>

<p>打开<code>TestLocations.gpx</code>这个文件，检查下这个内容：</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;gpx version="1.1" creator="Xcode"&gt;
  &lt;wpt lat="37.422" lon="-122.084058"&gt;
    &lt;name&gt;Google&lt;/name&gt;
  &lt;/wpt&gt;
  &lt;wpt lat="37.3270145" lon="-122.0310273"&gt;
    &lt;name&gt;Apple&lt;/name&gt;
  &lt;/wpt&gt;
&lt;/gpx&gt;
</code></pre>

<p>这个GPX文件一个XML格式的，包含两个waypoints:<code>Google’s Googleplex in Mountain View and Apple’s Headquarters in Cupertino.</code></p>

<p>用模拟器运行工程，当App加载这Main View Controller时，回到Xcode,在Debug bar中选中Locationt图标，选择<code>TestLocations</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-02-02-at-9.04.37-pm.png" alt="2" /></p>

<p>回到App中，点击导航栏上的左上角的Zoom按钮，定位当前位置，一旦你放大这个区域，你将会看到定位点在Google 像素点和 Apple像素点 来回移动。</p>

<p>添加两个地理围栏去测试这个App,Apple坐标和Google坐标，（如果之前你添加过其他的地理围栏，请先删除之前的，再开始）</p>

<p>为了测试这些地点，添加具体细节如下:</p>

<ul>
<li>Google:Radius: 1000m, Message: “Say Bye to Google!”, Notify on Exit</li>
<li>Apple:Radius: 1000m, Message: “Say Hi to Apple!”, Notify on Entry</li>
</ul>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/Geo2Fences-281x500.png" alt="1" /></p>

<p>一旦你添加了地理围栏信息，你将会看到每次当坐标点进入或者离开地理围栏的时候，控制台都会打印日志信息，如果你按下home键或者锁屏让App进入到后台，你将会看到日志信息每次都会打印，现在你可以很显然的验证之前的判断</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/GeofenceTriggered.png" alt="1" /></p>

<h2>用通知来响应地理围栏事件</h2>

<p>你已经有了很大的进步，当你的设备通过这个地理围栏的时候，你可以发送一个通知提示用户。准备好做下这个操作</p>

<p>为了获得通知消息，你可以通过触发<code>CLCircularRegion</code>来获得，你需要获取一个地理围栏信息从<code>NSUserDefaults</code>存储的数据中，在已经注册的地理围栏中，你可以用这个唯一的<code>identifier</code>去找到正确的<code>CLCircularRegion</code>。</p>

<p>在AppDelegate.swift中，添加下面的帮助方法：</p>

<pre><code>func note(fromRegionIdentifier identifier: String) -&gt; String? {
  let savedItems = UserDefaults.standard.array(forKey: PreferencesKeys.savedItems) as? [NSData]
  let geotifications = savedItems?.map { NSKeyedUnarchiver.unarchiveObject(with: $0 as Data) as? Geotification }
  let index = geotifications?.index { $0?.identifier == identifier }
  return index != nil ? geotifications?[index!]?.note : nil
}
</code></pre>

<p>这个方法会从持久化的内存中找到地理围栏的消息，仅仅靠<code>identifier</code>，就会返回地理围栏的消息</p>

<p>在<code>application(_:didFinishLaunchingWithOptions:)</code>添加如下方法，去注册一个通知:</p>

<pre><code>application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.sound, .alert, .badge], categories: nil))
UIApplication.shared.cancelAllLocalNotifications()
</code></pre>

<p>你添加的提示权限是为了确保这个App能否发送通知</p>

<p>现在，替换<code>handleRegionEvent(_:)</code>的内容:</p>

<pre><code>func handleEvent(forRegion region: CLRegion!) {
  // Show an alert if application is active
  if UIApplication.shared.applicationState == .active {
    guard let message = note(fromRegionIdentifier: region.identifier) else { return }
    window?.rootViewController?.showAlert(withTitle: nil, message: message)
  } else {
    // Otherwise present a local notification
    let notification = UILocalNotification()
    notification.alertBody = note(fromRegionIdentifier: region.identifier)
    notification.soundName = "Default"
    UIApplication.shared.presentLocalNotificationNow(notification)
  }
}
</code></pre>

<p>当这个App激活的时候，出现主界面的时候，将会弹出一个alert提示信息</p>

<p>编译运行工程，当坐标点经过你添加的地理围栏的时候，你的地理围栏事件将会被触发，将会受到一个提示信息，并且展示出来:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoSayByeToGoogle-281x500.png" alt="1" /></p>

<p>按一下home按钮，使得App进入后台模式，你依然能够通过地理围栏的事件信号定期收到通知信息</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/IMG_2239-281x500.png" alt="1" /></p>

<p> 现在，你已经有完整的功能，定位提示功能在你的App中，你可以添加其他的大头针，然后去到你添加坐标的地方测试~</p>

<h2>最终工程</h2>

<p>最后的工程你可以在这里<a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Geotify-Final-1.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MapKit教程:起步]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/15/mapkitjiao-cheng-qi-bu/"/>
    <updated>2016-12-15T15:02:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/15/mapkitjiao-cheng-qi-bu</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/maps/">MapKit</a>在ios开发中真的是很棒的API,它能很容易的展示地图和位置坐标，定位当前位置，可以路线规划甚至可以自定义覆盖物在地图上面</p>

<!--more-->


<p>在这个教程中，你将要创建一个app，在指定的地点能够放大缩小，并且可以设置大头针，支持点击操作，显示详情信息。</p>

<p>根据路线规划可以选择驾驶，步行等方式去往目的地。你的App将会解析json数据从服务器。</p>

<p>在这个过程中，你将会学会如何去添加一个MapKit在你的app中，放大或者缩小</p>

<h2>Getting Started</h2>

<p>在Xcode中新建一个工程，命名为: HonoluluArtMapDemo;</p>

<p>然后打开ViewController中，在顶部引入 地图框架
<code>import MapKit</code></p>

<p>然后手动创建一个mapView,代码如下:</p>

<pre><code> func initMap() -&gt; Void {
        mapView = MKMapView(frame: CGRect(x: 0, y: 0, width: screenWidth, height: screenHeight))
        self.view.addSubview(mapView)
    }
</code></pre>

<h2>设置可见区域</h2>

<p>在顶部设置一个可见区域
<code>
// set initial location in Honolulu
let initialLocation = CLLocation(latitude: 21.282778, longitude: -157.829444)
</code></p>

<p>你将要使用这个坐标去设置地图在地点Honolulu的位置。</p>

<p>当你尝试去告诉地图去显示什么的时候，你不能仅仅提供一个经度和纬度，对于定位中心点这个已经足够了，但是你还需要制定一个范围 region 去显示半径。</p>

<p>增加一个辅助方法:</p>

<pre><code>let regionRadius: CLLocationDistance = 1000
func centerMapOnLocation(location: CLLocation) {
  let coordinateRegion = MKCoordinateRegionMakeWithDistance(location.coordinate, 
    regionRadius * 2.0, regionRadius * 2.0)
  mapView.setRegion(coordinateRegion, animated: true)
}
</code></pre>

<p>在<code>ViewDidload</code>中，添加如下代码：</p>

<pre><code>initMap()
centerMapOnLocation(initialLocation)
</code></pre>

<h3>运行测试</h3>

<p>现在运行你的app,应该能看到一个地图，并且坐标是在 <code>Honolulu</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run2.png" alt="1" /></p>

<h2>获取Artworks Data</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/03/HonoluluArtResources.zip">HonoluluArtResources.zip</a>是服务器上的json文件，下载解压后有两个文件：Public.json和JSON.swift.你将会用JSON.swift去解析Public.json</p>

<p>把这两个文件拖拽到你的工程中，确保<code>Destination: Copy items if needed</code>并且<code>Add to targets: HonoluluArt</code>是选择状态。</p>

<h2>新建一个Artwork.swift 模型类</h2>

<pre><code>import UIKit
import MapKit

class Artwork: NSObject ,MKAnnotation {
    public var title: String?

    let locationName: String
    let discipline: String
    let coordinate: CLLocationCoordinate2D

    init(title: String, locationName: String, discipline: String, coordinate: CLLocationCoordinate2D) {
        self.title = title
        self.locationName = locationName
        self.discipline = discipline
        self.coordinate = coordinate

        super.init()
    }

    public var subtitle: String? {
        return locationName
    }
}
</code></pre>

<p>在这个模型类中，定义了标题和子标题，坐标和详细描述，并且实现了MKAnnotation协议。该协议中有两个属性必须实现:title 和 subtitle。</p>

<p>OK，这些属性title,locationName和coordinate属性将要被用于MKAnnotation上，但是<code>discipline</code>这个属性是做什么的呢？在这个教程中，你将会找到答案</p>

<p>接下来，在<code>ViewController</code>的 <code>ViewDiDload</code>方法中，加入如下代码:</p>

<pre><code>// show artwork on map
let artwork = Artwork(title: "King David Kalakaua",
  locationName: "Waikiki Gateway Park", 
  discipline: "Sculpture",
  coordinate: CLLocationCoordinate2D(latitude: 21.283921, longitude: -157.831661))

mapView.addAnnotation(artwork)
</code></pre>

<p>创建了一个Artwork的对象，作为一个annotation加入到mapView 中。这个mapView有 addAnnotaion方法。</p>

<p>OK，接下来你需要展示这个annotaion在map view中，为了实现这个，你必须实现MKMapViewDelegate协议 <code>MKPinAnnotationView</code>该协议负责显示大头针annotation的</p>

<p>代码如下：</p>

<pre><code>
import MapKit

extension ViewController: MKMapViewDelegate {

  // 1
  func mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! {
    if let annotation = annotation as? Artwork {
      let identifier = "pin"
      var view: MKPinAnnotationView
      if let dequeuedView = mapView.dequeueReusableAnnotationViewWithIdentifier(identifier)
        as? MKPinAnnotationView { // 2
        dequeuedView.annotation = annotation
        view = dequeuedView
      } else {
        // 3
        view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)
        view.canShowCallout = true
        view.calloutOffset = CGPoint(x: -5, y: 5)
        view.rightCalloutAccessoryView = UIButton.buttonWithType(.DetailDisclosure) as! UIView
      }
      return view
    }
    return nil
  }
}
</code></pre>

<p>这些代码并不复杂</p>

<ol>
<li><code>mapView(_:viewForAnnotation:)</code>是一个方法，每一个annotation都会调用去添加到mapView中，就像tableview中的<code>(_:cellForRowAtIndexPath:)</code>，每次都会返回一个View为每一个annotation</li>
<li>和<code>tableview</code>的'tableView(_:cellForRowAtIndexPath:)&lsquo;方法类似，当一些区域滑出屏幕外面的时候，map View也会返回一些重用的annotation View 的视图，所以这个代码第一次检查reusable annotation 是否存在，如果不存在，创建一个新的</li>
<li>如果<code>MKAnnotationView</code>可以从缓存池子中获取到，则用Artwork的title和subtitle属性去设置它，并且决定显示callout，可以支持点击的功能-当点击这个pin大头针的时候会出现一个气泡效果</li>
</ol>


<p>当然，你同样要设置</p>

<pre><code>mapView.delegate = self
</code></pre>

<p>这样代理方法才会被调用到。</p>

<p>好了，运行程序：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run32-174x320.png" alt="2" /></p>

<p><code>mapView(_:viewForAnnotation:)</code>方法中，在弹出的气泡中，右边有一个详情按钮，可以设置点击它的处理事件，你可以弹出一个alert框，或者调到一个详情页面，
在这个教程中：当用户点击了这个按钮之后，我们弹出Maps的app,完成驾车/步行 等导航路线的功能，这很酷的!</p>

<h2>加载Maps App</h2>

<p>为了提高用户体验，打开<code>Artwork.swift</code>，并且添加如下代码，导入 AddressBook(地址薄)框架</p>

<pre><code>import AddressBook
</code></pre>

<p>这里添加了一个<code>AddressBook</code>框架，你可能会问，这个地址簿框架是做什么的，和Map有什么关系呢？well,它包含了一些字典的键，比如<code>kABPersonAddressStreetKey</code>,当你设置一些地址或者城市或者州 的地址坐标时会用到它。</p>

<p>下一步，添加下面的帮助方法:</p>

<pre><code>// annotation callout info button opens this mapItem in Maps app
func mapItem() -&gt; MKMapItem {
  let addressDictionary = [String(kABPersonAddressStreetKey): subtitle]
  let placemark = MKPlacemark(coordinate: coordinate, addressDictionary: addressDictionary)

  let mapItem = MKMapItem(placemark: placemark)
  mapItem.name = title

  return mapItem
}
</code></pre>

<p>这里你从一个<code>MKPlacemark</code>中创建了一个<code>MKMapItem</code>，这个Maps app是可以从<code>MKMapItem</code>中获取到并且展示出来</p>

<p>下一步，你必须告诉MapKit当你点击 callout button 的时候，你要做什么</p>

<p>打开ViewController,添加<code>MKMapViewDelegate</code>的另外一个协议方法:<code>func mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!,
    calloutAccessoryControlTapped control: UIControl!)</code></p>

<pre><code> func mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, 
    calloutAccessoryControlTapped control: UIControl!) {
  let location = view.annotation as! Artwork
  let launchOptions = [MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving]
  location.mapItem().openInMapsWithLaunchOptions(launchOptions)
}
</code></pre>

<p>当用户点击地图上的大头针，弹出一个气泡视图，然后点击气泡视图上的info button,当用户点击这个info button的时候，<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>该代理方法被调用</p>

<p>在这个方法中，你获取到Artwork对象，然后通过创建一个关联的<code>MKMapItem</code>，然后调用mapItem的<code>openInMapsWithLaunchOptions</code>方法去加载一个 <code>Maps app</code></p>

<p>注意，你传递了一个字典给这个方法，这里允许你去指定几个不同的选项，这里的<code>DirectionModeKeys</code>设置成了<code>Driving</code>，这个就是显示的自驾模式，从你的当前定位地点到这个大头针的位置，当然，你可以设置其他的选项，比如walking,bus等模式。</p>

<p>我建议你通过传递在字典参数中传递其他几个不同的选项，看看展现的效果，你可以去查看<code>MKMapItem</code>类，这个类同事允许你传递多了可选项参数</p>

<p>在你运行程序之后，最后在xcode中设置一下你的坐标，打开<code>Product\Scheme\Edit Scheme</code>,然后选择<code>Run</code>,打开<code>Options</code>标签，选择<code>Core Location: Allow Location Simulation</code>,选择<code>Honolulu</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/12/defaultUserLocation-480x232.png" alt="1" /></p>

<p>好了，运行程序，你将会看到一个地图，点击地图上的大头针，然后点击info button,将会加载一个 Maps App</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run4b-174x320.png" alt="1" /></p>

<p>如果你也像我一样打开了地图，恭喜你！</p>

<h2>解析JSon数据并且转化成Artwork对象</h2>

<p>现在你知道如何在地图上展示artwork,怎嘛一股脑加载一个Maps app通过点击大头针的 callout info button,接下来我们介绍如何解析数据集。之后你可以从本地的地图区域中搜索数据。</p>

<p>首先，找到<code>JSON.swift</code>和文件：<code>PublicArt.json.</code>。<code>JSON.swift</code>包含了很好的解析json数据的API,提提供了对每个JSON value数据的转化。</p>

<p>把这两个文件拖入到工程中，在<code>Artwork.swift</code>添加如下方法:</p>

<pre><code>class func fromJSON(json: [JSONValue]) -&gt; Artwork? {
  // 1
  var title: String
  if let titleOrNil = json[16].string {
    title = titleOrNil
  } else {
    title = ""
  }
  let locationName = json[12].string
  let discipline = json[15].string

  // 2
  let latitude = (json[18].string! as NSString).doubleValue
  let longitude = (json[19].string! as NSString).doubleValue
  let coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)

  // 3
  return Artwork(title: title, locationName: locationName!, discipline: discipline!, coordinate: coordinate)
}
</code></pre>

<p>代码解析:</p>

<ol>
<li><code>fromJSON‘s</code>方法将会从一个数组中返回一个Artwork对象，如果你传递一个数组的元素，你将会看到title, locationName等字段，在这个方法中都有指定的索引来获取数据，这<code>title</code>对某些artwork来说又能是空的(nil).</li>
<li>转换经纬度为double</li>
<li>返回artwork对象</li>
</ol>


<p>返回的json数据大概是这样:</p>

<pre><code>[ 55, "8492E480-43E9-4683-927F-0E82F3E1A024", 55, 1340413921, "436621", 1340413921, "436621", "{\n}", "Sean Browne",
"Gift of the Oahu Kanyaku Imin Centennial Committee", "1989", "Large than life-size bronze figure of King David Kalakaua
mounted on a granite pedestal. Located at Waikiki Gateway Park.", "Waikiki Gateway Park", 
"http://hiculturearts.pastperfect-online.com/34250images/002/199103-3.JPG", "1991.03", "Sculpture", "King David 
Kalakaua", "Full", "21.283921", "-157.831661", [ null, "21.283921", "-157.831661", null, false ], null ]
</code></pre>

<p>在<code>ViewController.swift</code>中调用<code>fromJSON(_:)</code>方法，然后添加一个数组去存储从数据集中读到的json数据</p>

<pre><code>var artworks = [Artwork]()
</code></pre>

<p>然后，添加下面的help方法:</p>

<pre><code>func loadInitialData() {
  // 1
  let fileName = NSBundle.mainBundle().pathForResource("PublicArt", ofType: "json");
  var readError : NSError?
  var data: NSData = NSData(contentsOfFile: fileName!, options: NSDataReadingOptions(0),
    error: &amp;readError)!

  // 2
  var error: NSError?
  let jsonObject: AnyObject! = NSJSONSerialization.JSONObjectWithData(data, 
    options: NSJSONReadingOptions(0), error: &amp;error)

  // 3
  if let jsonObject = jsonObject as? [String: AnyObject] where error == nil,
  // 4
  let jsonData = JSONValue.fromObject(jsonObject)?["data"]?.array {
    for artworkJSON in jsonData {
      if let artworkJSON = artworkJSON.array,
      // 5
      artwork = Artwork.fromJSON(artworkJSON) {
        artworks.append(artwork)
      }
    }
  }
}
</code></pre>

<h2>标注Artworks</h2>

<p>现在你已经有了一组artwork的数据集，现在你需要把它们加入到地图上。</p>

<p>在<code>ViewDidLoad</code>方法中，创建<code>initialLocation</code>,然后设置map的中心点，调用<code>loadInitialData()</code>和<code>mapView.addAnnotations(artworks):</code></p>

<pre><code>loadInitialData()
mapView.addAnnotations(artworks)
</code></pre>

<p>删除之前创建的<code>King David Kalakaua</code>地图注解 数据的代码，你现在不需要它们了</p>

<pre><code>//    let artwork = Artwork(title: "King David Kalakaua", locationName: "Waikiki Gateway Park",
//      discipline: "Sculpture", coordinate: CLLocationCoordinate2D(latitude: 21.283921, longitude: -157.831661))
//    mapView.addAnnotation(artwork)
</code></pre>

<p>编译运行程序，你的app可以看到很多的大头针</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run5a1-174x320.png" alt="2" /></p>

<h2>为大头针设置不同的颜色</h2>

<p>还记的在artwork中的<code>discipline</code>属性吗？
它的值像<code>Sculpture, Plaque, Mural, Monument, other</code></p>

<p>在<code>Artwork.swift</code>中添加如下方法:</p>

<pre><code>// pinColor for disciplines: Sculpture, Plaque, Mural, Monument, other
func pinColor() -&gt; UIColor  {
        switch discipline {
        case "Sculpture", "Plaque":
            return UIColor.red
        case "Mural", "Monument":
            return UIColor.purple
        default:
            return UIColor.green
        }
    }
</code></pre>

<p>然后在ViewController中找到<code>mapView(_:viewForAnnotation:)</code>代码方法，设置pinColor属性:</p>

<pre><code>view.pinTintColor = annotation.pinColor()
</code></pre>

<h2>使用定位权限</h2>

<p>想要获取定位服务，首先要导入 <code>Corelocation</code>框架</p>

<p>在ViewController中加入下面代码:</p>

<pre><code>// MARK: - location manager to authorize user location for Maps app
var locationManager = CLLocationManager()
func checkLocationAuthorizationStatus() {
  if CLLocationManager.authorizationStatus() == .AuthorizedWhenInUse {
    mapView.showsUserLocation = true
  } else {
    locationManager.requestWhenInUseAuthorization()
  }
}

override func viewDidAppear(animated: Bool) {
  super.viewDidAppear(animated)
  checkLocationAuthorizationStatus()
}
</code></pre>

<h2>在info.plist中需要加入权限设置</h2>

<p>这里有几个权限设置你需要添加，你不加入的话，你的程序不会崩溃，但是你的locationManager’s的请求将会无效。为了让其工作良好，你必须添加<code>NSLocationWhenInUseUsageDescription</code>在你的app's的<code>Information Property Lis</code>,设置它的类型是string,值为一个消息，这个消息解释了为什么用户需要允许app访问他们的位置信息。</p>

<p>打开 <code>Info.plist</code>，点开左边的小三角
<img src="https://koenig-media.raywenderlich.com/uploads/2015/01/Infoplist-480x190.png" alt="1" /></p>

<p>最好再添加两个选线 Privacy 开头的和定位信息有关：
三个权限设置如下:</p>

<ol>
<li>Privacy - Location When In Use Usage Description</li>
<li>Privacy - Location Usage Description</li>
<li>Privacy - Location Always Usage Description</li>
</ol>


<h2>Final project</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/03/HonoluluArt-Swift3.zip">swift3版本的工程</a>下载</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift3-GCD]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/14/swift3-gcd/"/>
    <updated>2016-12-14T16:05:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/14/swift3-gcd</id>
    <content type="html"><![CDATA[<p>在swift3中，<a href="https://developer.apple.com/reference/dispatch">GCD</a>的语法已经全面修改，变得更加swift化了。</p>

<!--more-->


<h2>DispatchQueue</h2>

<p>首先，dispatch的全局函数不再为下划线风格的名称了，它变成了更符合Swift风格的DispatchQueue的样子</p>

<h3>main thread</h3>

<p>同样的，你不在需要去用<code>dispatch_get_main_queue()</code>来获取主线程，而是<code>DispatchQueue.main</code>，那么要放到主线程的代码怎么执行呢？只需要在后面使用<code>.async{}</code>即可：</p>

<pre><code>DispatchQueue.main.async { [weak self] in
      your code runs in main thread
}
</code></pre>

<h2>优先级</h2>

<p>我们知道，GCD的默认队列的优先级有四个:</p>

<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>


<p>现在swift3中正式更名为：</p>

<ul>
<li>.userInitialted</li>
<li>.default</li>
<li>.utility</li>
<li>.background</li>
</ul>


<p>当然，它们的对应关系也就是与顺序相同的:</p>

<pre><code> DISPATCH_QUEUE_PRIORITY_HIGH:         .userInitiated
 DISPATCH_QUEUE_PRIORITY_DEFAULT:      .default
 DISPATCH_QUEUE_PRIORITY_LOW:          .utility
 DISPATCH_QUEUE_PRIORITY_BACKGROUND:   .background
</code></pre>

<h2>获取一个队列</h2>

<p>我们使用<code>DispatchQueue.global()</code>获取一个系统的队列，这样的话获取的就是默认<code>.default</code>优先级的队列了，如果要获取其它优先级的队列，就使用<code>DispatchQueue.global(qos: .userInitiated)</code>,最后，我们使用<code>.async{}</code>来执行代码:</p>

<pre><code>DispatchQueue.global(qos: .userInitiated).async {
            //your code here
        }
</code></pre>

<h2>创建一个队列</h2>

<p>直接用<code>DispatchQueue</code>的初始化来创建一个队列，最简单的方法就是:</p>

<pre><code>let queue = DispatchQueue(label: "myBackgroundQueue")
</code></pre>

<p>复杂一点，你可以指定优先级以及队列类别:</p>

<pre><code>let queue = DispatchQueue(label: "myBackgroundQueue", qos: .userInitiated, attributes: .concurrent)
</code></pre>

<p>然后把代码放进去:</p>

<pre><code>queue.async {
    print("aaa")
}
</code></pre>

<h2>队列组</h2>

<p>对于组，现在你可以使用这样的语法直接创建一个组</p>

<pre><code>let group = DispatchGroup()
</code></pre>

<p>使用如下:</p>

<pre><code>let group = DispatchGroup()

let queue = DispatchQueue(label: "myBackgroundQueue")

queue.async(group:group) {
    print("background working")
}
</code></pre>

<p>那么，如果有多个并发队列在同一个组中，我们徐亚它们完成了再继续:</p>

<pre><code>group.wait()
</code></pre>

<h2>延迟执行</h2>

<pre><code>DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 3.0) {
    print("after!")
}
</code></pre>
]]></content>
  </entry>
  
</feed>
