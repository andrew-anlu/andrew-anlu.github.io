<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-11-04T21:51:06+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中常见的面试题二]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/"/>
    <updated>2016-11-04T20:22:42+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er</id>
    <content type="html"><![CDATA[<h2>如何进行真机调试</h2>

<ol>
<li>首先需要钥匙串创建一个钥匙(key)</li>
<li>将钥匙串上传到官网，获取ios Development证书</li>
<li>创建APP Id即我们应用程序中的BundleId</li>
<li>添加Device ID 即 UDID;</li>
<li>通过勾选前面所创建的证书：App ID, Deveice id</li>
<li>生成mobileProvision文件</li>
<li>先决条件：申请开发者账号 99美刀</li>
</ol>


<!--more-->


<h2>APP发布上架流程</h2>

<ol>
<li>登录苹果开发者网站</li>
<li>下载安装发布证书</li>
<li>选择发布证书，使用Archive编译发布包，用Xcode将代码上传到服务器</li>
<li>等待审核</li>
<li>生成ipa->菜单栏->Product->Archive</li>
</ol>


<h2>如何发送通知</h2>

<ul>
<li>一种是Apple自己提供的通知服务（APNS服务器），一种是用第三方推送机制</li>
<li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器请求deviceToken,并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用</li>
<li>推送信息内容，总容量不超过256个字节</li>
<li>iOSSDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示</li>
</ul>


<p>优点：不论应用是否开启，都会发送到手机端</p>

<p>缺点：消息推送机制是苹果服务器端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；</p>

<ul>
<li>第三方推送机制,普遍使用Socket机制来实现，几乎可以达到即时发送到目标用户手机端，适用于即时通讯类应用。</li>
</ul>


<p>优点：实时的，取决于心跳包的节凑</p>

<p>缺点：IOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用</p>

<h2>网络七层协议</h2>

<ul>
<li>应用层：

<ol>
<li>用户接口，应用程序</li>
<li>Application典型设备:网关；</li>
<li>典型协议，标准和应用：TELNET,FTP,HTTP</li>
</ol>
</li>
<li>表示层：

<ol>
<li>数据表示，压缩和加密presentation</li>
<li>典型设备:网关</li>
<li>典型协议，标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG</li>
<li>表示层相当于一个东西的表示，表示的一些协议，比如图片，声音和视频MPEG</li>
</ol>
</li>
<li>会话层：

<ol>
<li>会话的建立和结束；</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</li>
</ol>
</li>
<li>传输层：

<ol>
<li>主要功能：端到端控制Transport;</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：TCP，UDP，spx</li>
</ol>
</li>
<li>网络层：

<ol>
<li>主要功能：路由，寻址Network</li>
<li>典型设备:路由器</li>
<li>典型协议，标准和应用：IP,IPX,APPLETALK,ICMP</li>
</ol>
</li>
<li><p>数据链路层：</p>

<ol>
<li>主要功能：保证无差错的疏忽链路 data link;</li>
<li>典型设备：交换机，网桥，网卡</li>
<li>典型协议，标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li>
</ol>
</li>
<li>物理层：

<ol>
<li>主要功能：传输比特流Physical</li>
<li>典型设备：集线器，中继器</li>
<li>典型协议，标准和应用：V.35、EIA/TIA-232.</li>
</ol>
</li>
</ul>


<h2>对NSUserDefualts的理解</h2>

<ul>
<li>NSUserDefaults：系统提供的一种存储数据的方式，主要用户保存少量的数据，默认存储到library下的Preferences文件夹</li>
</ul>


<h2>LayoutSubViews在什么时候被调用</h2>

<p>当View本身的frame改变时，会调用这个方法</p>

<h2>单例模式理解与使用</h2>

<ul>
<li>单例模式是一种常用的设计模式，单利模式是一个类在系统中只有一个实例对象。通过全局的一个入口点对这个实例对象进行访问</li>
<li>iOS中单例模式的实现方式一般分为两种：非ARC和ARC+GCD</li>
</ul>


<h2>对沙盒的理解</h2>

<ul>
<li><p>每个ios应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，及时在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录，苹果对沙盒有几条限制：</p></li>
<li><p>应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序沙盒</p></li>
<li>应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中</li>
<li>苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；</li>
<li>沙盒目录里有三个文件夹：Documents——存储应用程序的数据文件，存储用户数据或其他定期备份的信息；Library下有两个文件夹，Caches存储应用程序再次启动所需的信息，
Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；
temp存放临时文件即应用程序再次启动不需要的文件</li>
</ul>


<h2>对瀑布流的理解</h2>

<ul>
<li>首先图片的宽度都是一样的

<ol>
<li>将图片等比例压缩，让图片不变形</li>
<li>计算图片最低应该摆放的位置，那一列低就放在哪</li>
<li>进行最优排列，在ScrollView的基础上添加两个tableView,然后将之前所计算的scrollView的高度通过tableView展示出来</li>
</ol>
</li>
<li>如何使用两个TableView产生联动：将两个TableView的滚动事件禁止掉，最外层的ScrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableview.</li>
</ul>


<h2>ViewController 的loadView,viewDidLoad,viewDidUnload 分别是在什么时候调用的？</h2>

<ul>
<li>viewDidLoad在View从nib文件初始化时调用，loadView在controller的View为nil时调用</li>
<li>此方法在编程实现view时调用，View控制器默认会注册memory warning notification,当view controller的任何View没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release，如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。</li>
</ul>


<h2>@synthesize、@dynamic的理解</h2>

<ul>
<li>@synthesize 是系统自动生成getter和setter属性声明；@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明</li>
<li>@dynamic是开发者自己提供相应的属性声明，@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter,对于读写属性需要提供setter和getter,查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。</li>
</ul>


<p>主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行动态生成子类属性</p>

<h2>Frame和bounds有什么不同？</h2>

<ul>
<li>frame指的是：该View在父view坐标系统中的位置和大小（参照点是父亲的坐标系统）</li>
<li>bounds指的是：该View在本身坐标系统中的位置和大小（参照点是本身坐标系统）</li>
</ul>


<h2>iOS中的响应者链的工作原理</h2>

<ul>
<li>每一个应用有一个响应者链，我们的视图结构是一个N叉树（一个视图可以有多个子视图，一个子视图同一时刻只有一个父亲视图），而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点</li>
<li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追溯出一条链，那么对于这个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶子节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发</li>
</ul>


<h2>Property属性的修饰符的作用</h2>

<ul>
<li>getter=getName、setter=setName：设置setter与getter的方法名；</li>
<li>readwrite,readonly:设置可供访问的级别</li>
<li>assign:方法直接赋值，不进行任何retain操作，为了解决原类型与循环引用问题</li>
<li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序</li>
<li>copy:其setter方法进行copy操作，与retain 处理流程一样，先对旧值release,再copy出新的对象，retaincount为1,这是为了减少对上下文的依赖而引入的机制</li>
<li>nonatomic:非原子性访问，不加同步，多线程并发访问会提供性能。注意，如果不加此属性，则默认是两个访问方法都是原子型事务访问</li>
</ul>


<h2>对Run Loop的理解</h2>

<ul>
<li>RUNLOOP，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程，主线程执行完即时任务时会继续等待接收事件而不退出，非主线程同城来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li>
<li>每一个线程都有其对应的RunLoop,只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动</li>
<li>在一个单独的线程中，如果需要在处理完某个人物后不退出，继续等待接收事件，则需要启用RunLoop</li>
<li>NSRunLoop提供了一个添加NStimer的方法，可以指定Mode,如果要让任何情况下都回调，则需要设置Mode为Common模式</li>
<li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载方式，如果我们没有东东调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop,也就不会去加载，更不会创建</li>
</ul>


<h2>XIB与Storyboards的优缺点</h2>

<p>优点:</p>

<ul>
<li><p>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类</p></li>
<li><p>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。</p></li>
</ul>


<p><em>缺点:</em></p>

<ul>
<li>XIB:需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li>
<li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li>
</ul>


<h2>队列和多线程的使用原理</h2>

<p>在iOS中队列分为以下几种：</p>

<ul>
<li>串行队列：队列中的任务只会顺序执行</li>
</ul>


<pre><code>dispatch_queue_t q = dispatch_queue_create("...", DISPATCH_QUEUE_SERIAL);
</code></pre>

<ul>
<li>并行队列：对垒中的任务通常会并发执行：</li>
</ul>


<pre><code>dispatch_queue_t q = dispatch_queue_create("......",DISPATCH_QUEUE_CONCURRENT);
</code></pre>

<ul>
<li>全局队列：是系统的，直接拿过来(get)用就可以，与并行队列类似：</li>
</ul>


<pre><code>dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre>

<ul>
<li>主队列：每一个应用程序对应唯一主队列，直接GET就行，在多线程开发中，使用祝队列更新UI：</li>
</ul>


<pre><code>dispatch_queue_t q = dispatch_get_main_queue();
</code></pre>

<p>如图：
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/1771779-da221054beb5cbb4.png" alt="1" />
 </p>

<h2>内存的使用和优化的注意事项</h2>

<ul>
<li>重用问题：如UITableViewCells,UICollectionViewCells, UITableViewHeaderFooterViews设置正确的reuseIdentifier,充分重用；</li>
<li>尽量把views设置为不透明，当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能</li>
<li>不要使用太复杂的XIB/StroyBoard;载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用，那些相比纯代码写的延迟加载，性能及内存就差了很多</li>
<li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出搞笑代码的基础，比如，数组：有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。存储键值对，用键来查找比较快。集合：无需的一组值，用值来查找很快，插入/删除很快；</li>
<li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li>
<li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载</li>
<li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储</li>
<li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉。重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建</li>
<li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li>
<li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li>
</ul>


<h2>UIViewController的完整生命周期</h2>

<pre><code>-[ViewController initWithNibName:bundle:]；
-[ViewController init]；
-[ViewController loadView]；
-[ViewController viewDidLoad]；
-[ViewController viewWillDisappear:]；
-[ViewController viewWillAppear:]；
-[ViewController viewDidAppear:]；
-[ViewController viewDidDisappear:]；
</code></pre>

<h2>UIImageView添加圆角</h2>

<pre><code>imgView.layer.cornerRadius = 10;// 这一行代码是很消耗性能的imgView.clipsToBounds = YES;
</code></pre>

<ul>
<li><em>这是离屏渲染（off-screen-rendering），消耗性能的</em></li>
<li>扩展:</li>
</ul>


<pre><code>- (UIImage *)imageWithCornerRadius:(CGFloat)radius {
CGRect rect = (CGRect){0.f, 0.f, self.size};

UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale);CGContextAddPath(UIGraphicsGetCurrentContext(),
 [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);CGContextClip(UIGraphicsGetCurrentContext());

[self drawInRect:rect];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return image;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中常见的面试题及答案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/"/>
    <updated>2016-11-03T17:50:01+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an</id>
    <content type="html"><![CDATA[<h2>ios中深拷贝和浅拷贝</h2>

<p>在ios开发中，经常涉及到深拷贝和浅拷贝的问题，针对深拷贝和浅拷贝，为了方便大家的理解，专门总结如下:</p>

<!--more-->


<ul>
<li>理解1</li>
</ul>


<p>浅拷贝是拷贝操作后，并没有进行真正的复制，而是另一个指针也指向了同一个地址。深拷贝，拷贝操作后，是真正的复制了一份，另一个指针指向了拷贝后的地址。如下图：A代表原有的指针，B代表拷贝的指针。（图一为浅拷贝，图二为深拷贝）</p>

<p><img src="http://img.blog.csdn.net/20141218004439540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="1" /></p>

<p><img src="http://img.blog.csdn.net/20141218004554327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="2" /></p>

<p>从上图中可以看到，浅拷贝（浅复制）中如果其中A指针改变了所指向的地址的内容，那么B指针也指向了被修改的内容，如果有些地方用到B指针，即便A指向的内容发生变化，也不希望B收到影响，则需要用深拷贝，真正复制一份A指向的内容，B指向复制后的值，这样即使A指向的内容变化了，B也不会产生影响。好比：浅复制好比你的影子，你完蛋，你的影子也完蛋。深复制好比你和你的克隆人，你完蛋，你的克隆人依然活着。</p>

<ul>
<li>理解2</li>
</ul>


<p>深拷贝和浅拷贝的本质是地址相同，就是浅拷贝，地址不同就是深拷贝。</p>

<p>iOS开发过程中，大体上会区分为对象和容器两个概念，对象的copy是浅拷贝，mutableCopy是深拷贝。容器也参照如上方法，但是需要记住，容器的包含对象的拷贝,无论使用copy,还是mutableCopy都将是浅拷贝，想要实现对象的深拷贝，必须自己提供拷贝的方法。</p>

<ul>
<li>理解3</li>
</ul>


<pre><code> NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
 NSMutableArray *array1=[array copy];        
[array1 addObject:@"three"];  
</code></pre>

<p>//这段代码是错误的，array1通过copy进行的是浅拷贝，即并没有真正复制array，而是也指向了array,此时array是不可变数组，无法进行新数据的添加</p>

<pre><code>NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
NSMutableArray *array2=[array mutableCopy];        
[array2 addObject:@"three"];  
</code></pre>

<p>这段代码是正确的，array2通过mutableCopy进行的是深拷贝，即把array真正复制了一份，并且复制后，变味了NSMutableArray,此时array2是可变数组，可以添加数据</p>

<blockquote><p>注意点:<em>(1)</em> 当使用mutableCopy时，不管源对象是否可变，副本是可变的，并且实现真正意义上的拷贝。当我们使用copy一个可变对象时，副本对象是不可变的。</p>

<p><em>(2)</em>要想实现对象的自定义拷贝，必须实现NSCopying,NSMutableCopying协议，实现该协议的copyWithZone方法和mutableCopyWithZone方法。深拷贝和浅拷贝的区别就在于copyWithZone方法的实现。</p></blockquote>

<h2>NSString属性什么时候用copy,什么时候用Strong?</h2>

<p>我们定义一个类，并且为其声明两个字符串属性，如下所示：</p>

<pre><code>@interface TestStringClass ()
@property (nonatomic, strong) NSString *strongString;
@property (nonatomic, copy) NSString *copyedString;
@end
</code></pre>

<p>上面的代码声明了两个字符串属性，其中一个内存特性是strong,一个是copy.下面我们来看看它们的区别。</p>

<p>首先，我们用一个不可变字符串来为这两个属性赋值,</p>

<pre><code>- (void)test {
    NSString *string = [NSString stringWithFormat:@"abc"];
    self.strongString = string;
    self.copyedString = string;
    NSLog(@"origin string: %p, %p", string, &amp;string);
    NSLog(@"strong string: %p, %p", _strongString, &amp;_strongString);
    NSLog(@"copy string: %p, %p", _copyedString, &amp;_copyedString);
}
</code></pre>

<p>输出结果为:</p>

<pre><code>origin string: 0x7fe441592e20, 0x7fff57519a48
strong string: 0x7fe441592e20, 0x7fe44159e1f8
copy string: 0x7fe441592e20, 0x7fe44159e200
</code></pre>

<p>我们可以看到，这种情况下，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string执行的地址，如果我们换做MRC环境，打印string的引用计数的话，会看到其引用计数是3,即String操作和copy做做都使原字符串对象的引用计数值+1.</p>

<p>接下来，我们把string由不可变改为可变对象，看看会是什么结果，即将下面这一句</p>

<pre><code>NSString *string = [NSString stringWithFormat:@"abc"];
</code></pre>

<p>改成:</p>

<pre><code>NSMutableString *string = [NSMutableString stringWithFormat:@"abc"];
</code></pre>

<p>其输出结果为:</p>

<pre><code>origin string: 0x7ff5f2e33c90, 0x7fff59937a48
strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8
copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0
</code></pre>

<p>可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让<em>copyedString对象指向这个字符串，在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而</em>copyedString的引用计数是1</p>

<p>此时，我们如果去修改string字符串的话，可以看到：因为<em>strongString和string都是指向同一个对象，所以</em>strongString的值会跟随者改变（需要注意的是，此时 <em>strongString 的类型实际上是NSmutableString,而不是NSString）而</em>copyedString指向的是另一个对象，所以并不会改变。</p>

<h3>结论</h3>

<p>由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的StrongString指针指向一个可变字符串是OK的。</p>

<p>而上面的例子可以看得出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是Strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>

<p>当源字符串是NSMUtableSring时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生了一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString,而不是NSMutableString,因此其实不可变的。</p>

<p>这里还有一个性能问题，即在源字符串是NSMutableString,strong是单纯的增加对象的引用计数，而copy操作是智行了一次深拷贝，所以性能上会有所差异，而如果源字符串是NSString时，则没有这个问题。</p>

<h2>OC的理解和特性</h2>

<ul>
<li>OC 作为一门面向对象的语言，自然具有面向对象的语言特性：封装，继承，多台，它既有静态语言的特性（如C++），又有动态语言的效率（动态绑定，动态加载）。总体来讲，OC确实是一门不错的编程语言</li>
<li><p>OC具有相当多的动态特性，表现为三个方面：动态类型（Dynamic typing）,动态绑定(Dynamic binding)和动态加载(Dynamic loading).动态-必须运行时（run time）才会做的事情</p></li>
<li><p>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单说就是id类型，事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者</p></li>
<li>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对对那个的属性和响应消息也被完全确定。</li>
<li>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retain设备上加载@2x的图片，而在老一些的普通苹果设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类</li>
</ul>


<h2>简述内存管理的基本原则</h2>

<ul>
<li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建活引用一个对象的时候，需要向它发送alloc,copy,retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制(MRC)</li>
<li>目前：ios5之后引用自动管理机制-自动引用计数（ARC），管理机制和手动机制一样，只是不再需要调用retain,release,autorelease,它编译时的特性，当你使用arc时，在适当位置插入release和 autorelease;它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针比那两指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动设置为nil</li>
<li>如果使用alloc,copy(mutableCopy)或者retain一个对象时，你就有义务向它发送一条release或者autorelease消息，其它方法创建的对象，不需要由你来管理内存。</li>
<li>向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池子中每个对象发送一条release消息，以此来释放对象</li>
<li>向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法，释放该对象和对象本身所拥有的实例。</li>
</ul>


<h2>其它注意事项</h2>

<ul>
<li>如果一个对象有一个<em>Strong类型的指针指向着，找个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil.如果一个指针被指向nil,那么它原来指向的对象就被释放了，当一个视图控制器被释放时，它内部的全部指针会被指向nil.&ldquo;不管是全局变量还是局部变量用</em>Strong描述就行&rdquo;</li>
<li>局部变量：出了作用域，指针会被设置为nil</li>
<li>方法内部创建对象，外部使用需要添加_autorelease</li>
<li>连线的时候，用_weak描述</li>
<li>代理使用unsafe_unretained就相当于assign</li>
<li>block中为了避免循环引用问题，使用_weak描述</li>
<li>声明属性时，不要以new开头，如果非要以new开头命名属性的名字，需要自己定制get方法名，如</li>
</ul>


<pre><code>@property(getter=theString) NSString * newString;
</code></pre>

<ul>
<li>如果要使用自动释放池，用@autoreleasepool{}</li>
<li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成Core Foundation中的变量需要交换管理权</li>
<li>在非ARC工程中采用ARC去编译某些类:<code>-fobjc-arc</code></li>
<li>在ARC工程下采用非ARC去比哪一某些类:<code>-fno-fobjc-arc</code></li>
</ul>


<h2>如何理解MVC设计模式</h2>

<p>mvc是一种架构模式，M表示Model，V表示视图View,C表示控制器Controller:
* Model负责存储，定义，操作数据
* View用来展示数据，和用户进行交互
* Controller是Model和View的协调者，Controller把MOdel中的数据拿过来给View用，Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，Model也要与Controller进行通信，这个时候要用Notification和KVO,这个方式就像一个广播一样，Model刚发送信号，Contrller设置坚挺接受信号，当有数据更新时就发信号给Controller,Model和View不能直接进行通信，这样会违背MVC设计模式</p>

<h2>如何理解MVVM设计模式</h2>

<ul>
<li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其它业务逻辑处理极好的地方，说白了，就是把原来ViewCOntroller层的业务逻辑和页面逻辑等剥离出来放到ViewModel层</li>
<li>View层，就是ViewController层，它的任务就是从ViewModel层获取数据，然后显示</li>
</ul>


<h2>Objective-C 中是否支持垃圾回收机制？</h2>

<ul>
<li>OC是支持垃圾回收机制的,但是Apple的移动终端中，是不支持GC的，Mac桌面系统开发中是支持的。</li>
<li>移动端开发是支持ARC的，ARC是在ios5之后推出的新技术，它与GC机制是不同的，我们在编写代码时，不需要想对象发送release或者autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release消息，ARC的特点是自动引用计数简化了内存管理的难度</li>
</ul>


<h2>ARC下Assign和weak的区别</h2>

<p>weak比assign对了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值nil,这个再向weak修饰的属性发送消息就不会导致野指针操作crash.</p>

<p>在arc模式下编程时，指针变量一定要用weak修饰，只有基本数据类型和结构体需要用assign，例如delegate,一定要用weak修饰。</p>

<ul>
<li>区别：如果用weak声明的变量在栈中就会自动清空，赋值为nil，如果用assign声明的变量在栈中可能不会自动赋值为nil,就会造成野指针错误</li>
</ul>


<h2>协议的基本概念和协议中方法默认什么类型</h2>

<p>OC中的协议是一个方法列表。它的特点是可以被任何类使用（实现），但它并不是类，自身不会实现这样方法，而是有其它人来实现协议，经常用来实现委托对象，如果一个类采用了一个协议，那么它必须实现协议中必须需要实现的方法，在协议中的方法默认是必须实现的（@required）,添加关键字@optional,表明一旦采用该协议，这些可选的方法是可以不实现的</p>

<h2>简述类目Category的有点和缺点</h2>

<h3>优点</h3>

<ul>
<li>不需要通过增加子类而增加现有类的行为或方法，且类目中的方法与原始类方法基本没有区别：</li>
<li>通过类目可以将庞大的一个类的方法进行划分，从而便于代码的日后的维护，更新及提高代码的阅读性</li>
</ul>


<h3>缺点</h3>

<ul>
<li>无法向类目中添加实例变量，如果需要添加实例变量，只能通过定义子类的方式</li>
<li>类目中的方法与原始类以及父类方法相比具有更高优先级，如果覆盖弗雷的方法，可能导致super消息的断裂，因此，最好不要覆盖原始类中的方法。</li>
</ul>


<h2>循环引用产生额原因，以及解决方法</h2>

<ul>
<li>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减去1.对象A的销毁依赖于对象B的销毁，同事对象B销毁也依赖于对象A的销毁，从而形成了循环引用，此时，即使外界没有任何指针访问它，它也无法释放。
<img src="http://devstorepic.qiniudn.com/FvDA-QQdrUBpndLKOmJgy6-vqM0F" alt="2" /></li>
</ul>


<p>对个对象之间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：</p>

<p><img src="http://devstorepic.qiniudn.com/Fk4cV48OjN9tUl-lDiU_ap5WWGUl" alt="1" /></p>

<h3>解决方法</h3>

<ul>
<li>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，让对象回收</li>
<li>使用weak声明</li>
</ul>


<h2>键路径(keyPath),键值编码(KVC),键值观察(KVO)</h2>

<h3>键路径</h3>

<ul>
<li>在一个给定的实体中，同一个属性的所有值具有相同的数据类型</li>
<li>键-值编码技术用于进行这样的查找-它是一种间接访问对象属性的机制。键路径是一个由点做分隔符组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于前面的性质</li>
<li><p>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相关对象的特定属性</p>

<h3>键值编码KVC</h3></li>
<li><p>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取的方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</p></li>
<li>KVC的缺点：一旦使用KVC，你的编译器无法检查出错误，即不会对设置的键，键路径进行错误检查，且执行效率要地域合成存取器方法和自定的setter和getter方法，因为使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量

<h3>键值观察KVO</h3></li>
<li>键值观察机制是一种能使的对象获取到其他对象属性变化的通知，极大的简化了代码</li>
<li>实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到，因此，KVC是KVO的基础</li>
</ul>


<h3>Demo</h3>

<p>比如我自定义一个Button</p>

<pre><code>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO 
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { 
     if ([keyPath isEqualToString:@"highlighted"] ) { 
      [self setNeedsDisplay]; } 
  }
</code></pre>

<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和KVC机制的道理是一样的。</p>

<h3>KVC机制通过key找到value的原理</h3>

<ul>
<li>当通过KVC调用对象时，比如：<code>[self valueForKey:@”someKey”]</code>,程序会自动视图通过下面几种不同的方式解析这个调用。</li>
<li>首先查找对象是否带有somekey这个方法，如果没找到，会继续查找对象是否带有somekey这个实例变量，如果还没有找到，程序会继续视图调用<code>-(id) valueForUndefinedKey:</code>这个方法，如果这个方法还是没有被实现的话，程序会抛出一个<code>NSUndefinedKeyException</code>错误</li>
<li>补充：KVC在查找方法的时候，不仅会超照somekey这个方法，还会查找getsomeKey这个方法，前面加一个get,或者<em>someKey以</em>getsomeKey这几种形式，同时，查找实例变量的时候也会不仅仅查找somekey这个变量，也会查找_someKey这个变量是否存在</li>
<li>设计<code>valueForUndefinedKey</code>方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li>
</ul>


<h2>在Objective-C中如何实现KVO</h2>

<ul>
<li>注册观察者（注意：观察者和被观察者不会被保留也不会被释放）</li>
</ul>


<pre><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 
options:(NSKeyValueObservingOptions)options 
context:(void *)context;

- (void)observeValueForKeyPath:(NSString *)keyPath 
ofObject:(id)object change:(NSDictionary *)change   context:(void *)context;

- (void)removeObserver:(NSObject *)observer 
forKeyPath:(NSString *)keyPath;
</code></pre>

<ul>
<li>KVO 中谁要监听谁注册，然后响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性都是通过NSString来查找，编译器不会检错和补位，全部取决于自己</li>
</ul>


<h2>代理的作用</h2>

<ul>
<li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性</li>
<li>改变或传递控制链，允许一个类在某些特定时刻通知到其他类，而不需要获取到哪些类的指针，可以减少框架的复杂度</li>
<li>另外一点，代理可以理解为java中回调监听机制的一种类似</li>
<li>代理的属性常常是assign的原因：防止循环引用，以至于对象无法得到正确的释放</li>
</ul>


<h2>NSNotification、Block、Delegate和KVO的区别</h2>

<ul>
<li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知</li>
<li>效率：Delegate比NSNotification高</li>
<li>Delegate和Block一般是一对一的通信</li>
<li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信</li>
<li>Block:Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate;</li>
</ul>


<h2>Objective-C中可修改和不可修改类型</h2>

<ul>
<li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改</li>
<li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不变的，而后者可以添加修改等，可以动态申请的内存空间</li>
</ul>


<h2>当我们调用一个静态方法时，需要对对象进行release吗？</h2>

<p>不需要，静态方法（类方法）创建一个对象时，对象已被放入自动释放池。在自定释放池被释放时，很有可能被销毁</p>

<h2>当我们释放我们的对象时，为什么需要调用[super dealloc]方法，它的位置又是如何的呢？</h2>

<ul>
<li>因为子类的某些实例是继承自父类的，因此需要调用<code>[super dealloc]</code>方法，来释放父类拥有的实例，其实也就是子类本身的，一般来说我们优先释放子类拥有的实例，最后释放父类所拥有的实例</li>
</ul>


<h2>对谓词的认识</h2>

<ul>
<li>Cocoa中提供乐意一个<code>NSPredicate</code>类，该类主要用于指定过滤器的条件，每一个对象通过谓词进行筛选，判断条件是否匹配</li>
</ul>


<h2>static，self，super关键字的作用</h2>

<ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配了一次，因此其值在下次调用时扔维持上次的值</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li>
<li>在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明</li>
<li>在类中的static成员变量属于整个类所拥有过，对类的所有对象只有一份拷贝</li>
<li>self：当前消息的接受者</li>
<li>super：向父类发送消息</li>
</ul>


<h2>include与#import的区别、#import 与@class 的区别</h2>

<ul>
<li>include和#import其效果相同，都是查询勒种定义的行为</li>
<li>import不会引起交叉编译，确保头文件只会被导入一次</li>
<li>@class的表明，只定义了类的名称，而具体类的行为是未知的，一般用于.h文件</li>
<li>@class比#import编译效率更高</li>
<li>此外@class和#import的主要区别在于解决引用死锁的问题</li>
</ul>


<h2>@public、@protected、@private @ fileprivate, open 它们的含义与作用</h2>

<ul>
<li>@public:对象的实例变量的作用域在任意地方都可以被访问</li>
<li>@protected:对象的实例变量作用域在本类和子类都可以被访问到</li>
<li>@private：实例变量的作用域只能在本类中访问</li>
</ul>


<h3>fileprivate</h3>

<p>在原有的swift中的private其实并不是真正的私有，如果一个变量定义为private,在同一个文件中的其他类依然是可以访问到的。这个场景在使用extension的时候很明显</p>

<pre><code>class User {
    private var name = "private"
}

extension User{
    var accessPrivate: String {
        return name
    }
}
</code></pre>

<p>这样带来了两个问题：</p>

<ul>
<li>当我们标记为private时，意思为真的私有还是文件内共享呢？</li>
<li>当我们如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件内，否则可能同文件里其它的代码访问到</li>
</ul>


<p>由此，在swift3中，新增加了一个<code>fileprivate</code>来显示表明，这个元素的访问权限为文件内私有，过去的private对应现在的fileprivate,现在private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问到</p>

<h3>open</h3>

<p>open则是弥补public语义上的不足。
现在public有两层含义:</p>

<ul>
<li>这个元素可以在其他作用域被访问</li>
<li>这个元素可以在其他作用域被继承或者ovrride</li>
</ul>


<p>继承是一件危险的事情，尤其对于一个framework或者module的设计者而言，在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者ovrride都是可控制的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改，这个对应的就是final.</p>

<p>final的问题在于标记之后，在任何地方都不能被ovrride,而对于lib的设计者而言，希望得到的是在module内可以ovrride,在被import到其他地方后其他用户使用的时候不能被ovrride.</p>

<p>这就是<code>open</code>产生的初衷，通过open和public标记区别一个元素在其他module中是只能被访问还是可以被ovrride.</p>

<p>例子:</p>

<pre><code>/// ModuleA:

// 这个类在ModuleA的范围外是不能被继承的，只能被访问
public class NonSubclassableParentClass {

    public func foo() {}

    // 这是错误的写法，因为class已经不能被继承，
    // 所以他的方法的访问权限不能大于类的访问权限
    open func bar() {}

    // final的含义保持不变
    public final func baz() {}
}

// 在ModuleA的范围外可以被继承
open class SubclassableParentClass {
    // 这个属性在ModuleA的范围外不能被override
    public var size : Int

    // 这个方法在ModuleA的范围外不能被override
    public func foo() {}

    // 这个方法在任何地方都可以被override
    open func bar() {}

    ///final的含义保持不变
    public final func baz() {}
}

/// final的含义保持不变
public final class FinalClass { }
/// ModuleB:

import ModuleA

// 这个写法是错误的，编译会失败
// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承
class SubclassA : NonSubclassableParentClass { }

// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.
class SubclassB : SubclassableParentClass {

    // 这样写也会编译失败
    // 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'.
    override func foo() { }

    // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写
    // 这里不需要再声明为open，因为这个类是internal的
    override func bar() { }
}

open class SubclassC : SubclassableParentClass {
    // 这种写法会编译失败，因为这个类已经标记为open
    // 这个方法override是一个open的方法，则也需要表明访问权限
    override func bar() { } 
}

open class SubclassD : SubclassableParentClass {
    // 正确的写法，方法也需要标记为open
    open override func bar() { }    
}

open class SubclassE : SubclassableParentClass {
    // 也可以显式的指出这个方法不能在被override
    public final override func bar() { }    
}
</code></pre>

<p>现在的访问权限则依次为:open,public,internal,fileprivate,private.</p>

<h2>iOS开发中数据持久性有哪几种？</h2>

<p>数据存储的核心都是写文件</p>

<ul>
<li>属性列表：只有NSString,NSArray,NSdictionary,NSdata可以writeToFile;存储依旧是plist文件，plist文件可以存储7种数据类型：array,dictionary,string,bool,data,date,number</li>
<li>对象序列化（对象归档）:对象序列化通过序列化的形式，键值关系存储到本地，转化为二进制刘，通过runtime实现自动化归档/解档，实现NSCoding协议必须实现的两个方法:</li>
<li>编码(对象序列化):把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData,可以存储到本地</li>
<li>解码:(对象反序列化)把二进制数据转化为本来的类型</li>
<li>SqlLite数据库：大量有规律的数据使用数据库</li>
<li>CoreData:通过管理对象进行增删改查操作。它不是一个数据库，不仅可以使用SqlLite数据库来保持数据，也可以使用其他方式来存储数据，如:XML</li>
</ul>


<h3><em>CoreData介绍</em></h3>

<ul>
<li>CoreData是面向对象的API，COreData是ios中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础</li>
<li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理，对象关系管理和持久化等方面相关的问题</li>
<li>大多数情况下，我们引用CoreData作为持久化数据的解决方法，并利用它作为持久护士数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转为数据，保存到SQL中，然后将保存后的数据还原成OC对象</li>
</ul>


<h3><em>CoreData的特征:</em></h3>

<ul>
<li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量</li>
<li>将对象数据存储在SQLite数据已获得性能优化</li>
<li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删改查</li>
<li>管理 undo/redo操作</li>
<li>检查托管对象的属性值是否正确</li>
</ul>


<h3><em>CoreData的6个成员对象</em></h3>

<ol>
<li>NSManageObject：被管理的数据记录Managed Object Model是描述应用程序数据模型，这个模型包含实体(Entity),特性(Property)，读取请求(Fetch Request)等</li>
<li>NSManageObjectContext：管理对象的上下文，持久化存储模型对象，参与数据对象进行各种操作的全过程，并检测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI</li>
<li>NSPersistentStoreCoordinator：连接数据库的Persistent Store Coordinator,相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集</li>
<li>NSManagedObjectModel：被管理的数据模型，数据结构</li>
<li>NSFetchRequest：数据请求</li>
<li>NSEntityDescription：表格实体结构，还需知道. xcdatamodel文件编译后为<code>.momd</code>或者<code>.mom</code>文件。</li>
</ol>


<h3>Core Data 的功能</h3>

<ul>
<li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系</li>
<li>自动验证属性值</li>
<li>支持跟踪修改和撤销操作</li>
<li>关系维护，CoreData管理数据的关系传播，包括维护对象之间的一致性</li>
<li>在内存上和界面上分组，过滤，组织数据</li>
<li>自动支持对象存储在外部数据仓库的功能</li>
<li>创建复杂请求：无需动手写SQL语句，在获取请求(Fetch request)中关联 NSPredicate,NSPredicated支持基本功能，想关子查询和其它高级的sql特性。它支持正确的Unicode编码，区域感知查询，排序和正则表达式</li>
<li>延迟操作：CoreData使用懒加载方式减少内存负载，还支持部分实体化延迟加载和复制队形的数据共享机制</li>
<li>合并策略：COreData内置版本跟踪和乐观锁来支持多用户写入冲突的解决，其中，乐观锁就是对局冲突进行检测，若冲突就返回冲突的信息</li>
<li>数据迁移：CoreData的Schema Migration工具尅简化对应数据库结构变化的任务，在某些情况下允许你执行高效率的数据库原地迁移工作</li>
<li>可选择针对程序Controller层的集成，来支持UI的显示同步core data在iphone os之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS上我们用Cocoa提供的绑定机制来完成的</li>
</ul>


<h2>对象可以被Copy的条件</h2>

<p>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝分为不可变拷贝和可变拷贝，</p>

<ul>
<li>NSCopying协议方法为:</li>
</ul>


<pre><code>- (id)copyWithZone:(NSZone *)zone {
 MyObject *copy = [[[self class] allocWithZone: zone] init]; copy.username = [self.username copyWithZone:zone]; return copy;
}
</code></pre>

<h2>在某个方法中 self.name = <em>name，name = </em>name 它 们有区别吗,为什么?</h2>

<ul>
<li>前者是存在内存管理的setter方法赋值，它会对_name对象进行保留或者拷贝操作</li>
<li>后者是普通赋值</li>
<li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写setter方法来执行某些额外的工作，比如说，外部传一个模型过来，那么我会直接重写setter方法，当模型传来时，也就意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI</li>
</ul>


<h2>解释self=[super init]方法</h2>

<ul>
<li>容错处理，当父类初始化失败，会返回一个nil,表示初始化事变，由于继承的关系，子类是需要拥有父类的实例和行为，因此，我们必须先初始化父类，然后再初始化子类</li>
</ul>


<h2>定义属性时,什么时候用 assign、retain、copy 以及它们的之间的区别</h2>

<ul>
<li>assign:普工赋值，一般常用于基本数据类型，常见委托设计模式，一次来防止循环引用（我们成为弱引用）</li>
<li>retain:保留计数，获得到了对象的所有权，引用计数在原有的基础上加1</li>
<li>copy:一般认为，是在内存中重新开辟了一个新的内存空间，用来存储新的对象，和原来的对象是两个不同的地址，引用计数分别1.当时当copy对象为不可变对象时，那么copy的作用相当于retain,因此，这样可以节约内存空间</li>
</ul>


<h3>堆和栈的区别</h3>

<ul>
<li>栈区(stack)由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等，栈是由低地址扩展的数据结构，是以一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的</li>
<li>堆区（heap）：一般是由程序员分配释放，弱程序员不释放，程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活</li>
<li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使的程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不能有一个内存块从栈中间弹出</li>
<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配是由alloc函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现</li>
<li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆是C/C++函数库提供的，它的机制是很复杂的</li>
<li>全局区(静态区)(static):全局变量和静态变量的存储是放在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放</li>
<li>文字常量区：常量字符串就是存放在这里的额，程序结束后由系统释放</li>
<li>程序代码区：存放函数体的二进制代码</li>
</ul>


<h2>怎样使用performSelector传入3个以上的参数，其中一个为结构体</h2>

<ul>
<li>因为系统提供的performSelector的API中，并没有提供三个参数，因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型，我们只能通过对象放入结构作为属性来传过去了。</li>
</ul>


<pre><code> - (id)performSelector:(SEL)aSelector; 
 - (id)performSelector:(SEL)aSelector withObject:(id)object; 
 - (id)performSelector:(SEL)aSelector withObject:
    (id)object1 withObject:(id)object2;
</code></pre>

<p>具体实现如下:</p>

<pre><code>typedef struct HYBStruct {
int a;
int b;
} *my_struct;
@interface HYBObject : NSObject
@property (nonatomic, assign) my_struct arg3;
@property (nonatomic, copy)  NSString *arg1;
@property (nonatomic, copy) NSString *arg2;

@end
@implementation HYBObject

// 在堆上分配的内存，我们要手动释放掉- (void)dealloc {
free(self.arg3);

}@end
</code></pre>

<p>测试:</p>

<pre><code>my_struct str = (my_struct)(malloc(sizeof(my_struct)));
str-&gt;a = 1;
str-&gt;b = 2;
HYBObject *obj = [[HYBObject alloc] init];
obj.arg1 = @"arg1";
obj.arg2 = @"arg2";
obj.arg3 = str; 
[self performSelector:@selector(call:) withObject:obj]; 
// 在回调时得到正确的数据的- (void)call:(HYBObject *)obj { NSLog(@"%d %d", obj.arg3-&gt;a, obj.arg3-&gt;b);
}
</code></pre>

<h2>UITableViewCell有个UIlabel,显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</h2>

<p>这是否刷新取决于timer加入到run loop中的mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView 滑动时切换到该Mode</li>
<li>UIInitializationRunLoopMode：run loop启动时，会切换到该Mode</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）:Mode集合苹果公开提供的Mode有两个：</li>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
<li>在编程中，如果我们把一个NStimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候，ScrollView滚动的过程中会因为mode的切换，而导致NSTimer将不再被调度，当我们滚动的时候，也希望不调度，那就应该使用该模式。
但是，我们希望在滚动的时候，定时器也要回调，那就应该使用common mode</li>
</ul>


<h2>对于单元格重用的理解</h2>

<ul>
<li>当cell滑动屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外划入屏幕内部时，从重用队列中找看有没有可重用的单元格，若有，就直接用，没有就重新创建一个</li>
</ul>


<h2>解决Cell重用的问题</h2>

<ul>
<li>UITableview通过重用单元格来达到节省内存的额目的，通过为每个单元格制定一个重用标识（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的Id，对于简单的表格，一个标识符就够了</li>
<li>如一个TableView中又10个单元格，但屏幕最多显示4个，实际上iPHone只为其分配了4个单元格的内存，没有分配10个，当关东单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的格式为屏幕最大显示数，当有新的cell进入屏幕时，会随你调用已经滚出屏幕的cell所占的内存，这就是cell的重用</li>
<li>对于多变的自定义cell,这种重用机制会导致内容出错，为解决这种出错的方法，把原来的</li>
</ul>


<pre><code>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString]
修改为：UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];
</code></pre>

<p>这样就解决掉cell重用机制导致的问题，但是数据量多的情况，会有性能问题</p>

<h2>有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？</h2>

<p>对于这4个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*任务a */ });
dispatch_group_async(group, queue, ^{ /*任务b */ });
dispatch_group_async(group, queue, ^{ /*任务c */ }); 
dispatch_group_async(group, queue, ^{ /*任务d */ }); 
dispatch_group_notify(group,dispatch_get_main_queue(), ^{ // 在a、b、c、d异步执行完成后，会回调这里});
</code></pre>

<ul>
<li>当然，我们还可以使用非常老套的方法来处理，通过4个变量来标识a,b,c,d四个人物是否完成，然后在runloop中让其等待，当完成时才退出runloop.但是这样做会让后面的代码得不到执行，直到Runloop执行完成</li>
<li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。</li>
</ul>


<h2>使用block有什么好处？使用NSTimer写出一个使用block显示（在UIlabel上）秒表的代码</h2>

<ul>
<li>代码紧凑，传值，回调都很方便，省去了写代理的很多代码</li>
<li>NSTimer封装成block</li>
<li>实现方法:</li>
</ul>


<pre><code>NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0
                              repeats:YES
                             callback:^() {
  weakSelf.secondsLabel.text = ...
}
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]
</code></pre>

<h2>线程和进程的区别和联系？</h2>

<ul>
<li>一个程序至少要有进程，一个进程至少要有一个线程</li>
<li>进程：资源分配的最小独立单元，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程：进程下的一个分支，是进程的实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一点在运行中不可少的资源（程序计数器，一组寄存器，栈）但是它可与同属一个进程的其他线程共享进程所拥有的全部资源</li>
<li>进程和线程的主要差别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于这个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源比较大，效率要差一些</li>
<li>但对于一些要求同事进行并且又要共享某些变量的并发造作，只能用线程，不能用进程</li>
</ul>


<h2>多线程编程</h2>

<ul>
<li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中，线程同步：多个线程同事访问一个数据会出问题，NSlock,线程同步块，@synchronized(self){}。</li>
<li>NSOperationQueue操作队列（不需要考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation, BSBlockOperation，自定义Operaton.创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到队列中时，默认会调用main方法。</li>
<li>GCD（<code>Grand Central Dispatch</code>）宏大的中央调度，串行队列，并发队列，主线程队列</li>
<li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个</li>
<li>串行和并行：串行是多个任务按照一定的顺序执行，并行是多个任务同事执行</li>
<li>代码是在分线程执行，在主线程刷新UI</li>
</ul>


<h3>多线程编程是防止主线程堵塞，增加运行效率的最佳方法</h3>

<ul>
<li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法</li>
<li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个想成管理器可以并行运行的线程数量等</li>
<li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径</li>
<li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力</li>
</ul>


<h2>定时器与线程的区别：</h2>

<ul>
<li>定时器：可以执行多次，默认在主线程中</li>
<li>线程：只能执行一次</li>
</ul>


<h2>Apple设备尺寸和编程尺寸</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-0.png" alt="1" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-1.png" alt="2" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-2.png" alt="3" /></p>

<h2>TCP和UPD的区别和联系</h2>

<ul>
<li>TCP为传输控制层协议，为面向连接，可靠地，点到点的通信</li>
<li>UPD为用户数据报协议，非连接的不可靠的点到多点的通信</li>
<li>TCP侧重可靠传输，UPD侧重于快速传输</li>
</ul>


<h2>TCP连接的三次握手</h2>

<ul>
<li>第一次握手：客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN,同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK,此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态</li>
</ul>


<h2>Scoket连接和HTTP连接的区别:</h2>

<ul>
<li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Scoket是对TCP/IP协议的封装，scoket本身并不是协议，而是一个调用接口(API)，通过Socket,我们才能使用TCP/IP协议</li>
<li>HTTP连接:短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPHone主要类NSURLSession</li>
<li>Socket连接：长连接，客户端跟服务器端直接使用Scoket进行连接，没有规定连接后断开，因此客户端和服务器保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8k</li>
</ul>


<h2>http协议的特点，关于http请求Get和Post的区别</h2>

<p>Get和post的区别：</p>

<ul>
<li>HTTP超文本传输协议，是短链接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开，Http是一个属于应用层面面向对象的协议，http有两类报文：请求报文和响应报文</li>
<li>http请求报文：一个http请求报文由请求行，请求头部，空行和请求数据4部分组成</li>
<li>http响应报文：由三部分组成：状态航，消息报头，响应正文</li>
<li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有的参数都拼接在地址后面），不适合传输大量数据，长度有限制，为1024个字节</li>
<li>Post请求：参数在请求数据区放着，相对Get更安全，并且数据大小没有限制，把提交的数据放置在HTTP包的包体中</li>
<li>GET提交的数据会在地址栏显示出来，而Post请求，地址栏不会改变</li>
</ul>


<p><em>传输数据的大小 ：</em>
* Get提交时，传输数据就会受到URL长度限制，Post由于不是通过URL传值，理论上不受限制</p>

<p><em>安全性：</em></p>

<ul>
<li>Post的安全性要比Get的安全性高；</li>
<li>通过Get提交数据，用户名和密码将明文出现在URL上，比如登录界面有可能被浏览器缓存</li>
<li>HTTPS：安全超文本传输协议(Secure Hypertext Transfer Protocol),它是一个安全通信通道，基于http 开发，用于客户计算机和服务器之间交换信息，使用安全套接字(SSI)进行信息交换，即HTTP的安全版</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义UICollectionViewLayout]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/"/>
    <updated>2016-10-28T14:34:50+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout</id>
    <content type="html"><![CDATA[<p>UICollectionView，自从ios6之后就被引入到开发中，现在已经变成了最流程的UI元素之一，它最吸引人的特性就是将数据和布局进行分离，依靠分离的数据元素去处理布局，这个布局对象是决定占位元素和视图的元素。</p>

<!--more-->


<p>你可能已经习惯了默认的flow layout布局，它是一个默认实现的被UIKit,它是由基本的表格布局组成的。当然你也可以自定义布局，你可以按照自己的喜好来对视图进行重排。自定义布局是非常强大和灵活的。</p>

<p>通过本章，你将学会如何自定义的布局，怎么去计算layout Attributes,怎么去处理动态的cell。</p>

<h2>Getting Started</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Pinterest-starterproject.zip">Download the started project</a>，下载后打开</p>

<p>编译运行，效果如图：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_starter_project.png" alt="1" /></p>

<h2>创建自定义的布局类</h2>

<p>你第一步就是创建一个自定义的布局类，UICollectionView有一个抽象类是<code>UIcollectionViewLayout</code>,它定义了你的Collection View 的每个cell的属性集合-<code>UICollectionViewLayoutAttributes</code>，它包含了你的CollectionView中每个item的属性，比如frame,透明度等</p>

<p>创建一个类继承自<code>UICollectionViewLayout</code>,确保选中的是swift语言，然后创建。</p>

<p>下一步，在你的storyboard中配置下你的自定义布局对象类。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_select_collection_view.png" alt="1" /></p>

<p>然后打开<code>Attributes Inspector</code>面板，选中<code>Custom</code>，在下一个<code>class</code>框中选中你刚才创建的新类<code>PinterestLayout</code>：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_change_layout.png" alt="1" /></p>

<p>好了，编译运行：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_empty_collection.png" alt="3" /></p>

<p>why?</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/meme-nopictures.jpg" alt="1" /></p>

<p>不要慌张！因为你还没有在自定义布局类中写入方法，所以这里什么都不显示。</p>

<h2>核心布局对象</h2>

<p>让我们先看看Collection View的布局调用流程，当Collection View 需要显示一些布局信息的时候，它会询问layout object 去提供一些防范去实现。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/layout-lifecycle.png" alt="1" /></p>

<p>你自定义的布局必须实现如下方法:</p>

<ul>
<li><code>prepareLayout()</code>，在cell将要进入屏幕的时候，这个方法将会被调用，这是一个机会当你去准备展示和计算CollectionView size和坐标的地方</li>
<li><code>collectionViewContentSize()</code>：在这个方法中，你将会返回CollectionView的高度和宽度-不仅仅是可视的内容，Collection View 将会用这些信息去配置ScrollView的内容尺寸</li>
<li><code>layoutAttributesForElementsInRect(_:):</code>在这个方法中，你需要返回所有的嵌套在矩形区域中的布局属性，你将要返回一个包含<code>UICollectionViewLayoutAttributes</code>属性的集合</li>
</ul>


<p>ok，现在你知道需要去实现什么方法了-但是如何去计算attributes？</p>

<h2>计算布局属性</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UICollectionView 新特性]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/"/>
    <updated>2016-10-24T10:35:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing</id>
    <content type="html"><![CDATA[<p>关于ios 10 UIcolelctionView的新特性，主要还是体现在如下三个方面</p>

<ol>
<li>顺滑的滑动体验</li>
<li>针对self=sizing的改进</li>
<li>Interactive recording重排</li>
</ol>


<!--more-->


<p>这个功能在iOS9的时候介绍过了，苹果在iOS10的API里面大大增强了这一个功能</p>

<h2>目录</h2>

<h3><a href="#1">UICollectionViewCell顺滑的滑动体验</a></h3>

<h3><a href="#2">UICollectionViewCell的预加载</a></h3>

<h3><a href="#3">UITableViewCell的预加载</a></h3>

<h3><a href="#4">针对self-sizing的改进</a></h3>

<h3><a href="#5">Interactive Recordering</a></h3>

<h3><a href="#6">UIRefreshControl的改进</a></h3>

<h2><a name="1"></a>UICollectionViewCell顺滑的滑动体验</h2>

<p>众所周知，iOS设备已良好的用户体验赢得了广大的用户群，iOS系统在用户点击屏幕会立即做出响应。而且很大一部分的操作是来自用户的滑动操作，所以滑动的顺滑性是使用用户沉浸在App中享受的必要条件，接下来我们就谈谈iOS10中增加了那些新特性。</p>

<p>我们先来看一下之前UIcollectionView的体验，假设我们每个cell都是简单的蓝色，实际开发app中，cell会比较复杂，我们先生成100cell.当用户滑动不是很快的时候，还感觉不出来卡顿，当用户大幅度滑动，整个UIcollectionView的卡顿就很明显了。如果整个cell的dataSource又是从网络加载的，那就更加卡顿了，如果如下图</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784344928825.gif" alt="1" /></p>

<p>如果这种app上架，用户使用过后，很可能就直接给1星评价了，但是为什么会造成这种问题呢？我们来分析一下，我们模拟一下系统是如果处理重用机制的，效果如下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784355209022.gif" alt="2" /></p>

<p>在上图中，我们可以看出，当cell准备进入屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了。而且更重要的是，在屏幕外面等待加载的cell是整整一行！这一行的cell都已经加载完数据。这是UICollectionView在用户大幅度滑动时卡顿的根本原因。用专业术语来说就是掉帧</p>

<p>接下来我们来详细说说掉帧的问题</p>

<p>当今的用户是很挑剔的，用户需要一个很顺滑的体验，只要有一点卡顿，很可能一言不合就卸载app了。要想用户感觉不到卡顿，那么我们的app就必须达到每秒60帧，用数学换算一下就是每帧16毫秒就必须刷新一次。</p>

<p>我们用图标来分析一下掉帧的问题，下面会出现两种不同的帧</p>

<ul>
<li>第一种情况，下图是当用户轻微的上下小幅度滑动，这个时候每个cell的加载压力都不打，ios针对这种情况，已经做了很好的优化了，所以用户感觉不到任何卡顿，这种情况下不会掉帧，用户也希望能使用如此顺滑的app</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784433822879.jpg" alt="1" /></p>

<ul>
<li>第二种情况，当用户大幅度滑动，每个cell加载的压力很大， 也许需要网络请求，也许需要读取数据库，而且每次都加载一行cell出来，这样每个cell的加载时间都增加了，加载一行的总时间也就大大增加了，如下图所示，这样，不仅仅当前帧在加载cell，总的时间还会挤压到下一帧的时间里面去。这种情况下，用户就感觉到卡顿了。</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784459878847.jpg" alt="2" /></p>

<p>我们换种方式在说明一下2种情况下掉帧的情况。我们用下图的标准来衡量一下上面2中情况。下图分为2部分，上面红色的区域，就是表示掉帧的区域，因为高于16ms。红色和绿色区域的分界线就在16ms处，Y轴我们表示的是CPU在主线程中花费的时间，X轴表示对额就是在用户滑动中发生的刷新事件。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784491910972.jpg" alt="1" /></p>

<p>针对上述掉帧的情况，绘制出实验数据，如下图，值得我们关注的是，曲线是很曲折的，非常的不平滑，当用户大幅度滑动的时候，峰值超过了16 ms ，当用户慢速滑动的时候，帧率又能保持在比较顺滑的区域，处于绿色区域内的cell加载压力都是很小的。这就是时而掉帧时而顺滑的场景。这种场景下，用户体验是很糟糕的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784519648239.jpg" alt="2" /></p>

<p>那怎么解决这个问题呢？我们来看下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784547235875.jpg" alt="2" /></p>

<p>上图中的曲线我们看着就很平缓了，而且这种情况也不会出现掉帧的情况了，每个滑动中的时间都能达到60帧了，这是怎样做到的呢？因为把每个cell的加载事件都评分了，每个cell不会再出现很忙和很闲的两个极端，这样我们就取消了之前的波峰和波谷。从而让该曲线达到了近乎水平的直线。</p>

<p>如何让每个cell都分摊加载任务的压力？这就要谈到新的cell的生命周期了。</p>

<p>先来看看老的UICollectionViewCell的声明周期，当用户滑动屏幕，屏幕外有一个cell准备加载显示进来。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784605179969.jpg" alt="1" />
这个时候我们把这个cell从reuse队列里面拿出来，然后调用<code>prepareForReuse</code>方法。这个方法就给了cell时间，用来重置cell,重置转台，刷新cell,加载新数据。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784613342397.jpg" alt="2" /></p>

<p>再滑动，我们就会调用<code>cellForItemAtIndexPath</code>方法了，这个方法里面就是我们开发者自定义的填充cell的方式了。这里会填充data model,然后赋值给cell,再把cell返回给iOS系统。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784643684182.jpg" alt="1" /></p>

<p>当cell马上要进入屏幕的时候，就会调用willDisplayCell的方法，这个方法给了我们app最后一次机会，为cell进入屏幕做最后的准备工作。执行完willDisplayCell之后，cell就进入屏幕了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784674667370.jpg" alt="2" /></p>

<p>当cell完全离开屏幕之后，就会调用<code>didEndDisplayingCell</code>方法，以上就是在iOS10之前的整个UICollectionViewCell的生命周期。</p>

<p>接下来我们看看iOS10 的UICollectionViewCell的生命周期是怎么样的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784919171617.jpg" alt="1" /></p>

<p>这里还是和iOS9一样的。当用户滑动UICollectionView的时候，需要一个cell,我们就从reuse队列中拿出一个cell，并调用<code>prepareForReuse</code>方法，注意调用这个方法的时间，当cell还没有进入屏幕的时候，就已经提前调用这个方法了。注意对比和iOS9的区别，iOS9是在cell上边缘马上进入屏幕的时候才调用方法， 而这里，cell整个生命周期都被提前了，提前到cell还在设备外面的时候。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784950618167.jpg" alt="2" /></p>

<p>这里还是和之前一样，在<code>cellForItemAtIndexPath</code>中创建cell，填充数据，刷新状态等操作，注意，这里的生命周期也比iOS9提前了。</p>

<p>用户继续滑动，这个时候就有不同了。</p>

<p>这个时候我们并不去调用<code>willDisplayCell</code>方法了，这里遵循的原则是，何时去显示，何时再去调用<code>willDisplayCell</code>.</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785001420508.jpg" alt="1" /></p>

<p>当cell要马上就需要显示的时候，我们再调用<code>willDisplayCell</code>方法。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785009176155.jpg" alt="2" /></p>

<p>当整个cell要从UICollectionView的可见区域消失的时候，这个时候回调用<code>didEndDisplayingCell</code>方法，接下来发生的事情和iOS9一样，cell会进入重用队列中。</p>

<p>如果用户想要显示某个cell,在iOS9中，cell只能从重用队列里面取出，再次走一遍生命周期，并调用<code>cellForItemAtIndexPath</code>去创建或者生成一个cell.</p>

<p>在iOS10当中，系统会把cell保持一段时间，在iOS中，如果用户把cell滑出屏幕后，如果突然又想回来，这个时候cell并不需要再走一遍生命周期了，只需要直接调用<code>willDisplayCell</code>就可以了。cell就又会重新出现在屏幕中了。这就是iOS10的整个UICollectionView的生命周期</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785140434098.jpg" alt="1" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785147242971.jpg" alt="2" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785156440182.jpg" alt="3" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785162269537.jpg" alt="4" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785168247905.jpg" alt="5" /></p>

<p>上面说的iOS10里面的场景同样适用于多列的情况，这时我们每次只加载一个cell,而不是每次加载一行的cell.当第一个cell准备好之后再叫第二个cell准备。当2个cell都准本号之后，接着我们再调用<code>willDisplayCell</code>给每个cell,发送完这个消息之后，cell就会出现在屏幕上了。</p>

<p>这虽然看起来是一个很小的改动，但是这小小的改动就提升了很多用户体验</p>

<p>让我们来看看上述的改动对滑动的影响！</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785199429168.gif">1</a></p>

<p>滑动比iOS9流畅很多，这里可以看到整个过程都很平缓，不卡顿。</p>

<p>还是和iOS9一样，我们来模拟一下系统是如果加载cell的情况。</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785382812684.gif">2</a></p>

<p>我们可以很明显的的看到，iOS系统是一个一个的加载cell的，一个cell加载完之后再去加载下一个cell,这里和iOS9的有很大的不同，ios9是记载整整一行的cell</p>

<p>这是因为我们用了新的UICollectionViewCell的生命周期，整个App完全没有加一行代码，现在iOS10是丝滑般的体验，是在是太棒了。</p>

<h2><a name = "2"></a>UICollectionViewCell的Pre-Fetching预加载</h2>

<p>当我们编译iOS10的APP的时候，这个Pre-Fetching默认是enable的。当然，如果有一些原因导致你必须用到iOS10之前的老的生命周期，你只需要给collectioView加入新的<code>isPrefetchingEnabled</code>属性即可。如果你不想用到<code>Pre-Fetching</code>，那么把这个属性变成false即可。</p>

<pre><code>collectionView.isPrefetchingEnabled = false
</code></pre>

<p>为了最佳实践一下这个新特性，我们先改变一下我们加载cell的方式，我们把很重的读取数据的操作，所有内容的创建都放到<code>cellForItemAtIndexPath</code>方法里面去完成。保证我们在<code>willDisplayCell</code>和<code>didEndDisplayCell</code>这两个方法里面基本不做其他事情。最后，保证<code>cellForItemAtIndexPath</code>加载的cell都不是从重用队列里面拿出来的。</p>

<p>如果这个时候你用ios10编译出你的app,那么非常顺滑的用户体验就会自动的优化出来</p>

<p>UICollectionView的流畅滑动解决了，那么在UICollectionViewCell在加载的时候所花费的时候，怎么解决呢？</p>

<p>UICollectionViewCell加载的时候取决于DataMOdel,DataMOdel很可能回去加载图片，来自于网络或者来自于本地的数据库，这些操作大多数都是异步操作，为了使data加载更快，iOS10引入了新的Apil来解决这个问题。</p>

<p>UICollectionView有两个小伙伴，那就是dataSource和delegate,在iOS10中，将会迎来第三个小伙伴，这个小伙伴就是<code>prefetchDataSource</code></p>

<pre><code>protocol UICollectionViewDataSourcePrefetching {
    func collectionView(_ collectionView: UICollectionView,
                        prefetchItemsAt indexPaths: [NSIndexPath])
    optional func collectionView(_ collectionView: UICollectionView,
                                 cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])
}
class UICollectionView : UIScrollView {
    weak var prefetchDataSource: UICollectionViewDataSourcePrefetching?
    var isPrefetchingEnabled: Bool
}
</code></pre>

<p>这个协议连只有一个必须要实现的方法-<code>ColletionView prefetchItemsAt indexPaths</code>，这个方法会在<code>prefetchDataSource</code>里面被调用，用来给你异步的预加载数据的。indexPaths数组是有序的，就是接下来item接收数据的顺序，让我们model异步处理数据更加方便。</p>

<p>在这个协议里面患有第二个方法<code>CollectionView cancelPrefetcingForItemsAt indexPaths</code>，不过这个方法是可选的，我们可以利用这个方法来处理在滑动中取消或者降低提前加载数据的优先级。</p>

<p>值得说明的是，新增加的这个小伙伴<code>prefetchDataSource</code>，并不能取代原来的读取数据的方法，这个预加载仅仅只是辅助加载数据，并不能删除原来我们读取数据的方法。</p>

<p>至此，我们来看看从文章开始到现在，UICollectionView的性能提升了多少，我们还是用掉帧的方法来看看UICollectionView的性能。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785413182613.jpg" alt="1" /></p>

<p>上面是iOS9 UICollectionView的性能，很明显的看见，波峰波谷很明显，并且还掉了8帧，有明显的卡顿现象。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785449871270.jpg" alt="2" />
上图是iOS10 UICollectionView的性能，我们可以明显的看到，经过ios10的优化，整个曲线很明显的平缓了一些，没有极端的波峰掉帧现象。但是依旧存在少量的波峰快到了16ms分界线了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785482131029.jpg" alt="1" /></p>

<p>上图是iOS10 + pre-Fetching Api之后的性能，已经优化的效果很明显了，整条曲线基本上都水平了。近乎完美，但是还是能发现有个别波峰特别高，波峰特别高的地方就是那个cell加载压力大， 时间花的比较长导致的。接下来我们继续优化！</p>

<p>先来总结一下使用Pre-Fetching API 需要注意的地方。</p>

<ul>
<li>在我们使用Pre-Fetching API的时候，我们一定要保证整个预加载过程都放在后台线程中进行。合理使用GCD和NSOperationQueue处理好多线程</li>
<li>请切记，Pre-Fetching API 是一种自适应的技术，何为自适应技术呢？当我们滑动速度很慢的时候，在这种“安静”的时期，Pre-Fetching API会默默的再后台预加载数据，但是一旦我们快速滑动，我们需要频繁的刷新，我们不会去执行pre-fetching API</li>
<li>最后，用<code>cancelPrefetchingAPI</code>去迎合用户的滑动动作的变换，比如说用户在快速滑动发现了有趣的感兴趣的事情，这个时候停下来，甚至快速反向滑动了，或者点击了事件，进去看详情了，这些时刻我们都应该开启<code>cancelPrefetchingAPI</code></li>
</ul>


<p>综合所述，Pre-Fetching API对于提高UICOllectionView的性能提升是很有帮助的，而且并不需要加入太多的代码，加入少量的代码就可以获得巨大的额性能提升！</p>

<h2><a name="3"></a>UITableViewCell的Pre-Fetching预加载</h2>

<p>在iOS10中，UITableViewCell也跟着UICollectionView一起得到了性能的提升，一样拥有了Pre-Fetching API</p>

<pre><code>protocol UITableViewDataSourcePrefetching {
    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [NSIndexPath])
    optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:
                            [NSIndexPath])
}
class UITableView : UIScrollView {
    weak var prefetchDataSource: UITableViewDataSourcePrefetching?
}
</code></pre>

<p>这里和上面的UICollectionView一样，会调用<code>TableView prefetchRowsAt indexPaths</code>方法，indexPaths还是一个有序数字，顺序就是列表上可见的顺序，第二个可选的API还是<code>TableView cancelPrefetchingForRowsAt indexPaths</code>，和之前的提到的一样，也是用来取消预加载的，性能的提升和UIcollectionView一样的，对于UITableView 的性能提升很大！</p>

<h2><a name="4"></a>针对self-sizing的改进</h2>

<p>self-sizing API 第一次被引入是在ios8中，然而现在在iOS10中得到了一些改进。</p>

<p>在UICollectionView中有个固定的类，叫UICollectionViewFlowlayout,iOS已经在这个类中完全支持了self-sizing.为了能开启这一特性，需要我们开发者为一些不能为0的 CGSize的cell设置一下estimated item size.</p>

<pre><code>layout.estimatedItemSize = CGSize(width:50,height:50)
</code></pre>

<p>这会告诉UICOllectionView我们想要开启动态计算内容的布局。</p>

<p>至今，我们有三种方法来动态的布局：</p>

<ul>
<li>第一种方法是使用autolayout，当我们合理的加入约束，当cell加载的时候，就会根据内容动态的加载布局</li>
<li>第二种方法，如果你不想使用autolayout的方法，想更加手动的控制它，那么我们就需要重写sizeThatFits()方法</li>
<li>第三种方法，终极的方法是重写<code>preferredLayoutAttributesFittingAttributes()</code>方法，在这个方法里面不仅仅可以提供size的信息，更可以得到alpha和transform的信息。</li>
</ul>


<p>所以想指定cell的大小，就可以用上面的三个方法之一</p>

<p>但是实际的操作中，我们可以发现，有时候设置一个合适的estimated item size，对于我们来说是很困难的事情，如果flow layout可以用数学的方法动态的计算布局，而不是根据我们给的size去布局，那回事很酷的事情。</p>

<p>iOS10中就引入了新的API来解决上述问题。</p>

<pre><code>layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize
</code></pre>

<p>对于开发者，我们需要做的事情，仅仅就是设置好flow layout,然后给<code>estimatedItemSize</code>设定一个新的常数，最后<code>UICollectionViewFlowLayout</code>就会自动计算高度了。</p>

<p>系统会自动计算好所有的布局，包括已经定下来的size的cell,并且还会动态的给出接下来的cell的大小的预测。</p>

<p>接下来看2个例子就可以很明显看出iOS10针对self-sizing的改进了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785547586106.gif" alt="1" />
上图可以看到，iOS 9的布局是针对单个cell计算的，当改变了单个cell,其它的cell依旧没有变化，还是需要重新计算</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785653922069.gif" alt="2" /></p>

<p>这里例子就可以很明显的看出差别了，当我们改变了第一个cell的size之后，系统会自动计算出所有的cell的size，并且每一行，每一个section的size都会被动态的计算出来，并且刷新界面！</p>

<p>以上就是iOS 10 针对 self-sizing的改进。</p>

<h2><a name="5"></a>Interactive Reordering</h2>

<p>谈到重新排列，这是我们就需要类比一下UITableview了，UICollectioNView重新排列就如同UITableview把cell上下移动，只不过UITableView的重新排列是针对垂直方向的。</p>

<p>在IOS 9 中，引入了UICollectionView的Interactive Reordering，在今年的iOS 10中，又加入了新的API</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785697559422.gif" alt="1" /></p>

<p>在上图中，我们可以看到，我们即使任意拖动cell,整个界面也会重新排列，并且我们改变了cell的大小，整个UICollectionView也会重新动态的布局。</p>

<p>我们先来看看iOS 9 里面的API</p>

<pre><code>class UICollectionView : UIScrollView {
    func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&gt; Bool
    func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint)
    func endInteractiveMovement()
    func cancelInteractiveMovement()
}
</code></pre>

<p>要想开启interactive movement,我们就需要调用<code>beginInteractiveMovementForItem()</code>方法，其中indexPath代表了我们将要移动的cell.接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作，这时我们就需要调用<code>updateInteractiveMovementTargetPosition()</code>方法，我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用<code>endInteractiveMovement()</code>方法。UICollectionView就会放下cell,处理完整个layout，此时你也可以重新刷新model或者处理数据model.如果中间突然手势取消了，那么这个时候就应该调用<code>cancelInteractiveMovement()</code>方法，如果我们重新把cell对应一圈之后有放回原位了，其实就是取消了移动，那这个时候就应该在<code>cancelInteractiveMovement()</code>方法里面不用取刷新data Source.</p>

<p>在iOS10中，如果你使用UICollectionViewController,那么这个重排对于你来说更加简单、</p>

<pre><code>class UICollectionViewController : UIViewController {
    var installsStandardGestureForInteractiveMovement: Bool
}
</code></pre>

<p>你只需要把installsStandardGestureForInteractiveMovement这个属性设置为true就可以了。CollectionViewController会自动为你加入手势，并且自定为你调用上面的方法。</p>

<p>以上就是去年ios 9 为我们增加的API</p>

<p>今年的ios 10 新加入的API是在iOS9的基础上增加了翻页的功能。</p>

<p>UICollectionView继承自UIScrollView,所以只需要你做的是把 isPagingEnable设置为true，即可开启分页的功能。</p>

<pre><code>collectionView.isPagingEnabled = true
</code></pre>

<p>开启分页之前:
<img src="http://cc.cocimg.com/api/uploads/20160706/1467785741500789.gif" alt="1" /></p>

<p>开启分页之后就长这样子:</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785759631412.gif" alt="2" /></p>

<p>每次移动一次就会以页为单位的翻页、</p>

<h2><a name="6"></a>UIRefreshControl的改进</h2>

<p>UIRefreshControl现在可以直接在CollectionView里面使用了，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController.因为现在RefreshCOntrol成为了ScrollView的一个属性了。</p>

<p>UIRefreshControl的使用方法很简单，就三步:</p>

<pre><code>let refreshControl = UIRefreshControl()
refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)),
                         for: .valueChanged)
collectionView.refreshControl = refreshControl
</code></pre>

<p>先创建一个refreshCOntroler,再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性就可以了。</p>

<h2>Summary</h2>

<ul>
<li>UICollectionview cell Pre-fetching预加载的机制</li>
<li>UICollectionView And UITableView prefetch DataSource新增的API</li>
<li>针对self-sizing cell改进</li>
<li>Interactive recordering 重排</li>
</ul>


<p>最后，原来有些地方用到 AsyncDispatchKit优化的UICollectioView速度的，现在可以考虑不用第三方库了，系统自带的方法可以解决一般性的卡顿问题了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配iOS10]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10/"/>
    <updated>2016-10-10T11:03:06+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10</id>
    <content type="html"><![CDATA[<h2>UICOllecitonViewCell的优化</h2>

<p>在ios10之前，UIcollectionView上面如果有大量的Cell,当用户活动很快的时候，整个UIcollectionView有很卡顿，为什么会造成这样的问题，这里涉及到iOS系统的重用机制，当cell准备加载进到屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了，也就是整整一行cell都已经加载完毕，这就是造成卡顿的主要原因，专业术语叫掉帧</p>

<!--more-->


<p>iOS10之前的UIcollectionViewCell的生命周期是这样的:</p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这个方法里面，可以重置cell的状态，加载新的数据</li>
<li>继续欢动，就会调用cellForItemAtIndexPath方法，在这个方法里面给cell赋值模型，然后返回给系统</li>
<li>当cell马上进去屏幕的时候，就会调用willDispalyCell方法，在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作</li>
<li>执行完willDisplayCell方法后，cell就进去屏幕了，当cell完全离开屏幕之后，会调用didEndDisplayingCell方法</li>
</ol>


<p><em>ios 10 UIcollectionViewCell的生命周期是这样的</em></p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这里当cell还没有进去屏幕的时候，就已经提前调用这个方法了，对比之前的区别就是cell的上边缘拿上进去屏幕的时候就会调用该方法，而ios10提前到cell还在屏幕外面的时候就调用</li>
<li>在cellForItemAtIndexPath中创建cell,填充数据，刷新状态等操作，相比之前也提前了</li>
<li>用户继续滑动的话，当cell马上就需要显示的时候我们再调用willDisplayCell方法，原则就是：何时需要显示，何时再去调用willDisplayCell方法</li>
<li>当cell完全离开屏幕以后，会调用didEndDispalyingCell方法，跟之前一样，cell会进入重用队列</li>
</ol>


<p>在ios10之前，cell只能从重用队列里面取出，再走一遍生命周期，并调用cellForItemAtIndexPath创建或者生成一个cell.</p>

<p>在ios10中，系统cell会保存一段时间，也就是说当用户把cell滑出屏幕以后，如果又滑动回来，cell不用再走一遍生命周期了，只需要调用willDisplayCell方法就可以重现出现在屏幕中了。</p>

<h2>ios10新增加的Pre-Fetching预加载</h2>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时间，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时候，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<pre><code>- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray *)indexPaths NS_AVAILABLE_IOS(10_0);

- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray *)indexPaths  NS_AVAILABLE_IOS(10_0);
</code></pre>

<p>在CollectionView prefetchItemAt indexPaths这个方法是异步预加载数据的，当中的indexPaths数组是有序的，就是Item接收数据的顺序：
ColletionView cancelPrefetchingForItemsAt indexPaths这个方法是可选的，可以用来处理在滑动中取消或者降低提前加载数据的优先级。
这个协议并不能代替之前读取数据的方法，仅仅是辅助加载数据</p>

<h2>UIRefreshControl的使用</h2>

<p>在iOS10中，UIRefreshControl 可以直接在UIcollectionView和UITableView中使用，并且脱离了UITableViewController，现在RefreshControl是UIScrollView的一个属性。</p>

<p>使用方法:</p>

<pre><code>UIRefreshControl *refreshControl = [[UIRefreshControl alloc] init];
  [refreshControl addTarget:self action:@selector(loadData) forControlEvents:UIControlEventValueChanged];
    collectionView.refreshControl = refreshControl;
</code></pre>

<h2>关于ATS的问题</h2>

<p>WWDC2015提出的ATS(App Transport Security)是Apple在推进网络通讯安全的一个重要的方式，在iOS9中，默认情况下非HTTPS的网络访问是被禁止的。当然，因为这样的推进影响面非常广，作为缓冲，我们可以在info.plist中添加<code>NSAppTransportSecurity</code>字典并且将<code>NSAllowsArbitraryLoads</code>设置为<code>YES</code>来禁用ATS.相信大家已经对这个非常熟悉了。</p>

<p>不过在WWDC2016中，Apple表示将继续在ios10和macOS 10.12里收紧对普通http的访问限制。从2017年一月一日起，所有的提交的app默认是不允许使用<code>NSAllowsArbitraryLoads</code>来绕过ATS限制的，也就是说，我们最好保证app的所有的网络请求都是HTTPS加密的，否则可能会在应用审核时遇到麻烦。</p>

<ol>
<li>默认情况下你的app可以访问加密足够强（TLS v1.2以上，AES-128和SHA-2）的HTTPS内容，这对所有的网络请求都有效，包括<code>NSURLSession</code>,<code>UIWebview</code>以及<code>WkWebView</code>等</li>
<li>你依然可以添加<code>NSAllowsArbitraryLoads</code>为<code>YES</code>来禁用ATS,不过如果你这么做的话，需要在提交app时进行说明，为什么需要访问非HTTPS的内容，一般来说，可能类似浏览器类的app比较容易能通过</li>
<li>相比于使用<code>NSAllowsArbitraryLoads</code>将全部HTTP内容放开，选择使用<code>NSExceptionDomains</code>来针对特定的域名开放HTTP应该要相对容易过审核。“需要访问的域名是第三方服务器,他们没有进行HTTPS对应”，会是审核时的一个可选理由，但是这应该只需要针对特定域名，而非全面开放，如果访问的是自己的服务器的话，可能这个理由会无法通过</li>
<li>对于网页浏览和视频播放的行为，iOS10中新加入了<code>NSAllowsArbitraryLoadsInWebContent</code>键，通过将它设置为<code>YES</code>，可以让你的app中的<code>WKWebView</code>和使用<code>AVFoundation</code>播放的在线视频不受ATS的限制。这也应该是绝大多数使用了相关特性的app的选择。但是坏消息是这个键在ios9中并不会起到作用</li>
</ol>


<p>总结：对于API请求，基本上必须使用HTTPS的，特别是如果你们自己可以管理服务器的话，可能需要后端的同学尽快升级到HTTPS.如果你的app只支持iOS10,并且有用户可以自由输入网址进行浏览的功能，或者是在线视频音频播放功能的话，简单地加入<code>NSAllowsArbitraryLoadsInWebContent</code>并且将组件换成<code>WKWebKit</code>或者<code>AVFoundation</code>就可以了。如果你还需要支持ios9,并且需要访问网页和视频的话，可能只能开启<code>NSAllowsArbitraryLoads</code>然后提交的时候进行说明，并且看Apple审核员的脸色决定让不让通过了。除了<code>WKWebKit</code>以外，另外一个访问网页的选择是使用<code>SFSafariViewController</code>。因为其实<code>SFSafariViewController</code>就是一个独立于App的Safari进程，所以它完全不受ATS限制</p>

<p>另外，当<code>NSAllowsArbitraryLoads</code>和<code>NSAllowsArbitraryLoadsInWebContent</code>同时存在时，根据系统不同，表现的行为也会不一样，简单说，ios9只看<code>NSAllowsArbitraryLoads</code>,而ios10会先看<code>NSAllowsArbitraryLoadsInWebContent</code>.在ios10中，要是<code>NSAllowsArbitraryLoadsInWebContent</code>存在的话，就忽略掉<code>NSAllowsArbitraryLoads</code>,如果它不存在，则遵循<code>NSAllowsArbitraryLoads</code>的设定。</p>
]]></content>
  </entry>
  
</feed>
