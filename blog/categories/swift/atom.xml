<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-05-27T08:33:44+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift语法小技巧]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/26/swiftyu-fa-xiao-ji-qiao/"/>
    <updated>2016-05-26T15:09:59+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/26/swiftyu-fa-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<h3><a name="判断某个对象是否响应了某个方法"> 判断某个对象是否响应了某个方法</a></h3>

<!--more-->


<p>没有参数的:</p>

<pre><code>if(view.respondsToSelector(#selector(startAnimating))){

}
</code></pre>

<p>一个参数的:</p>

<pre><code> if(self.modeView.respondsToSelector(#selector(hideAnimated(_:)))){

 }
</code></pre>

<p>多个参数的:</p>

<pre><code> if(self.modeView.respondsToSelector(#selector(setProgress(_:animated:)))){

 }
</code></pre>

<p>第一个参数用<code>_</code>，第二个先参数名字，中间没有逗号</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-构造函数]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu/"/>
    <updated>2016-05-16T15:38:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<p>本章包含的内容的如下:</p>

<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E8%B5%8B%E5%80%BC">存储属性的初始赋值</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">自定义构造过程</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8">默认构造器</a></li>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%90%86">值类型的构造器代理</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">类的集成和构造过程</a></li>
<li><a href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8">可失败构造器</a></li>
<li><a href="#%E5%BF%85%E8%A6%81%E6%9E%84%E9%80%A0%E5%99%A8">必要构造器</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E6%88%96%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">通过闭包或函数设置属性的默认值</a></li>
</ul>


<!--more-->


<p>构造过程是使用类，结构体或枚举型的实例之前的准备过程。在新实例可用钳必须执行这个过程，具体操作包括设置实例中的每个存储属性的初始值和执行其他必须的设置或初始化工作</p>

<p>通过定义构造器(Initializers)来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与Objc中的构造器不同，Swift的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>

<p>类的实例也可以通过定义析构器(deinitializer)在实例释放前执行特定的清除工作。</p>

<h2><a name="存储属性的初始赋值">存储属性的初始赋值</a></h2>

<p>类和结构体在创建实例时，必须为所有的存储属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>

<p>你可以在构造器中为存储属性赋初值，也可以在定义属性时为其设置默认值。以下小节详细讨论这两个方法。</p>

<blockquote><p><em>注意</em>
当你为存储型属性设置默认值或者在构造器中为期赋值时，它们的值是被直接设置的，不会触发任何属性观察期(property observers)</p></blockquote>

<h3>构造器</h3>

<p>构造器在创建某个特定类型的新实例时被调用。它的最简单形式类似于一个不带任何参数的实例方法，以关键字init命名:</p>

<pre><code>init(){
  //在此执行构造过程
}
</code></pre>

<p>下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit,它拥有一个<code>double</code>类型的存储型属性 temperature:</p>

<pre><code>struct Fahrenheit{
  var temperature:Double
  init(){
    temparture = 32.0
  }
}

var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// 输出 "The default temperature is 32.0° Fahrenheit”
</code></pre>

<p>这个结构体定义了一个不带参数的构造器init,并在里面将存储属性temperature 的值初始化为32</p>

<h3>默认初始值</h3>

<p>如前所述，你可以在构造器中为存储型属性设置初始化，同样，你也可以在属性声明时为其设置默认值</p>

<blockquote><p><em>注意</em>
如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的。只不过使用默认值让属性的初始化和声明结合的更紧密。使用默认值能让你的构造器更简洁，更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器，构造器继承等特性</p></blockquote>

<p>你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值:</p>

<pre><code>struct Fahrenheit{
  var temperature = 32.0
}
</code></pre>

<h2><a name="自定义构造过程">自定义构造过程</a></h2>

<p>你可以通过输入参数可可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。</p>

<h3>构造参数</h3>

<p>自定义构造过程时，可以在定义中提供构造函数，指定所需值的类型和名字。构造参数的功能和语法跟函数的方法的参数相同。</p>

<p>下面例子中定义了一个包含摄氏温度的结构体<code>Celsius</code>.它定义了两个不同的构造器:init(fromFahrenheit:)和init(fromKelvin:),两者分别通过接受不同温标下的温度值来创建新的实例:</p>

<pre><code>struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0”
</code></pre>

<p>第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit;第二个构造器也拥有一个构造函数，其外部名字为 fromKelvin,内部名字为 kelvin.这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性temperatureInCelsius中</p>

<h3>参数的内部名称和外部名称</h3>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要工作构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift会为构造器的每个参数自动生成一个跟内部名字相同的外部名.</p>

<p>以下例子中定义了一个结构体Color,它包含了三个常量:<code>red</code>,<code>green</code>和<code>blue</code>.这些属性可以存储在0-1之间的值，用来表示红绿蓝成分的含量</p>

<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造函数，Color也可以提供第二个狗奥奇，它只包含名为white的double类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>

<pre><code>struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
</code></pre>

<p>两种构造器都能用于创建一个新的color实例，你需要为构造器每个外部参数传入值:</p>

<pre><code>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)
</code></pre>

<p>注意,如果不通过外部参数名子传值，你是没法调用这个构造器的，只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误:</p>

<pre><code>let veryGreen = Color(0.0, 1.0, 0.0)
// 报编译时错误，需要外部名称
</code></pre>

<h4>不带外部名的构造参数</h4>

<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为.</p>

<p>下面是之前的Celsius例子的扩展，跟之前相比添加了一个带有double类型参数的构造器，其外部名用_代替:</p>

<pre><code>struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0
</code></pre>

<p>调用Celsius(37.0)意图明确，不需要外部参数名称。以此适合使用
<code>Celsius(37.0)</code>这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。</p>

<h3>可选属性类型</h3>

<p>如果你你定制的类型包含一个逻辑上允许取值为空的存储性属性 &ndash; 无论是因为它无法再初始化时赋值，还是因为它在之后某个时间点可以赋值为空&ndash;你都需要将它定为可选类型(optional type).可选类型的属性将自动初始化为nil,表示这个属性是有意在初始化时设置为空的。</p>

<p>下面的例子中定义了类<code>SurveyQuestion</code>,它包含了一个可选字符串属性response:</p>

<pre><code>class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// 输出 "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
</code></pre>

<p>迪奥哈问题的答案在回答前是无法确定的，因此我们将属性response声明为string?类型，或者说是可选字符串类型，当<code>SurveyQuestion</code>实例化时，它将自动赋值为nil,表明此字符串暂时还没有值</p>

<h3>构造过程中的属性修改</h3>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量尚需经被赋值，它将永远不可更改。</p>

<blockquote><p><em>注意:</em>
对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</p></blockquote>

<p>你可以修改上面的SurveyQuestion实例，用常量属性替代变量属性text,表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值</p>

<pre><code>class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// 输出 "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
</code></pre>

<h2><a name="默认构造器">默认构造器</a></h2>

<p>如果结构体或类的所有属性都有默认值，同事没有自定义的构造器，那么Swift会给这些结构体或类提供一个默认的构造器(default initalilizers)。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>

<p>下面例子中创建了一个类ShoppingListItem,它封装了购物清单中的某一个物品的属性:名字，数量和购买状态</p>

<pre><code>class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</code></pre>

<p>由于ShoppingListItem类中所有属性都有默认值，且它没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器，上面例子中使用默认构造创造了一个ShoppingListItem类的实例，并将其赋值给变量 item</p>

<h3>结构起的逐一成员的构造器</h3>

<p>除了上面提到的默认构造器，如果结构起没有提供自定义的构造器，他们将自动获得一个逐一成员构造器，及时结构天气的存储型尚需经没有默认值。</p>

<p>逐一成员构造器是用来初始化结构体新实例成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值</p>

<p>下面例子中定义了结构体size,包含两个属性width和height。swift可以根据这两个属性的初始赋值0自动推导出他们的类型为double</p>

<p>结构体size自动获得了一个逐一成员构造器init(width:height:)。你可以用它来为size创建新的实例:</p>

<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</code></pre>

<h2><a name="值类型的构造器代理">值类型的构造器代理</a></h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程成为构造器代理，它能减少多个构造器间的代码重用。</p>

<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>

<p>对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init</p>

<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员的构造器）。这种限制可以防止你为值类型增加了一个额外的且十分负载的构造器之后，仍然有人错误的使用自动生成的构造器</p>

<blockquote><p><em>注意</em>
如果你希望默认构造器，逐一成员构造器以及你自己的自定义的构造器都能用来创建实例，可以将自定义的构造器写到扩展中，而不是写在值类型的原始定义中。</p></blockquote>

<p>下面的例子将定义一个结构体 rect,用来代表几何矩形。这个例子需要两个辅助的结构体Size和point,它们各自为其所有的属性提供了默认值0</p>

<pre><code>struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
</code></pre>

<p>你可以通过以下三种方式为Rect创建实例&ndash;使用被初始化为默认值的origin和Size属性来初始化；提供指定的origin和size实例来初始化；提供指定的center和size来初始化。在下面Rect结构体定义中，我们为这三种方式提供了三个自定义的构造器:</p>

<pre><code>struct Rect {
    var origin = Point()
    var size = Size()

    init(){

    }

    init(origin:Point,size:Size){
        self.origin = origin
        self.size = size
    }

    init(center:Point,size:Size){
        let originX = center.x - (size.width/2)
        let originY = center.y - (size.height/2)
        self.init(origin: Point(x: originX, y: originY), size: size)

    }
}
</code></pre>

<p>第一个Rect构造器init(),在功能上跟没有自定义构造器自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号{}来表示，它没有指定任何构造过程。调用这个构造器将返回一个Rect实例，它的origin和size属性都是用定义时的默认值Point(x: 0.0, y: 0.0)和Size(width: 0.0, height: 0.0)：</p>

<pre><code>let basicRect = Rect()
// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)
</code></pre>

<p>第二个Rect构造器init(origin:size:)，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单的将origin和size的参数值赋给对应的存储性属性:</p>

<pre><code>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)
</code></pre>

<p>第三个Rect构造器init(center:size:)稍微复杂一点。它先通过center和size的值计算出origin的坐标，然后再调用init(origin:size:)构造器来将新的origin和size值赋值到对应的属性中:</p>

<pre><code>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)
</code></pre>

<p>构造器init(center:size:)可以直接将origin和size 的新值赋值到对应的属性中。然而，利用恰好提供了相关功能的现有构造器会更为方便，构造器init(center:size:)的意图也会更加清晰</p>

<h2><a name="类的集成和构造过程">类的集成和构造过程</a></h2>

<p>类里面的所有存储性属性&ndash;包括所有继承自父类的属性&ndash;都必须在构造过程中设置初始值</p>

<p>Swift为类类型提供了两种构造器来确保实例中所有存储性属性都能获得初始值，它们分别是指定构造器和便利构造器</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链上调用父类的构造器来实现父类的初始化</p>

<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>

<p>便利构造器(convenience initializers)是类中比较次要的，辅助性的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或者特定输入值的实例</p>

<p>你应当只在必要的时候为类提供便利构造器，比方或某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造郭恒更清晰明了</p>

<h3>指定构造器和便利构造器的语法</h3>

<p>类的指定构造器的写法跟值类型简单构造器一样:</p>

<pre><code>init(parameters) {
    statements
}
</code></pre>

<p>便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开：</p>

<pre><code>convenience init(parameters) {
    statements
}
</code></pre>

<h3>类的构造器代理规则</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift采用以下三条规则来限制构造器之间的代理调用:</p>

<ul>
<li>规则1 指定构造器必须调用其直接父类的指定构造器</li>
<li>规则2 便利构造器必须调用同一类中定义的其它构造器</li>
<li>规则3 便利构造器必须最终导致一个指定构造器被调用</li>
</ul>


<p>一个更方便记忆的方式是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p>这些规则可以通过下面的图例来说明:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation01_2x.png" alt="init" /></p>

<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到 规则2和3.而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则1</p>

<blockquote><p><em>注意</em>
这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类定义如何实现。</p></blockquote>

<p>下图中展示了一种涉及四个类的更复杂的类层次结构。它演示了指定构造器是如何在类层次中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation02_2x.png" alt="te" /></p>

<h3><a name="两段式构造过程">两段式构造过程</a></h3>

<p>Swift中类的构造过程包含两个阶段。第一个阶段，每个存储属性被引入它们的类指定一个初始值。当每个存储性属性的初始值被确定后，第二个阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储性属性。</p>

<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>

<blockquote><p><em>注意</em>
Swift的两段时构造过程跟Objective-C中的构造过程类似。最主要的区别在于阶段1，Objective-C给每一个属性赋值0或空值(比如说0或nil)。Swift的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</p></blockquote>

<p>Swift编译器将执行4种有效的安全检查，已确保两段式构造过程能不出错地完成：</p>

<p><em>安全检查1</em></p>

<p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类的构造器</p>

<p>如上所述，一个对象的内存只有在其所有存储性苏醒确定之后次啊能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>

<p><em>安全检查2</em></p>

<p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>

<p><em>安全检查3</em></p>

<p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中的其它指定构造器所覆盖</p>

<p><em>安全检查4</em></p>

<p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</p>

<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例会成为有效实例，才能访问属性和调用方法。</p>

<p>以下是两段式构造过程中基于上述安全检查的构造流程展示:</p>

<p><em>阶段1</em></p>

<ul>
<li>某个指定构造器或便利构造器被调用</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化</li>
<li>这个调用父类的构造器的过程沿着构造器链一直往上执行，知道到达构造器链的最顶层</li>
<li>当到达了构造器链的最顶部，且已确保所有势力包含的存储型属性都已经赋值，这个实例的内存被认为已经完成初始化。此时阶段1完成</li>
</ul>


<p><em>阶段2</em></p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self.修改它的属性并调用实例方法等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self</li>
</ul>


<p>下图展示了在假定的子类和父类之间的构造阶段1</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization01_2x.png" alt="1" /></p>

<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>

<p>如安全检查1所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程</p>

<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>

<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完成初始化，阶段1完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization02_2x.png" alt="2" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例。</p>

<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作。
最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作</p>

<h3>构造器的继承和重写</h3>

<p>跟Objc中的子类不同，Swift中的子类默认情况下不会继承父类的构造器。Swift的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>

<blockquote><p><em>注意</em></p>

<p>父类的构造器仅会在安全和适当的情况下被继承</p></blockquote>

<p>假如你希望自定义的子类中能提供一个或多个父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>

<p>当你编写与一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code>修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符。</p>

<p>正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>

<blockquote><p><em>注意</em>
当你重写了父类的指定构造器时，你总是需要写override修饰符，即使你的子类的指定构造器重写为了便利构造器</p></blockquote>

<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>

<p>在下面的例子中定义了一个叫做<code>Vehicle</code>的基类。基类中声明了一个存储型属性<code>numberOfWheels</code>,它是值为0的Int类型的存储型属性。numberOfWheel属性用于创建名为descrpiption的<code>String</code>类型的计算型属性:</p>

<pre><code>class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}
</code></pre>

<p><code>Vehicle</code>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器，自动获得的默认构造器总会是类中的指定构造器，它可以用于创建numberOfWheels为0的Vehicle实例:</p>

<pre><code>let vehicle = Vehicle()
print("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
</code></pre>

<p>下面例子中，定义了Vehicle的子类Bicycle:</p>

<pre><code>class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
</code></pre>

<p>子类<code>Bicycle</code>定义了一个自定义的指定构造器init(),这个指定构造器和父类的指定构造器匹配，所以<code>Bicycle</code>中的指定构造器需要带上override修饰符</p>

<p><code>Bicycle</code>的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类<code>Vechicle</code>的默认构造器，这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被<code>Vehicle</code>类初始化。在调用super.init()之后，属性<code>numberOfWheels</code>的原值被新值2替换。</p>

<p>如果你创建了<code>Bicycle</code>实例，你可以调用继承的<code>description</code>计算型属性去查看属性<code>numberOfWheels</code>是否有改变:</p>

<pre><code>let bicycle = Bicycle()
print("Bicycle: \(bicycle.description)")
// Bicycle: 2 wheel(s)
</code></pre>

<blockquote><p><em>注意</em></p>

<p>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性</p></blockquote>

<h3>构造器的自动继承</h3>

<p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>

<p>假如你为子类中引入的所有新属性都提供了默认值，以下2个规则适用：</p>

<p><em>规则1</em></p>

<p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器</p>

<p><em>规则2</em></p>

<p>如果子类提供了所有父类指定构造器的实现&ndash;无论是通过规则1继承过来的，还是提供了自定义实现&ndash;它将自动继承所有父类的便利构造器。</p>

<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用</p>

<blockquote><p><em>注意</em>
对于规则2，子类可以将父类的指定构造器实现为便利构造器</p>

<p><em>总结:</em></p>

<p>如果子类继承父类，在子类的构造器中，如果是继承的属性，则先调用<code>super.init(...)</code>方法，先让父类完成属性初始化，然后再对继承的属性赋值;</p>

<p>如果子类中独有的属性，则先完成子类属性的初始化，再调用父类的<code>super.init(...)</code>方法</p></blockquote>

<h3>指定构造器和便利构造器实践</h3>

<p>接下来的例子将在实践中展示知道你给构造器，便利构造器以及构造器的自动继承。这个例子定义了包含三个类<code>Food</code>,<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示他们的构造器是如何相互作用的。</p>

<p>类层次中的基类是Food,它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建<code>Food</code>实例:</p>

<pre><code>class Food {
    var name:String
    init(name:String){
     self.name = name
    }

    convenience init(){
        self.init(name:"[Unnamed]")
    }
}
</code></pre>

<p>下图中展示了<code>Food</code>的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample01_2x.png" alt="1" /></p>

<p>类类型没有默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例:</p>

<pre><code>let namedMeat = Food(name: "Bacon")
// namedMeat 的名字是 "Bacon”
</code></pre>

<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保<code>Food</code>实例的所有存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造过程。</p>

<p>Food类同样提供了一个没有参数的便利构造器init().这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理指定构造器<code>init(name: String)</code>并给参数name传值[unnamed]来实现:</p>

<pre><code>let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</code></pre>

<p>类层级中的第二类是Food的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了Int类型的属性<code>quantity</code>（以及从Food继承过来的name属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例:</p>

<pre><code>class RecipeIngredient: Food {
    var quantity:Int
    init(name:String,quantity:Int){
        self.quantity = quantity
        super.init(name:name)
    }

    override convenience init(name:String){
        self.init(name:name,quantity: 1)
    }
}
</code></pre>

<p>下图中展示了<code>RecipeIngredient</code>类的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample02_2x.png" alt="1" /></p>

<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来填充<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quanity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的尚需经。随后，构造器向上代理到父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足 <a href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">两段式构造过程中</a> 的安全检查1</p>

<p><code>RecipeIngredient</code>还定义了一个便利构造器 <code>init(name: String)</code>，它只通过 <code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为1，所以不需要显式指明数量即可创建出实例。</p>

<p>这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个<code>quantity</code>为1的<code>RecipeIngredient</code>实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并且为quantity参数传递1.</p>

<p>注意,<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>,因此必须在前面使用override修饰符</p>

<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>

<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器init().这个便利构造器会被<code>RecipeIngredient</code>继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是Food提供的版本。</p>

<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例:</p>

<pre><code>let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</code></pre>

<p>类层级中的第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>,这个类构建了购物单中出现的某一种调味料。</p>

<p>购物单中每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code>引入了布尔类型的属性<code>purchased</code>,它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>,它提供了关于<code>ShoppingListItem</code>实例的一个文字描述:</p>

<pre><code>class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
</code></pre>

<blockquote><p><em>注意:</em></p>

<blockquote><p><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p></blockquote></blockquote>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>

<p>下团展示了这三个类的构造器链:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample03_2x.png" alt="1" /></p>

<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例:</p>

<pre><code>var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x orange juice ✔
// 1 x bacon ✘
// 6 x eggs ✘
</code></pre>

<p>如上所述，例子中通过字面量方式创建了一个数组<code>breakfastList</code>，它包含了三个
<code>ShoppingListItem</code>实例，因此数组的类型也能被自动推导为<code>[ShoppingListItem]</code>.在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从[unnamed]更改为 <code>orange juice</code>，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>

<h2><a name="可失败构造器">可失败构造器</a></h2>

<p>如果一个类，结构起或枚举类型的对象，在构造过程中有可能失败，则为其定义个可失败的构造器。这里所指的<code>失败</code>是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或者是不满足某种必要的条件等。</p>

<p>为了妥善处理这种构造过程中可能会失败的情况，你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在init关键字后面添加问号(init?).</p>

<blockquote><p><em>注意:</em></p>

<p><b > 可失败构造器的参数名和参数类型，不能为其它非可失败构造器的参数名，及其参数类型相同 </b></p></blockquote>

<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过<code>return nil</code>语句来表明可失败构造器在何种情况下应该<code>失败</code>。</p>

<blockquote><blockquote><p><strong>注意</strong></p>

<p><a >严格来说，构造器都不支持返回值。以为构造器本身的租用，只是为了确保对象能被正确构造。因此你只是用<code>return nil</code>表明可失败构造器构造失败，而不要用关键字return来表明构造成功 </a></p></blockquote></blockquote>

<p>下例中，定义了一个名为<code>Animal</code>的结构体，其中有一个名为<code>species</code>的String类型的常量属性。同时该结构体还定义了一个接受一个名为<code>species</code>的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code>属性被赋值，构造成功。</p>

<pre><code>struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
</code></pre>

<p>你可以通过该可失败的构造器来创建一个Animal的实例，并检查构造过程是否成功。</p>

<pre><code>let someCreature = Animal(species: "Giraffe")
// someCreature 的类型是 Animal? 而不是 Animal

if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
// 打印 "An animal was initialized with a species of Giraffe"
</code></pre>

<p>如果你给改可失败构造器传入一个空字符串作为参数，则会导致构造失败:</p>

<pre><code>let anonymousCreature = Animal(species: "")
// anonymousCreature 的类型是 Animal?, 而不是 Animal

if anonymousCreature == nil {
    print("The anonymous creature could not be initialized")
}
// 打印 "The anonymous creature could not be initialized"
</code></pre>

<blockquote><p><strong>注意</strong></p>

<p><p style="color:red;text-align:left;font-family:Arial;font-style:normal;"> 空字符串（如"&ldquo;,而不是"Giraffe"）和一个值为nil的可选类型的字符串是两个完全不同的概念。上例中的空字符串(&rdquo;&ldquo;)其实是一个幼小的，非可选类型的字符串。这里我们只所以让Animal的可失败构造器失败，只是因为对于<code>Animal</code>这个类的<code>species</code>属性来说，它更适合有一个具体的值，而不是空字符串。</p></p></blockquote>

<h3>枚举类型的可失败构造器</h3>

<p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>

<p>下例中，定义了一个名为<code>TemperatureUnit</code>的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据<code>Character</code>值找出所对应的枚举成员的可失败构造器:</p>

<pre><code>enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .Kelvin
        case "C":
            self = .Celsius
        case "F":
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
</code></pre>

<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员匹配时，则构造失败:</p>

<pre><code>let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h3>带原始值的枚举类型的可失败构造器</h3>

<p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue:)</code>，该可失败构造器有一个名为<code>rawvalue</code>的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败.</p>

<p>因此上面的<code>TemperatureUnit</code>的例子可以重写为:</p>

<pre><code>enum TemperatureUnit: Character {
    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</code></pre>

<h3>构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其它可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>

<p>无论是向上代理还是横向代理，如果你代理的其它可失败构造器触发构造失败，整个构造过程将立即停止，接下来的任何构造代码不会再被执行。</p>

<blockquote><p><em>注意:</em></p>

<p><b style="font-style:normal">
可失败构造器也可以代理到其它的非可失败构造器，通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中
</b></p></blockquote>

<p>下面的例子中，定义了一个名为<code>CartItem</code>的<code>Product</code>类的子类，这个类建立了一个在线购物车中的物品的模型，它有一个名为<code>quantity</code>的常量存储型属性，并确保该属性的值至少为1:</p>

<pre><code>class Product {
    let name: String
    init?(name: String) {   
        if name.isEmpty { return nil }
        self.name = name
    }
}

class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity &lt; 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
</code></pre>

<p><code>CartItem</code>可失败构造器首先验证接收的<code>quantity</code>值是否大于等于1.倘若<code>quantity</code>值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样滴，<code>Product</code>的可失败构造器首先检查name值，假如<code>name</code>值为空字符串，则构造器立即执行失败。</p>

<p>如果你通过传入一个非空字符串name以及一个值大于等于1的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么构造方法能够成功被执行：</p>

<pre><code>if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// 打印 "Item: sock, quantity: 2”
</code></pre>

<p>倘若你以一个值为0的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么将导致<code>CartItem</code>构造器失败:</p>

<pre><code>if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Unable to initialize zero shirts")
}
// 打印 "Unable to initialize zero shirts”
</code></pre>

<p>同样滴，如果你尝试传入一个值为空字符串的name来创建一个<code>CartItem</code>实例，那么将导致父类<code>Product</code>的构造过程失败:</p>

<pre><code>if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Unable to initialize one unnamed product")
}
// 打印 "Unable to initialize one unnamed product”
</code></pre>

<h3>重写一个可失败构造器</h3>

<p>如同其他的构造器，你可以在子类中重写父类的可失败构造器，或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>

<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包</p>

<blockquote><p><em>注意</em></p>

<p><b style="font-style:normal">
你可以用非可失败构造器重写可失败构造器，但反过来却不行
</b></p></blockquote>

<p>下例中定义了一个名为<code>Document</code>的类，name属性的值必须为一个非空字符串或nil,但不能是一个空字符串:</p>

<pre><code>class Document {
    var name: String?
    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
    init() {}
    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}
</code></pre>

<p>下面的这个例子，定义了一个<code>Document</code>类的子类<code>AutomaticallyNamedDocument</code>。这个子类重写了父类的两个指定构造器，确保了无论使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串。生成的实例中的name属性总有初始"Untitled"；</p>

<pre><code>class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
</code></pre>

<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器<code>init(name:)</code>重写父类的课失败构造器(init?(name:))。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>

<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如：下面的<code>UntitledDocument</code>子类的name属性的值总是"untitled"，它在构造过程中使用了父类的可失败构造器init?(name:)</p>

<pre><code>class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}
</code></pre>

<p>在这个例子中，如果在调用父类的可失败构造器init?(name:)时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误</p>

<h3>可失败构造器 init!</h3>

<p>通常来说我们通过在init关键字后添加问号的方式(init?)来定义一个可失败构造器，但你也可以通过在init后面添加感叹号的方式来定义一个可失败构造器(init!)，该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>

<p>你可以在init?中代理到init!,反之亦然。你也可以用init?重写init!,反之亦然。你还可以用init代理到init!,不过一旦init!构造失效，则会触发一个断言。</p>

<h2><a name="必要构造器">必要构造器</a></h2>

<p>在类的构造器前添加<code>required</code>修饰符表明所有该类的子类都必须实现该构造器:</p>

<pre><code>class SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<p>在子类重写父类的必要构造器时，必须在子类的构造前也添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符:</p>

<pre><code>class SomeSubclass: SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</code></pre>

<blockquote><p><em>注意</em></p>

<p><a style="font-style:normal">
如果子类继承的构造器能满足必要构造器的要求，则无需在子类中显式提供必必要构造器的实现。
</a></p></blockquote>

<h2><a name="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</a></h2>

<p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用必要或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的必要或函数会被调用，而它们的返回值会当做默认值赋值给这个属性，</p>

<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>

<p>下面介绍了如何用闭包为属性提供默认值:</p>

<pre><code>class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</code></pre>

<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉Swift立即执行此比好。如果你忽略了这对括号，相当于将闭包本省作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal"></p>

<p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化，这意味着你不能在闭包里访问其它属性，即使这些属性都有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用任何实例方法
</a></p></blockquote>

<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘:</p>

<pre><code>struct Checkerboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...8 {
            for j in 1...8 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
    }()
    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
        return boardColors[(row * 8) + column]
    }
}
</code></pre>

<p>没当一个新的<code>Checkerboard</code>实例被创建时，赋值闭包会被执行，<code>boardColors</code>的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组<code>temporaryBoard</code>中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到<code>boardColors</code>中，并可以通过工具函数
<code>squareIsBlackAtRow</code>来查询:</p>

<pre><code>let board = Checkerboard()
print(board.squareIsBlackAtRow(0, column: 1))
// 打印 "true"
print(board.squareIsBlackAtRow(7, column: 7))
// 打印 "false"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义AsyncDisplayKit-Node]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node/"/>
    <updated>2016-04-26T15:13:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchy.png" alt="node" /></p>

<p>假设你已经读过<a href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/">AsyncDisplayKit入门</a>,下面我们将继续介绍AsyncDisplayKit.</p>

<!--more-->


<p>这篇教程将解释如何充分利用框架探索AsyncDisplayKit节点的层次结构，通过这样做，你将会更加熟悉AsyncDisplayKit这个有名的框架，并且会使你的app程序异常平滑，同时能够构建灵活的和可重用的ui</p>

<p>这AsyncDisplayKit中一个核心概念就是<code>node</code>,正如你所知，AsyncDisplayKit nodes 是一个线程安全的抽象于UIview之上的，（UIview不是线程安全的）,你可以学习更多AsyncDisplayKit在<a href="http://asyncdisplaykit.org/">AsyncDisplayKit’s Quick Start introduction</a></p>

<p>好消息是你已经知道了UIKit,那么你已经了解AsyncDisplayKit一些属性和方法了，因为API是很相似的。随后，你将会学到:</p>

<ul>
<li>如何去创建你自己的 AsDisplayNode</li>
<li>如何嵌套一个node到一个单个Node容器中，并且管理和重用</li>
<li>如何用一个Node层次结构支持View的层次结构，因为你自动减少在主线程绘制的机会，保持你的界面平滑和响应</li>
</ul>


<p>下面是你将要做的：你将要创建一个容器Node,并且添加两个子Node-其中一个是图片node,其中一个是文本node,你将会看到容器是如何测量他们的子Node尺寸和大小的.最后，你将会转化一个已经存在的UIview容器为一个ASDisplaytNode子类。</p>

<p>效果图如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt="node" /></p>

<h2>开始</h2>

<p>这个app,你将要创建一个卡片展示世界上一个奇观-泰姬陵</p>

<p>下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Starter.zip">开始工程</a></p>

<p>这个工程只有一个ViewController,这个工程是用 cocoaPods构建的，所以你必须安装 pods,然后创建 Podfile,引入 AsyncDisplayKit.</p>

<blockquote><p><em>注意</em>
如果你不了解 Pods,请学习<a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2">Introduction to CocoaPods Tutorial</a></p></blockquote>

<p>打开  ViewController.swift，然后注意到这个view controller只有一个常量<code>card</code>,它保存了一个泰姬陵的模型对象，你将会使用这个模型创建一个卡片的node去展示。</p>

<p>编译运行工程，你将会看到一个空的黑色屏幕
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-1-281x500.jpg" alt="logo" /></p>

<h2>创建并且显示一个容器Node</h2>

<p>现在你要开始构建你的第一个Node层次结构，它是非常相似的和创建一个UIview的层次结构</p>

<p>打开 Wonders-Bridging-Header.h，然后添加如下代码:</p>

<pre><code>#import &lt;AsyncDisplayKit/ASDisplayNode+Subclasses.h&gt;
</code></pre>

<p><code>ASDisplayNode+Subclasses.h</code>是AsDisplayNode的一个内部方法，你需要在<code>ASDisplayNode</code>子类中实现这个header中定义的方法，但是你只能调用这些方法在你的 ASDisplayNode的子类中，这是和<code>UIGestureRecognizer</code>模式很相似的。</p>

<p>打开CardNode.swift，然后添加ASDisplayNode子类实现:</p>

<pre><code>class CardNode: ASDisplayNode {}
</code></pre>

<p>定义了一个新的ASDisplayNode子类，你将会把它作为一个容器去处理用户的交互</p>

<p>打开ViewController.swift,在viewDidLoad()中实现如下:</p>

<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  // Create, configure, and lay out container node
  let cardNode = CardNode()
  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
  let origin = CGPointZero
  let size = CGSize(width: 100, height: 100)
  cardNode.frame = CGRect(origin: origin, size: size)
  // Create container node’s view and add to view hierarchy
  view.addSubview(cardNode.view)
}
</code></pre>

<p>上面的代码创建了一个新的卡片node,它定位在左上角并且高宽都是100.
不用担心之前的约束，你将会定位到中心在这个view controller中。</p>

<p>编译运行 ：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-2-281x500.jpg" alt="logo" /></p>

<p>太好了！你已经有了一个自定义的node在屏幕上显示，下一步是给你的子node取名为 <code>CardNode</code>,并且计算它的尺寸。在view中居中这是必须要知道的，你应该理解node布局引擎的工作原理。</p>

<h2>Node布局引擎</h2>

<p>下一步是询问Node去计算自己的尺寸通过调用<code>measure(constrainedSize:)</code>,你将会通过方法中constrainedSize参数去告诉node去计算一个尺寸去适应constrainedSize</p>

<p>通俗的说,这意味着计算大小不能大于限制大小。例如,考虑下面的图
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_measure.png" alt="logo" /></p>

<p>这个展示了一个约束的尺寸使用确定的宽度和高度，这个计算尺寸是和宽度相等的，但是比高度要小，它可能和宽度和高度都相等，或者比宽度和高度都要小，但是宽度和高度都不允许比约束的尺寸要大。</p>

<p>这个工作和UIView&rsquo;s<code>sizeThatFits(size:)</code>方法很相似。但是不同之处在于<code>measure(constrainedSize:)</code>计算它的尺寸，允许你访问缓存
node的calculatedSize属性。</p>

<p>一个例子就是当计算的高度和宽度的尺寸比约束尺寸更小的时候：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_constrained2.png" alt="lgo" /></p>

<p>这里图片的尺寸是更小比约束的尺寸，没有任何的sizing-to-fit，这里计算的尺寸比约束尺寸更小。</p>

<p>原因就是AsyncDisplayKit经常需要花费时间去计算尺寸，读取一个图片从硬盘中，可能会非常慢，通过合并尺寸到nodeApi,这个是线程安全的操作，这意味着计算尺寸可以在后台线程中运行！优雅的！它是一个有用的特性让你的UI程序平滑如黄油一般。</p>

<p>一个Node将会运行计算尺寸加入它没有存储值的话，假如这个约束尺寸提供是不同的，约束尺寸常常决定缓存的计算大小。</p>

<p>在程序中，工作如下:</p>

<ul>
<li>measure(constrainedSize:)返回一个存储你的尺寸或者进行一个计算尺寸通过调用calculateSizeThatFits(constrainedSize:)</li>
<li>你替换所有的尺寸计算通过<code>calculateSizeThatFits(constrainedSize:)</code>在你的ASDisplayNode子类中</li>
</ul>


<blockquote><p><em>注意</em>
calculateSizeThatFits(constrainedSize:)是ASDisplayNode的内部方法，你不应该在外部调用它</p></blockquote>

<h2>测量Node的大小</h2>

<p>现在是时候测量你的自己的node大小了。</p>

<p>打开CardNode.swift,然后替换这个类中的代码:</p>

<pre><code>class CardNode: ASDisplayNode {

  override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
    return CGSize(width: constrainedSize.width * 0.2, height: constrainedSize.height * 0.2)
  }

}
</code></pre>

<p>到现在为止，这个方法返回的大小是约束提供尺寸的20%.</p>

<p>打开ViewController.swift,删除viewDidLoad() 中的实现，然后实现下面的<code>createCardNode(containerRect:)</code>方法:</p>

<pre><code>/* Delete this method

override func viewDidLoad() {
  super.viewDidLoad()
  // 1
  let cardNode = CardNode()
  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
  let origin = CGPointZero
  let size = CGSize(width: 100, height: 100)
  cardNode.frame = CGRect(origin: origin, size: size)

  // 2
  view.addSubview(cardNode.view)
}
*/

func createCardNode(#containerRect: CGRect) -&gt; CardNode {
  // 3
  let cardNode = CardNode()
  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
  cardNode.measure(containerRect.size)

  // 4
  let size = cardNode.calculatedSize
  let origin = containerRect.originForCenteredRectWithSize(size)
  cardNode.frame = CGRect(origin: origin, size: size)
  return cardNode
}
</code></pre>

<p>上面的代码做的工作如下:</p>

<ol>
<li>删除之前创建的代码，配置和布局代码</li>
<li>删除之前的代码，把node加入到view的层次结构中</li>
<li>createCardNode(containerRect:) 创建了一个卡片Node使用相同的背景颜色和容器node,它用作一个容器去约束卡片node的大小，所以这个卡片Node不能比containerRect’的尺寸更大</li>
<li>通过originForCenteredRectWithSize(size:) 方法设置卡片到中心位置。</li>
</ol>


<p>定位到createCardNode(containerRect:) 这个方法，替换viewDidLoad():</p>

<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  let cardNode = createCardNode(containerRect: UIScreen.mainScreen().bounds)
  view.addSubview(cardNode.view)
}
</code></pre>

<p>当视图加载的时候，createCardNode(containerRect:)创建一个新的CardNode,这个卡片的Node不能比主屏幕的bounds尺寸更大。</p>

<p>在这个观点中，这个ViewController的视图还没有加载出来，因此，它不是安全的对用于ViewContrller的bounds尺寸。所以你使用主屏幕的尺寸去约束卡片Node的大小。</p>

<p>运行起来，尽管达不到优雅，因为这个视图控制器横跨了整个屏幕，稍后，我们将添加适当的方法，现在，它工作还可以。</p>

<p>编译运行，你将会看到你的node在正中心了.
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>异步节点设置和布局</h2>

<p>有时它会花费人们很多时间去解析复杂的层次结构，假如这是在主线程发生，这将会阻塞主线程，假如你想取悦用户的话，你不能让用户一直等待，之前用户是不能和程序有任何交互的。</p>

<p>因为这个原因，你将会在后台线程创建设置nodes，这样你能避免阻塞主线程。</p>

<p>在createCardNode(containerRect:)和viewDidLoad():中实现addCardViewAsynchronously(containerRect:)</p>

<pre><code>func addCardViewAsynchronously(#containerRect: CGRect) {
  dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)) {
    let cardNode = self.createCardNode(containerRect: containerRect)
    dispatch_async(dispatch_get_main_queue()) {
      self.view.addSubview(cardNode.view)
    }
  }
}
</code></pre>

<p><code>addCardViewAsynchronously(containerRect:)</code>创建这个<code>CardNode</code>在一个线程队列中，这是很好的，因为nodes是线程安全的！创建好之后，配置这个Node,然后异步调用主线程把Node添加到视图控制器中&ndash;毕竟，UIKit不是线程安全的！</p>

<blockquote><p><em>注意</em>
一旦你创建了Node的视图，所有访问node的节点只在主线程</p></blockquote>

<p>重新实现viewDidLoad()通过调用<code>addCardViewAsynchronously(containerRect:):</code></p>

<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
}
</code></pre>

<p>这将不再阻塞主线程，确保用户界面是可以随时响应的。</p>

<p>编译运行，和之前一样，不过所有的操作都是在后台线程执行的</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>约束节点大小</h2>

<p>记得之前我你会使用一个更优雅的解决方案节点不仅仅依靠屏幕尺寸的大小
?现在我来兑换我的诺言</p>

<p>打开 ViewController.swift，添加下面的属性：</p>

<pre><code>var cardViewSetupStarted = false
</code></pre>

<p>然后替换viewDidLoad()为viewWillLayoutSubviews():</p>

<pre><code>/* Delete this method
override func viewDidLoad() {
  super.viewDidLoad()
  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
}
*/

override func viewWillLayoutSubviews() {
  super.viewWillLayoutSubviews()
  if !cardViewSetupStarted {
    addCardViewAsynchronously(containerRect: view.bounds)
    cardViewSetupStarted = true
  }
}
</code></pre>

<p>替换掉了住屏幕的尺寸，这上面的逻辑是视图控制器的尺寸去约束卡片的尺寸。</p>

<p>现在它是线程安全的,去用这个视图控制器的尺寸，当viewWillLayoutSubviews()替换调viewDidLoad()。这一次在这个声明周期中，这个视图控制器已经设置好了它的尺寸。</p>

<p>这种加载方式是很出众的，因为一个视图控制器能被设置任何尺寸,你不想依赖视图控制器去横跨整个屏幕</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/screen_size_tyranny.png" alt="log" /></p>

<p>这个视图可能会加载多次，所以viewWillLayoutSubviews()能被调用多次，你仅仅想创建这个CardNode一次，所以这就是为什么你需要一个cardViewSetupStarted标识去证明这个视图控制创建多次。</p>

<p>编译运行：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>Node层次结构</h2>

<p>现在你有一个空的Node容器在屏幕上，现在你想展示一些内容，方式的就是你添加一些子node到这个Node容器中，下面的结构图展示了简单的Node结构图</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_Nodes.png" alt="node" /></p>

<p>添加子Node看起来将会非常像你在UIview中添加子View的过程。</p>

<p>第一步你需要添加一个图片的node,但是首先你的需要了解容器Node是如何布局子Node的。</p>

<h2>子Node的布局</h2>

<p>你现在知道了如何去测量容器的尺寸和如何去计算容器尺寸去布局容器内的node视图，但是这个容器node是如何布局它们的子Node呢？</p>

<p>有以下两步:</p>

<ol>
<li>第一，你测量每个子Node的尺寸在<code>calculateSizeThatFits(constrainedSize:).</code>中，这将确保每一个子Node都缓存一个计算好的尺寸</li>
<li>在UIKIt的主线程布局中，AsyncDisplayKit将会调用<code>layout()</code>在你的自定义的ASDisplayNode子类中，<code>layout()</code>的工作就像UIview的 <code>layoutSubivews()</code>，除了这个<code>layout()</code>不会计算所有子视图的尺寸，布局()简单查询计算每个节点的大小</li>
</ol>


<p>回到UI上，这个泰姬陵卡片尺寸将会和它的图片大小一样，并且这个标题将会适合它的大小。最简单的方式就是去测量这个<code>泰姬陵图片</code>node的大小并且使用这个结果去约束文本node的尺寸，所以这个文本node将会适合图片尺寸的大小</p>

<p>接下来，你将要使用lay out去布局你的卡片子Node,让我们开始</p>

<h2>添加一个子Node</h2>

<p>打开CardNode.swift,然后添加下面的代码在CardNode</p>

<pre><code>// 1
let imageNode: ASImageNode

// 2
init(card: Card) {
  imageNode = ASImageNode()
  super.init()
  setUpSubnodesWithCard(card)
  buildSubnodeHierarchy()
}

// 3
func setUpSubnodesWithCard(card: Card) {
  // Set up image node
  imageNode.image = card.image
}

// 4
func buildSubnodeHierarchy() {
  addSubnode(imageNode)
}
</code></pre>

<p>上面的代码做的工作如下:</p>

<ol>
<li>图片Node属性:这行代码添加一个图片Node的属性，去引用卡片图像的子Node</li>
<li>初始化:这个设计的初始化使用一个卡片模型保存卡片的图像和文本</li>
<li>设置子Node:这个方法使用卡片模型的图像去保存开始项目中的子Node图片</li>
<li>容器层次结构:你设置Node的层次结构就像你能设置视图的层次结构一样，这个方法创建卡片的层次结构通过添加一个子Node来实现。</li>
</ol>


<p>下一步，实现calculateSizeThatFits(constrainedSize:):</p>

<pre><code>override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
  // 1 
  imageNode.measure(constrainedSize)

  // 2 
  let cardSize = imageNode.calculatedSize

  // 3 
  return cardSize
}
</code></pre>

<p>上面的代码做的工作如下:</p>

<ol>
<li>这个卡片的尺寸就会匹配背景图片的大小，这个测量背景图片的尺寸会适合内嵌的约束尺寸，所有Node的子类都会被AsyncDisplay框架感知并且知道如何设置它们的尺寸，包括AsImageNode</li>
<li>这行代码临时存储图片计算的尺寸，特别说明的是，它使用图片Node测量尺寸正如卡片Node尺寸去约束子NOde，当添加更多的子Node的时候，你将会使用这个值</li>
<li>返回这个卡片Node的计算好的尺寸</li>
</ol>


<p>下一步，覆盖layout():</p>

<pre><code>override func layout() {
  imageNode.frame =
    CGRect(origin: CGPointZero, size: imageNode.calculatedSize).integerRect
}
</code></pre>

<p>这个图片的逻辑位置在左上角，坐标轴原点，它也确保了这个图片Node的frame没有任何多余的值，所以你能避免像素边界显示问题</p>

<p>注意这个方法是如何使用图片的Node去缓存计算尺寸的在布局的过程中。</p>

<p>因为这个图片Node的尺寸决定了卡片Node的尺寸，这个图片将会横跨这个卡片</p>

<p>回到ViewController.swift，然后添加一个createCardNode(containerRect:), 替换到之前初始化的<code>CardNode</code>：</p>

<pre><code>let cardNode = CardNode(card: card)
</code></pre>

<p>这行代码使用新的初始化去添加一个卡片Node,这个卡片值将会在初始化的时候被传入，并且存储这个泰姬陵的卡片模型</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-6-281x500.jpg" alt="t" /></p>

<p>漂亮，你成功的创建了容器Node并且呈现了Node的层次结构，当然，这个很简单，但是它是一个完成的Node层次！</p>

<h2>添加更多的子Node</h2>

<p>也许你已经注意到了，没有添加标题，不用担心，让我们开始添加吧。</p>

<p>打开CardNode.swift，然后添加下面的属性titleTextNode在类中：</p>

<pre><code>let titleTextNode: ASTextNode
</code></pre>

<p>在<code>init(card:)</code>方法中初始化<code>titleTextNode</code>，在super.init()这行代码之前:</p>

<pre><code>titleTextNode = ASTextNode()
</code></pre>

<p>添加下面的这行代码在<code>setUpSubnodesWithCard(card:):</code></p>

<pre><code>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(card.name)
</code></pre>

<p>这行代码给titleTextNode设置了富文本内容，<code>attributedStringForTitleText(text:)</code>是一个帮助方法被加到了NSAttributedString扩展属性中。在之前的开始工程中，它创建了富文本使用提供的标题。</p>

<p>下一步，在<code>buildSubnodeHierarchy():</code>的结尾增加如下代码:</p>

<pre><code>addSubnode(titleTextNode)
</code></pre>

<p>要确保它是在添加到图片Node的后面，不然图片将会遮盖住标题。</p>

<p>在内置的方法<code>calculateSizeThatFits(constrainedSize:)</code>中，添加如下代码:</p>

<pre><code>titleTextNode.measure(cardSize)
</code></pre>

<p>使用子Node的测量尺寸来作为卡片的约束尺寸</p>

<p>添加如下的布局代码layout():</p>

<pre><code>titleTextNode.frame =
  FrameCalculator.titleFrameForSize(titleTextNode.calculatedSize, containerFrame: imageNode.frame)
</code></pre>

<p>这行代码计算标题Node的frame通过工具方法FrameCalculator</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-281x500.jpg" alt="test" /></p>

<p>至此，你已经构建了完整的子Node层次结构，使用了容器Node,并且添加了两个子Node</p>

<h2>完整工程</h2>

<p><a href="https://github.com/TLSwiftDemo/Wonders/archive/master.zip">完整工程在这里下载</a></p>

<p>have fun 😀~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsynDisplayKit入门篇]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/"/>
    <updated>2016-04-15T10:22:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>FaceBook的Paper团队给我们开源了一个很棒的库:<a href="https://github.com/facebook/AsyncDisplayKit">AsynDisplayKit</a>,这个库能让你通过将图像解码，布局以及渲染操作都放到后台线程处理，从而带来了快速响应的用户界面，也就是说不再会因为界面卡顿尔阻断用户交互。</p>

<!--more-->


<p>例如，对于非常复杂的界面，你可以使用 AsyncDisplayKit构建它而得到一种如丝般顺滑的，60帧每秒的滑动体验。而平常的UIkit优化就不太可能克服这样的性能挑战。</p>

<p>从本教程中，你将从一个初始项目开始，它主要有一个UICollectionView的滑动问题，而使用AysncDisplayKit将大大提供其滑动性能。一路上，你将学会如何在旧项目上使用AsyncDisplaykit.</p>

<blockquote><p><em>注意</em>，在本教程之前，你应该熟悉 Swift,Core Animation以及Core Graphics.</p></blockquote>

<h2>开始</h2>

<p>开始之前，请先看看<a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/">AsyncDisplayKit介绍</a>,对它有个简要的概念，知道它是解决什么问题的。</p>

<p>准备好了，就下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/04/Layers-Start.zip">开始项目</a>,你需要至少Xcode6.1和iosSDK 8.1来编译它，如果用最新Xcode打开，swift语法需要做下转换和修改，请自行解决这些兼容问题.</p>

<p>你要研究的项目是由UICollectionView制作的卡片式界面来描述不同的雨林动物，每张信息卡上包含了一个图片，名字以及一个队雨林动物的描述，卡片的背景图是主图片的模糊感，视觉上设计的效果保证了文字的清晰可读。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20141124/1416797117122129.png" alt="logo" />
在Xcode中，打开初始项目的 Layers.xcworkspace。</p>

<p>在本教程里，请遵循以下原则以体会AsyncDisplayKit的那些十分吸引人的好处。</p>

<p>将应用运行到真机上，在模拟器上很难看出性能改善。</p>

<p>应用是通用的，但在ipad上看起来最好。</p>

<p>最后，要真正感谢这个库为你所有的事情，请尽量在最旧的ios8.1的设备上去运行该应用，第三代的ipad最好，因为它随让是视网膜屏，但是运行的不是很快。</p>

<p>运行该项目，效果如下:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt="logo" /></p>

<p>试着滑动CollectionVie并注意那可怜的帧率，在第三代ipad上，帧率只有15-20FPS，实在丢掉太多帧了，在本教程的最后，你能在60 FPS的帧率下滑动它.</p>

<blockquote><p><em>注意</em>
你所看到的图像都是在App的asset目录里，并不是从网络里获取的。</p></blockquote>

<p>在一个旧项目中使用AsyncDisplayKit前，你应该通过Instruments测量你的UI的性能，这样才能有一个基准线以便对比改动的效果。</p>

<p>最重要的是，你要知道是CPU-绑定，还是GPU-绑定，也就是说是CPU还是GPU拉低了应用的帧率，这个信息会告诉你该充分利用AsyncDisplayKit的那个特性以优化应用的性能。</p>

<p>如果你有时间，看看之前提到的WWDC2012 session 或在真实的设备上使用Instruments来评估初始项目的时间曲线。滑动性能是CPU-绑定的，你能猜到是什么原因导致了 CollectionView 丢掉了这么多帧吗?</p>

<h2>为项目准备好使用 AsyncDisplayKit</h2>

<p>在旧项目里使用AsyncDisplayKit，总结起来就是使用 Display Node 层级结构替换视图层级结构或Layer树，各种Display Node是AsyncDisplayKit的关键所在，它们位于视图之上，而且是线程安全的，也就是说之前在主线程才能执行的任务现在也可以在非主线程中执行。这就是减少主线程的工作量以执行其它操作，例如处理触摸事件，或如下本应用的情况下，处理CollectionView的滑动。</p>

<p>这就意味着在本教程里，你的第一步是移除视图层级结构。</p>

<h3>移除视图的层次结构</h3>

<p>打开 RainForestCardCell.Swift并删除awakeFromNib() 中所有的 addSubview(&hellip;.)调用，然后得到如下:</p>

<pre><code>override func awakeFromNib() {
  super.awakeFromNib()
  contentView.layer.borderColor =
    UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
  contentView.layer.borderWidth = 1
}
</code></pre>

<p>接下来，替换LayoutSubviews()的内容如下:</p>

<pre><code>override func layoutSubviews() {
  super.layoutSubviews()
}
</code></pre>

<p>再讲configureCellDisplayWithCardInfo(cardInfo:)的内容替换如下:</p>

<pre><code>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
  //MARK: Image Size Section
  let image = UIImage(named: cardInfo.imageName)!
  featureImageSizeOptional = image.size
}
</code></pre>

<p>删除RainforestCardCell的所有视图属性，只留一个如下:</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  ...
}
</code></pre>

<p>最后编译运行，你看的的是黑洞洞的一片:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt="logo" /></p>

<p>现在所有的cell都空了，滑动起来就很顺滑，你的目标是保证之后添加完各个Node之后，依然顺滑如初。</p>

<h3>添加一个占位图</h3>

<p>打开RainforestCardCell.swift,给RainforestCardCell添加一个可选的 CALayer变量，名为placeholderLayer：</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  ...
}
</code></pre>

<p>你之所以需要一个占位图是因为显示会异步完成，如果这个过程需要一些时间，那用户就会看到空的cell 。就如同如果你要从网络上获取图像，那么就需要用占位图来填充Cell,这能让你的用户知道内容还没准备好。随让在我们这种情况下，你是在后台线程绘制而不是从网络上下载。</p>

<p>在awakeFromNib()里，删除contentView的border设置，再创建并配置一个placeholderLayer.将其添加到cell的contentview的layer上，现在这个方法如下:</p>

<pre><code>override func awakeFromNib() {
  super.awakeFromNib()

  placeholderLayer = CALayer()
  placeholderLayer.contents = UIImage(named: "cardPlaceholder")!.CGImage
  placeholderLayer.contentsGravity = kCAGravityCenter
  placeholderLayer.contentsScale = UIScreen.mainScreen().scale
  placeholderLayer.backgroundColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 1).CGColor
  contentView.layer.addSublayer(placeholderLayer)
}
</code></pre>

<p>在layoutSubviews()里，你需要布局placeholderLayer.替换这个方法为:</p>

<pre><code>override func layoutSubviews() {
  super.layoutSubviews()

  placeholderLayer?.frame = bounds
}
</code></pre>

<p>编译并运行，你从虚无的边缘回来了:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt="logo" /></p>

<p>普通的CALayer不是由UIview支持的，当它们改变frame时，默认会有隐式动画，这就是你看到layer在布局放大时，要修复这个问题，改动layoutSubviews()如下:</p>

<pre><code>override func layoutSubviews() {
  super.layoutSubviews()

  CATransaction.begin()
  CATransaction.setValue(kCFBooleanTrue, forKey: kCATransactionDisableActions)
  placeholderLayer?.frame = bounds
  CATransaction.commit()
}
</code></pre>

<p>编译运行，问题解决了。</p>

<p>现在占位图不会乱动，不再动画它们的frame了。</p>

<h2>第一个Node</h2>

<p>重建App的第一步就是给每一个UICollectionView cell 添加一个背景图片的Node,步骤如下:</p>

<ol>
<li>创建，布局并添加一个图像Node到UICollectionView cell</li>
<li>处理cell重用Node和它们的layer</li>
<li>模糊图像Node</li>
</ol>


<p>但在做之前，打开 Layers-Bridging-Header.h 并导入 AsyncDisplayKit :</p>

<pre><code>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;
</code></pre>

<p>这会让所有的Swift文件都能访问AsyncDisplayKit类库。</p>

<p>编译一下，确保没有错误</p>

<p>现在，我们来看看Collectin View的祖成:</p>

<ul>
<li>View Controller: RainforestViewController没有什么花哨的东西，它只是为所有的雨林卡片获取一个数据数组，并为UIcollectioNView实现DataSource.事实上，你不需要花太多时间在这个上</li>
<li>DataSource:大部分时间都将花在Cell类的RainforestCardCell上，ViewController出队每个cell，并将雨林卡片的数据用configureCellDisplayWithCardInfo(cardInfo:) 传给它。cell就使用这个数据来配置自身.</li>
<li>Cell: 在configureCellDisplayWithCardInfo(cardInfo:)里，cell创建，配置，布局以及添加Node到它自己身上。这就意味着每次ViewController出队一个cell,这个cell就会创建并添加它自己一个新的Node层级结构</li>
</ul>


<p>如果你使用View而不是Node，那么这样做对于性能来说就不是最佳策略。但因为你可以异步的创建，配置以及布局，而且Node也是异步地绘制，所以这不会是一个问题。真正的难点是在cell准备重用时取消任何在进行额异步操作并移除旧的node.</p>

<p>然而，在实际生产中，你最好使用ASRangeController来缓存你的Node,这样你就不用每次在cell重用时重建它的Node层级结构，ASRangeController超出了本教程的范围。</p>

<p>OK，动手!</p>

<h3>添加背景图片Node</h3>

<p>现在你要走一遍用Node配置cell的过程，一次一步：
打开RainforestCardCell.swift 并替换configureCellDisplayWithCardInfo(cardInfo:) 为:</p>

<pre><code>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
  //MARK: Image Size Section
  let image = UIImage(named: cardInfo.imageName)!
  featureImageSizeOptional = image.size

  //MARK: Node Creation Section
  let backgroundImageNode = ASImageNode()
  backgroundImageNode.image = image
  backgroundImageNode.contentMode = .ScaleAspectFill
}
</code></pre>

<p>这就创建并配置了一个ASImageNode常量，叫做backgroundImageNode.</p>

<p>AsyncDisplayKit带有好几种Node类型，包括ASImageNode，用于显示图片。它相当于UIImageView,除了ASImageNode是默认异步的解码图片。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 底部:</p>

<pre><code>backgroundImageNode.layerBacked = true
</code></pre>

<p>这让backgroundImageNode变为layer支持的Node.</p>

<p>Node可由UIview支持或CALayer支持，当node需要处理事件时（例如触摸事件），你就要使用UIView支持的Node.如果你不需要处理事件，只需要显示一下内容，那使用Layer支持的Node会更加轻量，因此可以获得一个小的性能提升。</p>

<p>因为本教程的APP不需要处理事件，所以你可以让所有的Node都设置为Layer支持的。在上面的代码中，由于backgroundImageNode为Layer支持的。AsyncDisplayKit会创建一个CALayer用于雨林动物图像内容的显示.</p>

<p>继续在 configureCellDisplayWithCardInfo(cardInfo:)添加如下代码:</p>

<pre><code>//MARK: Node Layout Section
backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)
</code></pre>

<p>这里使用FrameCalculator为backgroundImageNode布局.</p>

<p>FrameCalculator是一个帮助类，负责给每个Node布局。注意所有的东西都是手动布局的，没有使用AutoLayout约束。<strong>如果你需要构建自适应布局或者本地化驱动的布局，那就要注意，因为你不能给Node添加约束</strong></p>

<p>接下来，添加如下代码到configureCellDisplayWithCardInfo(cardInfo:)底部:</p>

<pre><code>//MARK: Node Layer and Wrap Up Section
self.contentView.layer.addSublayer(backgroundImageNode.layer)
</code></pre>

<p>这句将backgroundImageNode的layer添加到cell ContentView的layer上。</p>

<blockquote><p><strong>注意</strong>
AsyncDisplayKit会为backgroundImageNode创建一个Layer.然而，你必须要将Node放到某个Layer树中才能在屏幕上显示，这个Node会异步地绘制，所以直到绘制完成，它的内容都不会显示，尽管它的Layer已经在一个Layer树中。</p></blockquote>

<p>从技术的角度来说，layer一直都存在。但渲染图像是异步进行的。layer初始化时没有内容，一旦渲染完成，layer的contents就会更新为包含图像的内容。</p>

<p>在这个点，cell的contentView的layer将会包含两个Sublayer:一个占位图和Node的layer。在node完成绘制前，只有占位图会显示。</p>

<p>注意到configureCellDisplayWithCardInfo(cardInfo:)会在每次cell出队时被调用。每次cell被回收，这个逻辑会添加一个新的sublayer到cell的contentview layer上。不要担心，你很快会解决这个问题。</p>

<p>回到RainforestCardCell.swift开头，给RainforestCardCell添加一个ASImageNode变量存为属性backgroundImageNode，如下:</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  var backgroundImageNode: ASImageNode? ///&lt; ADD THIS LINE
  ...
}
</code></pre>

<p>你之所以需要这个属性是因为必须要有某个东西将backgroundImageNode的引用保留住，否则ARC就会将其释放，也就不会有任何东西显示出来了&ndash;即使Node的在一个layer树中，你依然需要保留Node.</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:)底部的Node Layer and Wrap Up Section ,设置cell新的backgroundImageNode为之前的backgroundImageNode：</p>

<pre><code>self.backgroundImageNode = backgroundImageNode
</code></pre>

<p>下面是完整的configureCellDisplayWithCardInfo(cardInfo:) 方法：</p>

<pre><code>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
  //MARK: Image Size Section
  let image = UIImage(named: cardInfo.imageName)!
  featureImageSizeOptional = image.size

  //MARK: Node Creation Section
  let backgroundImageNode = ASImageNode()
  backgroundImageNode.image = image
  backgroundImageNode.contentMode = .ScaleAspectFill
  backgroundImageNode.layerBacked = true

  //MARK: Node Layout Section
  backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)

  //MARK: Node Layer and Wrap Up Section
  self.contentView.layer.addSublayer(backgroundImageNode.layer)
  self.backgroundImageNode = backgroundImageNode
}
</code></pre>

<p>编译运行，观察AsyncDisplaytKit是如何异步地使用图像设置Layer的Contents的。这能让你在CPU还在绘制layer的内容的同事上下滑动页面。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>如果你运行在旧设备上，注意图像是如何弹出到位置&ndash;这是爆米花效果，但不总是让人喜欢。本教程的最后一节将会搞定这个不令人愉快的弹出效果，给你展示图像如何弹入弹出，如同摇滚巨星。</p>

<p>如同之前所讨论的，新的Node会在每次cell被重用时创建，这并不理想，因为这意味着新的Layer会在每次cell被重用时加入。</p>

<p>如果你想看看Sublayer堆积太多的影响，那就不停的滑上滑下，然后加断点打印出cell的contentview的Layer的sublayers属性。你会看到很多layer,这不好.</p>

<h2>处理cell重用</h2>

<p>继续RainforestCardCell.swift,给RainforestCardCell 添加一个contentLayer的CALayer属性，这个属性也是一个可选类型:</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  var backgroundImageNode: ASImageNode?
  var contentLayer: CALayer? ///&lt; ADD THIS LINE
  ...
}
</code></pre>

<p>你将使用此属性去移除Cell的ContentView的Layer树中旧的Node Layer.虽然你可以简单地保留Node并访问其Layer属性，但上面的写法更加明确。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 结尾：</p>

<pre><code>self.contentLayer = backgroundImageNode.layer
</code></pre>

<p>这句让backgroundImageNode的Layer保留到contentLayer属性。</p>

<p>替换prepareForReuse()的实现如下:</p>

<pre><code>override func prepareForReuse() {
  super.prepareForReuse()
  backgroundImageNode?.preventOrCancelDisplay = true
}
</code></pre>

<p>因为AsyncDisplaytKit能够异步地绘制Node,所以Node让你能预防从头绘制或取消任何在进行的绘制。无论是你需要预防或取消绘制，都可将preventOrcancelDisplay设置为true,如上面的代码所示，在本来中，你要在cell被重用前取消任何正在进行的绘制活动.</p>

<p>接下来，添加如下代码到prepareForReuse（）尾部:</p>

<pre><code>contentLayer?.removeFromSuperlayer()
</code></pre>

<p>这将contentLayer从其SuperLayer(也就是contentview的Layer)中移除.</p>

<p>每次一个cell被回收时，这个代码就移除Node的旧Layer,因而解决了堆积问题。所以在任何时间，你的Node最多只有两个sublayer:占位图和Node的Layer.</p>

<p>接下来添加如下代码到prepareForReuse()尾部:</p>

<pre><code>contentLayer = nil
backgroundImageNode = nil
</code></pre>

<p>这确保cell释放它们的引用，这样如有必要，ARC才好做清理工作。</p>

<p>编译运行，这次，没有sublayer会堆积的问题，且所有不必要的绘制都将被取消.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>是时候来点模糊效果了!
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/asyncscroll.png" alt="blue" /></p>

<h2>模糊图像</h2>

<p>要实现模糊图像，你要添加一个额外的步骤到图像Node的显示过程里。</p>

<p>继续RainforestCardCell.swift ,在configureCellDisplayWithCardInfo(cardInfo:) 的设置backgroundImageNode.layerBacked 的后面，添加如下代码:</p>

<pre><code>backgroundImageNode.imageModificationBlock = { input in
  if input == nil {
    return input
  }
  if let blurredImage = input.applyBlurWithRadius(
    30,
    tintColor: UIColor(white: 0.5, alpha: 0.3),
    saturationDeltaFactor: 1.8,
    maskImage: nil, 
    didCancel:{ return false }) {
      return blurredImage
  } else {
    return image
  }
}
</code></pre>

<p>ASImageNode的imageModificationBlock给你一个积水在显示之前去处理底层的图像，这是非常实用的功能，它让你对图像Node做一些操作，例如添加滤镜等。</p>

<p>在上面的代码中，你使用imageModificationBlock来为cell的背景图像应用模糊效果。关键点就是图像Node将会绘制它的内容并在后台执行这个闭包，而主线程依然顺滑流畅。这个闭包接受原始的UIImage并返回一个修改过的UIimage.</p>

<p>上面的代码使用了UIImage的模糊category,它由Apple在WWDC2013提供。使用了Accelerate framework 在CPU上模糊图像。因为模糊会消耗很多时间和内存，这个版本的category被修改为包含了取消机制。这个模糊方法将定期调用didCancel闭包来决定是否应该停止模糊。</p>

<p>现在，上面的代码给didCancel简单地返回false,之后你可以重写didCancel闭包.</p>

<blockquote><p><em>注意</em>
还记得第一次运行APP时collectionView那可怜的滑动效果吗？模糊方法阻塞了主线程。通过使用AsyncDisplayKit将模糊放入后台线程，你就大幅度地提高了CollectionView的滑动性能。简直天壤之别。</p></blockquote>

<p>编译并运行，观察模糊效果:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="lgo" />
注意你可以非常流畅的滑动页面了</p>

<p>当Collectionview出队一个cell时，一个模糊操作将开始后台线程，当用户快速滑动时，CollectionView会重用每个cell多次，并开始许多模糊操作。我们的目标是在cell准备重用时取消正在进行中的模糊操作。</p>

<p>你已经在prepareForReuse()里取消了Node的绘制操作，但一旦控制被移交给处理你图像修改的闭包，那就是你的责任来处理Node的preventOrCancelDisplay的设置。</p>

<h2>取消模糊操作</h2>

<p>要取消进行中的模糊操作，你需要实现模糊方法的didCancel闭包.</p>

<p>添加一个捕获列表到imageModificationBlock以捕捉一个backgroundImageNode的weak引用:</p>

<pre><code>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
   ...
}
</code></pre>

<p>你需啊哟weak引用来避免闭包和图像Node之间的循环引用问题。你将使用这个weak  backgroundImageNode 来确定是否要取消模糊操作。</p>

<p>是时候构建模糊取消碧波啊了。添加如下代码到imageModificationBlock:</p>

<pre><code>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
  if input == nil {
    return input
  }

  // ADD FROM HERE...
  let didCancelBlur: () -&gt; Bool = {
    var isCancelled = true
    // 1
    if let strongBackgroundImageNode = backgroundImageNode {
      // 2
      let isCancelledClosure = {
        isCancelled = strongBackgroundImageNode.preventOrCancelDisplay
      }

      // 3
      if NSThread.isMainThread() {
        isCancelledClosure()
      } else {
        dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)
      }
    }
    return isCancelled
  }
  // ...TO HERE

  ...
}
</code></pre>

<p>下面解释一下这些代码：</p>

<ol>
<li>得到backgroundImageNode的Strong引用，准备其干活。如果backgroundImageNode在本次运行时小时，那么isCancelled将保持为true,然后模糊操作会被取消，如果没有Node需要显示，自然没有必要继续模糊操作。</li>
<li>在此你将操作取消检查包在闭包里，因为一旦Node创建它的Layer或View，那就只能在主线程访问Node的属性。由于你需要访问preventOrCancelDisplay，所以你必须在主线程检查。</li>
<li>最后，确保isCancelledClosure是在主线程进行，无论是在主线程直接运行，还是不再主线程而通过dispatch_sync来调度。它必须是一个同步的调度，因为我们需要闭包完成，并在didCancelblue闭包返回之前设置isCancelled.</li>
</ol>


<p>在调用applyBlurWithRadius(&hellip;)中，修改传递给didCancel的参数，替换一直返回false的闭包为你刚才定义并保留在didCancelBlur的闭包。</p>

<pre><code>if let blurredImage = input.applyBlurWithRadius(
  30,
  tintColor: UIColor(white: 0.5, alpha: 0.3),
  saturationDeltaFactor: 1.8,
  maskImage: nil,
  didCancel: didCancelBlur) {
  ...
}
</code></pre>

<p>编译运行，你看你不会注意到太多差别，但现在任何在cell离开屏幕时还未完成的模糊都会被取消了。这就意味着设备比之前做的更少。你可能观察到轻微的性能提升，特别是在较慢的设备如第三代iPad上运行。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<p>你的卡片需要内容，通过下面四个小节，你将学会:</p>

<ul>
<li>创建一个容器Node,它将所有的SubNode绘制到一个单独的CALayer里</li>
<li>构建一个Node层次结构</li>
<li>创建一个自定义的ASDispalyNode子类，并在后台构建并布局Node层次结构</li>
</ul>


<p>做完这些，你就会得到一个看起来和添加AsyncDisplayKit之前一样的APP，但有着黄油版顺滑的滑动体验。</p>

<h2>栅格化的容器Node</h2>

<p>直到现在，你一直在操作cell内的一个单独的Node，接下来，你将创建一个容器Node，它会包含所有卡片内容。</p>

<h3>添加一个容器Node</h3>

<p>继续 RainforestCardCell.swift,在 configureCellDisplayWithCardInfo(cardInfo:) 的backgroundImageNode.imageModificationBlock后面以及Node Layout Section前面添加如下代码：</p>

<pre><code>//MARK: Container Node Creation Section
let containerNode = ASDisplayNode()
containerNode.layerBacked = true
containerNode.shouldRasterizeDescendants = true
containerNode.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
containerNode.borderWidth = 1
</code></pre>

<p>这就创建并配置了一个叫做containerNode的ASDisplayNode常量。注意这个容器的shouldRasterizeDescendants,这是一个关于节点如何工作的提示以及一个如何让它们工作的更好的机会.</p>

<p>如单词<code>descendants (子孙)</code>所暗示的，你可以创建 AsyncDisplayKit Node的层次结构或树，就如你可以创建Core Animation Layer 的层次结构一样。例如，如果你有一个都是Layer支持的Node层级结构，那么AsyncDisplaykit将会为每个Node创建一个分离的CALayer,Layer层次结构将会和Node层级结构一样，如同镜像。</p>

<p>这听起来很熟悉：它类似于当你使用UIkit时，Layer层次结构镜像于View层次结构。然而，这个Layer的栈有一些不同的效果。</p>

<p>首先，因为是异步渲染，你就不会看到每个layer一个接一个的显示，当AsyncDisplayKit绘制完成每个layer，它马上制作layer的显示内容，所以如果你有一个layer的绘制比其他layer耗时更长，那么它将会在它们之后显示。用户会看到零碎的layer组件，这个过程通常是不可见的，因为Core Animation会在显示任何东西之前重绘所有必须的Layer。</p>

<p>第二，有需要Layer能够引起性能问题。每个CALayer都需要一个支持存储来保存它的像素位图和内容。同样，CoreAnimation必须将每个Layer通过XPC发给渲染服务器。最后，渲染服务器可能需要重绘一些Layer以复合它们，例如在混合layer时，总的来说，更多的Layer意味着CoreAnimation更多的工作。所以限制layer使用的数量有许多不同的好处。</p>

<p>为了解决这个问题，AsyncDisplayKit有一个方便的特性，它允许你绘制一个Node层次结构到一个单独的Layer容器里。这就是shouldRasterizeDescendants所做的，当你设置它，那在完成素有的subnode的绘制之前，ASDisplayNode将不会设置Layer的Contents。</p>

<p>所以在之前的步骤里，设置容器Node的shouldRasterizeDescendants为true有两个好处:</p>

<ol>
<li>它确保卡片一次显示所有的Node，如同旧的同步绘制</li>
<li>而且它通过栅格化Layer栈为单个Layer并较少未来的合成而提高了效率</li>
</ol>


<p>不足之处是，由于你将所有的layer放入了一个位图，你就不能再之后单独动画某个Node了。</p>

<p>接下来，在 Container Node Creation Section后，添加backgroundImageNode为containerNode的subnode:</p>

<pre><code>//MARK: Node Hierarchy Section
containerNode.addSubnode(backgroundImageNode)
</code></pre>

<blockquote><p><em>注意</em>
添加Node的顺序很重要，就如同subview和sublayer,最先添加的Node会被之后添加的阻挡显示</p></blockquote>

<p>替换 Node Layout Section 的第一行为：</p>

<pre><code>//MARK: Node Layout Section
containerNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)
</code></pre>

<p>最后，使用FrameCalculator布局backgroundImageNode:</p>

<pre><code>backgroundImageNode.frame = FrameCalculator.frameForBackgroundImage(
  containerBounds: containerNode.bounds)
</code></pre>

<p>这设置backgroundImageNode填满整个containerNode.</p>

<p>你几乎完成了新的Node层次结构，但首先你需要正确地设置Layer层次结构，因为容器Node现在是根。</p>

<h3>管理容器Node的Layer</h3>

<p>在Node Layer and Wrap Up Section，将backgroundImageNode的Layer添加到containerNode的layer上，而不是containerView的Layer上:</p>

<pre><code>// Replace the following line...
// self.contentView.layer.addSublayer(backgroundImageNode.layer)
// ...with this line:
self.contentView.layer.addSublayer(containerNode.layer)
</code></pre>

<p>删除下面的backgroundImageNode保留:</p>

<pre><code>self.backgroundImageNode = backgroundImageNode
</code></pre>

<p>因为cell只需要单独保留容器Node,所以你要移除backgroundImageNode属性。</p>

<p>不再设置cell的contentLayer属性为backgroundImageNode的Layer,现在将其设置为containerNode的layer：</p>

<pre><code>// Replace the following line...
// self.contentLayer = backgroundImageNode.layer
// ...with this line:
self.contentLayer = containerNode.layer
</code></pre>

<p>给RainforestCardCell添加一个可选的ASDisplayNode实例存储为属性containerNode:</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  var backgroundImageNode: ASImageNode?
  var contentLayer: CALayer?
  var containerNode: ASDisplayNode? ///&lt; ADD THIS LINE
  ...
}
</code></pre>

<p>记住你需要保留你自己的Node，如果你不怎么做它们就会被立即释放。</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:)，在Node Layer and Wrap Up Section 最后，设置containerNode属性为containerNode常量:</p>

<pre><code>self.containerNode = containerNode
</code></pre>

<p>编译运行，模糊的图形将会再次显示！但还有最后一件事要去改变，因为现在有了新的Node层次结构，回忆之前cell重用时你将图像停止显示。现在你需要让整个Node层次结构停止显示。</p>

<h3>在新的Node层次结构上处理cell重用</h3>

<p>继续RainforestCardCell.swift ，在prepareForReuse()里，替换设置backgroundImageNode.preventOrCancelDisplay 为在 containerNode 上调用 recursiveSetPreventOrCancelDisplay(&hellip;) 并传递 true：</p>

<pre><code>override func prepareForReuse() {
  super.prepareForReuse()

  // Replace this line...
  // backgroundImageNode?.preventOrCancelDisplay = true
  // ...with this line:
  containerNode?.recursiveSetPreventOrCancelDisplay(true)

  contentLayer?.removeFromSuperlayer()
  ...
}
</code></pre>

<p>当你要取消整个Node层次结构的绘制，就使用 recursiveSetPreventOrCancelDisplay()。这个方法将会设置这个node以及所有子Node的preventOrCancelDisplay属性，无论true或false。</p>

<p>接下来，依然在prepareForReuse(),用设置containerNode为nil替换设置backgroundImageNode为nil:</p>

<pre><code>override func prepareForReuse() {
  ...
  contentLayer = nil

  // Replace this line...
  // backgroundImageNode = nil
  // ...with this line:
  containerNode = nil
}
</code></pre>

<p>移除RainforestCardCell的backgroundImageNode属性:</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  // var backgroundImageNode: ASImageNode? ///&lt; REMOVE THIS LINE
  var contentLayer: CALayer?
  var containerNode: ASDisplayNode?
  ...
}
</code></pre>

<p>编译运行，这个APP就如之前一样，但现在你的图像Node在容器Node内，而重用依然和它应有的方式一样.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<h2>cell内容</h2>

<p>目前为止你有了一个Node层级结构，但容器内还只有一个Node&ndash;图像Node.现在是时候设置Node层次结构去复制在添加AsyncDisplayKit之前时应用的视图层次结构了。这意味着添加text和一个未模糊的特征图像。</p>

<h3>添加特征图像</h3>

<p>我们要添加特征图像了，它是一个未模糊的图像，显示在卡片的顶部。</p>

<p>打开RainforestCardCell.swift ，并找到configureCellDisplayWithCardInfo(cardInfo:).在Node Creation Section 底部，添加如下代码:</p>

<pre><code>let featureImageNode = ASImageNode()
featureImageNode.layerBacked = true
featureImageNode.contentMode = .ScaleAspectFit
featureImageNode.image = image
</code></pre>

<p>这会创建并配置一个叫做featureImageNode的ASImageNode常量。它被设置为Layer支持的，放大以适用，并设置显示图像，这次不需要模糊。</p>

<p>在Node Hierarchy Section的最后，添加featureImageNode为containerNode的subNode:</p>

<pre><code>containerNode.addSubnode(featureImageNode)
</code></pre>

<p>你正在用更多Node填充容器哦!</p>

<p>在Node Layout Section中，使用FrameCalculator布局featureImageNode：</p>

<pre><code>featureImageNode.frame = FrameCalculator.frameForFeatureImage(
  featureImageSize: image.size,
  containerFrameWidth: containerNode.frame.size.width)
</code></pre>

<p>编译运行，你就会看到特征图像在卡片的顶部出现，位于模糊图像的上方，注意特征图像和模糊图像是如何在同一时间跳出。这是你之前添加的shouldRasterizeDescendants在起作用.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0015.png" alt="logo" /></p>

<h2>添加Title文本</h2>

<p>接下来添加文字Label,以显示动物的名字和描述，首先来添加动物名字吧。</p>

<p>继续configureCellDisplayWithCardInfo(cardInfo:),找到Node Creation Section。添加下列代码到这节尾部，就在创建featureImageNode之后：</p>

<pre><code>let titleTextNode = ASTextNode()
titleTextNode.layerBacked = true
titleTextNode.backgroundColor = UIColor.clearColor()
titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(cardInfo.name)
</code></pre>

<p>这就创建了一个叫做titleTextNode的AsTextNode常量。</p>

<p>ASTextNode是另一个AsyncDisplayKit提供的Node子类，其用于显示文本。他是一个具有UIlabel效果的Node.它接受一个attributedString,由TextKit支持，有许多特性如文本链接，要学到更多关于这个Node的功能，去看ASTextNode.h吧。</p>

<p>初始羡慕包含一个NSAttributedString的扩展，它提供了一个工厂方法去生成一个属性字符串用于Title和Description文本以显示在雨林卡片上。上面的代码使用了这个扩展的attributedStringForTitleText(&hellip;) 方法。</p>

<p>现在在Node Hierarchy Section 底部，添加如下代码:</p>

<pre><code>containerNode.addSubnode(titleTextNode)
</code></pre>

<p>这就添加了titleTextNode到Node层次结构里，它将位于特征图像和背景图像智商，因为它在它们之后添加。</p>

<p>在Node Layout Section底部添加如下代码：</p>

<pre><code>titleTextNode.frame = FrameCalculator.frameForTitleText(
  containerBounds: containerNode.bounds,
  featureImageFrame: featureImageNode.frame)
</code></pre>

<p>一样使用FrameCalculator布局titleTextNode,就像backgroundImageNode和featureImageNode那样。</p>

<p>编译运行，你就有了一个title显示在特征图像的顶部。再次说明，Label只会在整个Cell准备好渲染时才渲染。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0017.png" alt="logo" /></p>

<h2>添加Description文本</h2>

<p>添加一个有着Description文本的Node和添加Title文本的Node类似.</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:),在 Node Creation Section 最后，添加如下代码。就在之前创建titleTextNode的语句之后:</p>

<pre><code>let descriptionTextNode = ASTextNode()
descriptionTextNode.layerBacked = true
descriptionTextNode.backgroundColor = UIColor.clearColor()
descriptionTextNode.attributedString = 
  NSAttributedString.attributedStringForDescriptionText(cardInfo.description)
</code></pre>

<p>这就创建并配置了一个叫做descriptionTextNode的AStextNode实例。</p>

<p>在 Node Hierarchy Section最后，添加descriptionTextNode到containerNode：</p>

<pre><code>containerNode.addSubnode(descriptionTextNode)
</code></pre>

<p>在 Node Layout Section,一样使用FrameCalculator布局descriptionTextNode：</p>

<pre><code>descriptionTextNode.frame = FrameCalculator.frameForDescriptionText(
  containerBounds: containerNode.bounds,
  featureImageFrame: featureImageNode.frame)
</code></pre>

<p>编译运行，现在你能看到Description文本了。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0018.png" alt="logo" /></p>

<h2>自定义Node子类</h2>

<p>目前为止，你使用了ASImageNode和AStextNode,但有些时候你需要自己定义Node,就如同某些时候在传统的UIKit编程里你需要自己的View一样。</p>

<h3>创建梯度Node类</h3>

<p>接下来，你将给GradientView.swift 添加Core Graphics 代码来构建一个自定义的梯度Display Node,这回被用于创建一个绘制梯度的自定义Node.梯度图会显示在特征图像的地步以便让Title看起来更加明显。</p>

<p>打开Layers-Bridging-Header.h，并添加如下代码</p>

<pre><code>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;
</code></pre>

<p>需要这一步是因为这个类没有包含在主头文件中，你在子类化任何ASDisplayNode或者_ASDisplayLayer时都需要访问这个类。</p>

<p>菜单 File\New\File… 。选择 iOS\Source\Cocoa Touch Class 。命名类为 GradientNode 并使其作为 ASDisplayNode 的子类。选择 Swift 语言并点击 Next 。保存文件再打开 GradientNode.swift 。</p>

<p>添加如下方法到这个类:</p>

<pre><code>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {

}
</code></pre>

<p>如同Uiview或者CALayer,你可以子类化ASDisplayNode去做自定义绘制。你可以使用如同用于UIView的Layer或单独的CALayer的绘制代码，这取决于客户Node如何配置Node.查看ASDisplayNode+Subclasses.h 获取更多关于子类化 ASDisplayNode 的信息。</p>

<p>进一步，ASDisplayNode的绘制方法比在UIView和CALayer里接受更多参数，给你提供方法少做工作，更有效率。</p>

<p>要为你的自定义DisplayNode填充内容，你需要实现来自<em>ASDisplayLayerDelegate协议的drawRect(&hellip;) 或 displayWithParameters(&hellip;)。在继续之前，看看 </em>ASDisplayLayer.h 得到这个方法和它们参数的信息。搜索_ASDisplayLayerDelegate。重点看看头文件注释里关于drawRect(..)的描述。</p>

<p>因为梯度图位于特征图的上方，使用Core Graphics 绘制，所以你需要使用drawRect.</p>

<p>打开GradientView.swift 并拷贝drawRect(&hellip;)的内容到GradientNode.swift 的drawRect(&hellip;)，如下：</p>

<pre><code>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
  let myContext = UIGraphicsGetCurrentContext()
  CGContextSaveGState(myContext)
  CGContextClipToRect(myContext, bounds)

  let componentCount: UInt = 2
  let locations: [CGFloat] = [0.0, 1.0]
  let components: [CGFloat] = [0.0, 0.0, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0]
  let myColorSpace = CGColorSpaceCreateDeviceRGB()
  let myGradient = CGGradientCreateWithColorComponents(myColorSpace, components,
    locations, componentCount)

  let myStartPoint = CGPoint(x: bounds.midX, y: bounds.maxY)
  let myEndPoint = CGPoint(x: bounds.midX, y: bounds.midY)
  CGContextDrawLinearGradient(myContext, myGradient, myStartPoint,
    myEndPoint, UInt32(kCGGradientDrawsAfterEndLocation))

  CGContextRestoreGState(myContext)
}
</code></pre>

<p>然后删除GradientView.swift,确保编译没有错误</p>

<h3>添加梯度Node</h3>

<p>打开RainforestCardCell.swift并找到configureCellDisplayWithCardInfo(cardInfo:)，在Node Creation Section底部，添加如下代码，就在创建descriptionTextNode的代码之后:</p>

<pre><code>let gradientNode = GradientNode()
gradientNode.opaque = false
gradientNode.layerBacked = true
</code></pre>

<p>这就创建了一个叫做gradientNode的GradientNode常量。</p>

<p>在Node Hierarchy Section，在添加featureImageNode那样下面，添加gradientNode到containerNode:</p>

<pre><code>//MARK: Node Hierarchy Section
containerNode.addSubnode(backgroundImageNode)
containerNode.addSubnode(featureImageNode)
containerNode.addSubnode(gradientNode) ///&lt; ADD THIS LINE
containerNode.addSubnode(titleTextNode)
containerNode.addSubnode(descriptionTextNode)
</code></pre>

<p>梯度Node需要这个位置才能在特征图之后，Title之下。</p>

<p>然后添加如下代码到Node Layout Section底部:</p>

<pre><code>gradientNode.frame = FrameCalculator.frameForGradient(
  featureImageFrame: featureImageNode.frame)
</code></pre>

<p>编译运行，你将看到梯度在特征图的底部，title确实看的更清楚了</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>爆米花特效</h2>

<p>如之前提到的，cell的Node内容会在完成绘制时“弹出”，这不是很理想，所以让我们继续，以修复这个问题，但首先，更加深入AsyncDisplayKit以看看它是怎么工作的。</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:) 的Container Node Creation Section，关闭容器Node的shouldRasterizeDescendants：</p>

<pre><code>containerNode.shouldRasterizeDescendants = false
</code></pre>

<p>编译运行，你会注意到现在容器层次结构里不同的Node一个接一个的弹出。你会看到文字弹出然后是特征图，然后是模糊背景图。</p>

<p>当shouldRasterizeDescendants关闭后，AsyncDisplayKit就不是绘制一个容器Layer了，它会创建一个镜像卡片Node层次结构的Layer数。记得爆米花特效存在是因为每个Layer都在它绘制结束后立即出现，而某些Layer比另外一个花费更多时间在绘制上。</p>

<p>这不是我们所需要的，但它描述了AsyncDisplayKit的工作方式，我们不想要这个行为，所以还是将shouldRasterizeDescendants打开：</p>

<pre><code>containerNode.shouldRasterizeDescendants = true
</code></pre>

<h2>在后台构造Node</h2>

<p>除了异步的绘制，使用AsyncDisplayKit,你同样可以异步地创建，配置以及布局。深呼吸一下，接下来开始做事情。</p>

<h3>创建一个Node构造操作(OPeration)</h3>

<p>你要讲Node层次结构的构造包装到一个NSOperation中，这样做很棒，因为这个操作能很容易的在不同的操作队列中执行，包括后台队列。</p>

<p>打开RainforestCardCell.swift ，然后添加如下方法：</p>

<pre><code>func nodeConstructionOperationWithCardInfo(cardInfo: RainforestCardInfo, image: UIImage) -&gt; NSOperation {
  let nodeConstructionOperation = NSBlockOperation()
  nodeConstructionOperation.addExecutionBlock { 
    // TODO: Add node hierarchy construction
  }
  return nodeConstructionOperation
}
</code></pre>

<p>绘制并不是唯一会拖慢主线程的操作，对于复杂的屏幕，布局计算也有可能变得昂退。目前为止，本教程当前状态的项目，一个缓慢的Node布局会引起Collectionview丢帧。</p>

<p>60FPS意味着你有大约17ms的时间让你的cell准备好显示，否则一个或者多个帧就会被丢掉。这在Table view和 collection view有很复杂的cell时时非常常见的，滑动时丢帧就是这个原因。</p>

<p>AsyncDisplayKit前来救援</p>

<p>你将使用上面的nodeConstructionOperation将所有Node层次结构以及布局从主线程剥离并放入后台NSOperatonQueue，进一步确保Collection view能尽量以接近60 fps的帧率滑动。</p>

<blockquote><p><em>注意</em>
你可以在后台访问并设置Node的属性，但只能在Node的Layer或View被创建之前，也就是当你第一次访问Node的Layer或View属性时。</p></blockquote>

<p>一旦Node的Layer或View被创建，你必须在主线程才能访问和设置Node的属性，因为Node将会转发这些调用到它的Layer或View.如果你得到一个崩溃log说“Incorrect display node thread affinity”,那就意味着在创建Node的Layer或View之后，你依然尝试在后台访问或设置Node的属性。</p>

<p>修改nodeConstructionOperation 操作Block的内容如下:</p>

<pre><code>nodeConstructionOperation.addExecutionBlock {
  [weak self, unowned nodeConstructionOperation] in
  if nodeConstructionOperation.cancelled {
    return
  }
  if let strongSelf = self {
    // TODO: Add node hierarchy construction
  }
}
</code></pre>

<p>在这个操作运行时，cell可能已经被释放了，在那种情况下，你不需要做任何工作。类似的，如果操作被取消了，那一样也没有工作要做了。</p>

<p>之所以对nodeConstructionOperation使用 unowner无主引用是为了避免在操作和执行必要之间产生循环引用。</p>

<p>现在找到configureCellDisplayWithCardInfo(cardInfo:)。将任何在Image Size Section之后的代码移动到nodeConstructionOperation的执行闭包里，将代码放在strongSelf的条件语句里，即 TODO的位置，之后configureCellDisplayWithCardInfo(cardInfo:)将开起来如下:</p>

<pre><code>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
  //MARK: Image Size Section
  let image = UIImage(named: cardInfo.imageName)!
  featureImageSizeOptional = image.size
}
</code></pre>

<p>目前，你会有一些编译错误，这是因为操作Block里的self是weak引用，因此是可选的。但你有一个self的strong引用，因为代码在可选绑定语句内。所以替换错误的几行成下面的样子:</p>

<pre><code>strongSelf.contentView.layer.addSublayer(containerNode.layer)
strongSelf.contentLayer = containerNode.layer
strongSelf.containerNode = containerNode
</code></pre>

<p>最后，添加如下代码到你刚改动的三行之下:</p>

<pre><code>containerNode.setNeedsDisplay()
</code></pre>

<p>编译确保没有错误。如果你现在运行，那么之后占位图会显示，因为Node的创建操作还没有实际使用。让我们来添加它</p>

<h3>使用Node创建操作</h3>

<p>打开 RainforestCardCell.swift 并添加如下属性：</p>

<pre><code>class RainforestCardCell: UICollectionViewCell {
  var featureImageSizeOptional: CGSize?
  var placeholderLayer: CALayer!
  var backgroundImageNode: ASImageNode?
  var contentLayer: CALayer?
  var containerNode: ASDisplayNode?
  var nodeConstructionOperation: NSOperation? ///&lt; ADD THIS LINE
  ...
}
</code></pre>

<p>这就添加了一个叫做nodeConstructionOperation可选属性。
当Cell准备回收时，你会使用这个属性取消Node的构造。这会在用户非常快速地滑动Collection View时发生，特别是如果布局还需要一些计算时间的话。</p>

<p>在prepareForReuse()添加如下指示的代码:</p>

<pre><code>override func prepareForReuse() {
  super.prepareForReuse()

  // ADD FROM HERE...
  if let operation = nodeConstructionOperation {
    operation.cancel()
  }
  // ...TO HERE

  containerNode?.recursiveSetPreventOrCancelDisplay(true)
  contentLayer?.removeFromSuperlayer()
  contentLayer = nil
  containerNode = nil
}
</code></pre>

<p>这就在cell重用时取消了操作，所以如果Node创建还没完成，它也不会完成。</p>

<p>现在找到 configureCellDisplayWithCardInfo(cardInfo:) ,并添加如下指示的代码:</p>

<pre><code>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
  // ADD FROM HERE...
  if let oldNodeConstructionOperation = nodeConstructionOperation {
    oldNodeConstructionOperation.cancel()
  }
  // ...TO HERE

  //MARK: Image Size Section
  let image = UIImage(named: cardInfo.imageName)!
  featureImageSizeOptional = image.size
}
</code></pre>

<p>这个Cell现在会在它准备重用并开始配置时，取消任何进行中的 Node构造操作。这确保了操作被取消，即使cell在准备重用前就被重新配置。</p>

<p>在主线程运行</p>

<p>AsyncDisplayKit允许你在非主线程做许多工作。但当它要面对UIKit和CoreAnimation时，你还是需要在主线程做。目前为止，你从主线程移走了所有的Node创建，但还有一件事需要被放在主线程&ndash;即设置coreAnimation的Layer层次结构。</p>

<p>在RainforestCardCell.swift里，找到nodeConstructionOperationWithCardInfo(cardInfo:image:) 并替换Node Layer and Wrap Up Section 为如下代码:</p>

<pre><code>// 1
dispatch_async(dispatch_get_main_queue()) { [weak nodeConstructionOperation] in
  if let strongNodeConstructionOperation = nodeConstructionOperation {
    // 2
    if strongNodeConstructionOperation.cancelled {
      return
    }

    // 3
    if strongSelf.nodeConstructionOperation !== strongNodeConstructionOperation {
      return
    }

    // 4
    if containerNode.preventOrCancelDisplay {
      return
    }

    // 5
    //MARK: Node Layer and Wrap Up Section
    strongSelf.contentView.layer.addSublayer(containerNode.layer)
    containerNode.setNeedsDisplay()
    strongSelf.contentLayer = containerNode.layer
    strongSelf.containerNode = containerNode
  }
}
</code></pre>

<p>下面描述一下:</p>

<ol>
<li>回忆当Node的Layer属性被第一个访问时，所有的Layer会被创建。这就是为何你必须运行Node Layer并在主线程包装小节，因此代码访问Node的Layer.</li>
<li>操作被检查以确定是否在添加Layer之前就已经取消了。在操作完成前，cell被重用或者重新配置，就很可能出现这样的情况，那你就不应该添加Layer了。</li>
<li>作为一个保险，确保Node当前的nodeConstructionOperation和调度闭包的操作是同一个NSOperation</li>
<li>如果containerNode的preventOrCancel是true就立即返回。如果构造操作完成，但node的绘制还没有被取消，你依然不想Node的layer现在在cell里</li>
<li>最后，添加Node的Layer到层次结构中，如果必要，这就创建Layer.</li>
</ol>


<p>编译确保没有错误</p>

<h3>开始Node创建操作</h3>

<p>你依然没有实际创建和开始操作，让我们开始吧</p>

<p>继续在RainforestCardCell.swift里，改变configureCellDisplayWithCardInfo(cardInfo:) 的方法签名为:</p>

<pre><code>func configureCellDisplayWithCardInfo(
  cardInfo: RainforestCardInfo,
  nodeConstructionQueue: NSOperationQueue)
</code></pre>

<p>这里添加了一个新的参数nodeConstructionQueue.它就是一个用于Node创建操作入队的NSOperationQueue.</p>

<p>在func configureCellDisplayWithCardInfo(
  cardInfo: RainforestCardInfo,
  nodeConstructionQueue: NSOperationQueue) 底部，添加如下代码:</p>

<pre><code>let newNodeConstructionOperation = nodeConstructionOperationWithCardInfo(cardInfo, image: image)
nodeConstructionOperation = newNodeConstructionOperation
nodeConstructionQueue.addOperation(newNodeConstructionOperation)
</code></pre>

<p>这就创建了一个Node构造操作，将其保留在nodeConstructionOperation属性，并将其添加到传入的队列。</p>

<p>最后打开 RainforestViewController.swift ，给RainforestViewController添加一个叫做nodeConstructionQueue 的初始化为常量的属性，如下:</p>

<pre><code>class RainforestViewController: UICollectionViewController {
  let rainforestCardsInfo = getAllCardInfo()
  let nodeConstructionQueue = NSOperationQueue() ///&lt; ADD THIS LINE
  ...
}
</code></pre>

<p>接下来，在collectionView(collectionView:cellForItemAtIndexPath indexPath:)里，传递View Controller的 nodeConstructionQueue到 configureCellDisplayWithCardInfo(cardInfo:nodeConstructionQueue:) ：</p>

<pre><code>cell.configureCellDisplayWithCardInfo(cardInfo, nodeConstructionQueue: nodeConstructionQueue)
</code></pre>

<p>cell将会创建一个新的Node构造操作并将其添加到ViewControler的操作队列里并发运行。记住在cell出队时就会创建一个新的Node层次结构。这并不理想，但足够好。如果你要缓存Node的重用，看看ASRangeController 吧</p>

<p>OK，编译运行，你讲看到和之前一样的效果，但现在布局和渲染都没在主线程执行了，牛！我打赌你从来没有想过你看到这一天你所做的事情，这就是AsyncDisplayKit的威力。你可以将更多不需要再主线程操作从主线程中移除，这将给主线程更多机会处理和用户的交互，让你的App摸起来如黄油般顺滑</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>淡入Cell</h2>

<p>在这个就简短的章节，你将会学到:</p>

<ul>
<li>用自定义的Display Layer子类来支持Node</li>
<li>触发Node Layer的隐式动画</li>
</ul>


<p>这将会确保你的移除爆米花特效并最终带来良好的淡入动画</p>

<p>创建一个新的Layer子类.</p>

<p>菜单 File\New\File… ，选择 iOS\Source\Cocoa Touch Class 并单击Next.命名类为AnimatedContentsDisplayLayer并使其作为_ASDisplayLayer子类。选择 Swift语言并单击Next.最后保存并打开AnimatedContentsDisplayLayer.swift .</p>

<p>现在添加如下方法到类:</p>

<pre><code>override func actionForKey(event: String!) -&gt; CAAction! {
  if let action = super.actionForKey(event) {
    return action
  }

  if event == "contents" &amp;&amp; contents == nil {
    let transition = CATransition()
    transition.duration = 0.6
    transition.type = kCATransitionFade
    return transition
  }

  return nil
}
</code></pre>

<p>Layer有一个contents属性，它告诉系统为这个Layer绘制什么，AsyncDisplayKit通过在后台渲染contents并最后在主线程设置contents</p>

<p>这个代码将会添加一个过渡动画，这样contents就会淡入到View中，你可以在Apple的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html">Core Animation Prgramming Guide</a>找到更多关于隐式Layer动画</p>

<p>打开 RainforestCardCell.swift。在nodeConstructionOperationWithCardInfo(cardInfo:image:) 里，在Container Node Creation Section开头，改动如下:</p>

<pre><code>// REPLACE THIS LINE...
// let containerNode = ASDisplayNode()
// ...WITH THIS LINE:
let containerNode = ASDisplayNode(layerClass: AnimatedContentsDisplayLayer.self)
</code></pre>

<p>这会告诉容器Node使用AnimatedContentsDisplayLayer实例作为其支持Layer,因此自动带来淡入效果</p>

<blockquote><p><em>注意</em>
只有_ASDisplayLayer的子类才能被异步地绘制</p></blockquote>

<p>编译运行，你讲看到容器Node会在其绘制好之后淡入.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0023.png" alt="logo" /></p>

<h2>完整工程</h2>

<p><a href="https://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Layers-Finished-7.3.zip">完整工程</a>请在这里下载!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过一个Demo详解UIStackView]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-%5B%3F%5D-ge-demoxiang-jie-uistackview/"/>
    <updated>2016-04-04T19:48:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-[?]-ge-demoxiang-jie-uistackview</id>
    <content type="html"><![CDATA[<p><a href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/">在上一个章节</a>我们已经介绍了什么是UIStackView了，其实它更类似于Android开发中的LinerLayer排版技术。</p>

<p>这一章节，我们通过一个完整的例子来讲解UIStackView的用法</p>

<!--more-->


<h2>开始</h2>

<p>下下载这个<a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip">开始工程</a>,下载完毕后，用Iphone6 模拟器运行起来，你将会看到一个度假旅游的列表</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/01-table-view-is-now-correct_750x1334-281x500.png" alt="logo" />
点击第一行cell,咋看，这个视图没有什么问题，但是你仔细观察，就会发现有几个问题:</p>

<ol>
<li>看视图的下面的那一排按钮，它们中间都有一定间隙规则布局，但是它们并没有适配整个屏幕的布局，看着挺丑的，临时转换屏幕landscape orientation,通过 <code>Command-left</code></li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt="logo" /></p>

<ol>
<li>在详情页面，点击hidden按钮，它成功地隐藏了文字，但是下面的内容并没有顶上去，中间一片空白
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/03-hide-weather-issue_750x1334-281x500.png" alt="logo" /></li>
</ol>


<p>现在你已经有几点好的建议去提升app的体验，现在让我们开始切入这个工程</p>

<p>打开Main.storyboard然后找到 <code>Spot Info View Controller</code>,这里有一些颜色在stackView中。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/04-colorful-scene-in-storyboard_504x636-396x500.png" alt="logo" /></p>

<p>这些标签和按钮已经有几种不同颜色的背景色，但是在运行时他们的背景色就是透明的，在这个storyboard中，他们仅仅是为了帮助你展示stackView是怎么改变属性影响嵌套的子视图</p>

<p>你不需要做这些，但是从另一个观点来说你实际上喜欢去看看这些背景色当运行程序的时候，你能临时做些改变在SpotInfoViewController的viewDidLoad()中:</p>

<pre><code>// Clear background colors from labels and buttons
for view in backgroundColoredViews {
  view.backgroundColor = UIColor.clearColor()
}
</code></pre>

<p>当然，其它标签都有占位符文字说明，他们仅仅是为了让你区分哪些是和后台连接的。哪些是描述什么内容的。例如<code>&lt;whyVisitLabel&gt;</code>是连接</p>

<pre><code>@IBOutlet weak var whyVisitLabel: UILabel!
</code></pre>

<p>另外一个需要注意的是在这个storyboard中不是默认的 600 x 600,当你使用SizeClass的时候。</p>

<p>SizeClass总是可用的，但是初始化Navigation Controller 默认是总是iPhone 4-inch在模拟器下，这个是容易的在storyboard中，这个模拟器在启动的时候是不受影响的，这个视图将会动态适应不同的设备。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/05-simulated-metrics-iphone-4-inch_639x173.png" alt="logo" /></p>

<h2>你的第一个StackView</h2>

<p>第一件事是你将通过一个stackView修复最下面一排按钮的间距，一个stackView能描述在不不同轴向的布局（横向坐标和纵向坐标），其中之一就是子视图之间的距离设置。</p>

<p>幸运的是，修改已经存在的View在一个stackView中并不复杂，选中 <code>Spot Info View Controller</code>底部的所有按钮</p>

<p>检查这三个按钮是不是都选择上了，打开左边的控件面板查看，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/08-verify-button-selection_360x90.png" alt="logo" /></p>

<p>一旦选中了，在storyboard的右下角点击new Stack button
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/09-stack_button_outlined_148x52.png" alt="logo" /></p>

<p>这个按钮将会变成嵌入式的在stackView中</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/10-bottom-row-is-now-in-stack-view_640x100.png" alt="logo" /></p>

<p>这些按钮看起来不是平滑的，稍后我们将会修复</p>

<p>当这个stackView开始嵌套这些按钮的时候，我们将要添加自动布局给这个stackView</p>

<p>当你嵌套一个视图在一个stackView中，这个视图的任何约束都会被移除，例如，在嵌套到stackView之钱，在最前面的那个按钮<code>Submit Rating</code>有个垂直距离的约束和<code>Rating:</code>label之间:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/11-prior-constraint_420x90.png" alt="logo" /></p>

<p>点击<code>Submit Rating</code>按钮去看看是否还有这个约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/12-no-more-constraints_400x80.png" alt="logo" /></p>

<p>为了给stackView添加约束，首先你必须选中它，一个简单的方式去选择这个stackView在outline View:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" />
另外一种方式是按住 shift&amp;Right-click 在你想选择的视图上，或者按钮 <code>control</code>+<code>shift</code>+<code>左键点击</code>在你想要选择的视图上，你将会看到一个菜单视图，供你选择。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt="logo" /></p>

<p>现在，点击pin按钮在自动布局的工具条上  去 添加约束。</p>

<p>首先检查Constrain to margins，然后添加下载的约束:</p>

<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 0
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/17-bottom-stack-view-constraints_264x364.png" alt="logo" /></p>

<p>现在，这个stackVeiw是正确的尺寸，但是它有一点拉伸第一个按钮，因为它要去利用多余的空间。</p>

<p>stackView有个<code>distribution</code>属性来决定子视图的布局，当前，它是fill,这意味着包含的子视图都会完全填充stackview剩下的空间，为了修补这个，这个stackView将要展开其中的一个子视图去填补这个多余的空间</p>

<p>然而，你并不期望这个按钮完全填充stackView，你想让他们占用相同的空间。</p>

<p>选中这个stackView,然后修改它的属性<code>Distribution</code>从<code>Fill</code>到<code>Equal Spacing:</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/19-change-distribution-to-equal-spacing_640x148.png" alt="logo" /></p>

<p>现在编译运行，点击这个cell.旋转屏幕，你将会看到底部的按钮平分在屏幕的底部，是不是很酷呢!
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt="logo" /></p>

<p>如果不使用stackView来解决这个问题，你不得不使用sapce views，在没两个按钮之间，你的加入等比宽度的约束。很是麻烦。
它看起来像是下面这样，这中间的space View看起来有点灰色</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/21-alternate-solution-1_346x76.png" alt="logo" /></p>

<p>这个问题还是不是很大在一个storyboard中，但是很多视图都是动态的，这就不是一个简单的任务了，在运行时去增加一个按钮或者隐藏一个按钮，因为需要去调节视图和约束之间的关系。</p>

<p>为了在一个stack view中隐藏一个视图，你不得不设置子视图的hidden属性为true.现在你将要修复之前说过的那个问题，就是当点击 hidden之后，文字消失，下面的多余空间要顶上去。</p>

<h2>转换Sections</h2>

<p>你将要转换所有的section用stack view中，这将要确保你容易的完成你的任务，下一步你将要转换 rating section.</p>

<h3>Rating section</h3>

<p>定位到你刚才的页面，然后选择<code>RATING</code>标签和 星星的视图：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/22-select-rating-label-and-stars-label_640x74.png" alt="logo" />
然后点击 stack按钮让其嵌套在一个stackView中。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/23-after-clicking-stack-button_640x74.png" alt="logo" />
 现在，点击PIN按钮，添加下面三个属性:</p>

<pre><code class="`"> Top: 20, Leading: 0, Bottom: 20
</code></pre>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/24-add-second-stack-view-constraints_264x171.png" alt="logo" /></p>

<p> 现在切换到<code>Attributes inspector</code>，设置 spacing为8:
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/25-set-spacing-to-8_259x87.png" alt="logo" /></p>

<p> 这时，你看到视图上的两个控件之间已经有些间距了，
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/26-stars-label-weirdly-stretched_640x85.png" alt="logo" />
 有时候，xcode可能提示你stackview的位置是不正确的，但是这些警告将会消失，当你更新其它控件的时候，你通常可以忽略他们。</p>

<p>为了证明这个，改变 <code>Alignment</code>从<code>Fill</code>到<code>Top</code>然后再改为Fill,你将会看到这个stars 标签变成正确的位置了。</p>

<p>编译运行你的app,一切看起来还是和从前一样.</p>

<h2>取消嵌套一个Stack View</h2>

<p>在你深入学习之前，去进行一些"急救"训练，有时，你会发现你的视图上有一个你不再需要的stackview,或许你为了练习而导致的事故。</p>

<p>幸运的是，这里有容易的方式去移除一个嵌套的view从stack view中。</p>

<p>首先，你最好选择你想要删除的stack view,按住<code>Option</code>键，然后点击 <code>stack</code>按钮，点击 <code>Unembed</code>菜单就可以了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/28-how-to-unembed_186x71.png" alt="logo" /></p>

<h2>你的第一个垂直Stack view</h2>

<p>现在，你将要创建一个垂直的stack view,选中<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/29-select-why-visit-labels_640x90.png" alt="logo" />
Xcode将会正确的推断出这个视图将会需要一个垂直的stack view,点击<code>Stack</code>按钮去嵌套它们到一个stack view中。</p>

<p>当stack view添加成功之后，嵌套的视图的约束将会给删除，当前的这个stack view没有任何约束，所以它会适配子视图中最大尺寸的。</p>

<p>当这个stack view选中的时候，点击 Pin按钮，设置如下属性:
Top, Leading and Trailing 都为0</p>

<p>然后，点击dropdown在右下角，然后选择<code>WEATHER (current distance = 20):</code></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/31-dont-select-nearest-neighbor-constraint_463x417.png" alt="logo" /></p>

<p>最后，添加这4个约束，你将会看到如下结果：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/32-why-visit-stack-view-stretched_640x90.png" alt="logo" />
现在你有两个一个展开的stackview,它的右边界是定位到了视图的右边界，然而，这下面的标签依然是同样宽的，你将要修复它通过stack view的<code>alignment</code>属性</p>

<h2>Alignment属性</h2>

<p>这个alignment属性决定了stack view在其轴向上的布局方式，可能是Fill,Leading,Center和Trailing.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/33-horizontal-and-vertical-alignment_594x171.png" alt="logo" /></p>

<p>在垂直的stackview中，选择不同的属性，将会看到不同的布局:</p>

<p>Fill:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/34-alignment-fill_640x64.png" alt="logo" /></p>

<p>Leading:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/35-alignment-leading_640x64.png" alt="logo" /></p>

<p>Center:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/36-alignment-center_640x64.png" alt="lgo" /></p>

<p>Trailing:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/37-alignment-trailing_640x64.png" alt="lgo" /></p>

<p>当你测试完每个属性值后，最后设置成Fill</p>

<p>编译运行程序看起来是OK的，特别需要指出的是，<code>Fill</code>意味着你想要所有的视图都是完全占用空间在其轴向上，这将引起<code>WHY VISIT</code>标签去展开它到右边缘。</p>

<p>但是如果你只想下面的label张开到右边缘，此时该怎么做呢?</p>

<h2>转换"what to see"模块</h2>

<p>这个转换和上面的那个很相似，介绍如下:</p>

<ol>
<li>首先，选择<code>WHAT TO SEE</code>标签和<code>&lt;whatToSeeLabel&gt;</code></li>
<li>点击<code>Stack</code>按钮</li>
<li>点击<code>Pin</code>按钮</li>
<li>设置<code>margins</code>约束，添加下面4个约束</li>
</ol>


<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 20
</code></pre>

<ol>
<li>设置stack view的Alignment为FIll</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/39-after-what-to-see-section_640x308.png" alt="logo" />
编译运行你的工程，验证页面是不是看起来和之前一样。</p>

<p>剩下就是这个<code>weather</code>模块了</p>

<h2>转换weather模块</h2>

<p>这个weather模块比其他几个稍微复杂一些，因为它包含了一个hidden按钮</p>

<p>一种方法是你将会创建一个最近的stacview通过嵌套<code>WEATHER</code>标签和<code>Hide</code>按钮在一个水平的stackview中，然后嵌套水平的stackview和<code>&lt;weatherInfoLabel&gt;</code>到一个垂直的stackview中。</p>

<p>看起来你像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/40-weather-stack-in-stack_640x92.png" alt="lgo" /></p>

<p>点击<code>Stack</code>按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/43-weather-click-stack-button_640x92.png" alt="logo" /></p>

<p>然后点击 Pin按钮，设置margin约束,设置如下:</p>

<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 20
</code></pre>

<p>设置 stack view的Alignment为Fill
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/44-weather-alignment-fill_640x92.png" alt="logo" /></p>

<p>你需要一个在hide按钮和<code>WEATHER</code>标签的右边加一个约束，因为<code>WEATHER</code>标签被加到了stack view中，它的所有约束都被自动去掉了.</p>

<p>然后，你希望底部的<code>&lt;weatherInfoLabel&gt;</code>去填充整个stack view.</p>

<p>你可以完成这个通过把<code>WEATHER</code>嵌套进一个垂直的stack view中，记住垂直stackview可以设置alignment为 .Leading,假如stack view是拉伸的超出了它固有的边界，它包含的子视图将会到达它的边界。</p>

<p>选择<code>WEATHER</code>标签通过document outline，或者通过<code>Control-Shift-click</code>方法:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/45-select-just-the-weather-label_640x92.png" alt="logo" /></p>

<p>点击 stack按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/46-weather-in-horizontal-stack_640x92.png" alt="lgo" /></p>

<p>设置Alignment为Leading,然后确保axis是垂直方向:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/47-vertical-and-leading_640x92.png" alt="log" /></p>

<p>完美！你已经完成了外部的stackview平铺，在嵌套的stackView中去填充它的宽度，但是内部的stackview允许这个标签去保持它原有的宽度。</p>

<p>编译运行，为什么hide按钮现在飘到上面去了呢？
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/48-hide-label-incorrect-position_750x573-419x320.png" alt="dlo" /></p>

<p>它是因为当你嵌套<code>WEATHER</code>标签到一个stackview中时，它的所有和hide按钮相关的约束都被移除掉了。</p>

<p>现在你需要给hide按钮和<code>WEATHER</code>标签之间增加新的约束,按住<code>control-drag</code>从Hide按钮拖向<code>WEATHER</code>标签:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/49-drag-to-weather-label_380x94.png" alt="logo" /></p>

<p>添加两个约束:</p>

<ol>
<li>Horizontal Spacing</li>
<li>Baseline</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/50-add-multiple-constraints_380x224.png" alt="logo" />
编译运行，这个Hide按钮看起来正常了。</p>

<p>现在所有的模块都是在唯一的stackview中了，你把他们全部都嵌套进了stackview中。</p>

<h2>设置第一级Stack view</h2>

<p>点击 <code>command</code> 然后选择所有的5个顶级的stackview在 outline view中
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/52-select-all-stack-views-in-outline_640x260.png" alt="log" /></p>

<p>然后点击stack按钮：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/53-stack-all-the-views_640x185.png" alt="lgo" /></p>

<p>点击Pin按钮，设置约束属性:
全部都设置成0.然后设置Spacing为20, Alignment为Fill,你的storyboard看起来像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt="g" /></p>

<p>编译运行，此时你的 hide按钮又跑偏了，和之前设置的一样，需要把hide和<code>WEATHER</code>重新建立约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/56-add-constraints-to-button-again_380x223.png" alt="d" /></p>

<p>编译运行，此时hide按钮在正确的位置上了。</p>

<h2>重新布局视图</h2>

<p>现在所有的的模块都在顶级的stackview中，你现在可以更改<code>what to see</code>模块的位置，比如和<code>weather</code>模块的位置进行互换。</p>

<p>选择<code>middle stack view</code>从outline view然后拖拽它和weather的那个stackview进行互换，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/57-drag-and-drop-to-reposition-section_639x130.png" alt="log" /></p>

<p>此时，<code>weather</code>模块是第三个模块，但是这个 hide按钮不是在stackview中，它不会被移动。</p>

<p>选中 Hide按钮 :
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/58-hide-button-not-moved_640x130.png" alt="logo" />
然后点击<code>Resolve Auto Layout Issues</code>在自动布局的菜单上点击 update frame:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/59-resolve-auto-layout-issues_356x269.png" alt="logo" /></p>

<h2>Size class based configuration</h2>

<p>最后，你能把你注意力集中到之前的任务清单上，在加载模式中，垂直空间是昂贵的，所以你想让stackview中的模块靠近些，为了做到这些，你将要使用size classes去设置顶部stackview的空间从20修改成10.</p>

<p>选中顶部的stackview然后点击小小的<code>+</code>号，设置spacing:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/61-select-plus-button_260x120.png" alt="log" /></p>

<p>选择 Any Width > Compact Height:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/62-anywidth-compact-height_403x108.png" alt="lgo" /></p>

<p>然后设置Spacing 为10,在 new wAny hC文本框中:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/63-set-spacing-to-10_260x160.png" alt="lgo" /></p>

<h2>动画</h2>

<p>打开SpotInfoViewController.swift文件，然后找到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code>方法</p>

<p>你将要替换这一行代码:</p>

<pre><code>weatherInfoLabel.hidden = shouldHideWeatherInfo
</code></pre>

<p>改成如下:</p>

<pre><code>if animated {
  UIView.animateWithDuration(0.3) {
    self.weatherInfoLabel.hidden = shouldHideWeatherInfo
  }
} else {
  weatherInfoLabel.hidden = shouldHideWeatherInfo
}
</code></pre>

<p>编译运行，点击<code>hide</code>和<code>show</code>按钮，会不会感觉出来有点动画效果呢?</p>

<p>在stackview中增加动画效果也是很容易的，比如hidden, alignment, distribution, spacing，甚至axis。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip">完整工程</a></p>

<p>希望能够帮到你~</p>
]]></content>
  </entry>
  
</feed>
