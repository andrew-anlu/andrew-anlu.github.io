<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-09-21T17:11:45+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS推送]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/21/iostui-song/"/>
    <updated>2016-09-21T16:25:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/21/iostui-song</id>
    <content type="html"><![CDATA[<p>推送服务可以说是所有App的标配，不论是那种类型的App,推送都从很大程度上决定了App的打开率，使用率，存活率。因此熟知并掌握推送原理及方法,对每一个开发者来说都是必备技能，对每一个依赖App的公司都至关重要</p>

<p>从ios10新增的<code>UserNotifications Framework</code>可以发现，Apple整合了原有散乱的API,并且增加了很多强大的功能。以Apple官方的角度来看，也必然是相当重视推送服务对App的影响，以及对Apple生态圈长远发展的影响。</p>

<!--more-->


<h2>准备</h2>

<h3>Tip 1：推送通知（Push Notification）必须购买Apple开发者账号，并使用特定的推送证书</h3>

<ul>
<li>使用免费账号不能推送</li>
<li>如果我们使用的是第三方推送服务，比如 &lt;极光推送>,也必须购买开发者账号，因为所有的第三方都会将推送请求发至 <code>APNS</code>(Apple push Notification service，苹果推送通知服务)，所有的推送都是由Apns发送的</li>
<li>如果注册及正确的配置证书，参考这里<a href="http://docs.jiguang.cn/client/ios_tutorials/#ios_1">ios证书设置指南</a></li>
</ul>


<h2>原理</h2>

<h3>Tip2:推送通知本身是iOS系统的行为，所以在App没有运行的时候：</h3>

<ul>
<li>仍然能够推送及接收(通知中心通知，顶部横幅，刷新App右上角小圆点等都会由系统控制和展示)</li>
<li>收到推送时，是无法再App的代码中获取到通知内容的。因为沙盒机制，此时App的任何代码都不可能被执行</li>
</ul>


<h3>Tip3:手机向APNS注册推送服务</h3>

<ol>
<li>在代码中注册推送服务:</li>
</ol>


<pre><code> #ifdef __IPHONE_8_0
 if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {
     UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge| UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];
     [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
 } else {
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
}
 #else
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
 #endif
</code></pre>

<ol>
<li>在第一次触发这段代码的时候，会有一个系统弹窗，询问你是否允许该App要给你推送信息。当你选择允许时，系统会打包App+手机唯一标识+证书信息 发送至Apns服务器注册推送服务，APNs系统会对该手机安装的该App是否有推送权限进行验证，所以必须要加入了Apple Device的手机，使用对应App的推送证书才能够成功注册。</li>
<li>如果注册成功，则可以在<code>AppDelegate.swift</code>的如下方法中获取到<code>deviceToken</code>,它是对该手机+该App组合的一个唯一标识，当使用远程推送时，只需将推送消息发给指定的<code>deviceToken</code>即可使推送消息传达给指定手机的指定App上。因此如果你使用第三方，就需要在这里将<code>deviceToken</code>传给第三方。（在ios9为了更好的保护用户隐私，会出现多次重复删除/安装App导致<code>deviceToken</code>不断变化的情况。有时会出现一条推送手机会受到2次的问题，属于iOS9系统问题）</li>
</ol>


<pre><code> -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
     [JPUSHService registerDeviceToken:deviceToken];//将 deviceToken 传给极光推送
 }
</code></pre>

<ol>
<li><p>如果以上步骤都成功，此时你能够获取到第三方提供的设备注册的id，能够获取到该id值，可以作为判断设备是否能够成功推送的标准，因此当你获取到该值时：</p></li>
<li><p>推送证书配置正确（你拥有了推送权限）</p></li>
<li>设备成功在Apns注册并返回了<code>deviceToken</code>（Apns能识别你的设备了）</li>
<li><p>返回的<code>deviceTOken</code>传给第三方，成功在第三方生成了唯一标识注册id（第三方能将你的设备信息传给APNS了）</p></li>
<li><p>综上，注册及接受推送必须使用真机，必须连网</p></li>
</ol>


<h3>Tip4:推送通知从服务端->App代码的过程</h3>

<ol>
<li>使用你们公司或第三方的服务端向APNs发送推送请求（请参考苹果APNS相关资料，或者使用第三方提供的Rest Api）</li>
<li>APNS接受并验证推送请求</li>
<li>APNS找到设备下发推送</li>
<li><p>手机收到推送通知，系统根据App状态进行处理：</p></li>
<li><p>前台收到：</p>

<ul>
<li>系统会将通知内容传到 <code>didReceiveRemoteNotification</code></li>
</ul>
</li>
<li><p>后台收到:</p>

<ul>
<li>如果开启了<code>Remote Notification</code>,系统将推送传到<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>,否则此时代码中收不到推送</li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
<li><p>退出收到:</p>

<ul>
<li>如果点击推送横幅/通知中心而启动App,系统将通知传到<code>didFinishLaunchingWithOptions</code></li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
</ol>


<h2>推送通知内容篇</h2>

<h3>Tip5:推送通知分为本地/远程 2种类型:</h3>

<ul>
<li>本地通知，可指定推送时间，在该时间准时弹出推送通知。</li>
<li><p>远程推送通知，分为普通推送/后台推送/静默推送3种类型。存在延迟问题（由于Tip1的第2点，APNS的不稳定及高峰时段的巨量请求所致）</p>

<ul>
<li><p>普通推送</p>

<ul>
<li>就是我们在手机上平时见到的推送通知</li>
<li>包括声音，横幅，角标，自定义字段</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组合与继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng/"/>
    <updated>2016-09-10T08:45:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng</id>
    <content type="html"><![CDATA[<h2>何时使用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的UITableViewCell,那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不管代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

<!--more-->


<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个<code>OBJDevice</code>类，让一些子类如 <code>OBJIPhoneDevice</code>和<code>OBJIPadDevice</code>,甚至更深层次的子类如<code>OBJIPhone5Device</code>来继承，并让这些子类重写特定的方法，例如，你的<code>OBJDevice</code>类可能包含了函数<code>applyRoundedCornersToView:withRadius</code>,它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类可能很有用的场景是模型对象（model object）.绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code>,<code>hash</code>,<code>copyWithzone:</code>,和<code>description</code>等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找这样的一个基类，可以考虑使用<a href="https://github.com/mantle/mantle">Mantle</a>,它就是这么做的，并且做的更多）</p>

<h2>何时不适用子类</h2>

<p>在以往工作过得很多工程中，我见过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。</p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代的方案可选。在下面的章节中，我们会逐个进行更详细的描述。如果你的子类只是使用相同的接口，协议会是非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有的对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h1>替代方案</h1>

<h2>协议(Protocols)</h2>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在app中你有一个播放器对象，它可以播放视频。现在你想添加对YouTube的支持，使用相同的接口，但是具体实现不同。你可以像这样用子类来实现:</p>

<pre><code>@class Player : NSObject

- (void)play;
- (void)pause;

@end


@class YouTubePlayer : Player

@end
</code></pre>

<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的昂奋。可以这样用协议来写你的代码：</p>

<pre><code>@protocol VideoPlayer &lt;NSObject&gt;

- (void)play;
- (void)pause;

@end


@class Player : NSObject &lt;VideoPlayer&gt;

@end


@class YouTubePlayer : NSObject &lt;VideoPlayer&gt;

@end
</code></pre>

<p>这样，<code>YouTubePlayer</code>类就不必知道<code>Player</code>类内部实现了</p>

<h2>替代方案:代理(delegate)</h2>

<p>再一次假设你有一个像上面例子中的<code>Player</code>类，现在，你想在开始播放的时候在某个地方执行一个自定的函数。这么做相对容易一些：创建一个自定义的子类，重写<code>play</code>方法，调用<code>[super play]</code>，然后开始做你自定义的工作。这么做是一种方法，另外一种方法是，改动你的<code>Player</code>对象，然后给它设置一个代理。如下：</p>

<pre><code>@class Player;

@protocol PlayerDelegate

- (void)playerDidStartPlaying:(Player *)player;

@end


@class Player : NSObject

@property (nonatomic,weak) id&lt;PlayerDelegate&gt; delegate;

- (void)play;
- (void)pause;

@end
</code></pre>

<p>现在，在播放器的<code>play</code>方法里，就可以给代理发<code>playerDidStartPlaying :</code>消息了。这个<code>Player</code>类的任何使用者都可以仅仅实现这个代理协议，而不用继承该类，<code>Player</code>类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像<code>UITextField</code>这样的类，还有<code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如<code>UITableView</code>,它不仅有个一个代理(delegate),还有一个数据源(dataSource)</p>

<h2>替代方案：类别(Categories)</h2>

<p>有时候，你可能会想给你一个对象增加一点点额外的功能，比如你想给NSArray增加一个方法<code>arrayByRemovingFirstObject</code>.不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<pre><code>@interface NSArray (OBJExtras)

- (void)obj_arrayByRemovingFirstObject;

@end
</code></pre>

<p>在用类别扩展一个不是你自己的类的时候，在方法前欠佳前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有一个另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h2>替代方案:配置对象(Configuration Objects)</h2>

<p>在我经常犯的错误中，其中一条就是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。假如，在一个幻灯片应用里，你有一个主题类<code>Theme</code>,它含有几个属性，比如<code>backgroundColor</code>和<code>Font</code>，还有一些在一张幻灯片上如何布局的逻辑函数</p>

<p>然后，对每种主题，你都创建一个<code>Theme</code>的子类，重写某个函数(例如 <code>setup</code>)并且配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如 幻灯片布局）放在<code>Theme</code>类中，把属性的配置放到比较简单的对象中，这些对象中只包含有这些属性。</p>

<p>例如，类<code>ThemeConfiguration</code>具有<code>backgroundColor</code>和<code>font</code>属性，而类<code>Theme</code>在其初始化函数中获取一个配置类<code>ThemeConfiguration</code>的值</p>

<h2>替代方案:组合</h2>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不像共享同样的接口，组合就是你的首选武器，例如，假设你要设计一个缓存类:</p>

<pre><code>@interface OBJCache : NSObject

- (void)cacheValue:(id)value forKey:(NSString *)key;
- (void)removeCachedValueForKey:(NSString *)key;

@end
</code></pre>

<p>简单点的做法是直接继承<code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法.</p>

<pre><code>@interface OBJCache : NSDictionary
</code></pre>

<p>但是这么做有几个弊端，它本来是应该被详细实现的，但只是通过字典来实现，现在，在任何需要一个<code>NSDictionary</code>参数的时候，你可以直接提供一个<code>OBJCache</code>值。但如果你想把它转为其它完全不同的东西，你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性(或者实例变量)中，对外仅仅暴露这两个<code>cache</code>方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo/"/>
    <updated>2016-07-19T13:44:10+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在ios中，所有的View都是由一个底层的layer来驱动的。View和它的layer之间有着紧密的联系，View其实直接从layer对象中获取了绝大多数它所需要的数据。在ios中也有一些单独的layer,比如<code>AVCaptureVideoPreviewLayer</code>和<code>CAShapeLayer</code>，它们不需要附加到view上就可以在屏幕上显示内容。两种情况下都是layer起决定作用。当然了，附加到view上的layer和单独的layer在行为上还是稍有不同的。</p>

<!--more-->


<p>基本上你改变一个单独的layer的任何属性的时候，都会触发一个从旧值过渡到新值的简单动画（就是所谓的动画<code>animatable</code>）。然而，如果你改变的是view中layer的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有layer,但是当layer附加在view上时，它的默认的隐式动画的layer行为就不起作用了。</p>

<blockquote><p><em>注意</em>
animatable 几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以'animatable'结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，设置也囊括了像isHidden和doubleSides这样的布尔值。像paths这样的属性也是animatable的。但是它不支持隐式动画。</p></blockquote>

<p>在 Core Animation 编程指南的"How to Animate Layer-Backed Views"中，对为什么会这样做出了一个解释:</p>

<blockquote><p>UIView默认情况下进制了layer动画，但是在animation block中又重新启用了它们</p></blockquote>

<p>这正是我们所看到的额行为，当一个属性在动画block之外被改变时，没有动画，但是当属性在动画block内改变时，就带上了动画。对于这是如何发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了view和layer之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的layer属性改变时，layer都会寻找并运行何时的'Action'来实行这个改变。在core Animation的专业术语中就把这样的动画统称为动作(Action,或者CAAction)</p>

<blockquote><p>CAAction:从技术上来说，这是一个接口，并可以用来做各种事情，但是实际上，某种程度上你可以只把它理解为用来处理动画</p></blockquote>

<p>layer将像文档中缩写的那样去寻找动作，整个过程分为5个步骤。第一步中的view和layer中交互的部分是最有意思的：</p>

<p>layer通过向它的代理发送 <code>actionForLayer:forKey:</code>消息来询问提供一个对应属性变化的action.delegate可以通过返回以下三者之一来进行响应:</p>

<ol>
<li>它可以返回一个动作对象，这种情况下layer将使用这个动作</li>
<li>它可以返回一个nil,这样layer就会到其他地方继续寻找</li>
<li>它可以返回一个NShull对象，告诉layer这里不需要执行一个动作，搜索也会就此停止</li>
</ol>


<p>而让这一切变得有趣的是，当layer在背后支持一个view的时候，view就是它的delegate;</p>

<blockquote><p>在ios中，如果layer与一个UIview对象关联时，这个属性必须被设置为持有这个layer的那个view</p></blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了；属性改变时layer会向View请求一个动作，而一般情况下view将返回一个NSNull,只有当属性改变发生在动画block中时，view才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的layer属性向view询问动作就可以了，比如对于'position':</p>

<pre><code>NSLog(@"outside animation block: %@",
      [myView actionForLayer:myView.layer forKey:@"position"]);

[UIView animateWithDuration:0.3 animations:^{
    NSLog(@"inside animation block: %@",
          [myView actionForLayer:myView.layer forKey:@"position"]);
}];
</code></pre>

<p>运行上面的代码，可以看到在block外view返回的是NSNull对象，而在block中时返回的是一个CABasicAnimation.很优雅，对吧?值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))：</p>

<pre><code>outside animation block: &lt;null&gt;
inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;
</code></pre>

<p>对于view中的layer来说，对动作的搜索只会到第一步为止。对于单独的layer来说，剩余的4个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer</a>actionForKey: 文档中找到。</p>

<h2>从UIKit中学习</h2>

<p>我很确定我们都会同意UIview动画是一组非常优秀的API,它简洁明确，实际上，它使用了Core Animation来执行动画，这给了我们一个绝佳的积水来深入研究UIKit是如何使用Core Animation的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴.</p>

<p>当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forKey:方法将添加到layer中，就像显示地添加动画那样。再一次，别直接相信我，让我们实践检验一下</p>

<p>归功于UIview的layerClass 类方法，View和layer之间的交互很容易被观测到。通过这个方法我们可以在为View创建layer时为其指定要使用的类。通过子类一个UIView,以及用这个方法返回一个自定义的layer类，我们就可以重写layer子类中的 <code>addAnimaiton:ForKey:</code>并输出一些东西来验证它是佛确实被调用。唯一要记住的是我们需要调用super方法，不然的话我们就把要观测的行为完全改变了：</p>

<pre><code>@interface DRInspectionLayer : CALayer
@end

@implementation DRInspectionLayer
- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
{
    NSLog(@"adding animation: %@", [anim debugDescription]);
    [super addAnimation:anim forKey:key];
}
@end


@interface DRInspectionView : UIView
@end

@implementation DRInspectionView
+ (Class)layerClass
{
    return [DRInspectionLayer class];
}
@end
</code></pre>

<p>通过输出动画的debug信息，我们不仅可以验证它确实如逾期一样被调用了，还可以看到动画是如何组织构建的：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
    fillMode = both; 
    timingFunction = easeInEaseOut; 
    duration = 0.3; 
    fromValue = NSPoint: {5, 5}; 
    keyPath = position
&gt;
</code></pre>

<p>当动画被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue(也就是当前值)被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的行为应该是:</p>

<blockquote><p>只有FromValue不是nil时，在fromvalue和属性当前显示层的值之间进行插值</p></blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到layer上：</p>

<pre><code>CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@"opacity"];
fadeIn.duration  = 0.75;
fadeIn.fromValue = @0;

myLayer.opacity = 1.0; // 更改 model 的值 ...
// ... 然后添加动画对象
[myLayer addAnimation:fadeIn forKey:@"fade in slowly"];
</code></pre>

<p>这很简洁，你也不需要再动画被移除的时候做什么额外的操作，如果动画是在一段延迟后才开始的话，你可以使用backward填充模式(或者'both'填充模式)，就像UIKit所创建的动画那样</p>

<p>可能你看见上面输出中的动画的delegate了，想知道这个类是用来做什么的呢？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a>,它主要用来维护动画的一些状态(持续时间，延时，重复次数等等)，它还负责对一个栈做push和pop,这是为了在多个动画block嵌套时能够获取正确的动画状态。这些都是事先细节，除非你想要写一套自己的基于block的动画API,否则可能你不会用到它们</p>

<p>然后真正有意思的是这个delegate事先了 animationDidStart: 和 animationDidStop:finished: 并将信息传给了它自己的delegate</p>

<blockquote><p>这里不太容易理解，加以说明:从上面的头文件可以看出，作为CAAnimation的delegate的私有类UIViewAnimationState中还有个<code>_delegate</code>成员，并且<code>animationDidStart</code>和<code>animationDidStop:finished:</code>也是典型的delegate的实现方法.</p></blockquote>

<p>通过打印这个delegate的delegate,我们可以发现它也是一个私有类：<code>UIViewAnimationBlockDelegate</code>。同样进行<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且进行相应的block.如果我们使用自己的Core Animation代码，并且选阿泽block而不是delegate做回调的话，添加这个是很容易的：</p>

<pre><code>@interface DRAnimationBlockDelegate : NSObject

@property (copy) void(^start)(void);
@property (copy) void(^stop)(BOOL);

+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
                                   completion:(void(^)(BOOL finished))completion;

@end

@implementation DRAnimationBlockDelegate

+ (instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
                                    completion:(void (^)(BOOL))completion
{
    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
    result.start = beginning;
    result.stop  = completion;
    return result;
}

- (void)animationDidStart:(CAAnimation *)anim
{
    if (self.start) {
        self.start();
    }
    self.start = nil;
}

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    if (self.stop) {
        self.stop(flag);
    }
    self.stop = nil;
}

@end
</code></pre>

<p>虽然是我的个人喜好，但是我觉得像这样的基于block的回调风格可能会比实现一个delegate回调更适合你的代码:</p>

<pre><code>fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
    NSLog(@"beginning to fade in");
} completion:^(BOOL finished) {
    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
}];
</code></pre>

<h2>自定义基于block的动画APIS</h2>

<p>一旦你知道了<code>actionForKey:</code>的原理之后，UIview就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于block的动画Apis。我所设计的动画将通过block中用一个很激进的时间曲线来做动画，以吸引用户对该View的注意，之后做一个缓慢的动画回到原始状态。你可以把它看做一种类似pop的行为。与一般使用<code>UIViewAnimationOptionAutoreverse</code>的动画block不同，因为动画设计和概念上的需要，我自己实现了将model值改变回原始值的过程。自定义的动画API的使用方法就像这样:</p>

<pre><code>[UIView DR_popAnimationWithDuration:0.7
                             animations:^{
                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
                                }];
</code></pre>

<p>当我们完成后，效果是这样样子的(对四个不同的View为位置，尺寸，颜色和旋转进行动画)</p>

<p><img src="http://7xsn4e.com1.z0.glb.clouddn.com/2014-05-01-view-layer-synergy-custom-block-animations.gif" alt="1" /></p>

<p>要开始实现它，我们首先要做的是当一个layer属性变化时获取delegate的回调，因为我们无法实现预测layer要改变什么，所以我选择在一个UIView的category中的swizzle<code>actionForLayer:forKey:</code>方法:</p>

<pre><code>@implementation UIView (DR_CustomBlockAnimations)

+ (void)load
{        
    SEL originalSelector = @selector(actionForLayer:forKey:);
    SEL extendedSelector = @selector(DR_actionForLayer:forKey:);

    Method originalMethod = class_getInstanceMethod(self, originalSelector);
    Method extendedMethod = class_getInstanceMethod(self, extendedSelector);

    NSAssert(originalMethod, @"original method should exist");
    NSAssert(extendedMethod, @"exchanged method should exist");

    if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
        class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, extendedMethod);
    }
}
</code></pre>

<p>为了保证我们不破坏其他依赖于<code>actionForLayer:forKey:</code>的回调代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子莱索一个简单的Bool其实就够了，但是如果我们之后要写更多内容的话，上下文的话要灵活得多了：</p>

<pre><code>static void *DR_currentAnimationContext = NULL;
static void *DR_popAnimationContext     = &amp;DR_popAnimationContext;

- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
    if (DR_currentAnimationContext == DR_popAnimationContext) {
        // 这里写我们自定义的代码...
    }

    // 调用原始方法
    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
}
</code></pre>

<p>在我们的实现中，我们要确保在执行动画block之前设置动画的上下文，并且在执行后恢复上下文：</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;
     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();
     /* 一会儿再添加 */
     DR_currentAnimationContext = NULL;
 }
</code></pre>

<p>如果我们想要做的不过是添加一个从旧值向新值过渡的动画的话，我们可以直接在delegate的回调中来做。然后因为我们想要更精确的控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓</p>

<p>有意思的是，ios添加的一个基于block的动画API也遇到了同样了问题，使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每一个关键帧，在属性变化时，view返回nil,但是却存储下需要的状态。这样就能在所有关键帧block执行后创建一个<code>CAKeyframeAnimationz</code>对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么layer被更改了，什么key path的值被改变了，以及原来的值是什么:</p>

<pre><code> @interface DRSavedPopAnimationState : NSObject

 @property (strong) CALayer  *layer;
 @property (copy)   NSString *keyPath;
 @property (strong) id        oldValue;

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath;

 @end

 @implementation DRSavedPopAnimationState

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath
 {
     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
     savedState.layer    = layer;
     savedState.keyPath  = keyPath;
     savedState.oldValue = [layer valueForKeyPath:keyPath];
     return savedState;
 }

 @end
</code></pre>

<p>接下来，在我们的交换后的delegate回调中，我们简单地讲被变更的属性的状态存入一个静态可变数组中：</p>

<pre><code> if (DR_currentAnimationContext == DR_popAnimationContext) {
       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
                                                                                 keyPath:event]];

       // 没有隐式的动画 (稍后添加)
       return (id&lt;CAAction&gt;)[NSNull null];
   }
</code></pre>

<p>在动画block执行完毕后，所有的属性都被变更了，它们的状态也被保存了，现在，创建关键帧动画:</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;

     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();

     [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
         DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
         CALayer *layer    = savedState.layer;
         NSString *keyPath = savedState.keyPath;
         id oldValue       = savedState.oldValue;
         id newValue       = [layer valueForKeyPath:keyPath];

         CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];

         CGFloat easing = 0.2;
         CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
         CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];

         anim.duration = duration;
         anim.keyTimes = @[@0, @(0.35), @1];
         anim.values = @[oldValue, newValue, oldValue];
         anim.timingFunctions = @[easeIn, easeOut];

         // 不带动画地返回原来的值
         [CATransaction begin];
         [CATransaction setDisableActions:YES];
         [layer setValue:oldValue forKeyPath:keyPath];
         [CATransaction commit];

         // 添加 "pop" 动画
         [layer addAnimation:anim forKey:keyPath];

     }];

     // 扫除工作 (移除所有存储的状态)
     [[self DR_savedPopAnimationStates] removeAllObjects];

     DR_currentAnimationContext = nil;
 }
</code></pre>

<p>注意老的model值被设置到了layer上，所以在当动画结束和移除后，model的值和persentation的值是相符合的。</p>

<p>创建像这样的你自己的API不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂UIview block动画的APis,特别是你已经在core Animation的舒适区的时候，这非常有助于你的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 ViewController 容器转场]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang/"/>
    <updated>2016-07-19T10:02:19+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang</id>
    <content type="html"><![CDATA[<p>我们在本文讨论navigation controller中的两个view controller之间的转场动画，但是这些做法在 tab bar controller或者任何你自己定义的view controller容器中也是通用的&hellip;</p>

<!--more-->


<p>尽管从技术角度来讲，使用ios7的api,你可以对自定义容器中的view controller做自定义转场，但是这不是能直接使用的，实现这种效果非常不容易。</p>

<p>请注意我正在讨论的自定义视图控制器容器都是UIViewController的直接子类，而不是UITabBarController或者UINavigationController的子类。</p>

<p>对于你自定义的继承与UIViewController的容器子类，并没有现成可用的Api允许一个任意的动画控制器将一个子视图控制器自动转场到另外一个，不管是可交互的转场还是不可交互式的转场。我甚至都觉得苹果根据不想支持这种方式。苹果支持下面的几种转场方式:</p>

<ul>
<li>Navigation Controller推入和推出页面</li>
<li>Tab bar Controller选择的改变</li>
<li>Model页面的展示和消失</li>
</ul>


<p>在本文中，我将向你展示如何自定义视图控制器容器，并且使其支持第三方的动画控制器</p>

<h2>预热准备</h2>

<p>看到这里，你可能对上文我们说到一些问题犯嘀咕，让我来告诉你答案吧:</p>

<p>为什么我们不直接继承UINavigationController或UITabBarController.并且使用它们提供的功能呢？</p>

<p>有些时候这是你不想要的。可能你想要一个非常特殊的外观或者行为，和这些类能够提供给你的差别非常大，因此你必须使用一些黑客式的手段去达到你想要的结果，同时还要担心系统框架的版本更新后这些黑客式的手段是否还仍然有效。或者，你就是想完全控制你的视图控制器容器，避免不得不支持一些特定的功能。</p>

<p>好吧，那么为什么不实用
<code>transitionFromViewController:toViewController:duration:options:animations:completion :</code>去实现呢?</p>

<p>这又是一个好问题，你可能想用这种方式去实现，但是或许你对代码的整洁性比较在意，想把这种转场相关的代码封装在内部。那么为什么不实用一个即存的，被良好验证的设计模式呢？这种设计模式可以非常方便的支持第三方的转场动画。</p>

<h2>介绍相关的API</h2>

<p>在我们开始写代码之前，让我们先花一分钟时间来简单看一下我们需要的组件吧。</p>

<p>ios7自定义视图控制器转场的API基本上都是以协议的方式提供的，这也使其可以非常灵活的使用，因为你可以很简单地讲它们插入到你的类中。最主要的五个组件如下：</p>

<ol>
<li>动画控制器(Animation Controllers)遵从UIViewControllerAnimatedTransitioning协议，并且负责实际执行动画。</li>
<li>交互控制器(Interaction Controllers)通过遵从UIViewControllerInteractiveTransitioning协议来控制可交互式的转场</li>
<li>转场代理(Transitioning Delegates)根据不同的转场类型方便的提供需要的动画控制器和交互控制器</li>
<li>转场上下文(Transitioning Contexts)定义了转场时需要的元数据，比如在转场过程中所参与的视图控制和视图相关属性。转场上下文对象遵从UIViewControllerContextTransitoning协议，并且这是由系统负责生成和提供的。</li>
<li>转场协调器(Transition Coordinators)可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoorinator协议。</li>
</ol>


<p>正如你从其他的阅读材料中得知的那样，转场有不可交互式和可交互式两种方式。在本文红，我们将集中精力于不可交互的转场。这种转场是最简单的转场，也是我们学习的一个好的开始。这意味着我们需要处理上面提到的动画控制器(animation controllers)，转场代理(transioning delegates)和转场上下文(transionging contexts)</p>

<h2>示例工程</h2>

<p>通过三个阶段，我们将要实现一个简单自定义的视图控制器容器，它可以对子视图控制器提供自定义的转场动画的支持。</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions">这里</a>找到这三个阶段的Xcode工程的源代码</p>

<h3>阶段1:基础</h3>

<p>我们应用中的核心类是<code>ContainerViewController</code>，它持有一个UIViewController实例的数组，每个实例是一个普通的ChildViewController。容器视图控制器设置了一个带有可点击图标，并代表每个子视图控制器的私有的子视图:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-1.gif" alt="1" /></p>

<p>我们通过点击图标在不同的子视图控制器之间切换，在这一阶段，子视图控制器之间切换时是没有转场动画的。</p>

<p>你可以在这里查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-1">阶段1</a>的源代码</p>

<h3>阶段2：转场动画</h3>

<p>当我们添加转场动画时，我们想要使用一个遵从 UIViewControllerAnimatedTransitioning协议的动画控制器(animation controllers)。这个协议声明了三个方法，前面的2歌方法是必须实现的：</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
- (void)animationEnded:(BOOL)transitionCompleted;  
</code></pre>

<p>通过这些方法，我们可以获得我们所需的所有东西。当我们的视图控制器容器准备执行动画时，我们可以从动画冬至器中获取动画的持续时间，并让其去执行真正的动画。当动画执行完毕后，如果动画控制器实现了可选的 <code>animationEnded:</code>方法，我们可以调用动画控制器中的 animationEnded: 方法。</p>

<p>但是，首先我们必须把一件事情搞清楚。正如你在上面的方法签名中看到的那样，上面两个必须实现的方法需要一个转场上下文参数，这是一个遵从 <code>UIViewControllerContextTransionging</code>协议的对象。通常情况下，当我们使用系统内建的类时，系统框架为我们创建了转场上下文对象，并把它传递给动画控制器。但是在我们这种情况下，我们需要自定义转场动画，所以我们需要承担系统框架的责任，自己去创建这个转场上下文对象。</p>

<p>这就是大量使用协议的方便之处。我们可以不用必须复写一个私有类，而复写私有类这种方法是明显不可行的。我们可以定义自己的类，并使其遵从文档中相应的协议就可以了。</p>

<p>尽管在UIViewControllerContextTransioning协议中声明了很多方法，而且他们都是必须要实现的，但是我们现在可以暂时忽略它们中的一些方法，因为我们现在仅仅支持不可交互的转场。</p>

<p>同UIKit类似，我们定义了私有类<code>NSObject &lt;UIViewControllerContextTransitioning&gt;</code>.在我们的特定例子汇总，这个私有类是 PrivateTransitionContext,它的初始化方法如下实现:</p>

<pre><code>- (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController goingRight:(BOOL)goingRight {
    NSAssert ([fromViewController isViewLoaded] &amp;&amp; fromViewController.view.superview, @"The fromViewController view must reside in the container view upon initializing the transition context.");

    if ((self = [super init])) {
        self.presentationStyle = UIModalPresentationCustom;
        self.containerView = fromViewController.view.superview;
        self.viewControllers = @{
            UITransitionContextFromViewControllerKey:fromViewController,
            UITransitionContextToViewControllerKey:toViewController,
        };

        CGFloat travelDistance = (goingRight ? -self.containerView.bounds.size.width : self.containerView.bounds.size.width);
        self.disappearingFromRect = self.appearingToRect = self.containerView.bounds;
        self.disappearingToRect = CGRectOffset (self.containerView.bounds, travelDistance, 0);
        self.appearingFromRect = CGRectOffset (self.containerView.bounds, -travelDistance, 0);
    }

    return self;
}
</code></pre>

<p>我们把视图的出现和消失时的状态记录了下来，比如初始状态和最终状态的frame.</p>

<p>请注意一点，我们的初始化方法需要我们提供我们是在向右切换还是向左切换。在我们的<code>ContainerViewController</code>中，按钮是一个接一个水平排列的，转场上下文通过设置每个frame来记录它们之间的位置关系。动画控制器或者说 animator,在生成动画时可以使用这些frame.</p>

<p>我们也可以通过另外的方式去获取这些信息，但是那样的话，就会使animator和<code>ContainerViewController</code>及其视图控制器耦合在一起了，这是不好的，我们并不想这样。animator应该只关心它自己以及传递给它的上下文，因为这样，在理想的情况下，animator可以在不同的上下文中得到复用。</p>

<p>在下一步实现我们自己的动画控制器时，我们应该时刻记住这一点，现在让我们来实现转场上下文吧。</p>

<p>使用Animator类的实例来做转场动画的核心代码如下所示:</p>

<pre><code>[fromViewController willMoveToParentViewController:nil];
[self addChildViewController:toViewController];

Animator *animator = [[Animator alloc] init];

NSUInteger fromIndex = [self.viewControllers indexOfObject:fromViewController];
NSUInteger toIndex = [self.viewControllers indexOfObject:toViewController];
PrivateTransitionContext *transitionContext = [[PrivateTransitionContext alloc] initWithFromViewController:fromViewController toViewController:toViewController goingRight:toIndex &gt; fromIndex];

transitionContext.animated = YES;
transitionContext.interactive = NO;
transitionContext.completionBlock = ^(BOOL didComplete) {
    [fromViewController.view removeFromSuperview];
    [fromViewController removeFromParentViewController];
    [toViewController didMoveToParentViewController:self];
};

[animator animateTransition:transitionContext];
</code></pre>

<p>这其中的大部分是对视图控制器容器的操作，计算出我们是在向左切换还是向右切换，做动画的部分基本上只有3行代码：</p>

<ol>
<li>创建Animator</li>
<li>创建转场上下文</li>
<li>触发动画执行</li>
</ol>


<p>有了上面的代码，转场效果看起来如下图所示:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-2.gif" alt="2" /></p>

<p>非常酷，我们甚至没有写一行动画相关的代码</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-2">阶段2</a>标签下看到这部分代码的变化。</p>

<h3>阶段3：封装</h3>

<p>我想我们最后要做的一件事情是封装 ContainerViewController,使其能够:</p>

<ol>
<li>提供默认的转场动画</li>
<li>提供替换默认动画控制器的代理</li>
</ol>


<p>这意味着我们需要对Animator类的依赖移除，同时需要创建一个代理协议。</p>

<p>我们如下定义这个协议:</p>

<pre><code>@protocol ContainerViewControllerDelegate &lt;NSObject&gt;
@optional
- (void)containerViewController:(ContainerViewController *)containerViewController didSelectViewController:(UIViewController *)viewController;
- (id &lt;UIViewControllerAnimatedTransitioning&gt;)containerViewController:(ContainerViewController *)containerViewController animationControllerForTransitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController;
@end
</code></pre>

<p><code>containerViewController:didSelectViewController:</code>方法使<code>ContainerViewController</code>可以很容易的集成与功能齐全的应用中。</p>

<p><code>containerViewController:animationControllerForTransitionFromViewController:toViewController:</code>方法挺有趣的，当然，你可以把它和下面的UIKit中的视图控制器容器的代理协议做对比:</p>

<ul>
<li>tabBarController:animationControllerForTransitionFromViewController:toViewController: (UITabBarControllerDelegate)</li>
<li>navigationController:animationControllerForOperation:fromViewController:toViewController: (UINavigationControllerDelegate)</li>
</ul>


<p>所有的这些方法都返回一个id<UIViewControllerAnimatedTransitioning>对象。与之前一直使用一个 Animator 对象不同，我们现在可以从我们的代理那里获取一个动画控制器:</p>

<pre><code>id&lt;UIViewControllerAnimatedTransitioning&gt;animator = nil;
if ([self.delegate respondsToSelector:@selector (containerViewController:animationControllerForTransitionFromViewController:toViewController:)]) {
    animator = [self.delegate containerViewController:self animationControllerForTransitionFromViewController:fromViewController toViewController:toViewController];
}
animator = (animator ?: [[PrivateAnimatedTransition alloc] init]);
</code></pre>

<p>如果我们有代理并且它返回一个Animator,那么我们就使用这个 animator.否则，我们使用内部私有类PrivateAnimatedTransition 创建一个默认的 animator.接下来我们将实现 <code>PrivateAnimatedTransition</code>类。</p>

<p>尽管默认的动画和 Animator有一些不同，但是代码看起来惊人的相似，下面是完整的代码实现:</p>

<pre><code>@implementation PrivateAnimatedTransition

static CGFloat const kChildViewPadding = 16;
static CGFloat const kDamping = 0.75f;
static CGFloat const kInitialSpringVelocity = 0.5f;

- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return 1;
}

- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {

    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];

    // When sliding the views horizontally, in and out, figure out whether we are going left or right.
    BOOL goingRight = ([transitionContext initialFrameForViewController:toViewController].origin.x &lt; [transitionContext finalFrameForViewController:toViewController].origin.x);

    CGFloat travelDistance = [transitionContext containerView].bounds.size.width + kChildViewPadding;
    CGAffineTransform travel = CGAffineTransformMakeTranslation (goingRight ? travelDistance : -travelDistance, 0);

    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;
    toViewController.view.transform = CGAffineTransformInvert (travel);

    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:kDamping initialSpringVelocity:kInitialSpringVelocity options:0x00 animations:^{
        fromViewController.view.transform = travel;
        fromViewController.view.alpha = 0;
        toViewController.view.transform = CGAffineTransformIdentity;
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
    }];
}

@end
</code></pre>

<p>需要注意一点的是，上面的代码没有通过设置视图的frame 来反应它们之间的位置关系，但是代码仍然可以正常工作，只不过转场总是在同一个方向上。因此，这个类也可以被其它的代码库使用。</p>

<p>转场动画看起来像是这样:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-3.gif" alt="2" /></p>

<p>在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-3">阶段3</a>代码中，app delegate中设置代理的部分被注释掉了，这样就可以看到默认的动画效果了，你可以将其设置回再使用 Animator类，你可能想查看同<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-2...stage-3">阶段2相比所有的修改</a></p>

<p>我们现在有一个自包含的提供了默认转场动画的 ContainerViewController 类，这个默认的转场动画可以被开发者定义的ios7自定义动画控制器(UIViewControllerAnimatedTransitioning)的对象代替，甚至都可以不用关心我们的源代码就可以方便的替换。</p>

<h2>结论</h2>

<p>在本文中，我们通过使用ios7提供的自定义视图控制器转场的新特性，使得我们自定义的视图控制器容器成为了UIkit的一等公民。</p>

<p>这意味着你可以把自定义的非交互的转场动画应用到自定义的视图控制器容器中。你可以看到我们把7个话题之前使用的转场类直接拿过来使用，而且没有做任何修改。</p>

<p>如果你想让自己的容器视图控制器作为一个类库或者框架，或者仅仅想使你的代码得到更好的复用，这将是非常完美的。</p>

<p>我们现在仅仅支持非交互式的转场，下一步就是对交互式的转场也提供支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua/"/>
    <updated>2016-05-30T09:26:31+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua</id>
    <content type="html"><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要使用用户的需求以及为执行各种任务而改变状态。</p>

<p>在这些状态之间转换时，清晰的揭示正在发生什么是非常重要的。而不是在页面之间跳跃，动画帮助我们解释用户从哪里来，要到哪里去。</p>

<!--more-->


<p>键盘在View中滑进滑出给了我们一个错觉，让我们以为它是简单的被隐藏在屏幕下方的，并且是手机很自然的一个部分。View Controller转场加强了我们的应用程序的导航结构，并且给了用户正在移向那个方向的提示。微妙的反弹和碰撞使界面栩栩如生，并且激发出了物理的质感。要是没有这些的话，我们就只有一个没有视觉设计的干巴巴的环境了。</p>

<p>动画是叙述你的应用的故事的绝佳方式，在了解动画背景的基本原理之后，设计它们会轻松很多。</p>

<h2>首要任务</h2>

<p>在这篇文章中，我们将特别地针对  Core Anmiation进行探讨，虽然你将看到的很多东西也可以用更高级的UIKit的方法来完成，但是Core Animation将会让你更好的理解正在发生什么。它以一种更明确的方式来描述动画，这对这篇文章以及你自己的代码的读者来说都非常有用。</p>

<p>在看动画如何与我们的屏幕上的看到的内容交互之前，我们需要快速浏览一下Core Animation的<code>CALayer</code>，这是动画产生作用的地方。</p>

<p>你大概知道UIView实例，以及layer-backed的NSView,修改它们的layer来委托强大的Core Graphics框架来进行渲染。然而你务必要理解，当把动画添加到一个layer时，是不直接修改它的属性的。</p>

<p>取而代之，Core Animation维护了两个平行的layer层次结构:mode layer tree(模型层树)和presentation layer tree(表示层树)。前者中的layers反映了我们能直接看到的layers的状态，而后者的layers则是正在表现的值的近似。</p>

<p>考虑在view上增加一个渐出动画。如果在动画中的任意时刻，查看layer的opacity值，你是得不到与屏幕内容对应的透明度的。取而代之，你需要查看presentaion layer 以获得正确的结果。</p>

<p>虽然你可能不会去直接设置presentaion layer的属性，但是使用它的当前值来创建新的动画护着在动画发生时与layers交互式非常有用的。</p>

<p>通过使用 <code>-[CALayer presentaionLayer]</code>和<code>[CALayer modelLayer]</code>，你可以在两个layer之间轻松切换。</p>

<h2>基本动画</h2>

<p>可能最常见的情况是将一个View的属性从一个值改变为另一个值，考虑夏敏的这个例子。</p>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-linear.gif" alt="w" />
 
在这里，我们让红色小火箭的 x-position从77 变为455,刚好超过的parent View的边，为了填充所有路径，我们需要确定我们的火箭在任意时刻所到达的位置。这通常使用线性插值法来完成。</p>

<pre><code>X(T)=x0 + t△x
</code></pre>

<p>也就是说，对于动画给定的一个分数t,火箭的x坐标就是起始点的x坐标77，加上一个到终点的距离∆x = 378,乘以该分数的值。</p>

<p>使用<code>CABasicAnimation</code>，我们可以如下实现这个动画:</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

[rocket.layer addAnimation:animation forKey:@"basic"];
</code></pre>

<p>请注意我们的动画键路径，也就是position.x,实际上包含一个存储在<code>position</code>属性中的CGPoint结构体成员。这是CoreAnimation一个非常方便的特性。请查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html">支持的键路径的完整列表</a></p>

<p>然而，当我们运行该代码时，我们意识到火箭在完成动画后马上回到了初始位置，这是因为在默认情况下，动画不会再超出其持续时间后还修改 presentaion layer.实际上，在结束时它甚至会被彻底移除。</p>

<p>一旦动画被移除，presentation layer将回到 model layer的值，并且因为我们从未修改该layer的 postion属性，所以我们的飞船将重新出现在它开始的地方。</p>

<p>这里有两种解决这个问题的方法:</p>

<p>第一种方法是直接在 model layer上更新尚需经，这是推荐的做法，因为它使得动画完全可选。</p>

<p>一旦动画完成并且从layer中移除，presentation layer将回到model layer设置的值，而这个值恰好与动画最后一个步骤相匹配</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

[rocket.layer addAnimation:animation forKey:@"basic"];

rocket.layer.position = CGPointMake(455, 61);
</code></pre>

<p>或者，你可以通过设置动画的fillMode属性为<code>kCAFillModeForward</code>，并设置<code>removedOnCompletion</code>为No以防止它被自动移除:</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

animation.fillMode = kCAFillModeForward;
animation.removedOnCompletion = NO;

[rectangle.layer addAnimation:animation forKey:@"basic"];
</code></pre>

<p>如果将已完成的动画保持在layer上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>

<p>指的指出的是，实际上我们创建的动画对象在被添加到layer时立刻就复制了一份。这个特性在多个view中重用动画时这非常有用。比方说我们想要第二个火箭在第一个火箭起飞后不久后起飞：</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.byValue = @378;
animation.duration = 1;

[rocket1.layer addAnimation:animation forKey:@"basic"];
rocket1.layer.position = CGPointMake(455, 61);

animation.beginTime = CACurrentMediaTime() + 0.5;

[rocket2.layer addAnimation:animation forKey:@"basic"];
rocket2.layer.position = CGPointMake(455, 111);
</code></pre>

<p>设置动画的<code>beginTime</code>为未来0.5秒将只会影响<code>rocket2</code>，因为动画在执行语句<code>[rocket1.layer addAnimation:animation forKey:@"basic"];</code>时已经被复制了，并且之后的rocket1也不会考虑对动画对象的改变。</p>

<p>不妨看一看David的<a href="http://ronnqvi.st/controlling-animation-timing/">关于动画时间的一篇很棒的文章</a>，通过它可以学习如何更精确的控制你的动画。</p>

<p>我决定再使用<code>CABasicAnimation</code>的byValule属性创建一个动画，这个动画从presentaion layer的当前值开始，加上byValue的值后结束。这使得动画更易于重用，因为你不需要精确的指定可能无法提前知道的from- 和 toValue的值。</p>

<p><code>fromValue</code>,<code>byValue</code>和<code>toValue</code>的不同组合可以用来实现不同的效果，如果你需要创建一个可以在你的不同应用中重用的动画，你可以<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">查看文档</a></p>

<h2>多步动画</h2>

<p>这很容易想到一个场景，你想要为你的冻哈定义超过两个步骤，我们可以使用更通用的<code>CAKeyframeAnimation</code>，而不是去链接多个<code>CABasicAnimation</code>实例。</p>

<p>关键帧(keyFrame)使我们能够定义动画中任意的一个点，然后让core Animation填充所谓的中间帧</p>

<p>比方说我们正在制作我们下一个Iphone应用程序汇总的登录表单，我们希望当用户输入错误的密码时表单会晃动，使用关键帧动画，看起来大概像是这样：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/form.gif" alt="d" /></p>

<pre><code>CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @"position.x";
animation.values = @[ @0, @10, @-10, @10, @0 ];
animation.keyTimes = @[ @0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1 ];
animation.duration = 0.4;

animation.additive = YES;

[form.layer addAnimation:animation forKey:@"shake"];
</code></pre>

<p>values数组定义了表单应该到哪些位置、</p>

<p>设置keytimes属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal">
请注意我是如何选择不同的值从0到10到-10转换以维持恒定的速度的。
</a></p></blockquote>

<p>设置additive尚需经为YES 使 Core Animation在更新 presentaion layer之前将动画的值添加到 model layer中去。这使得我们能够对所有形式的需要更新的元素重用相同的动画，且无需提前知道它们的位置。因为这个属性从<code>CAPropertyAnimation</code>继承，所以你也可以在使用<code>CABasicAnimation</code>时使用它。</p>

<h2>沿路径的动画</h2>

<p>虽然用代码实现一个简单的水平晃动并不难，但是沿着复杂路径的 动画就需要我们在关键帧的values数组中存储大量box化的CGPoint.指的庆幸的是，<code>CAKeyFrmeAnimaiton</code>提供了更加便利的Path属性作为代替</p>

<p>举个例子，我们如何让一个view做圆周运动:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets.gif" alt="1" /></p>

<pre><code>CGRect boundingRect = CGRectMake(-150, -150, 300, 300);

CAKeyframeAnimation *orbit = [CAKeyframeAnimation animation];
orbit.keyPath = @"position";
orbit.path = CFAutorelease(CGPathCreateWithEllipseInRect(boundingRect, NULL));
orbit.duration = 4;
orbit.additive = YES;
orbit.repeatCount = HUGE_VALF;
orbit.calculationMode = kCAAnimationPaced;
orbit.rotationMode = kCAAnimationRotateAuto;

[satellite.layer addAnimation:orbit forKey:@"orbit"];
</code></pre>

<p>使用<code>CGPathCreateWithEllipseInRect ()</code>，我们创建一个圆形的<code>CGPath</code>作为我们的关键帧动画的path.</p>

<p>使用<code>calculationMode</code>是控制关键帧动画时间的另一种方式。我们通过将其设置为<code>kCAAnimationPaced</code>，让Core Animation想被驱动的对象施加一个恒定速度，不管路径的各个线程有多长，将其设置为<code>kCAAnimationPaced</code>将无视所有我们已经设置的 keyTimes.</p>

<p>设置 rotationsMode属性为 <code>kCAAnimationRotateAuto</code>，确保飞船沿着路径旋转。作为对比，我们将该属性设置为nil，那动画会怎么样呢？</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets-incorrect.gif" alt="2" /></p>

<h2>时间函数</h2>

<p>让我们再次来看看第一个例子 ：</p>

<p>你会发现我们的火箭的动画有些看起来非常不自然的地方，那是因为我们在现实时间中看到的大部分运动需要时间来加速或者减速。对象瞬间达到最高速度，然后再立即停止往往看起来非常不自然。除非你在让机器人跳舞，但这很少是想要的结果。</p>

<p>为了给我们的动画一个存在惯性的感觉，我们可以使用我们上面提到的参数因子来进行插值。然而，如果我们接下来需要为每个需要加速或减速的行为创建一个新的插值函数，这将是一个很难扩展的方法。</p>

<p>取而代之，常见的做法是把要进行动画的属性的插值从动画的速度中解耦出来。这样一来，给动画提速会差生一种小火箭加速运动的效果，而不用改变我们的插值函数。</p>

<p>我们可以通过引入一个时间函数 （timing function）来实现这个目标。该函数通过修改持续时间的分数来控制动画的速度。</p>

<p>最简单的easing函数是linear.它在整个动画上维持一个恒定的速度。在 Core Animation中，这个功能由CAMediaTimingFunction来表示。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-linear.gif" alt="2" /></p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x"; 
animation.fromValue = @50;
animation.toValue = @150;
animation.duration = 1;

animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];

[rectangle.layer addAnimation:animation forKey:@"basic"];

rectangle.layer.position = CGPointMake(150, 0);
</code></pre>

<p>Core Animation附带了一些linear之外的内置easing函数，如:</p>

<ul>
<li><p>Ease in (kCAMediaTimingFunctionEaseIn):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easein.gif" alt="1" /></p></li>
<li><p>Ease out (kCAMediaTimingFunctionEaseOut):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeout.gif" alt="2" /></p></li>
<li><p>Ease in ease out (kCAMediaTimingFunctionEaseInEaseOut):</p></li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeineaseout.gif" alt="3" /></p>

<ul>
<li>默认 (kCAMediaTimingFunctionDefault):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-default.gif" alt="4" /></li>
</ul>


<p>在一定限度内，你也可以使用<code>+functionWithControlPoints::::</code>创建自己的easing函数。通过传递cubic Bezier曲线的两个控制点的x和y坐标，你可以轻松的创建自定义easying函数，比如我为我们的红色小火箭选择的那个。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-custom.gif" alt="custom" /></p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0.5:0:0.9:0.7];

[rocket.layer addAnimation:animation forKey:@"basic"];

rocket.layer.position = CGPointMake(150, 0);
</code></pre>

<p>我不打算讲太多关于Bezier曲线的细节，在计算机图形学中，它们是创建平滑曲线的常用技术。你可能在基于矢量的绘图工具，比如Sketch或者Adobe lllustrotor中见过它们。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/bezier.png" alt="1" /></p>

<p>传递给 <code>+functionWithControlPoints::::</code>的值有效地控制了控制点的位置。所得到的定时函数将基于得到的路径来调整动画的速度。X轴代表时间的分数，而Y轴是插值函数的插入值。</p>

<p>遗憾的是，由于这些部分被锁定在[0-1]的范围内，我们不可能用它来创建一些像预期动作(Anticipation,一种像目标进发前先回退一点，到达目标后还过冲一会，见下图)这样的常见效果 .</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/anticipate.gif" alt="3" /></p>

<h2>动画组</h2>

<p>对于某些复杂的效果，可能需要同时为多个属性进行动画。想象一下，在一个媒体播放程序中，当切换到随机曲目时我们让随机动画效果，看起来就想下面这样:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/covers.gif" alt="animaiton" /></p>

<p>你可以看到，我们需要同时对上面的封面的 position,roation和 z-position进行动画，使用 CAAimationGroup来动画其中一个封面的代码如下:</p>

<pre><code>CABasicAnimation *zPosition = [CABasicAnimation animation];
zPosition.keyPath = @"zPosition";
zPosition.fromValue = @-1;
zPosition.toValue = @1;
zPosition.duration = 1.2;

CAKeyframeAnimation *rotation = [CAKeyframeAnimation animation];
rotation.keyPath = @"transform.rotation";
rotation.values = @[ @0, @0.14, @0 ];
rotation.duration = 1.2;
rotation.timingFunctions = @[
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
];

CAKeyframeAnimation *position = [CAKeyframeAnimation animation];
position.keyPath = @"position";
position.values = @[
    [NSValue valueWithCGPoint:CGPointZero],
    [NSValue valueWithCGPoint:CGPointMake(110, -20)],
    [NSValue valueWithCGPoint:CGPointZero]
];
position.timingFunctions = @[
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
];
position.additive = YES;
position.duration = 1.2;

CAAnimationGroup *group = [[CAAnimationGroup alloc] init];
group.animations = @[ zPosition, rotation, position ];
group.duration = 1.2;
group.beginTime = 0.5;

[card.layer addAnimation:group forKey:@"shuffle"];

card.layer.zPosition = 1;
</code></pre>

<p>我们使用CAAimationGroup得到一个好处是可以将所有动画作为一个对象暴露出去。如果你要在应用程序中的多个地方用工厂对象创建的重用的动画的话，这将会非常有用。</p>

<p>你也可以使用动画组同时控制所有动画组成部分的时间</p>

<h2>Core Animation 之外</h2>

<p>你应该已经听过 UIKIT Dynamics了，这是ios7中引入的一个物理模拟框架，它允许你使用约束和力来为 views做动画。与core Animation不同，它与你在屏幕上看到的内容交互更为间接，但是它的动态特性让你可以在事先不知道结果时创建动画。</p>
]]></content>
  </entry>
  
</feed>
