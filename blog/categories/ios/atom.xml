<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-07-21T08:59:19+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo/"/>
    <updated>2016-07-19T13:44:10+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在ios中，所有的View都是由一个底层的layer来驱动的。View和它的layer之间有着紧密的联系，View其实直接从layer对象中获取了绝大多数它所需要的数据。在ios中也有一些单独的layer,比如<code>AVCaptureVideoPreviewLayer</code>和<code>CAShapeLayer</code>，它们不需要附加到view上就可以在屏幕上显示内容。两种情况下都是layer起决定作用。当然了，附加到view上的layer和单独的layer在行为上还是稍有不同的。</p>

<!--more-->


<p>基本上你改变一个单独的layer的任何属性的时候，都会触发一个从旧值过渡到新值的简单动画（就是所谓的动画<code>animatable</code>）。然而，如果你改变的是view中layer的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有layer,但是当layer附加在view上时，它的默认的隐式动画的layer行为就不起作用了。</p>

<blockquote><p><em>注意</em>
animatable 几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以'animatable'结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，设置也囊括了像isHidden和doubleSides这样的布尔值。像paths这样的属性也是animatable的。但是它不支持隐式动画。</p></blockquote>

<p>在 Core Animation 编程指南的"How to Animate Layer-Backed Views"中，对为什么会这样做出了一个解释:</p>

<blockquote><p>UIView默认情况下进制了layer动画，但是在animation block中又重新启用了它们</p></blockquote>

<p>这正是我们所看到的额行为，当一个属性在动画block之外被改变时，没有动画，但是当属性在动画block内改变时，就带上了动画。对于这是如何发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了view和layer之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的layer属性改变时，layer都会寻找并运行何时的'Action'来实行这个改变。在core Animation的专业术语中就把这样的动画统称为动作(Action,或者CAAction)</p>

<blockquote><p>CAAction:从技术上来说，这是一个接口，并可以用来做各种事情，但是实际上，某种程度上你可以只把它理解为用来处理动画</p></blockquote>

<p>layer将像文档中缩写的那样去寻找动作，整个过程分为5个步骤。第一步中的view和layer中交互的部分是最有意思的：</p>

<p>layer通过向它的代理发送 <code>actionForLayer:forKey:</code>消息来询问提供一个对应属性变化的action.delegate可以通过返回以下三者之一来进行响应:</p>

<ol>
<li>它可以返回一个动作对象，这种情况下layer将使用这个动作</li>
<li>它可以返回一个nil,这样layer就会到其他地方继续寻找</li>
<li>它可以返回一个NShull对象，告诉layer这里不需要执行一个动作，搜索也会就此停止</li>
</ol>


<p>而让这一切变得有趣的是，当layer在背后支持一个view的时候，view就是它的delegate;</p>

<blockquote><p>在ios中，如果layer与一个UIview对象关联时，这个属性必须被设置为持有这个layer的那个view</p></blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了；属性改变时layer会向View请求一个动作，而一般情况下view将返回一个NSNull,只有当属性改变发生在动画block中时，view才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的layer属性向view询问动作就可以了，比如对于'position':</p>

<pre><code>NSLog(@"outside animation block: %@",
      [myView actionForLayer:myView.layer forKey:@"position"]);

[UIView animateWithDuration:0.3 animations:^{
    NSLog(@"inside animation block: %@",
          [myView actionForLayer:myView.layer forKey:@"position"]);
}];
</code></pre>

<p>运行上面的代码，可以看到在block外view返回的是NSNull对象，而在block中时返回的是一个CABasicAnimation.很优雅，对吧?值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))：</p>

<pre><code>outside animation block: &lt;null&gt;
inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;
</code></pre>

<p>对于view中的layer来说，对动作的搜索只会到第一步为止。对于单独的layer来说，剩余的4个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer</a>actionForKey: 文档中找到。</p>

<h2>从UIKit中学习</h2>

<p>我很确定我们都会同意UIview动画是一组非常优秀的API,它简洁明确，实际上，它使用了Core Animation来执行动画，这给了我们一个绝佳的积水来深入研究UIKit是如何使用Core Animation的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴.</p>

<p>当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forKey:方法将添加到layer中，就像显示地添加动画那样。再一次，别直接相信我，让我们实践检验一下</p>

<p>归功于UIview的layerClass 类方法，View和layer之间的交互很容易被观测到。通过这个方法我们可以在为View创建layer时为其指定要使用的类。通过子类一个UIView,以及用这个方法返回一个自定义的layer类，我们就可以重写layer子类中的 <code>addAnimaiton:ForKey:</code>并输出一些东西来验证它是佛确实被调用。唯一要记住的是我们需要调用super方法，不然的话我们就把要观测的行为完全改变了：</p>

<pre><code>@interface DRInspectionLayer : CALayer
@end

@implementation DRInspectionLayer
- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
{
    NSLog(@"adding animation: %@", [anim debugDescription]);
    [super addAnimation:anim forKey:key];
}
@end


@interface DRInspectionView : UIView
@end

@implementation DRInspectionView
+ (Class)layerClass
{
    return [DRInspectionLayer class];
}
@end
</code></pre>

<p>通过输出动画的debug信息，我们不仅可以验证它确实如逾期一样被调用了，还可以看到动画是如何组织构建的：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
    fillMode = both; 
    timingFunction = easeInEaseOut; 
    duration = 0.3; 
    fromValue = NSPoint: {5, 5}; 
    keyPath = position
&gt;
</code></pre>

<p>当动画被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue(也就是当前值)被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的行为应该是:</p>

<blockquote><p>只有FromValue不是nil时，在fromvalue和属性当前显示层的值之间进行插值</p></blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到layer上：</p>

<pre><code>CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@"opacity"];
fadeIn.duration  = 0.75;
fadeIn.fromValue = @0;

myLayer.opacity = 1.0; // 更改 model 的值 ...
// ... 然后添加动画对象
[myLayer addAnimation:fadeIn forKey:@"fade in slowly"];
</code></pre>

<p>这很简洁，你也不需要再动画被移除的时候做什么额外的操作，如果动画是在一段延迟后才开始的话，你可以使用backward填充模式(或者'both'填充模式)，就像UIKit所创建的动画那样</p>

<p>可能你看见上面输出中的动画的delegate了，想知道这个类是用来做什么的呢？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a>,它主要用来维护动画的一些状态(持续时间，延时，重复次数等等)，它还负责对一个栈做push和pop,这是为了在多个动画block嵌套时能够获取正确的动画状态。这些都是事先细节，除非你想要写一套自己的基于block的动画API,否则可能你不会用到它们</p>

<p>然后真正有意思的是这个delegate事先了 animationDidStart: 和 animationDidStop:finished: 并将信息传给了它自己的delegate</p>

<blockquote><p>这里不太容易理解，加以说明:从上面的头文件可以看出，作为CAAnimation的delegate的私有类UIViewAnimationState中还有个<code>_delegate</code>成员，并且<code>animationDidStart</code>和<code>animationDidStop:finished:</code>也是典型的delegate的实现方法.</p></blockquote>

<p>通过打印这个delegate的delegate,我们可以发现它也是一个私有类：<code>UIViewAnimationBlockDelegate</code>。同样进行<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且进行相应的block.如果我们使用自己的Core Animation代码，并且选阿泽block而不是delegate做回调的话，添加这个是很容易的：</p>

<pre><code>@interface DRAnimationBlockDelegate : NSObject

@property (copy) void(^start)(void);
@property (copy) void(^stop)(BOOL);

+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
                                   completion:(void(^)(BOOL finished))completion;

@end

@implementation DRAnimationBlockDelegate

+ (instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
                                    completion:(void (^)(BOOL))completion
{
    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
    result.start = beginning;
    result.stop  = completion;
    return result;
}

- (void)animationDidStart:(CAAnimation *)anim
{
    if (self.start) {
        self.start();
    }
    self.start = nil;
}

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    if (self.stop) {
        self.stop(flag);
    }
    self.stop = nil;
}

@end
</code></pre>

<p>虽然是我的个人喜好，但是我觉得像这样的基于block的回调风格可能会比实现一个delegate回调更适合你的代码:</p>

<pre><code>fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
    NSLog(@"beginning to fade in");
} completion:^(BOOL finished) {
    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
}];
</code></pre>

<h2>自定义基于block的动画APIS</h2>

<p>一旦你知道了<code>actionForKey:</code>的原理之后，UIview就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于block的动画Apis。我所设计的动画将通过block中用一个很激进的时间曲线来做动画，以吸引用户对该View的注意，之后做一个缓慢的动画回到原始状态。你可以把它看做一种类似pop的行为。与一般使用<code>UIViewAnimationOptionAutoreverse</code>的动画block不同，因为动画设计和概念上的需要，我自己实现了将model值改变回原始值的过程。自定义的动画API的使用方法就像这样:</p>

<pre><code>[UIView DR_popAnimationWithDuration:0.7
                             animations:^{
                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
                                }];
</code></pre>

<p>当我们完成后，效果是这样样子的(对四个不同的View为位置，尺寸，颜色和旋转进行动画)</p>

<p><img src="http://7xsn4e.com1.z0.glb.clouddn.com/2014-05-01-view-layer-synergy-custom-block-animations.gif" alt="1" /></p>

<p>要开始实现它，我们首先要做的是当一个layer属性变化时获取delegate的回调，因为我们无法实现预测layer要改变什么，所以我选择在一个UIView的category中的swizzle<code>actionForLayer:forKey:</code>方法:</p>

<pre><code>@implementation UIView (DR_CustomBlockAnimations)

+ (void)load
{        
    SEL originalSelector = @selector(actionForLayer:forKey:);
    SEL extendedSelector = @selector(DR_actionForLayer:forKey:);

    Method originalMethod = class_getInstanceMethod(self, originalSelector);
    Method extendedMethod = class_getInstanceMethod(self, extendedSelector);

    NSAssert(originalMethod, @"original method should exist");
    NSAssert(extendedMethod, @"exchanged method should exist");

    if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
        class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, extendedMethod);
    }
}
</code></pre>

<p>为了保证我们不破坏其他依赖于<code>actionForLayer:forKey:</code>的回调代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子莱索一个简单的Bool其实就够了，但是如果我们之后要写更多内容的话，上下文的话要灵活得多了：</p>

<pre><code>static void *DR_currentAnimationContext = NULL;
static void *DR_popAnimationContext     = &amp;DR_popAnimationContext;

- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
    if (DR_currentAnimationContext == DR_popAnimationContext) {
        // 这里写我们自定义的代码...
    }

    // 调用原始方法
    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
}
</code></pre>

<p>在我们的实现中，我们要确保在执行动画block之前设置动画的上下文，并且在执行后恢复上下文：</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;
     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();
     /* 一会儿再添加 */
     DR_currentAnimationContext = NULL;
 }
</code></pre>

<p>如果我们想要做的不过是添加一个从旧值向新值过渡的动画的话，我们可以直接在delegate的回调中来做。然后因为我们想要更精确的控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓</p>

<p>有意思的是，ios添加的一个基于block的动画API也遇到了同样了问题，使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每一个关键帧，在属性变化时，view返回nil,但是却存储下需要的状态。这样就能在所有关键帧block执行后创建一个<code>CAKeyframeAnimationz</code>对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么layer被更改了，什么key path的值被改变了，以及原来的值是什么:</p>

<pre><code> @interface DRSavedPopAnimationState : NSObject

 @property (strong) CALayer  *layer;
 @property (copy)   NSString *keyPath;
 @property (strong) id        oldValue;

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath;

 @end

 @implementation DRSavedPopAnimationState

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath
 {
     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
     savedState.layer    = layer;
     savedState.keyPath  = keyPath;
     savedState.oldValue = [layer valueForKeyPath:keyPath];
     return savedState;
 }

 @end
</code></pre>

<p>接下来，在我们的交换后的delegate回调中，我们简单地讲被变更的属性的状态存入一个静态可变数组中：</p>

<pre><code> if (DR_currentAnimationContext == DR_popAnimationContext) {
       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
                                                                                 keyPath:event]];

       // 没有隐式的动画 (稍后添加)
       return (id&lt;CAAction&gt;)[NSNull null];
   }
</code></pre>

<p>在动画block执行完毕后，所有的属性都被变更了，它们的状态也被保存了，现在，创建关键帧动画:</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;

     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();

     [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
         DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
         CALayer *layer    = savedState.layer;
         NSString *keyPath = savedState.keyPath;
         id oldValue       = savedState.oldValue;
         id newValue       = [layer valueForKeyPath:keyPath];

         CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];

         CGFloat easing = 0.2;
         CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
         CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];

         anim.duration = duration;
         anim.keyTimes = @[@0, @(0.35), @1];
         anim.values = @[oldValue, newValue, oldValue];
         anim.timingFunctions = @[easeIn, easeOut];

         // 不带动画地返回原来的值
         [CATransaction begin];
         [CATransaction setDisableActions:YES];
         [layer setValue:oldValue forKeyPath:keyPath];
         [CATransaction commit];

         // 添加 "pop" 动画
         [layer addAnimation:anim forKey:keyPath];

     }];

     // 扫除工作 (移除所有存储的状态)
     [[self DR_savedPopAnimationStates] removeAllObjects];

     DR_currentAnimationContext = nil;
 }
</code></pre>

<p>注意老的model值被设置到了layer上，所以在当动画结束和移除后，model的值和persentation的值是相符合的。</p>

<p>创建像这样的你自己的API不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂UIview block动画的APis,特别是你已经在core Animation的舒适区的时候，这非常有助于你的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 ViewController 容器转场]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang/"/>
    <updated>2016-07-19T10:02:19+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang</id>
    <content type="html"><![CDATA[<p>我们在本文讨论navigation controller中的两个view controller之间的转场动画，但是这些做法在 tab bar controller或者任何你自己定义的view controller容器中也是通用的&hellip;</p>

<!--more-->


<p>尽管从技术角度来讲，使用ios7的api,你可以对自定义容器中的view controller做自定义转场，但是这不是能直接使用的，实现这种效果非常不容易。</p>

<p>请注意我正在讨论的自定义视图控制器容器都是UIViewController的直接子类，而不是UITabBarController或者UINavigationController的子类。</p>

<p>对于你自定义的继承与UIViewController的容器子类，并没有现成可用的Api允许一个任意的动画控制器将一个子视图控制器自动转场到另外一个，不管是可交互的转场还是不可交互式的转场。我甚至都觉得苹果根据不想支持这种方式。苹果支持下面的几种转场方式:</p>

<ul>
<li>Navigation Controller推入和推出页面</li>
<li>Tab bar Controller选择的改变</li>
<li>Model页面的展示和消失</li>
</ul>


<p>在本文中，我将向你展示如何自定义视图控制器容器，并且使其支持第三方的动画控制器</p>

<h2>预热准备</h2>

<p>看到这里，你可能对上文我们说到一些问题犯嘀咕，让我来告诉你答案吧:</p>

<p>为什么我们不直接继承UINavigationController或UITabBarController.并且使用它们提供的功能呢？</p>

<p>有些时候这是你不想要的。可能你想要一个非常特殊的外观或者行为，和这些类能够提供给你的差别非常大，因此你必须使用一些黑客式的手段去达到你想要的结果，同时还要担心系统框架的版本更新后这些黑客式的手段是否还仍然有效。或者，你就是想完全控制你的视图控制器容器，避免不得不支持一些特定的功能。</p>

<p>好吧，那么为什么不实用
<code>transitionFromViewController:toViewController:duration:options:animations:completion :</code>去实现呢?</p>

<p>这又是一个好问题，你可能想用这种方式去实现，但是或许你对代码的整洁性比较在意，想把这种转场相关的代码封装在内部。那么为什么不实用一个即存的，被良好验证的设计模式呢？这种设计模式可以非常方便的支持第三方的转场动画。</p>

<h2>介绍相关的API</h2>

<p>在我们开始写代码之前，让我们先花一分钟时间来简单看一下我们需要的组件吧。</p>

<p>ios7自定义视图控制器转场的API基本上都是以协议的方式提供的，这也使其可以非常灵活的使用，因为你可以很简单地讲它们插入到你的类中。最主要的五个组件如下：</p>

<ol>
<li>动画控制器(Animation Controllers)遵从UIViewControllerAnimatedTransitioning协议，并且负责实际执行动画。</li>
<li>交互控制器(Interaction Controllers)通过遵从UIViewControllerInteractiveTransitioning协议来控制可交互式的转场</li>
<li>转场代理(Transitioning Delegates)根据不同的转场类型方便的提供需要的动画控制器和交互控制器</li>
<li>转场上下文(Transitioning Contexts)定义了转场时需要的元数据，比如在转场过程中所参与的视图控制和视图相关属性。转场上下文对象遵从UIViewControllerContextTransitoning协议，并且这是由系统负责生成和提供的。</li>
<li>转场协调器(Transition Coordinators)可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoorinator协议。</li>
</ol>


<p>正如你从其他的阅读材料中得知的那样，转场有不可交互式和可交互式两种方式。在本文红，我们将集中精力于不可交互的转场。这种转场是最简单的转场，也是我们学习的一个好的开始。这意味着我们需要处理上面提到的动画控制器(animation controllers)，转场代理(transioning delegates)和转场上下文(transionging contexts)</p>

<h2>示例工程</h2>

<p>通过三个阶段，我们将要实现一个简单自定义的视图控制器容器，它可以对子视图控制器提供自定义的转场动画的支持。</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions">这里</a>找到这三个阶段的Xcode工程的源代码</p>

<h3>阶段1:基础</h3>

<p>我们应用中的核心类是<code>ContainerViewController</code>，它持有一个UIViewController实例的数组，每个实例是一个普通的ChildViewController。容器视图控制器设置了一个带有可点击图标，并代表每个子视图控制器的私有的子视图:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-1.gif" alt="1" /></p>

<p>我们通过点击图标在不同的子视图控制器之间切换，在这一阶段，子视图控制器之间切换时是没有转场动画的。</p>

<p>你可以在这里查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-1">阶段1</a>的源代码</p>

<h3>阶段2：转场动画</h3>

<p>当我们添加转场动画时，我们想要使用一个遵从 UIViewControllerAnimatedTransitioning协议的动画控制器(animation controllers)。这个协议声明了三个方法，前面的2歌方法是必须实现的：</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
- (void)animationEnded:(BOOL)transitionCompleted;  
</code></pre>

<p>通过这些方法，我们可以获得我们所需的所有东西。当我们的视图控制器容器准备执行动画时，我们可以从动画冬至器中获取动画的持续时间，并让其去执行真正的动画。当动画执行完毕后，如果动画控制器实现了可选的 <code>animationEnded:</code>方法，我们可以调用动画控制器中的 animationEnded: 方法。</p>

<p>但是，首先我们必须把一件事情搞清楚。正如你在上面的方法签名中看到的那样，上面两个必须实现的方法需要一个转场上下文参数，这是一个遵从 <code>UIViewControllerContextTransionging</code>协议的对象。通常情况下，当我们使用系统内建的类时，系统框架为我们创建了转场上下文对象，并把它传递给动画控制器。但是在我们这种情况下，我们需要自定义转场动画，所以我们需要承担系统框架的责任，自己去创建这个转场上下文对象。</p>

<p>这就是大量使用协议的方便之处。我们可以不用必须复写一个私有类，而复写私有类这种方法是明显不可行的。我们可以定义自己的类，并使其遵从文档中相应的协议就可以了。</p>

<p>尽管在UIViewControllerContextTransioning协议中声明了很多方法，而且他们都是必须要实现的，但是我们现在可以暂时忽略它们中的一些方法，因为我们现在仅仅支持不可交互的转场。</p>

<p>同UIKit类似，我们定义了私有类<code>NSObject &lt;UIViewControllerContextTransitioning&gt;</code>.在我们的特定例子汇总，这个私有类是 PrivateTransitionContext,它的初始化方法如下实现:</p>

<pre><code>- (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController goingRight:(BOOL)goingRight {
    NSAssert ([fromViewController isViewLoaded] &amp;&amp; fromViewController.view.superview, @"The fromViewController view must reside in the container view upon initializing the transition context.");

    if ((self = [super init])) {
        self.presentationStyle = UIModalPresentationCustom;
        self.containerView = fromViewController.view.superview;
        self.viewControllers = @{
            UITransitionContextFromViewControllerKey:fromViewController,
            UITransitionContextToViewControllerKey:toViewController,
        };

        CGFloat travelDistance = (goingRight ? -self.containerView.bounds.size.width : self.containerView.bounds.size.width);
        self.disappearingFromRect = self.appearingToRect = self.containerView.bounds;
        self.disappearingToRect = CGRectOffset (self.containerView.bounds, travelDistance, 0);
        self.appearingFromRect = CGRectOffset (self.containerView.bounds, -travelDistance, 0);
    }

    return self;
}
</code></pre>

<p>我们把视图的出现和消失时的状态记录了下来，比如初始状态和最终状态的frame.</p>

<p>请注意一点，我们的初始化方法需要我们提供我们是在向右切换还是向左切换。在我们的<code>ContainerViewController</code>中，按钮是一个接一个水平排列的，转场上下文通过设置每个frame来记录它们之间的位置关系。动画控制器或者说 animator,在生成动画时可以使用这些frame.</p>

<p>我们也可以通过另外的方式去获取这些信息，但是那样的话，就会使animator和<code>ContainerViewController</code>及其视图控制器耦合在一起了，这是不好的，我们并不想这样。animator应该只关心它自己以及传递给它的上下文，因为这样，在理想的情况下，animator可以在不同的上下文中得到复用。</p>

<p>在下一步实现我们自己的动画控制器时，我们应该时刻记住这一点，现在让我们来实现转场上下文吧。</p>

<p>使用Animator类的实例来做转场动画的核心代码如下所示:</p>

<pre><code>[fromViewController willMoveToParentViewController:nil];
[self addChildViewController:toViewController];

Animator *animator = [[Animator alloc] init];

NSUInteger fromIndex = [self.viewControllers indexOfObject:fromViewController];
NSUInteger toIndex = [self.viewControllers indexOfObject:toViewController];
PrivateTransitionContext *transitionContext = [[PrivateTransitionContext alloc] initWithFromViewController:fromViewController toViewController:toViewController goingRight:toIndex &gt; fromIndex];

transitionContext.animated = YES;
transitionContext.interactive = NO;
transitionContext.completionBlock = ^(BOOL didComplete) {
    [fromViewController.view removeFromSuperview];
    [fromViewController removeFromParentViewController];
    [toViewController didMoveToParentViewController:self];
};

[animator animateTransition:transitionContext];
</code></pre>

<p>这其中的大部分是对视图控制器容器的操作，计算出我们是在向左切换还是向右切换，做动画的部分基本上只有3行代码：</p>

<ol>
<li>创建Animator</li>
<li>创建转场上下文</li>
<li>触发动画执行</li>
</ol>


<p>有了上面的代码，转场效果看起来如下图所示:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-2.gif" alt="2" /></p>

<p>非常酷，我们甚至没有写一行动画相关的代码</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-2">阶段2</a>标签下看到这部分代码的变化。</p>

<h3>阶段3：封装</h3>

<p>我想我们最后要做的一件事情是封装 ContainerViewController,使其能够:</p>

<ol>
<li>提供默认的转场动画</li>
<li>提供替换默认动画控制器的代理</li>
</ol>


<p>这意味着我们需要对Animator类的依赖移除，同时需要创建一个代理协议。</p>

<p>我们如下定义这个协议:</p>

<pre><code>@protocol ContainerViewControllerDelegate &lt;NSObject&gt;
@optional
- (void)containerViewController:(ContainerViewController *)containerViewController didSelectViewController:(UIViewController *)viewController;
- (id &lt;UIViewControllerAnimatedTransitioning&gt;)containerViewController:(ContainerViewController *)containerViewController animationControllerForTransitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController;
@end
</code></pre>

<p><code>containerViewController:didSelectViewController:</code>方法使<code>ContainerViewController</code>可以很容易的集成与功能齐全的应用中。</p>

<p><code>containerViewController:animationControllerForTransitionFromViewController:toViewController:</code>方法挺有趣的，当然，你可以把它和下面的UIKit中的视图控制器容器的代理协议做对比:</p>

<ul>
<li>tabBarController:animationControllerForTransitionFromViewController:toViewController: (UITabBarControllerDelegate)</li>
<li>navigationController:animationControllerForOperation:fromViewController:toViewController: (UINavigationControllerDelegate)</li>
</ul>


<p>所有的这些方法都返回一个id<UIViewControllerAnimatedTransitioning>对象。与之前一直使用一个 Animator 对象不同，我们现在可以从我们的代理那里获取一个动画控制器:</p>

<pre><code>id&lt;UIViewControllerAnimatedTransitioning&gt;animator = nil;
if ([self.delegate respondsToSelector:@selector (containerViewController:animationControllerForTransitionFromViewController:toViewController:)]) {
    animator = [self.delegate containerViewController:self animationControllerForTransitionFromViewController:fromViewController toViewController:toViewController];
}
animator = (animator ?: [[PrivateAnimatedTransition alloc] init]);
</code></pre>

<p>如果我们有代理并且它返回一个Animator,那么我们就使用这个 animator.否则，我们使用内部私有类PrivateAnimatedTransition 创建一个默认的 animator.接下来我们将实现 <code>PrivateAnimatedTransition</code>类。</p>

<p>尽管默认的动画和 Animator有一些不同，但是代码看起来惊人的相似，下面是完整的代码实现:</p>

<pre><code>@implementation PrivateAnimatedTransition

static CGFloat const kChildViewPadding = 16;
static CGFloat const kDamping = 0.75f;
static CGFloat const kInitialSpringVelocity = 0.5f;

- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
    return 1;
}

- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {

    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];

    // When sliding the views horizontally, in and out, figure out whether we are going left or right.
    BOOL goingRight = ([transitionContext initialFrameForViewController:toViewController].origin.x &lt; [transitionContext finalFrameForViewController:toViewController].origin.x);

    CGFloat travelDistance = [transitionContext containerView].bounds.size.width + kChildViewPadding;
    CGAffineTransform travel = CGAffineTransformMakeTranslation (goingRight ? travelDistance : -travelDistance, 0);

    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;
    toViewController.view.transform = CGAffineTransformInvert (travel);

    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:kDamping initialSpringVelocity:kInitialSpringVelocity options:0x00 animations:^{
        fromViewController.view.transform = travel;
        fromViewController.view.alpha = 0;
        toViewController.view.transform = CGAffineTransformIdentity;
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
    }];
}

@end
</code></pre>

<p>需要注意一点的是，上面的代码没有通过设置视图的frame 来反应它们之间的位置关系，但是代码仍然可以正常工作，只不过转场总是在同一个方向上。因此，这个类也可以被其它的代码库使用。</p>

<p>转场动画看起来像是这样:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-3.gif" alt="2" /></p>

<p>在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-3">阶段3</a>代码中，app delegate中设置代理的部分被注释掉了，这样就可以看到默认的动画效果了，你可以将其设置回再使用 Animator类，你可能想查看同<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-2...stage-3">阶段2相比所有的修改</a></p>

<p>我们现在有一个自包含的提供了默认转场动画的 ContainerViewController 类，这个默认的转场动画可以被开发者定义的ios7自定义动画控制器(UIViewControllerAnimatedTransitioning)的对象代替，甚至都可以不用关心我们的源代码就可以方便的替换。</p>

<h2>结论</h2>

<p>在本文中，我们通过使用ios7提供的自定义视图控制器转场的新特性，使得我们自定义的视图控制器容器成为了UIkit的一等公民。</p>

<p>这意味着你可以把自定义的非交互的转场动画应用到自定义的视图控制器容器中。你可以看到我们把7个话题之前使用的转场类直接拿过来使用，而且没有做任何修改。</p>

<p>如果你想让自己的容器视图控制器作为一个类库或者框架，或者仅仅想使你的代码得到更好的复用，这将是非常完美的。</p>

<p>我们现在仅仅支持非交互式的转场，下一步就是对交互式的转场也提供支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua/"/>
    <updated>2016-05-30T09:26:31+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua</id>
    <content type="html"><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要使用用户的需求以及为执行各种任务而改变状态。</p>

<p>在这些状态之间转换时，清晰的揭示正在发生什么是非常重要的。而不是在页面之间跳跃，动画帮助我们解释用户从哪里来，要到哪里去。</p>

<!--more-->


<p>键盘在View中滑进滑出给了我们一个错觉，让我们以为它是简单的被隐藏在屏幕下方的，并且是手机很自然的一个部分。View Controller转场加强了我们的应用程序的导航结构，并且给了用户正在移向那个方向的提示。微妙的反弹和碰撞使界面栩栩如生，并且激发出了物理的质感。要是没有这些的话，我们就只有一个没有视觉设计的干巴巴的环境了。</p>

<p>动画是叙述你的应用的故事的绝佳方式，在了解动画背景的基本原理之后，设计它们会轻松很多。</p>

<h2>首要任务</h2>

<p>在这篇文章中，我们将特别地针对  Core Anmiation进行探讨，虽然你将看到的很多东西也可以用更高级的UIKit的方法来完成，但是Core Animation将会让你更好的理解正在发生什么。它以一种更明确的方式来描述动画，这对这篇文章以及你自己的代码的读者来说都非常有用。</p>

<p>在看动画如何与我们的屏幕上的看到的内容交互之前，我们需要快速浏览一下Core Animation的<code>CALayer</code>，这是动画产生作用的地方。</p>

<p>你大概知道UIView实例，以及layer-backed的NSView,修改它们的layer来委托强大的Core Graphics框架来进行渲染。然而你务必要理解，当把动画添加到一个layer时，是不直接修改它的属性的。</p>

<p>取而代之，Core Animation维护了两个平行的layer层次结构:mode layer tree(模型层树)和presentation layer tree(表示层树)。前者中的layers反映了我们能直接看到的layers的状态，而后者的layers则是正在表现的值的近似。</p>

<p>考虑在view上增加一个渐出动画。如果在动画中的任意时刻，查看layer的opacity值，你是得不到与屏幕内容对应的透明度的。取而代之，你需要查看presentaion layer 以获得正确的结果。</p>

<p>虽然你可能不会去直接设置presentaion layer的属性，但是使用它的当前值来创建新的动画护着在动画发生时与layers交互式非常有用的。</p>

<p>通过使用 <code>-[CALayer presentaionLayer]</code>和<code>[CALayer modelLayer]</code>，你可以在两个layer之间轻松切换。</p>

<h2>基本动画</h2>

<p>可能最常见的情况是将一个View的属性从一个值改变为另一个值，考虑夏敏的这个例子。</p>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-linear.gif" alt="w" />
 
在这里，我们让红色小火箭的 x-position从77 变为455,刚好超过的parent View的边，为了填充所有路径，我们需要确定我们的火箭在任意时刻所到达的位置。这通常使用线性插值法来完成。</p>

<pre><code>X(T)=x0 + t△x
</code></pre>

<p>也就是说，对于动画给定的一个分数t,火箭的x坐标就是起始点的x坐标77，加上一个到终点的距离∆x = 378,乘以该分数的值。</p>

<p>使用<code>CABasicAnimation</code>，我们可以如下实现这个动画:</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

[rocket.layer addAnimation:animation forKey:@"basic"];
</code></pre>

<p>请注意我们的动画键路径，也就是position.x,实际上包含一个存储在<code>position</code>属性中的CGPoint结构体成员。这是CoreAnimation一个非常方便的特性。请查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html">支持的键路径的完整列表</a></p>

<p>然而，当我们运行该代码时，我们意识到火箭在完成动画后马上回到了初始位置，这是因为在默认情况下，动画不会再超出其持续时间后还修改 presentaion layer.实际上，在结束时它甚至会被彻底移除。</p>

<p>一旦动画被移除，presentation layer将回到 model layer的值，并且因为我们从未修改该layer的 postion属性，所以我们的飞船将重新出现在它开始的地方。</p>

<p>这里有两种解决这个问题的方法:</p>

<p>第一种方法是直接在 model layer上更新尚需经，这是推荐的做法，因为它使得动画完全可选。</p>

<p>一旦动画完成并且从layer中移除，presentation layer将回到model layer设置的值，而这个值恰好与动画最后一个步骤相匹配</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

[rocket.layer addAnimation:animation forKey:@"basic"];

rocket.layer.position = CGPointMake(455, 61);
</code></pre>

<p>或者，你可以通过设置动画的fillMode属性为<code>kCAFillModeForward</code>，并设置<code>removedOnCompletion</code>为No以防止它被自动移除:</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

animation.fillMode = kCAFillModeForward;
animation.removedOnCompletion = NO;

[rectangle.layer addAnimation:animation forKey:@"basic"];
</code></pre>

<p>如果将已完成的动画保持在layer上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>

<p>指的指出的是，实际上我们创建的动画对象在被添加到layer时立刻就复制了一份。这个特性在多个view中重用动画时这非常有用。比方说我们想要第二个火箭在第一个火箭起飞后不久后起飞：</p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.byValue = @378;
animation.duration = 1;

[rocket1.layer addAnimation:animation forKey:@"basic"];
rocket1.layer.position = CGPointMake(455, 61);

animation.beginTime = CACurrentMediaTime() + 0.5;

[rocket2.layer addAnimation:animation forKey:@"basic"];
rocket2.layer.position = CGPointMake(455, 111);
</code></pre>

<p>设置动画的<code>beginTime</code>为未来0.5秒将只会影响<code>rocket2</code>，因为动画在执行语句<code>[rocket1.layer addAnimation:animation forKey:@"basic"];</code>时已经被复制了，并且之后的rocket1也不会考虑对动画对象的改变。</p>

<p>不妨看一看David的<a href="http://ronnqvi.st/controlling-animation-timing/">关于动画时间的一篇很棒的文章</a>，通过它可以学习如何更精确的控制你的动画。</p>

<p>我决定再使用<code>CABasicAnimation</code>的byValule属性创建一个动画，这个动画从presentaion layer的当前值开始，加上byValue的值后结束。这使得动画更易于重用，因为你不需要精确的指定可能无法提前知道的from- 和 toValue的值。</p>

<p><code>fromValue</code>,<code>byValue</code>和<code>toValue</code>的不同组合可以用来实现不同的效果，如果你需要创建一个可以在你的不同应用中重用的动画，你可以<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">查看文档</a></p>

<h2>多步动画</h2>

<p>这很容易想到一个场景，你想要为你的冻哈定义超过两个步骤，我们可以使用更通用的<code>CAKeyframeAnimation</code>，而不是去链接多个<code>CABasicAnimation</code>实例。</p>

<p>关键帧(keyFrame)使我们能够定义动画中任意的一个点，然后让core Animation填充所谓的中间帧</p>

<p>比方说我们正在制作我们下一个Iphone应用程序汇总的登录表单，我们希望当用户输入错误的密码时表单会晃动，使用关键帧动画，看起来大概像是这样：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/form.gif" alt="d" /></p>

<pre><code>CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @"position.x";
animation.values = @[ @0, @10, @-10, @10, @0 ];
animation.keyTimes = @[ @0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1 ];
animation.duration = 0.4;

animation.additive = YES;

[form.layer addAnimation:animation forKey:@"shake"];
</code></pre>

<p>values数组定义了表单应该到哪些位置、</p>

<p>设置keytimes属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal">
请注意我是如何选择不同的值从0到10到-10转换以维持恒定的速度的。
</a></p></blockquote>

<p>设置additive尚需经为YES 使 Core Animation在更新 presentaion layer之前将动画的值添加到 model layer中去。这使得我们能够对所有形式的需要更新的元素重用相同的动画，且无需提前知道它们的位置。因为这个属性从<code>CAPropertyAnimation</code>继承，所以你也可以在使用<code>CABasicAnimation</code>时使用它。</p>

<h2>沿路径的动画</h2>

<p>虽然用代码实现一个简单的水平晃动并不难，但是沿着复杂路径的 动画就需要我们在关键帧的values数组中存储大量box化的CGPoint.指的庆幸的是，<code>CAKeyFrmeAnimaiton</code>提供了更加便利的Path属性作为代替</p>

<p>举个例子，我们如何让一个view做圆周运动:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets.gif" alt="1" /></p>

<pre><code>CGRect boundingRect = CGRectMake(-150, -150, 300, 300);

CAKeyframeAnimation *orbit = [CAKeyframeAnimation animation];
orbit.keyPath = @"position";
orbit.path = CFAutorelease(CGPathCreateWithEllipseInRect(boundingRect, NULL));
orbit.duration = 4;
orbit.additive = YES;
orbit.repeatCount = HUGE_VALF;
orbit.calculationMode = kCAAnimationPaced;
orbit.rotationMode = kCAAnimationRotateAuto;

[satellite.layer addAnimation:orbit forKey:@"orbit"];
</code></pre>

<p>使用<code>CGPathCreateWithEllipseInRect ()</code>，我们创建一个圆形的<code>CGPath</code>作为我们的关键帧动画的path.</p>

<p>使用<code>calculationMode</code>是控制关键帧动画时间的另一种方式。我们通过将其设置为<code>kCAAnimationPaced</code>，让Core Animation想被驱动的对象施加一个恒定速度，不管路径的各个线程有多长，将其设置为<code>kCAAnimationPaced</code>将无视所有我们已经设置的 keyTimes.</p>

<p>设置 rotationsMode属性为 <code>kCAAnimationRotateAuto</code>，确保飞船沿着路径旋转。作为对比，我们将该属性设置为nil，那动画会怎么样呢？</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets-incorrect.gif" alt="2" /></p>

<h2>时间函数</h2>

<p>让我们再次来看看第一个例子 ：</p>

<p>你会发现我们的火箭的动画有些看起来非常不自然的地方，那是因为我们在现实时间中看到的大部分运动需要时间来加速或者减速。对象瞬间达到最高速度，然后再立即停止往往看起来非常不自然。除非你在让机器人跳舞，但这很少是想要的结果。</p>

<p>为了给我们的动画一个存在惯性的感觉，我们可以使用我们上面提到的参数因子来进行插值。然而，如果我们接下来需要为每个需要加速或减速的行为创建一个新的插值函数，这将是一个很难扩展的方法。</p>

<p>取而代之，常见的做法是把要进行动画的属性的插值从动画的速度中解耦出来。这样一来，给动画提速会差生一种小火箭加速运动的效果，而不用改变我们的插值函数。</p>

<p>我们可以通过引入一个时间函数 （timing function）来实现这个目标。该函数通过修改持续时间的分数来控制动画的速度。</p>

<p>最简单的easing函数是linear.它在整个动画上维持一个恒定的速度。在 Core Animation中，这个功能由CAMediaTimingFunction来表示。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-linear.gif" alt="2" /></p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x"; 
animation.fromValue = @50;
animation.toValue = @150;
animation.duration = 1;

animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];

[rectangle.layer addAnimation:animation forKey:@"basic"];

rectangle.layer.position = CGPointMake(150, 0);
</code></pre>

<p>Core Animation附带了一些linear之外的内置easing函数，如:</p>

<ul>
<li><p>Ease in (kCAMediaTimingFunctionEaseIn):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easein.gif" alt="1" /></p></li>
<li><p>Ease out (kCAMediaTimingFunctionEaseOut):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeout.gif" alt="2" /></p></li>
<li><p>Ease in ease out (kCAMediaTimingFunctionEaseInEaseOut):</p></li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeineaseout.gif" alt="3" /></p>

<ul>
<li>默认 (kCAMediaTimingFunctionDefault):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-default.gif" alt="4" /></li>
</ul>


<p>在一定限度内，你也可以使用<code>+functionWithControlPoints::::</code>创建自己的easing函数。通过传递cubic Bezier曲线的两个控制点的x和y坐标，你可以轻松的创建自定义easying函数，比如我为我们的红色小火箭选择的那个。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-custom.gif" alt="custom" /></p>

<pre><code>CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @77;
animation.toValue = @455;
animation.duration = 1;

animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0.5:0:0.9:0.7];

[rocket.layer addAnimation:animation forKey:@"basic"];

rocket.layer.position = CGPointMake(150, 0);
</code></pre>

<p>我不打算讲太多关于Bezier曲线的细节，在计算机图形学中，它们是创建平滑曲线的常用技术。你可能在基于矢量的绘图工具，比如Sketch或者Adobe lllustrotor中见过它们。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/bezier.png" alt="1" /></p>

<p>传递给 <code>+functionWithControlPoints::::</code>的值有效地控制了控制点的位置。所得到的定时函数将基于得到的路径来调整动画的速度。X轴代表时间的分数，而Y轴是插值函数的插入值。</p>

<p>遗憾的是，由于这些部分被锁定在[0-1]的范围内，我们不可能用它来创建一些像预期动作(Anticipation,一种像目标进发前先回退一点，到达目标后还过冲一会，见下图)这样的常见效果 .</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/anticipate.gif" alt="3" /></p>

<h2>动画组</h2>

<p>对于某些复杂的效果，可能需要同时为多个属性进行动画。想象一下，在一个媒体播放程序中，当切换到随机曲目时我们让随机动画效果，看起来就想下面这样:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/covers.gif" alt="animaiton" /></p>

<p>你可以看到，我们需要同时对上面的封面的 position,roation和 z-position进行动画，使用 CAAimationGroup来动画其中一个封面的代码如下:</p>

<pre><code>CABasicAnimation *zPosition = [CABasicAnimation animation];
zPosition.keyPath = @"zPosition";
zPosition.fromValue = @-1;
zPosition.toValue = @1;
zPosition.duration = 1.2;

CAKeyframeAnimation *rotation = [CAKeyframeAnimation animation];
rotation.keyPath = @"transform.rotation";
rotation.values = @[ @0, @0.14, @0 ];
rotation.duration = 1.2;
rotation.timingFunctions = @[
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
];

CAKeyframeAnimation *position = [CAKeyframeAnimation animation];
position.keyPath = @"position";
position.values = @[
    [NSValue valueWithCGPoint:CGPointZero],
    [NSValue valueWithCGPoint:CGPointMake(110, -20)],
    [NSValue valueWithCGPoint:CGPointZero]
];
position.timingFunctions = @[
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
];
position.additive = YES;
position.duration = 1.2;

CAAnimationGroup *group = [[CAAnimationGroup alloc] init];
group.animations = @[ zPosition, rotation, position ];
group.duration = 1.2;
group.beginTime = 0.5;

[card.layer addAnimation:group forKey:@"shuffle"];

card.layer.zPosition = 1;
</code></pre>

<p>我们使用CAAimationGroup得到一个好处是可以将所有动画作为一个对象暴露出去。如果你要在应用程序中的多个地方用工厂对象创建的重用的动画的话，这将会非常有用。</p>

<p>你也可以使用动画组同时控制所有动画组成部分的时间</p>

<h2>Core Animation 之外</h2>

<p>你应该已经听过 UIKIT Dynamics了，这是ios7中引入的一个物理模拟框架，它允许你使用约束和力来为 views做动画。与core Animation不同，它与你在屏幕上看到的内容交互更为间接，但是它的动态特性让你可以在事先不知道结果时创建动画。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为iOS建立Travis CI]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci/"/>
    <updated>2016-05-23T14:30:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci</id>
    <content type="html"><![CDATA[<p>你是否曾经试着为ios项目搭建一台支持<a href="http://baike.baidu.com/link?url=9m9zB2m909wrZ82wdNWMhtPBTt14PduTPIyi78YL0sS7ccrE-DN22S55wCuEhuobFZ0dL5T4MhKmQzFLx1q4-K">持续集成</a>的服务器，从我的个人经验而言，这可不是一个轻松的活。首先需要准备一台MAc电脑，并安装好全部所需的软件和插件。你要负责管理所有的用户账户，并提供安全保护。你需要授予访问仓库的权限，并配置所有的编译步骤和证书，在项目的运行时期，你需要保持服务器稳健和最新。</p>

<!--more-->


<p>最后，原本你想节省时间，会发现你花费了大量的时间去维护这台服务器，不过如果你的项目托管在github上，现在有了新的希望：<a href="https://travis-ci.org/">Travis CI</a>.该服务可以为你的项目提供持续集成的支持，也就意味着它会负责好托管一个项目的所有细节。在ruby的世界中，Travis CI以久负盛名。从2013年4月起，Travs也开始支持ios和mac平台</p>

<p>在这篇文章中，我将向你展示如何一步步的在项目中集成Travis.不仅包括项目的编译的单元测试运行，还包括将应用部署到你所有的测试设备上。</p>

<h2>GITHub集成</h2>

<p>我最喜欢Travis的一点就是它与GitHub的webUI集成的非常好，例如pull请求，Travis会为每次请求都执行编译操作。如果一切正常，pull请求在Github上看起来这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_ready_to_merge.jpg" alt="e" /></p>

<p>万一编译不成功，Github页面会修改相应的颜色。给予提醒:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_merge_with_caution.jpg" alt="1" /></p>

<h2>链接 Travis 和 GitHub</h2>

<p>让我们看一下如何将Github项目与Travis链接上，使用Github账号登录 <a href="https://travis-ci.org/">Travis 站点</a>。对于私有仓库，需要注册一个Travis 专业版账号</p>

<p>登录成功后，需要为项目开启Travis支持，导航到<a href="https://travis-ci.org/profile">属性页面</a>,该页面列出了所有的github项目，不过要注意，如果此后创建了一个新的仓库，要使用 sync now 按钮进行同步。Travis只会偶尔更新的项目列表.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_travis_flick.jpg" alt="test" /></p>

<p>现在只需要打开这个开关就可以在你的项目添加Travis服务，之后你会看到Travis会和Github项目设置关联。下一步就是告诉Travis，当它收到项目改动通知之后该做什么。</p>

<h2>最简单的项目配置</h2>

<p>Tranvis CI 需要项目的一些基本信息。在项目的根目录创建一个名为 .travis.yml的文件，文件中内容如下：</p>

<pre><code>language: objective-c
</code></pre>

<p>Travis 编译器运行在虚拟机环境下，该编译器已经利用 <code>Ruby</code>,<code>homebrew</code>,<code>CocoaPods</code>和一些默认的编译脚本进行过<a href="http://about.travis-ci.org/docs/user/osx-ci-environment/">预配置</a>.上述的配置项已经足够编译你的项目了。</p>

<p>预装的编译脚本会分析你的Xcode项目，并对每个target进行编译。如果所有文件都没有编译错误，并且测试也没有被打断，那么项目就编译成功了。现在可以将改动push到GitHub上看看能否成功编译。</p>

<p>虽然上述配置过程真的很简单，不过对你的项目不一定适用。这里几乎没有什么文档来指导用户如何配置默认的编译行为。例如：有一次我没有用 iphonesimulator SDK 导致代码签名错误。如果刚刚那个最简单的配置对你的项目不适用的话，让我们来看一下如何对Travis使用自定义的编译命令</p>

<h3>自定义编译命令</h3>

<p>Travis 使用命令行对项目进行编译。因此，第一步就是使项目能够在本地编译。作为Xcode命令行工具的一部分，Apple提供了<code>xcodebuild</code>命令</p>

<p>打开终端并输入:</p>

<pre><code>xcodebuild --help
</code></pre>

<p>上述命令会列出xcodebuild所有可用的参数。如果命令执行失败了，确保命令行工具已经成功安装。一个常见的编译命令看起来是这样的：</p>

<pre><code>'xcodebuild -project {project}.xcodeproj -target {target} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>使用 iphonesimulator SDK是为了避免签名错误，知道我们稍后引入证书之前，这一步是必须的。通过设置<code>ONLY_ACTIVE_ARCH=NO</code>我们可以确保利用模拟器架构编译工程。你也可以设置额外的属性，例如<code>configuration</code>,输入 man xcodebuild查看相关文档。</p>

<p>对于使用 CocoaPods的项目，需要用下面的命令来指定 workspace和scheme:</p>

<pre><code>xcodebuild -workspace {workspace}.xcworkspace -scheme {scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>schemes 是由Xcode自动生成的，但这在服务器上不会发生。确保所有的scheme都被设置为 shared并加入到仓库中，否则它只会在本地工作而不会被Travis CI识别。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_shared_schemes.jpg" alt="w" /></p>

<p>我们实例项目下的 .travis.yml文件现在看起来应该是这样</p>

<pre><code>language: objective-c
script: xcodebuild -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<h2>运行测试</h2>

<p>对月测试来说，通常使用如下这个命令(注意 test 属性)</p>

<pre><code>xcodebuild test -workspace {workspace}.xcworkspace -scheme {test_scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>不幸的是，xcodebuild对于ios来说，并不能正确支持target和应用程序的测试。<a href="http://www.raingrove.com/2012/03/28/running-ocunit-and-specta-tests-from-command-line.html">这里有一些解决方案</a>不过我建议使用Xctool.</p>

<h3>Xctool</h3>

<p><a href="https://github.com/facebook/xctool">Xctool</a>是来自FaceBook的命令行工具，它可以简化程序的编译和测试。它的彩色输出信息比 xcodebuild更加简洁美观。同时还添加了对逻辑测试，应用测试的支持。</p>

<p>Travis中已经预装了xctool。要在本地测试的话，需要用homebrew安装xctool:</p>

<p>xctool用法非常简单，它使用的参数跟xcodebuild相同：</p>

<pre><code>xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>一旦相关命令在本地能正常工作，那么就是时候把它们添加到 .travis.yml中了：</p>

<pre><code>language: objective-c
script:
  - xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
  - xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>到此为止，介绍的内容对于使用Travis的library工程来说，已经足够了。我们可以确保项目正常编译并测试通过。但对于ios应用来说，我们希望能在真实的物理设备上进行测试。也就说我们需要将应用部署到我们的所有测试设备上。当然，我们希望Travis能自动完成这项任务。首先，我们需要给程序签名</p>

<h1>应用程序的签名</h1>

<p>为了在Travis中能给程序签名，我们需要准备好所有必须的证书和配置文件。就像每个ios开发人员指导的那样，这可能是最困难的一步。后面，我将写一些脚本在服务器上给应用程序签名。</p>

<h2>证书和配置文件</h2>

<h3>1.苹果全球开发者关系认证</h3>

<p>从<a href="http://developer.apple.com/certificationauthority/AppleWWDRCA.cer">苹果官网</a>或者从钥匙串中导出。并将保存到项目的目录<code>scripts/certs/apple.cer</code>中。</p>

<h3>2.iPhone发布证书 + 私钥</h3>

<p>如果还没有发布证书的话，先创建一个。登录<a href="https://developer.apple.com/account/overview.action">苹果开发者账号</a>,按照步骤，创建一个新的生产环境证书(<em>Certificates</em>)><em>Production</em>><em>Add</em>><em>App Store and ad hoc</em>)。然后下载并安装证书。之后，可以在钥匙串中找到它。打开Mac中的钥匙串应用程序：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/dist_cert_keychain.jpg" alt="key" /></p>

<p>右键单击证书，选择<code>Export ....</code>将证书导出至<code>scripts/certs/dist.cer</code>.然后导出私钥并保存至<code>cripts/certs/dist.p12</code>.记得输入私钥的密码.</p>

<p>由于Travis需要知道私钥密码，因此我们要把这个密码存储在某个地方，当然，我们不希望已明文的形式存储。我们可以用<a href="http://about.travis-ci.org/docs/user/build-configuration/#Secure-environment-variables">Travis的安全环境变量</a>。打开终端，并定位到包含 .travis.yml文件所在目录。首先用 <code>gem install travis</code>命令安装Travis gem.之后用下面的命令添加秘钥密码:</p>

<pre><code>travis encrypt "KEY_PASSWORD={password}" --add
</code></pre>

<p>上面的命令会安装一个叫做<code>Key_Password</code>的加密环境变量到 .travis.yml 配置文件中。这样就可以在被 Travis CI执行的脚本中使用这个变量</p>

<h3>3.ios 配置文件(发布)</h3>

<p>如果还没有用于发布的配置文件，那么也创建一个新的。根据开发者账号类型，可以选择创建 <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/TestingYouriOSApp/TestingYouriOSApp.html">ADHoc</a>或<a href="https://developer.apple.com/programs/ios/enterprise/gettingstarted/">IN House</a>配置文件<em>(Provisioning Profiles > Distribution > Add > Ad Hoc or In House)</em>.然后将其下载保存到<code>scripts/profile/</code>目录。</p>

<p>由于Travis需要访问这个配置文件，所以我们需要将这个文件的名字存储为一个全局变量。并将其添加到.travis.yml文件的全局环境变量section中。例如，如果配置文件的名字是 <code>TravisExample_Ad_Hoc.mobileprovision</code>,那么按照如下进行添加:</p>

<pre><code>env:
  global:
  - APP_NAME="TravisExample"
  - 'DEVELOPER_NAME="iPhone Distribution: {your_name} ({code})"'
  - PROFILE_NAME="TravisExample_Ad_Hoc"
</code></pre>

<p>上面还声明了两个环境变量。第三行中的<code>APP_name</code>通常为项目默认的target的名字。第四行的<code>DEVELOPER_NAME</code>是xcode中，默认target里面Build Settings的Code Signing Identity > Release 对应的名字。然后搜索程序的<code>Ad Hod</code>或者<code>In house</code>配置文件，将其中黑体文字取出，根据设置的不同，括弧中可能不会有任何信息。</p>

<h2>加密证书和配置文件</h2>

<p>如果你的GitHub仓库是公开的，你可能希望对证书和配置文件进行加密。如果你的是私有仓库，可以跳过这一节</p>

<p>首先，我们需要一个密码来对所有的文件进行加密。在我们的实例中，密码为"foo",记住在你的工程中设置的密码应该更加复杂。在命令行汇总，我们使用<code>openssl</code>加密所有的敏感文件：</p>

<pre><code>openssl aes-256-cbc -k "foo" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -a
openssl aes-256-cbc -k "foo" -in scripts/certs/dist.cer -out scripts/certs/dist.cer.enc -a
openssl aes-256-cbc -k "foo" -in scripts/certs/dist.p12 -out scripts/certs/dist.cer.p12 -a
</code></pre>

<p>通过上面的命令，可以创建出以 .enc结尾的加密文件。之后可以把原始文件忽略或者移除掉。至少不要把原始文件提交到GitHub中，否则原始文件会显示在GitHub中。如果你不小心把原始文件提交上去了，那么请看这里<a href="https://help.github.com/articles/remove-sensitive-data">如何解决</a></p>

<p>现在，我们的文件已经被加密了，接下来我们需要告诉Travis对文件进行解密。解密过程，需要用到密码。具体释放方法跟之前创建的<code>KEY_PASSOWORD</code>变量一样:</p>

<pre><code>travis encrypt "ENCRYPTION_SECRET=foo" --add
</code></pre>

<p>最后，我们需要告诉Travis那些文件需要进行解密.将下面的命令添加到 .travis.yml文件中的before-script部分：</p>

<pre><code>before_script:
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -d -a -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12
</code></pre>

<p>就这样，在GitHub上面的文件就安全了，并且Travis依旧能读取并使用这些加密后的文件。但是有一个安全问题你需要知道，在Travis的编译日志中可能会显示出解密环境变量。不过对pull请求来说不会出现</p>

<h2>添加脚本</h2>

<p>现在我们需要确保证书都导入到了Travis CI的钥匙串中。为此，我们需要在scripts文件夹中添加一个名为 <code>add-key.sh</code>的文件：</p>

<pre><code>#!/bin/sh
security create-keychain -p travis ios-build.keychain
security import ./scripts/certs/apple.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
security import ./scripts/certs/dist.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
security import ./scripts/certs/dist.p12 -k ~/Library/Keychains/ios-build.keychain -P $KEY_PASSWORD -T /usr/bin/codesign
mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
cp ./scripts/profile/$PROFILE_NAME.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
</code></pre>

<p>通过上面的命令创建了一个名为<code>ios-build</code>的临时钥匙串，里面包含了所有证书。注意，这里我们使用了<code>$Key_PASSWORD</code>来导入私钥。最后一步是将配置文件拷贝到LIbrary文件夹。</p>

<p>创建好文件之后，确保其授予了可执行的权限：在命令行输入:<code>chmod a+x scripts/add-key.sh</code>即可。为了正常使用脚本，必须要这样处理一下。</p>

<p>至此，已经导入了所有的证书和配置文件，我们可以开始给应用程序签名了。注意，在给程序签名之前必须对程序进行编译。由于我们需要知道编译结果存储在磁盘的具体位置，我建议在编译命令中使用<code>OBJROOT</code>和<code>SYMROOT</code>来指定输出目录，另外，为了创建 release版本，还需要把SDK设置为 iphones,以及configuration修改为 Release:</p>

<pre><code>xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO 'CODE_SIGN_RESOURCE_RULES_PATH=$(SDKROOT)/ResourceRules.plist'
</code></pre>

<p>如果运行了上面的命令，那么编译完成之后，可以在<code>build/Release-iphoneos</code>目录中找到对应程序的二进制文件。接下来，就可以对其签名，并创建IPA文件了。为此，我们创建了一个新的脚本：</p>

<pre><code>#!/bin/sh
if [[ "$TRAVIS_PULL_REQUEST" != "false" ]]; then
  echo "This is a pull request. No deployment will be done."
  exit 0
fi
if [[ "$TRAVIS_BRANCH" != "master" ]]; then
  echo "Testing on a branch other than master. No deployment will be done."
  exit 0
fi

PROVISIONING_PROFILE="$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_NAME.mobileprovision"
OUTPUTDIR="$PWD/build/Release-iphoneos"

xcrun -log -sdk iphoneos PackageApplication "$OUTPUTDIR/$APPNAME.app" -o "$OUTPUTDIR/$APPNAME.ipa" -sign "$DEVELOPER_NAME" -embed "$PROVISIONING_PROFILE"
</code></pre>

<p>第二行至第九行非常重要。我们并不希望在某个特性分支上创建新的release.对Pull请求也一样的。由于安全环境变量被禁用，所有pull请求也不会编译。</p>

<p>第十四行，才是真正的签名操作。这个命令会在<code>build/Release-iphoneos</code>目录下生成2个文件：<code>TravisExample.ipa</code>和<code>TravisExample.app.dsym</code>。第一个文件包含了分发至手机上的应用程序。dsym文件包含了二进制文件的调试信息。这个文件对于记录设备上的crash信息非常重要。之后当我们部署应用程序的时候，会用到这两个文件。</p>

<p>最后一个脚本是移除之前创建的临时钥匙串，并删除配置文件。虽然这不是必须的，不过这有助于进行本地测试。</p>

<pre><code>#!/bin/sh
security delete-keychain ios-build.keychain
rm -f ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_NAME.mobileprovision
</code></pre>

<p>最后一步，我们必须告诉Travis什么时候执行这三个脚本，在应用程序编译，签名和清楚等之前，需要先添加私钥。在 .travis.yml文件中添加如下内容：</p>

<pre><code>before_script:
- ./scripts/add-key.sh
- ./scripts/update-bundle.sh
script:
- xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO
after_success:
- ./scripts/sign-and-upload.sh
after_script:
- ./scripts/remove-key.sh
</code></pre>

<p>完成上面的所有操作之后，我们就可将所有内容push到GItHub上，等待Travis对应用程序进行签名，我们可以在工程页面下的Travis控制台验证是否一切正常，如果一切正常的话，下面来看看如何将签名好的应用程序部署给测试人员。</p>

<h2>部署应用程序</h2>

<p>这里有两个知名的服务可以帮你发布应用程序:<a href="http://testflightapp.com/">TestFlight</a>和<a href="http://hockeyapp.net/">HockyeyApp</a>。不管选择哪个都能满足需求。就我个人而言，推荐使用 HockeyApp,不过这里我会对这两个服务都做介绍。</p>

<p>首先我们队 sign-and-build.sh脚本做一个扩充&ndash;在里面添加一些release记录:</p>

<pre><code>RELEASE_DATE=`date '+%Y-%m-%d %H:%M:%S'`
RELEASE_NOTES="Build: $TRAVIS_BUILD_NUMBER\nUploaded: $RELEASE_DATE"
</code></pre>

<p>注意这里使用了一个Travis的全局变量<code>TRAVIS_BUILD_NUMBER</code>.</p>

<h2>TestFlight</h2>

<p>创建一个<a href="https://testflightapp.com/register/">TestFlight账号</a>，并配置好应用程序。为了使用TestFlight的API,首先需要获得<a href="https://testflightapp.com/account/#api">apitoken</a>和<a href="https://testflightapp.com/dashboard/team/edit/?next=/api/doc/">teamtoken</a>。再强调一次，我们需要确保它们是加密的。在命令行中执行如下命令:</p>

<pre><code>travis encrypt "TESTFLIGHT_API_TOKEN={api_token}" --add
travis encrypt "TESTFLIGHT_TEAM_TOKEN={team_token}" --add
</code></pre>

<p>现在我们可以调用相应的API了。并将下面的内容添加到<code>sign-and-build.sh:</code></p>

<pre><code>curl http://testflightapp.com/api/builds.json \
  -F file="@$OUTPUTDIR/$APPNAME.ipa" \
  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
  -F api_token="$TESTFLIGHT_API_TOKEN" \
  -F team_token="$TESTFLIGHT_TEAM_TOKEN" \
  -F distribution_lists='Internal' \
  -F notes="$RELEASE_NOTES"
</code></pre>

<p>千万不要使用verbose标记(-v)&ndash;这会暴露加密tokens.</p>

<h2>HOckeyApp</h2>

<p>注册一个<a href="http://hockeyapp.net/plans">HockeyApp账号</a>，并创建一个新的应用程序。然后在概述页面获取一个AppId.接下来，我们必须创建一个Api Token.打开<a href="https://rink.hockeyapp.net/manage/auth_tokens">这个页面</a>并创建一个。如果你希望自动的将新版本部署给所有的测试人员，那么请选择 Full Access版本。</p>

<p>对App Id 和token进行加密:</p>

<pre><code>travis encrypt "HOCKEY_APP_ID={app_id}" --add
travis encrypt "HOCKEY_APP_TOKEN={api_token}" --add
</code></pre>

<p>然后在sign-and-build.sh文件中调用相关的API:</p>

<pre><code>curl https://rink.hockeyapp.net/api/2/apps/$HOCKEY_APP_ID/app_versions \
  -F status="2" \
  -F notify="0" \
  -F notes="$RELEASE_NOTES" \
  -F notes_type="0" \
  -F ipa="@$OUTPUTDIR/$APPNAME.ipa" \
  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
  -H "X-HockeyAppToken: $HOCKEY_APP_TOKEN"
</code></pre>

<p>注意我们还上传了dsym文件。如果集成了TestFlight或HockeyAppSdk，我们可以立即收集到易读的crash报告。</p>

<h2>Travis故障排除</h2>

<p>知道如何不通过直接访问编译环境就能找出问题是非常重要的。</p>

<p>在写本文的时候，还没有可以下载的虚拟机映像。如果Travis不能正常编译，首先试着在本地重现问题。在本地执行跟Travis相同的编译命令：</p>

<pre><code>xctool ...
</code></pre>

<p>为了调试shell脚本，首先需啊哟定义环境变量。我的做法是创建一个新的shell脚本来设置所有的环境变量。记得将这个脚本添加到 .gitignore文件中&ndash;因为我们不希望将该文件公开暴露出去。支队示例工程来说， config.sh脚本文件看起来是这样的：</p>

<pre><code>#!/bin/bash

# Standard app config
export APP_NAME=TravisExample
export DEVELOPER_NAME=iPhone Distribution: Mattes Groeger
export PROFILE_NAME=TravisExample_Ad_Hoc
export INFO_PLIST=TravisExample/TravisExample-Info.plist
export BUNDLE_DISPLAY_NAME=Travis Example CI

# Edit this for local testing only, DON'T COMMIT it:
export ENCRYPTION_SECRET=...
export KEY_PASSWORD=...
export TESTFLIGHT_API_TOKEN=...
export TESTFLIGHT_TEAM_TOKEN=...
export HOCKEY_APP_ID=...
export HOCKEY_APP_TOKEN=...

# This just emulates Travis vars locally
export TRAVIS_PULL_REQUEST=false
export TRAVIS_BRANCH=master
export TRAVIS_BUILD_NUMBER=0
</code></pre>

<p>为了暴露所有的环境变量，执行如下命令(确保config.sh是可执行的)</p>

<pre><code>. ./config.sh
</code></pre>

<p>然后试着运行 <code>echo $APP_NAME</code>,以此检查脚本是否正确。如果正确的话，那么现在我们不用做任何修改，就能在本地运行所有的shell脚本了。</p>

<p>如果在本地得到的是不同的编译信息，那么可能是使用了不同的库和gems.尽量试着将配置信息设置和Travis VM 相同的信息。Travis在这里列出了其所有的安装的软件版本，你也可以在travis的配置文件中添加调试信息得到所有库文件的版本。</p>

<pre><code>gem cocoapod --version
brew --version
xctool -version
xcodebuild -version -sdk
</code></pre>

<p>在本地安装好与服务器完全相同的软件之后，再重新编译项目。</p>

<p>如果获取的编译信息仍然不一样，试着将项目check out到一个新目录。并确保所有的缓存都已清空。每次编译程序时，Travis都会创建一个全新的虚拟机，所以不存在缓存的问题，但在你的本地机器上可能会出现。</p>

<p>一旦在本地重现出和服务器相同的错误，就可以开始调差具体问题了。当然导致问题的原因取决于具体问题。一般来说，通过Google都能找到引发问题的根源。</p>

<p>如果一个问题影响到了Travis上的其它项目，那么可能是Travis环境配置的原因。</p>

<h2>点评</h2>

<p>TravisCI跟市面上同类产品相比还是有一些限制。因为Travis运行在一个预先配置好的虚拟机上，因此必须为每次编译都安装一遍所有的依赖。这会花费一些额外的时间。不过Travis团队已经在着手提供一种缓存机制解决这个问题了。</p>

<p>在一定程度上，你会依赖于Travis所提供的配置。比如你只能使用Travis内置的Xcode版本进行编译。如果你本地使用的Xcode版本比较新，你的项目在服务器上可能无法编译通过。如果Travis能够为不同的Xcode版本都分别设置一个对应虚拟机会就好了。</p>

<p>对于复杂的项目来说，你可能希望把整个编译任务分为编译应用，运行集成测试等。这样你可以快速获得编译信息而不用等所有的测试都完后才能。目前Travis还没有直接支持有依赖的编译。</p>

<p>当项目被push到Github上时，travis会自动触发。不过编译动作不会立即触发，你的项目会被放到一个根据项目所用语言不同而不同的一个全局编译队列，不过专业版允许并发编译。</p>

<h2>总结</h2>

<p>Travis Ci提供了一个动能完整的持续集成环境，已进行应用程序的编译，测试和部署。对于开源项目来说，这项服务是完全免费的。很多社区都得益于GitHub强大的持续集成能力。</p>

<p>如果你还没有用过Travis.赶紧去试试吧，它棒极了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/catransform3d/"/>
    <updated>2016-05-04T17:25:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/catransform3d</id>
    <content type="html"><![CDATA[<h1>图层的几个坐标系</h1>

<p>对于ios来说，坐标系的(0,0)点在左下角，就是越往下，Y值越大。越向右，X值就越大.</p>

<!--more-->


<p>一个图层的frame,它是position,bounds,anchorPoint和transform尚需经的一部分。</p>

<p>设置一个新的frame将会相应的改变图层的position和bounds,但是frame本身并没有保存。</p>

<h3>position</h3>

<p>是一个CGPoint值，它指定图层相当于它父图层的位置，该值基于父图层的坐标系</p>

<h3>bounds</h3>

<p>是一个CGRect值，指定图层的大小(bounds.size)和图层的原点(bounds.origin)，这个坐标系是基于自身的。如果改变bounds的origin,那么在该图层的子图层，左边会跟着改变。也就是说，改变自身的坐标系，本身在福图层的位置不变，但它上面的自图层位置变化</p>

<h3>anchorPoint</h3>

<p>是一个CGPoint值，它是指定了一个基于bounds的符合坐标系的位置。锚点(anchor point)制定了bounds相对于position的值，同时也作为一个变化时候的中心点。锚点使用空间坐标系取值范围是0-1之间的数。默认是0.5,也就是图标的中心点，如果是(0,0)那么图层向左上方移动。如果是(1,1)就向右下方移动。</p>

<p>看下面的两个图，就能够清晰的看出锚点变化所带来的不一样。（此图为Mac OS 坐标系，如果是iOS，那么（0，0）点在图的左上方。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-ec88270eb7d8c9a0.png" alt="1" /></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-bfe77d9ab6636ce0.png" alt="2" /></p>

<p>对于anchorPoint的解释在ios中如图:</p>

<p>下图中的红点位置就是锚点的位置，默认是(0.5,0.5)。在对图像进行变化时，都是按照这个店来进行缩放，偏移等。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-76ff5832ae84e2f6.png" alt="1" /></p>

<p>一旦修改锚点位置为:(0,0),那么图像就会变成下图.各种变换就会按照这个点来运动.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-e6bcb36d43e12c4d.png" alt="2" /></p>

<p>所以说在ios系统中，锚点的坐标系是:左上角为(0,0),右下角为(1,1)。</p>

<p>根据此图，再理解上面的定义，就直观多了。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-47294f41d81081da.png" alt="1" /></p>

<h1>图层的几何变换</h1>

<p>可以通过矩阵来改变一个图层的几何形状。</p>

<p><em>CATransform3D</em>的数据结构定义了一个同质的三维变换(4*4 CGFloat值的矩阵),用于图层的旋转，缩放，偏移和应用的透视。</p>

<p>图层的2歌属性指定了变换矩阵:transform和sublayerTransform。</p>

<h3>transform</h3>

<p>是结合anchorPoint的位置来对图层和图层上的子图层进行变化</p>

<h3>sublayerTransform</h3>

<p>是结合anchorPoint的位置来对图层的子图层进行变化，不包括本身</p>

<h3>CATransform3DIdentity</h3>

<p>是单位矩阵，该矩阵没有缩放，旋转，歪斜，透视。该矩阵应用到图层上，就是设置默认值。</p>

<h1>变换函数</h1>

<h3>CATransform3DMakeTranslation</h3>

<p>官方文档:</p>

<pre><code>Returns a transform that translates by '(tx, ty, tz)'. t' = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].

CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)。
</code></pre>

<p>对于CATransform3D来说，它是一个4*4的 CGFloat的矩阵。而上面的值:<code>[1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].</code>给竖起来后，就发现:</p>

<pre><code>1    0    0    0

0    1    0    0

0    0    1    0

tx   ty   tz   1
</code></pre>

<p>竖起来就很明显了。</p>

<p>CATransform3D又是一个结构，他有自己的一个公式，可以进行套用.</p>

<pre><code>struct CATransform3D

{

CGFloat    m11（x缩放）,    m12（y切变）,      m13（旋转）,   m14（）;

CGFloat    m21（x切变）,    m22（y缩放）,      and（）   ,   m24（）;

CGFloat    m31（旋转）  ,    m32（ ）  ,      m33（z轴缩放）   ,   m34（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;

CGFloat    m41（x平移）,    m42（y平移）,      m43（z平移） ,   m44（）;

};
</code></pre>

<p>根据这个公式就一目了然了。</p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)参数的意思就是 <em>tx:：x平移。  ty：y平移。  tz：z平移</em></p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</p>

<pre><code>tx：X轴偏移位置，往下为正数。

ty：Y轴偏移位置，往右为正数。

tz：Z轴偏移位置，往外为正数。
</code></pre>

<p>举个栗子:</p>

<p>如果有两个图层，一个是绿色的，一个是红色的，先加载绿色，后加载红色</p>

<p>tx,ty的偏移就先不说了</p>

<p>如果绿色的tz为-10，红色的tz为0，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-7d642630070e7554.png" alt="1" /></p>

<p>如果绿色的tz为0,红色的tz为-10，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-29ecdd06f03578f4.png" alt="2" /></p>

<p>对于tz来说，tz越大，那么图层就越靠近屏幕，值越小，图层越往里（离屏幕越远）</p>

<h4>CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz);</h4>

<p>t:就是上一个函数，其它都一样
就可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);</h4>

<p><em>sx:</em> x轴缩放，代表一个缩放比例，一般都是0-1之间的数字
<em>sy:</em> y轴上缩放
<em>sz:</em> 整体比例变换时，也就是m11(sx) == m22(sy)时，若m33(sz) > 1时，图形整体缩小，若0&lt;1,图形整体放大，若m33(sz) &lt; 0时，发生关于原点的对称等比变换。</p>

<p>当sx = 1时，sy = 1时，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-04771b49561f6d76.png" alt="1" /></p>

<p>当sx=0.5,sy=0.5时，如图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-6023b3794fd9917d.png" alt="2" /></p>

<h4>CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz)</h4>

<p>t：就是上一个函数。其他的都一样。</p>

<p>就可以理解为：函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>旋转效果</p>

<p>angle：旋转的弧度，所以要把角度转换成弧度：角度 * M_PI / 180</p>

<p>x:向X轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>y:向Y轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>z:向Z轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>原始图像如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-1.png" alt="1" /></p>

<p>例如：向X轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-2.png" alt="1" /></p>

<p>向Y轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-3.png" alt="1" /></p>

<p>向z轴方向旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-4.png" alt="test" /></p>

<p>向x轴和y轴都旋转60度，就是沿着对角线旋转</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-5.png" alt="t" /></p>

<h4>CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>t:就是上一个函数
可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DInvert (CATransform3D t);</h4>

<p>翻转效果</p>

<p>原始效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-6.png" alt="test" /></p>

<p>调用翻转后的效果:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-7.png" alt="result" /></p>

<h4>CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t);</h4>

<p>仿射效果</p>

<p>就是把一个CATransform3D对象转化成一个CGAffineTransform对象，也就是把CATransform3D矩阵转化成CGAffineTransform矩阵</p>

<p>变换函数同时提供了可以比较一个变换矩阵是否是单位矩阵，或者两个矩阵是否相等。</p>

<h4>bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);</h4>

<p>判断两个变换的矩阵是否相等</p>

<p>也可以通过修改数据结构和键值来设置变换效果</p>

<pre><code>struct CATransform3D

{

CGFloat m11, m12, m13, m14；

CGFloat m21, m22, m23, m24；

CGFloat m31, m32, m33, m34；

CGFloat m41, m42, m43, m44；

}
</code></pre>

<p>可以直接修改其中一个值，来达到相同的效果</p>

<p>或者修改键值</p>

<pre><code>[myLayer setValue:[NSNumber numberWithInt:0] forKeyPath:@"transform.rotation.x"];
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-43f4b4134597cd19.png" alt="e" /></p>
]]></content>
  </entry>
  
</feed>
