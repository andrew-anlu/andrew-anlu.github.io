<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-04-19T21:53:36+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解RunLoop]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/"/>
    <updated>2016-03-29T17:29:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<pre><code>function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>

<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<pre><code>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>

<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre>

<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<pre><code>struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};

struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
</code></pre>

<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<pre><code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
CFRunLoopRunInMode(CFStringRef modeName, ...);
</code></pre>

<p>Mode暴露的管理Mode Item的有下面几个:</p>

<pre><code>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</code></pre>

<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<pre><code>CFRunLoop {
    current mode = kCFRunLoopDefaultMode
    common modes = {
        UITrackingRunLoopMode
        kCFRunLoopDefaultMode
    }

    common mode items = {

        // source0 (manual)
        CFRunLoopSource {order =-1, {
            callout = _UIApplicationHandleEventQueue}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventSignalCallback }}
        CFRunLoopSource {order = 0, {
            callout = FBSSerialQueueRunLoopSourceHandler}}

        // source1 (mach port)
        CFRunLoopSource {order = 0,  {port = 17923}}
        CFRunLoopSource {order = 0,  {port = 12039}}
        CFRunLoopSource {order = 0,  {port = 16647}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventCallback}}
        CFRunLoopSource {order = 0, {port = 2407,
            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
        CFRunLoopSource {order = 0, {port = 1c03,
            callout = __IOHIDEventSystemClientAvailabilityCallback}}
        CFRunLoopSource {order = 0, {port = 1b03,
            callout = __IOHIDEventSystemClientQueueCallback}}
        CFRunLoopSource {order = 1, {port = 1903,
            callout = __IOMIGMachPortPortCallback}}

        // Ovserver
        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
            callout = _wrapRunLoopWithAutoreleasePoolHandler}
        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
            callout = _UIGestureRecognizerUpdateObserver}
        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _afterCACommitHandler}
        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
            callout = _wrapRunLoopWithAutoreleasePoolHandler}

        // Timer
        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
            next fire date = 453098071 (-4421.76019 @ 96223387169499),
            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
    },

    modes ＝ {
        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = 0, {
                    callout = FBSSerialQueueRunLoopSourceHandler}}
            },
            sources1 = (null),
            observers = {
                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
            )},
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventSignalCallback}}
            },
            sources1 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventCallback}}
            },
            observers = (null),
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = (null),
            sources1 = (null),
            observers = (null),
            timers = (null),
        }
    }
}
</code></pre>

<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<pre><code>{
    /// 1. 通知Observers，即将进入RunLoop
    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
    do {

        /// 2. 通知 Observers: 即将触发 Timer 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

        /// 4. 触发 Source0 (非基于port的) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

        /// 6. 通知Observers，即将进入休眠
        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);

        /// 7. sleep to wait msg.
        mach_msg() -&gt; mach_msg_trap();


        /// 8. 通知Observers，线程被唤醒
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);

        /// 9. 如果是被Timer唤醒的，回调Timer
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);

        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);

        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);


    } while (...);

    /// 10. 通知Observers，即将退出RunLoop
    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
}
</code></pre>

<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<pre><code>CFSocket
CFNetwork       -&gt;ASIHttpRequest
NSURLConnection -&gt;AFNetworking
NSURLSession    -&gt;AFNetworking2, Alamofire
</code></pre>

<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<pre><code>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
</code></pre>

<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<pre><code>- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
</code></pre>

<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUrlSession详解]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie/"/>
    <updated>2016-03-27T18:48:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie</id>
    <content type="html"><![CDATA[<p>NSUrlSession是NSUrlConnection的替代品。</p>

<p>NSUrlConennection指的是一组构成 Foundation框架中URL加载系统的相互关联的组件:NSURLRequest,NSUrlResponse,NSURlProtocol等,在协商发送一个请求到服务器的过程中，该服务器可发出验证质询，这可以由共享的cookie，证书存储（credential storage）或通过连接委托自动处理。必要的时候，为了无缝地改变装载行为，传出请求也可以被注册的NSURLProtocol对象截获.</p>

<!--more-->


<p>不管怎样，考虑到NSURLConnection作为一个网络基础架构，成千上万的Cocoa和Cocoa Touch应用程序从中获益，它已经表现得相当好。但是，这些年来，iPhone和iPad新兴的用例，特别是有一些已经向NSURLConnection的几个核心设想提出了挑战，对其重构已经迫在眉睫。</p>

<p>在2013年的WWDC上，Apple揭开了NSURLConnection继任者的面纱：NSURLSession.</p>

<p>与NSUrlConnection类似，除了同名类 NSUrlsession,NSUrlSession指的是一组相互依赖的类，NSURlSession包括与之前相同的组件，例如NSUrlRequest,NSURLCatch等等。
　　</p>

<h2>NSURlconenction 与 NSSession的不同</h2>

<p>　　与NSUrlConnection相比，NSUrlSession最直接的改善就是提供了配置每个回话的缓存，协议，cookie和证书策略(credential policies),甚至跨应用程序共享它们的能力。这使得框架的网络基础架构和部分应用程序独立工作，而不会相互干扰，每一个NSUrlSession对象都是根据一个NSURlSessionConfiguration初始化的，
　　
　　</p>

<p>该NSURlSessionConfiguration指定了上面提到的策略，一级一系列为了提高移动设备性能而专门添加的新选项。</p>

<p>NSUrlSession的另一个重要组成部分就是会话任务，它负责处理数据的加载，以及客户端与服务器之间的文件和数据的上传和下载。</p>

<h2>NSURLSession简介</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="logo" /></p>

<p>NSURLsession关键对象负责接收和发送http请求，创建NSURlSessionConfiguration,这里有三种方式:</p>

<ul>
<li><code>defaultSessionConfiguration</code>创建一个默认的配置文件，用户可以存储缓存，创建证书和缓存cookie等</li>
<li><code>ephemeralSessionConfiguration</code>和默认配置文件很相似，除了它可以在内存中存储之外，它更像是一个私有的session</li>
<li><code>backgroundSessionConfiguration</code>这个配置文件支持上传和下载任务在后台。当程序挂起或者被终止之后任务可以继续执行。</li>
</ul>


<p><code>NSURLSessionConfiguration</code>依然可以让你配置session的属性，比如设置超时时间，缓存策略和http请求头等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration">这里</a>有完整的配置文档。</p>

<p><code>NSURLSessionTask</code>是一个抽象的任务符号,一个session创建一个任务，它不仅可以请求数据，还可以上传和下载。</p>

<p>这里有三种类型的任务：</p>

<ul>
<li><code>NSURLSessionDataTask</code>：用这个任务可以发送http请求，从而从服务器得到返回的数据</li>
<li><code>NSURLSessionUploadTask</code>：用这个任务可以从本地硬盘上往服务器上传文件，一般是HTTP post请求或者PUT请求.</li>
<li><code>NSURLSessionDownloadTask</code>:用这个任务可以从远程服务器上下载文件</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="logo" /></p>

<p>你可以挂起，回滚和取消任务，<code>NSURLSessionDownloadTask</code>还有一个特性就是支持断点下载。</p>

<p>一般来讲, NSURLSession 有两种方式返回数据：</p>

<ol>
<li>利用completion handler,当任务完成之后，不管是成功返回还是产生错误；</li>
<li>还有一种就是利用NSSession的代理，依然可以捕获到返回的数据;</li>
</ol>


<h2>编写实例Demo</h2>

<p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip">启动工程在这里下载</a>,</p>

<p>开始做一个 在Itunes搜索歌曲，通过<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">Itunes API</a>下载歌曲的这么个小工程，支持暂停，下载功能。</p>

<p>下完工程，运行效果如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt="itunes" /></p>

<h3>开始编写代码</h3>

<p>你可以添加代码去查询itunes中的歌曲，通过查找 Itunes search Api.</p>

<p>在<code>SearchViewController.swift</code>文件中，添加如下代码:</p>

<pre><code>// 1
let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
// 2
var dataTask: NSURLSessionDataTask?
</code></pre>

<p>上面的代码做了如下工作:</p>

<ol>
<li>用默认的配置文件创建NSURLSession</li>
<li>你定义了一个<code>NSURLSessionDataTask</code>变量，用它发送http请求，这个任务将会被重复初始化和重复利用在用户创建一个新查询的时候</li>
</ol>


<p>现在，替换<code>searchBarSearchButtonClicked(_:)</code>里面的代码:</p>

<pre><code>func searchBarSearchButtonClicked(searchBar: UISearchBar) {
  dismissKeyboard()

  if !searchBar.text!.isEmpty {
    // 1
    if dataTask != nil {
      dataTask?.cancel()
    }
    // 2
    UIApplication.sharedApplication().networkActivityIndicatorVisible = true
    // 3
    let expectedCharSet = NSCharacterSet.URLQueryAllowedCharacterSet()
    let searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!
    // 4
    let url = NSURL(string: "https://itunes.apple.com/search?media=music&amp;entity=song&amp;term=\(searchTerm)")
    // 5
    dataTask = defaultSession.dataTaskWithURL(url!) {
      data, response, error in
      // 6
      dispatch_async(dispatch_get_main_queue()) {
        UIApplication.sharedApplication().networkActivityIndicatorVisible = false
      }
      // 7
      if let error = error {
        print(error.localizedDescription)
      } else if let httpResponse = response as? NSHTTPURLResponse {
        if httpResponse.statusCode == 200 {
          self.updateSearchResults(data)
        }
      }
    }
    // 8
    dataTask?.resume()
  }
}
</code></pre>

<p>运行后代码如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160401-1.png" alt="logo" /></p>

<p>如果出现错误<code>An SSL error has occurred and a secure connection to the server cannot be made.</code></p>

<p>请在info.plist中配置，在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为 YES</p>

<p>上面的代码步骤意义如下:</p>

<ol>
<li>检查用户每一次查询，dataTask是否已经初始化，如果没有，则取消该任务</li>
<li>设置的状态栏上的转子运行起来，证明数据正在请求当中</li>
<li>当用户输入查询参数之前，调用 请求字符串的<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>,确保是一个正确的URL.　(这个 text 的类型是 String ，常用于搜索功能，在  URL 中包含被搜的关键字，如果不处理搜中文或者带空格的英文会直接崩溃);</li>
<li>下一步创建一个NSURL用上面的（安全的）字符串，使用GET请求去调用Itunes Search API</li>
<li>从创建的Session中，你初始化<code>NSURLSessionDataTask</code>去处理http请求，这个<code>NSURLSessionDataTask</code>任务使用completion handler （回调函数）去响应服务器返回的数据</li>
<li>异步调用主线程，在主线程上隐藏网络请求的转子</li>
<li>如果http请求是成功的，你可以调用<code>updateSearchResults(_:)</code>来刷新表格数据，返回数据是NSData类型的，需要在updateSearchResults方法中进行处理</li>
<li>所有任务默认是挂起状态，需要你调用 <code>resume()</code>去启动任务</li>
</ol>


<h2>下载</h2>

<p>看着搜索到的歌曲，感觉页面不错，但是如果我们能够通过点击 download,然后把歌曲下载到本地是不是更爽呢?下一步让我实现这个功能点.</p>

<p>用多线程实现下载是容易的。首先你要创建一个新的文件命名为 <code>Download.swift</code>. 打开这个文件，添加如下代码:</p>

<pre><code>class Download: NSObject {

  var url: String
  var isDownloading = false
  var progress: Float = 0.0

  var downloadTask: NSURLSessionDownloadTask?
  var resumeData: NSData?

  init(url: String) {
    self.url = url
  }
}
</code></pre>

<p>属性说明如下:</p>

<ul>
<li>URL:下载文件的url地址，它也扮演着唯一的标识符在下载过程中</li>
<li>isDownloading:是否正在下载或暂停</li>
<li>progress : 下载的进度,[0-1]</li>
<li>downloadTask: NSURLSessionDownloadTask下载任务</li>
<li>resumeData:当你暂停一个下载任务时，它负责存储此时的数据量；如果后台服务器支持的话，当用户再次点击继续下载，它会从这里开始继续下载这个文件，俗称 断点下载</li>
</ul>


<p>切换到 <code>SearchViewController.swift</code>，添加如下代码:</p>

<pre><code>var activeDownloads = [String: Download]()
</code></pre>

<h2>创建下载任务</h2>

<p>准备工作做得差不多了，现在你只需实现下载，首先你要创建一个session去实现下载任务.</p>

<p>在 <code>SearchViewController.swift</code>文件中，在<code>viewDidLoad():</code>之前添加如下代码:</p>

<pre><code>lazy var downloadsSession: NSURLSession = {
  let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
  let session = NSURLSession(configuration: configuration, delegate: self, delegateQueue: nil)
  return session
}()
</code></pre>

<p>这里初始化了一个session,用默认的配置文件，去处理所有的下载任务，你也可以指定delegate,这将会使你收到 <code>NSURLSession</code>的代理调用，这个是很有用的，它能有效的跟踪下载任务下载的进度和是否下载完成等。</p>

<p>设置代理的队列是nil,会促使session创建一个操作队列，默认的去调用代理方法和回调方法.</p>

<p>在创建<code>downloadsSession</code>属性的时候，我们加了<code>lazy</code>特性，这会让你延迟加载这个session直到你需要它的时候，更重要的是，它会通过<code>self</code>作为代理参数去初始化，假如<code>self</code>还没有初始化。</p>

<p>在<code>SearchViewController.swift</code>文件中，找到空的<code>NSURLSessionDownloadDelegate</code>并且扩展如下:</p>

<pre><code>extension SearchViewController: NSURLSessionDownloadDelegate {
  func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
    print("Finished downloading.")
  }
}
</code></pre>

<p><code>NSURLSessionDownloadDelegate</code>定义了代理方法你需要去实现，在你使用 NSURLSession 下载任务的时候，这个唯一的不是可选的代理方法是 <code>URLSession(_:downloadTask:didFinishDownloadingToURL:),</code>,当下载完成的时候，将会执行这个代理方法，打印简答的一句话.</p>

<p>在<code>SearchViewController.swift</code>文件中，替换<code>startDownload(_:)</code>这个方法的代码如下:</p>

<pre><code>func startDownload(track: Track) {
  if let urlString = track.previewUrl, url =  NSURL(string: urlString) {
    // 1
    let download = Download(url: urlString)
    // 2
    download.downloadTask = downloadsSession.downloadTaskWithURL(url)
    // 3
    download.downloadTask!.resume()
    // 4
    download.isDownloading = true
    // 5
    activeDownloads[download.url] = download
  }
}
</code></pre>

<p>当你点击 <code>Download</code>按钮的时候，你将会调用<code>startDownload(_:)</code>函数去执行下载命令，上面的代码执行的步骤如下:</p>

<ol>
<li>你用URL去初始化一个DownLoad对象</li>
<li>使用上面的NSURL和downloadsSession去初始化<code>NSURLSessionDownloadTask</code></li>
<li>调用resume()去启动一个下载任务</li>
<li>设置下载标识 为true</li>
<li>最后，你把下载的URL作为key,download对象作为值放到一个字典中</li>
</ol>


<p>编译运行你的项目，查询出来的歌曲中，点击 Download按钮，你将会看到一个消息打印在控制台。
<code>Finished downloading.</code></p>

<h2>保存&amp;播放</h2>

<p>当下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>提供了一个URL存储临时文件路径，你的工作就是移动它到你程序的沙盒当中，在这个方法返回之前。当然，这个过程当中你需要删除全局字典中正在下载的download对象，并且更新表格.</p>

<p>你需要添加一个Helper方法简化这个操作，在<code>SearchViewController.swift</code>中，添加如下方法:</p>

<pre><code>func trackIndexForDownloadTask(downloadTask: NSURLSessionDownloadTask) -&gt; Int? {
  if let url = downloadTask.originalRequest?.URL?.absoluteString {
    for (index, track) in searchResults.enumerate() {
      if url == track.previewUrl! {
        return index
      }
    }
  }
  return nil
}
</code></pre>

<p>这个方法仅仅返回 当前的URL在 searchResults集合中的索引，下一步，替换 URLSession(_:downloadTask:didFinishDownloadingToURL:) 中的代码:</p>

<pre><code>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
  // 1
  if let originalURL = downloadTask.originalRequest?.URL?.absoluteString,
    destinationURL = localFilePathForUrl(originalURL) {

    print(destinationURL)

    // 2
    let fileManager = NSFileManager.defaultManager()
    do {
      try fileManager.removeItemAtURL(destinationURL)
    } catch {
      // Non-fatal: file probably doesn't exist
    }
    do {
      try fileManager.copyItemAtURL(location, toURL: destinationURL)
    } catch let error as NSError {
      print("Could not copy file to disk: \(error.localizedDescription)")
    }
  }

  // 3
  if let url = downloadTask.originalRequest?.URL?.absoluteString {
    activeDownloads[url] = nil
    // 4
    if let trackIndex = trackIndexForDownloadTask(downloadTask) {
      dispatch_async(dispatch_get_main_queue(), {
        self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: trackIndex, inSection: 0)], withRowAnimation: .None)
      })
    }
  }
}
</code></pre>

<p>上面的代码做的事情如下:</p>

<ol>
<li>定义了两个变量，<code>originalURL</code>请求路径的url,<code>destinationURL</code>变量则是通过<code>localFilePathForUrl(_:)</code>方法生成的，该方法会获取当前程序的沙盒路径再追加 传递的URL的最后一个后缀(/)的路径作为返回的参数。作为目标文件夹的路径</li>
<li>使用NSFileManager,在开始拷贝文件之前，先删除目标文件夹下的文件，如果存在的话。然后进行拷贝从本地拷贝到目标文件夹</li>
<li>删除download从全局的download字典中</li>
<li>最后刷新表格对应的哪一行</li>
</ol>


<p>编译运行你的工程，点击搜索然后选中一行进行下载，当下载完成时候，在控制台会打印一行信息,下载的目标路径</p>

<pre><code>file:///Users/Andrew/Library/Developer/CoreSimulator/Devices/875165C2-FA55-4884-96AE-A7C8E3223C12/data/Containers/Data/Application/52B47648-04A2-4C26-8BCF-F41D2C76CA21/Documents/mzm.gyadmzom.aac.p.m4a
</code></pre>

<p>这时下载按钮将会消失，再次点击表格的对应的那行，将会弹出一个 MPMoviePlayerViewController,开始播放音频.</p>

<h2>监视下载进度</h2>

<p>当然，现在你还没有监视下载的进度条，为了提高用户体验，你将要改变你的App去监听下载的进度在每个cell中。</p>

<p>在SearchViewController.swift文件中,找到 <code>NSURLSessionDownloadDelegate</code>的扩展，然后添加如下的代理方法:</p>

<pre><code>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {

    // 1
    if let downloadUrl = downloadTask.originalRequest?.URL?.absoluteString,
      download = activeDownloads[downloadUrl] {
      // 2
      download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
      // 3
      let totalSize = NSByteCountFormatter.stringFromByteCount(totalBytesExpectedToWrite, countStyle: NSByteCountFormatterCountStyle.Binary)
      // 4
      if let trackIndex = trackIndexForDownloadTask(downloadTask), let trackCell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: trackIndex, inSection: 0)) as? TrackCell {
        dispatch_async(dispatch_get_main_queue(), {
          trackCell.progressView.progress = download.progress
          trackCell.progressLabel.text =  String(format: "%.1f%% of %@",  download.progress * 100, totalSize)
        })
    }
  }
}
</code></pre>

<p>通过这个代理方法做的工作如下:</p>

<ol>
<li>使用提供的 downloadTask 找到URL属性，然后从全局激活的下载字典中查找 DownLoad对象</li>
<li>这个方法将会返回总的字节数和已经写入的字节数，你可以利用这个两个值算出当前的下载进度并且实时更新进度条。</li>
<li>NSByteCountFormatter 将会把字节数转化成人类能够看懂的文件大小，有将会使用这个字符串去显示下载的文件大小和百分比</li>
<li>最后，你将要定位到这个Cell,在主线程中更新进度条和显示的百分比</li>
</ol>


<p>下一步，你将要配置这个cell属性去显示进度条</p>

<p>找到下面的代码在 <code>tableView(_:cellForRowAtIndexPath:):</code>中</p>

<pre><code>let downloaded = localFileExistsForTrack(track)
</code></pre>

<p>添加如下代码在这行的上面:</p>

<pre><code>var showDownloadControls = false
if let download = activeDownloads[track.previewUrl!] {
  showDownloadControls = true

  cell.progressView.progress = download.progress
  cell.progressLabel.text = (download.isDownloading) ? "Downloading..." : "Paused"
}
cell.progressView.hidden = !showDownloadControls
cell.progressLabel.hidden = !showDownloadControls
</code></pre>

<p>为了跟踪正在下载的歌曲，你将要设置 showDownloadControls为true,否则，你将要设置为false.你将要显示这进度条和文字。</p>

<p>为了暂停任务，显示"Paused"状态，否则，显示 “Downloading&hellip;.”
最后，替换这行代码:</p>

<pre><code>cell.downloadButton.hidden = downloaded
</code></pre>

<p>使用下面这行代码:</p>

<pre><code>cell.downloadButton.hidden = downloaded || showDownloadControls
</code></pre>

<p>到这，你可以告诉表格是否隐藏下载按钮。</p>

<p>编译运行你的工程，点击下载按钮，你将要看到一个进度条和下载的进度，以及下载的百分比。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-17-at-11.02.03-pm-480x78.png" alt="logo" /></p>

<p>OK,你做到了!😀</p>

<h2>暂停 恢复  取消下载任务</h2>

<p>假如我需要暂停一个任务，或者取消任务？此时该怎么做呢？</p>

<p>在这个章节，你将要实现暂停，恢复，取消任务操作。</p>

<p>你将要开始编写代码，通过允许用户去取消一个正在激活的任务
替换 <code>cancelDownload(_:)</code> 使用下面的代码:</p>

<pre><code>func cancelDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      download.downloadTask?.cancel()
      activeDownloads[urlString] = nil
  }
}
</code></pre>

<p>为了取消任务，你可以从全局激活的字典中取出Download对象，然后调用它的 cancel() 方法，执行取消命令，然后在全局字典中移除它</p>

<p>暂停任务和取消任务非常类似，不同点在于当你暂停一个任务的时候，会产生恢复数据，它包含了足够多的信息去恢复下载数据，当然后台服务器必须要支持这个特性才能完全实现断点下载功能.</p>

<blockquote><p><strong>注意</strong>
你能恢复一个下载任务在一定的控制条件下，例如，从你第一下请求下载开始，这个下载资源就不能再改变了。想要更详细的控制条件，请参考苹果的 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDownloadTask_class/index.html#//apple_ref/occ/instm/NSURLSessionDownloadTask/cancelByProducingResumeData:">官方文档</a></p></blockquote>

<p>现在，替换 <code>pauseDownload(_:)</code>使用下面的代码:</p>

<pre><code>func pauseDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      if(download.isDownloading) {
        download.downloadTask?.cancelByProducingResumeData { data in
          if data != nil {
            download.resumeData = data
          }
        }
        download.isDownloading = false
      }
  }
}
</code></pre>

<p>这个关键字是不同的 cancelByProducingResumeData(_:) 替代了 cancel(),你检索这个恢复的数据从这个方法cancelByProducingResumeData提供的回调函数中，并且把恢复的数据保存到Download的resumeData属性中。并且设置isDownloading=false</p>

<p>下面替换<code>resumeDownload(_:)</code>用下面的代码:</p>

<pre><code>func resumeDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      if let resumeData = download.resumeData {
        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)
        download.downloadTask!.resume()
        download.isDownloading = true
      } else if let url = NSURL(string: download.url) {
        download.downloadTask = downloadsSession.downloadTaskWithURL(url)
        download.downloadTask!.resume()
        download.isDownloading = true
      }
  }
}
</code></pre>

<p>当用户恢复一个下载任务时，你检查下当前的Download对象 恢复数据的属性是否有值，如果有值，你将会创建一个新的下载任务通过 <code>downloadTaskWithResumeData(_:)</code>和一个恢复数据的参数，启动<code>resume()</code>恢复数据的命令;如果这个 恢复数据的属性是空的或者其他一些原因，你将要用URL创建一个新的下载任务，启动它.</p>

<p>在上面的案例中，你设置这个isDownloading为true,表明任务正在进行.</p>

<p>还有一件事件要做就是设置这三个函数的工作属性，你需要在cell中显示 或者隐藏 <code>暂停</code>，<code>取消</code>和<code>继续下载</code>按钮。</p>

<p>找到 <code>tableView(_:cellForRowAtIndexPath:)</code>然后找到下面这行代码:</p>

<pre><code>if let download = activeDownloads[track.previewUrl!] {
</code></pre>

<p>然后添加下面的代码:</p>

<pre><code>let title = (download.isDownloading) ? "Pause" : "Resume"
cell.pauseButton.setTitle(title, forState: UIControlState.Normal)
</code></pre>

<p>暂停和继续下载按钮共用一个按钮。</p>

<p>下一步，添加下面的代码在 <code>tableView(_:cellForRowAtIndexPath:)</code>结尾:</p>

<pre><code>cell.pauseButton.hidden = !showDownloadControls
cell.cancelButton.hidden = !showDownloadControls
</code></pre>

<p>当下载任务激活的时候，这里仅仅把按钮显示出来。</p>

<p>编译运行你的工程，下载几个歌曲试试，你可以暂停，继续下载，取消 下载任务。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="logo" /></p>

<h2>支持后台下载</h2>

<p>你的App现在看来已经很不错了，但是还有一个问题，是否支持后台任务下载:当你的程序进入后台模式或者因为别的原因意外终止了，后台任务是否能继续下载?</p>

<p>假如你的App不再运行了，那它怎么能继续工作呢？这儿有一个守护进程在App运行之外，去管理后台任务下载；它发送一个适当的代理方法通知给app让其任务下载继续，当这个app正在下载的时候突然退出，这个任务将要继续下载。</p>

<p>当任务完成的时候，这个守护进程将要重新加载在后台模式中，这个重新加载app将要重新连接这同样的session.收到相关的完成的代理消息并且执行一些要求的动作，比如持久化下载的文件到硬盘上等。</p>

<blockquote><p><em>注意</em>
如果你强制退出app通过app switche，这个系统将要取消所有后台下载的任务，并且不会再视图重启这个app</p></blockquote>

<p>仍然在SearchViewController.swift这个文件中，在初始化 <code>downloadsSession</code>的地方，找到下面这行代码:</p>

<pre><code>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</code></pre>

<p>替换成下面的代码:</p>

<pre><code>let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("bgSessionConfiguration")
</code></pre>

<p>替换默认的session配置文件，指定一个特殊的后台session配置文件，注意你设置了唯一的ID为这个session,这会允许你引用并且重新连接同样的后台session.</p>

<p>下一步，在 viewDidLoad()中，增加如下代码:</p>

<pre><code>_ = self.downloadsSession
</code></pre>

<p>调用懒加载属性<code>downloadsSession</code>,确保应用程序确实创建了一个后台session 的SearchViewController的实例。</p>

<p>当一个后台任务完成的时候，这个App不再运行，这个app将会重新运行到后台进程中，你需要去处理你的app的一些代理方法.</p>

<p>切换到 AppDelegate.swift,添加下面的代码在类的顶部:</p>

<pre><code>var backgroundSessionCompletionHandler: (() -&gt; Void)?
</code></pre>

<p>下一步，添加如下代码在AppDelegate.swift:</p>

<pre><code>func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) {
  backgroundSessionCompletionHandler = completionHandler
}
</code></pre>

<p>提供一个completionHandler作为一个变量在你的App代理方法中，等会会用到。</p>

<p>application(_:handleEventsForBackgroundURLSession:)会唤醒这个App处理完成这个后台任务，你需要去处理两个事情：</p>

<ul>
<li>首先，通过代理方法用这个App去重新连接这个后台session,一旦你创建并且每次使用后台session时，SearchViewController就会被实例化，你已经重新连接了.</li>
<li>第二，你需要去捕获完成的回调方法，在完成的回调函数中，更新你的UI,然后告诉系统你的App已经工作完毕使用后台任务的session.</li>
</ul>


<p>但是什么时候你将会调用完成的回调函数呢？
<code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>将会是一个好的选择，它是NSURLSessionDelegate的一个代理方法，当所有的任务在后台session中完成的时候。</p>

<p>实现下面的扩展在<code>SearchViewController.swift</code>中</p>

<pre><code>extension SearchViewController: NSURLSessionDelegate {

  func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
    if let appDelegate = UIApplication.sharedApplication().delegate as? AppDelegate {
      if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
        appDelegate.backgroundSessionCompletionHandler = nil
        dispatch_async(dispatch_get_main_queue(), {
          completionHandler()
        })
      }
    }
  }
}
</code></pre>

<p>上面的代码仅仅抓取了在APPDelegate中存储的回调函数，并且在主线中调用它.</p>

<p>编译运行你的工程，开始几个下载之后迅速按在home键，使得下载任务进入后台，等几十秒你的下载任务将会完成，然后双击home,关闭当前程序。</p>

<p>下载任务将会完成并且他们将会更新显示状态。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt="logo" /></p>

<p>OK，这个demo已经完备了。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程从 <a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip">这里</a></p>

<p>更多资源</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/">苹果的官方文档</a></li>
<li><a href="https://github.com/Alamofire/Alamofire">AlamoFire</a>是Swift中非常流行的第三方框架，可以学习一下.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue简单介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao/"/>
    <updated>2016-03-26T08:11:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao</id>
    <content type="html"><![CDATA[<p>在iOS中有两种方式来实现多线程:NSOperation和GCD.
其中GCD是基于C的底层的API,而NSOperation则是GCD实现的Object-c的API,随让NSOPeration是基于GCD实现的，但是并不意味着它是一个GCD的重复版本，相反，我们可以用NSOperation轻易的实现一些GCD要写大量代码的事情，因此，NSOperation是被推荐使用的.</p>

<!--more-->


<h2>为什么优先使用NSOperationQuere,而不是GCD</h2>

<p>你可能写过这样的网络请求的代码:</p>

<pre><code>dispatch_async(_Queue, ^{  
    //请求数据 
    NSData *data = [NSData dataWithContentURL:[NSURL URLWithString:@"http://domain.com/a.png"]]; 
    dispatch_async(dispatch_get_main_queue(), ^{ 
        [self refreshViews:data];
     });
});
</code></pre>

<p>这段代码是可以正常工作的，但是有一个很大的缺点，就是<em>这个任务是无法取消的</em></p>

<p><code>dataWithContentURL:</code>是同步拉取数据，它会一直阻塞主线程，直到所有的数据返回之后；这个期间，并发队列就需要为其它任务新建线程，这样可能导致性能下降问题。因此我们不推荐这种写法来从网络上拉取数据。</p>

<p>操作队列是有GCD提供的一个队列模型的Coco对象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了更加方便的功能。NSOperation相对GCD来说有以下优点:</p>

<ul>
<li>提供了GCD中不那么容易复制的有用特性</li>
<li>可以很方便的取消一个NSOperation的执行</li>
<li>可以容易的添加任务的依赖关系</li>
<li>提供了任务的状态:isExecting,isFinished
*</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue就是一个线程队列，可以吧 <code>NSOperation</code>加入到队列中，可以取消或者执行完队列中所有的 <code>NSOperation</code>,我们可以通过<code>maxConcurrentOperationCount</code>属性来控制并发任务的数量，当设置为1时，就是一个串行队列。</p>

<h2>NSOperation</h2>

<p>它是创建线程的对象，系统已经默认提供了<code>NSBlockOperaton</code>和<code>NSInvocationOperation</code>.你也可以实现自己的子类，通过重写
<code>main</code>或者<code>start</code>方法来自定义nsoperation</p>

<p>使用<code>main</code>方法非常简单，不需要管理一些状态属性,当main方法返回的时候，这个operation就执行结束了，所以一般用来执行同步任务。</p>

<p>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么重写<code>start</code>方法，但是注意，在这种情况下，你必须手动的管理操作的状态，只有发送isFinished的KVO消息时，才认为是operaiton结束。</p>

<pre><code>
@implementation YourOperation
- (void)start
{
    self.isExecuting = YES;
    // 任务代码 ...
}
- (void)finish //异步回调
{
    self.isExecuting = NO;
    self.isFinished = YES;
}
@end
</code></pre>

<p><em>当实现了<code>start</code>方法时，默认就会执行start方法，而不执行main方法</em>，为了让操作队列捕获到做的改变，需要将状态的属性配合KVO的方式实现，如果你不使用它们默认的sette来进行设置的话，就需要在合适的时候手动发送KVO消息。</p>

<p>需要手动管理的状态有:</p>

<ol>
<li>isExecuting  代表任务正在进行中</li>
<li>isFinished   代表任务已经执行完成</li>
<li>isCanceled  代表任务已经取消</li>
</ol>


<p>手动发送KVo消息，通知状态:</p>

<pre><code>[self willChangeValueForKey:@"isCancelled"];
_isCancelled = YES;
[self didChangeValueForKey:@"isCancelled"];
</code></pre>

<p>为了能使用队列所提供的取消功能，你需要在长时间操作中不时地检查isCanceled属性，比如在一个长的循环中:</p>

<pre><code>- (void)main
{
    while (notDone &amp;&amp; !self.isCancelled) {
        // 任务处理
    }
}
@end
</code></pre>

<h2>简单使用</h2>

<p>NSOperaiton和NSOperationQueue实现多线程的步骤:</p>

<ol>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装放到一条新线程中执行</li>
</ol>


<p>NSOperation是个抽象类，并不具备封装操作的能力，必须实现它的子类。</p>

<h3>NSInvocationOperation子类</h3>

<pre><code>//创建操作对象，封装要执行的任务
//NSInvocationOperation   封装操作
    NSInvocationOperation *operation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];

    //执行操作
    [operation start];
</code></pre>

<p>一旦执行操作，就会调用target的test方法</p>

<p>操作对象默认在主线程中执行，只有添加到列队中才会开启新的线程，即默认情况下，如果操作没有放到队列queue中，都是同步执行，只有将NSoperation放到一个NSOperationQueue中，才会异步执行.</p>

<h2>NSBlockOoperaiton</h2>

<p>创建对象和添加操作:</p>

<pre><code>//创建NSBlockOperation操作对象
    NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
        //......
    }];

    //添加操作
    [operation addExecutionBlock:^{
        //....
    }];
</code></pre>

<pre><code>//创建NSBlockOperation操作对象
     NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"NSBlockOperation------%@",[NSThread currentThread]);
     }];

     //添加操作
     [operation addExecutionBlock:^{
        NSLog(@"NSBlockOperation1------%@",[NSThread currentThread]);
     }];

     [operation addExecutionBlock:^{
         NSLog(@"NSBlockOperation2------%@",[NSThread currentThread]);
     }];

     //开启执行操作
    [operation start];
</code></pre>

<p>只要NSBlockOperation封装的操作数>1，就会异步操作。</p>

<h2>NSOperationQueue</h2>

<p>NSOperationQueue可以调用start方法来执行任务，但默认是同步执行的。
如果将NSOperation添加到NSOperationQueue中，系统就会自动异步执行NSOPeration中的操作。</p>

<pre><code>
#import "YYViewController.h"

@interface YYViewController ()

@end

@implementation YYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    //创建NSInvocationOperation对象，封装操作
    NSInvocationOperation *operation1=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test1) object:nil];
    NSInvocationOperation *operation2=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test2) object:nil];
    //创建对象，封装操作
    NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"NSBlockOperation3--1----%@",[NSThread currentThread]);
    }];
    [operation3 addExecutionBlock:^{
        NSLog(@"NSBlockOperation3--2----%@",[NSThread currentThread]);
    }];

    //创建NSOperationQueue
    NSOperationQueue * queue=[[NSOperationQueue alloc]init];
    //把操作添加到队列中
    [queue addOperation:operation1];
    [queue addOperation:operation2];
    [queue addOperation:operation3];
}

-(void)test1
{
    NSLog(@"NSInvocationOperation--test1--%@",[NSThread currentThread]);
}

-(void)test2
{
    NSLog(@"NSInvocationOperation--test2--%@",[NSThread currentThread]);
}

@end
</code></pre>

<p>系统自动将NSOperationqueue中的NSOPeration对象取出，将其封装的操作放到一条新的线程中执行，
上面的代码一共有4个任务，operation1和operation2分别有一个任务，operation3有两个任务，一共4个任务，开启了4条线程。</p>

<p>这些任务是并行执行的。</p>

<blockquote><p><strong>提示</strong>
队列的取出时有顺序的，与打印结果并不矛盾，这就好比赛跑，起跑的顺序是A,B,C，但是到达终点的顺序就不一样是 A B  C了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习CAShapeLayer]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer/"/>
    <updated>2016-03-04T14:20:24+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>CAShapeLayer继承自CALayer,因此，可以使用CaLayer的所有属性。但是，CAShapeLayer需要和贝塞尔曲线配合使用才有意义.</p>

<p>CAShapeLayer是在其坐标系统内绘制贝塞尔曲线的。因此使用CAShapeLayer需要与 <code>UIbezierPath</code>一起使用。</p>

<p>它有一个 <code>path</code>属性，而<code>UIBezierPath</code>就是对 <code>CGPathRef</code>类型的封装，因此这两者是绝配</p>

<!--more-->


<h2>CASHapeLayer和drawRect的比较</h2>

<ol>
<li>drawRect : 属于CoreGraphics框架，占用cpu,性能消耗大</li>
<li>CAShapeLayer:属于CoreAnimation框架，通过GPU来渲染图形，节省性能。动画渲染直接提交给手机的GPU,不消耗内存。</li>
</ol>


<p>这两者各有各的用途，而不是说有个CAShapeLayer就不需要drawRect了。</p>

<h2>CAShapeLayer月UIBezierPath的关系</h2>

<ol>
<li>CAShapeLayer中的shape代表形状的意思，所以需要形状才能生效</li>
<li>贝塞尔曲线可以创建矢量的路径，而<code>UIBezierPath</code>类是对 <code>CGPathRef</code>的封装</li>
<li>贝塞尔曲线给 <code>CAShapeLayer</code>提供路径，CAShapelayer在提供的路径中进行渲染。路径会闭环，所以绘制出了 <code>Shape</code></li>
<li>用于<code>CAShapeLayer</code>的贝塞尔曲线作为path,其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线。</li>
</ol>


<h2>CAShapeLayer与UIBezierPath画圆</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-2.png" alt="logo" /></p>

<p>代码:</p>

<pre><code>-(CAShapeLayer*)drawCircle{
    CAShapeLayer *circleLayer=[CAShapeLayer layer];

    circleLayer.frame=CGRectMake(100, 10, 200, 200);
    //设置居中显示
   // circleLayer.position=self.view.center;
    //设置填充颜色
    circleLayer.fillColor=[UIColor clearColor].CGColor;
    //设置线宽
    circleLayer.lineWidth=2;
    //设置线的颜色
    circleLayer.strokeColor=[UIColor redColor].CGColor;

    //使用UIBezierPath创建路径
    CGRect frame=CGRectMake(0, 0, 200, 200);
    UIBezierPath *circlePath=[UIBezierPath bezierPathWithOvalInRect:frame];
    //设置CAShapeLayer与UIBezierPath关联
    circleLayer.path=circlePath.CGPath;

    [self.view.layer addSublayer:circleLayer];

    return circleLayer;

}
</code></pre>

<p>注意，我们这里不是放在-drawRect:方法中调用的。我们直接将这个CAShapeLayer放到self.view.layer上，直接呈现出来。</p>

<p>我们创建一个<code>CAShapeLayer</code>，然后配置相关属性，然后再通过 <code>UIBezierPath</code>的类方法创建一个内切圆路径，然后将路径指定给<code>CAShapeLayer.path</code>,这就将两者关联起来了，最后，将这个层放到了self.view.layer上呈现出来。</p>

<h2>CAShapeLayer与UIBezierPath的简单Loading效果</h2>

<p>代码:</p>

<pre><code>- (void)drawHalfCircle {
  self.loadingLayer = [self drawCircle];

  // 这个是用于指定画笔的开始与结束点
  self.loadingLayer.strokeStart = 0.0;
  self.loadingLayer.strokeEnd = 0.75;

  self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1
                                                target:self
                                              selector:@selector(updateCircle)
                                              userInfo:nil
                                               repeats:YES];
}

- (void)updateCircle {
  if (self.loadingLayer.strokeEnd &gt; 1 &amp;&amp; self.loadingLayer.strokeStart &lt; 1) {
    self.loadingLayer.strokeStart += 0.1;
  } else if (self.loadingLayer.strokeStart == 0) {
    self.loadingLayer.strokeEnd += 0.1;
  }

  if (self.loadingLayer.strokeEnd == 0) {
    self.loadingLayer.strokeStart = 0;
  }

  if (self.loadingLayer.strokeStart &gt;= 1 &amp;&amp; self.loadingLayer.strokeEnd &gt;= 1) {
    self.loadingLayer.strokeStart = 0;
    [self.timer invalidate];
    self.timer = nil;
  }
}
</code></pre>

<p>我们要实现这个效果，是通过 <code>stokeStart</code>和<code>stokeEnd</code>这两个属性好实现的，这两个的取值范围是[0-1],当stokeStart的值慢慢变成1时，我们看到路径是慢慢消失的。这里实现的效果并不好，因为不能一直循环。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios的Block循环引用]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/04/iosde-blockxun-huan-yin-yong/"/>
    <updated>2016-03-04T13:22:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/04/iosde-blockxun-huan-yin-yong</id>
    <content type="html"><![CDATA[<p>ios在开发的过程中，很容易引发内存泄露问题。也很容易造成循环引用，之前使用block的时候也没有过多注意，其实坑很多。
对于新手来说，出现循环引用的时候，很难去排查。</p>

<!--more-->


<h2>Controller之间的block循环引用</h2>

<p>现在，我们声明两个类，一个是ViewController,另一个是TLController,在ViewController中有个按钮，点击 push到TlController中。
先看TLController中类的声明：</p>

<pre><code>typedef void(^CallbackBlock)();

@interface TLController : UIViewController
- (instancetype)initWithCallback:(CallbackBlock)callback;

@property (nonatomic, copy) CallbackBlock callbackBlock;
</code></pre>

<p>TlController.m</p>

<pre><code>- (instancetype)initWithCallback:(CallbackBlock)callback{
    self=[super init];
    if(self){
        _callbackBlock=callback;
    }
    return self;
}
</code></pre>

<p>为了验证该类是不是被释放掉了，我们重写两个方法来检测:</p>

<pre><code>-(void)viewDidAppear:(BOOL)animated{
    [super viewDidAppear:animated];
    NSLog(@"进入控制器：%@", [[self class] description]);
}
- (void)dealloc {
    NSLog(@"控制器被dealloc: %@", [[self class] description]);
}
</code></pre>

<p>在 ViewController中，创建一个按钮，按钮的单击事件如下:</p>

<pre><code>// 点击button时
- (void)goToNext {
    //__weak __typeof(self) weakSelf=self;

    TLController *vc = [[TLController alloc] initWithCallback:^{
        [self.button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];
    }];
    self.vc = vc;
    [self.navigationController pushViewController:vc animated:YES];
}
</code></pre>

<p>现在看Viewcontroller，这里就形成了两个循环，因此vc属性得不到释放，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-0.png" alt="logo" /></p>

<p>这里形成了两个循环</p>

<ol>
<li><p>ViewContrller->强引用了vc->强引用了callback->强引用了Viewcontroller</p></li>
<li><p>Viewcontroler->强引用了属性vc->强引用了callback->强引用了Viewcontroller的属性button</p></li>
</ol>


<p>我们要解决这两个循环引用，可以如下操作:</p>

<p>不声明vc属性，或者将vc属性声明为weak弱引用类型，在callback回调处，将self.button改为 weakSelf.button,也就是让callback的这个block对viewcontroller弱引用，这样内存就可以顺利释放了。</p>

<pre><code>// 点击button时
- (void)goToNext {
    __weak __typeof(self) weakSelf=self;

    TLController *vc = [[TLController alloc] initWithCallback:^{
        [weakSelf.button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];
    }];
   // self.vc = vc;
    [self.navigationController pushViewController:vc animated:YES];
}
</code></pre>

<h2>Controller和View之间的block引用</h2>

<p>我们先定义一个view,用于和Contrller交互，当点击view上的按钮时，就把结果回调给controller;</p>

<p>TLView定义如下:
TlView.h</p>

<pre><code>typedef void(^FeedbackBlock)(id model);
@interface TLView : UIView
@property (nonatomic, copy) FeedbackBlock block;
- (instancetype)initWithBlock:(FeedbackBlock)block;
@end
</code></pre>

<p>TlView.m</p>

<pre><code>-(instancetype)initWithBlock:(FeedbackBlock)block{
    self=[super init];
    if(self){
        self.block=block;
        UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
        [button setTitle:@"反馈给controller" forState:UIControlStateNormal];
        button.frame = CGRectMake(50, 200, 200, 45);
        button.backgroundColor = [UIColor redColor];
        [button setTitleColor:[UIColor yellowColor] forState:UIControlStateNormal];
        [button addTarget:self action:@selector(feedback) forControlEvents:UIControlEventTouchUpInside];
        [self addSubview:button];
    }
    return self;
}


- (void)feedback {
    if (self.block) {
        // 传模型回去，这里没有数据，假设传nil
        self.block(nil);
    }
}

/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect {
    // Drawing code
}
*/

- (void)dealloc {
    NSLog(@"dealloc: %@", [[self class] description]);
}
</code></pre>

<p>接下来，在TlController中增加两个属性</p>

<pre><code>@property (nonatomic, strong) TLView *aView;
@property (nonatomic, strong) id currentModel;
</code></pre>

<p>  调用如下:</p>

<pre><code class="``">  -(void)testView{

   // __weak __typeof(self) weakSelf=self;

    self.aView = [[TLView alloc] initWithBlock:^(id model) {
        // 假设要更新model
        self.currentModel = model;
        //weakSelf.currentModel=model;
    }];
    // 假设占满全屏
    self.aView.frame = self.view.bounds;
    [self.view addSubview:self.aView];
    self.aView.backgroundColor = [UIColor whiteColor];
}
</code></pre>

<p>  在viewDidLoad方法中，调用<code>[self testView]</code></p>

<p>  这样Controller和view之间就形成了循环引用，如图:
  <img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-1.png" alt="logo" /></p>

<ol>
<li>TlViewController->强引用aView->block->tlViewcontroller属性的currentModel</li>
</ol>


<p>  解决的办法是:在创建aView的时候，block内对currentModel的引用改成弱引用</p>

<pre><code class="``">  __weak __typeof(self) weakSelf=self;

    self.aView = [[TLView alloc] initWithBlock:^(id model) {
        // 假设要更新model
        weakSelf.currentModel=model;
    }];
</code></pre>

<p>  很多程序员直接使用<em>currentModel,其实这样也会造成循环引用，因为</em>currentModel也是属于类的成员变量，也会被强引用的。要解决此问题，也要改成弱引用</p>

<pre><code class="``">  __block __weak __typeof(_currentModel) weakModel = _currentModel;
self.aView = [[TLView alloc] initWithBlock:^(id model) {
  // 假设要更新model
  weakModel = model;
}];
</code></pre>

<h2>模拟循环引用</h2>

<pre><code>@autoreleasepool {
  A *aVC = [[A alloc] init];
  B *bVC = [[B allcok] init];
  aVC.controller = bVC;
  bVC.controller = aVC;
}
</code></pre>

<p>aVC->强引用了bVC</p>

<p>bVC->强引用了aVC</p>

<p>如果是这样引用，就形成环了。aVC->bVC->aVC，这就形成了环。</p>

<h3>如果一个Controller中，存在一个局部变量，是否循环引用呢?</h3>

<p>在Viewcontroller中声明一个变量
<code>@property (nonatomic,strong)NSMutableArray *array;</code></p>

<pre><code>-(void)test1{
    self.array = [NSMutableArray arrayWithObjects:@"a",@"b",@"abc",nil];
    TLController *vc = [[TLController alloc] initWithCallback:^{
        [self.array removeObjectAtIndex:0];
    }];
    [self.navigationController pushViewController:vc animated:YES];
}
</code></pre>

<p>点击跳转按钮，控制台打印</p>

<pre><code>BlockDemo1[5511:1169090] 进入控制器：TLController
2016-03-04 14:08:45.612 
</code></pre>

<p>点击回退,控制台打印</p>

<pre><code>BlockDemo1[5511:1169090] 控制器被dealloc: TLController
</code></pre>

<p>  说明成员变量NSMutableArray不会形成循环引用。</p>
]]></content>
  </entry>
  
</feed>
