<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-12-24T21:40:23+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IP TCP 和HTTP]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http/"/>
    <updated>2016-11-22T10:04:46+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http</id>
    <content type="html"><![CDATA[<p>当app和服务器进行通信的额时候，大多数情况下，都是采用http协议。http最初是为web浏览器而定制的，如果在浏览器输入 <code>http://www.baidu.com</code>。浏览器就会通过http协议和baidu所对应的服务器进行通信。</p>

<!--more-->


<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<pre><code>Application Layer -- e.g. HTTP
----
Transport Layer -- e.g. TCP
----
Internet Layer -- e.g. IP
----
Link Layer -- e.g. IEEE 802.2
</code></pre>

<p>所谓的<a href="https://en.wikipedia.org/wiki/OSI_model">OSI(Open Systems Interconnnection),开放式系统互联</a>模型定义了七层结构。本文会关注应用层(application layer)传输层(transport layer)和网络层(internet layer),他们分别代表了典型的HTTP的应用的HTTP,TCP,以及IP.在ip之下的是数据连接和物理层级，比如像Ethernet的实现之类的东西</p>

<p>如上文所述，我们只关注应用层，传输层和网络层部分，更确切的说，着重探讨一种特殊的混合模式：基于IP的TCP,以及基于TCP实现的HTTP.这就是我们每天使用的app的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的HTTP问题产生的原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只是HTTP一种，HTTP之所以被广泛使用的原因是其非常稳定，易用，即便是防火墙一般也是允许HTTP协议穿透的。</p>

<p>接下来，我们从最低的一层谈起，说说IP网络协议。</p>

<h3>IP网络协议(IP_Internet Protocol)</h3>

<p>TCP/IP 中的Ip是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议(Internet Protocol)</a>的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP实现了分组交换网络，在协议下，机器被叫做主机(host)，IP协议明确了host之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制的数据，其中包含了发送源主机和目标主机的信息。IP网络负责源主机和目标主机之间的数据包传输。IP协议的特点是best effort(尽力服务，其目标是提供有效服务并尽力传输)。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包</p>

<p>IP网络中的主机都配有自己的地址，被称为IP地址。每个数据包中都包含了源主机和目标主机的IP地址，IP协议负责路径计算，即IP数据包在网络中的传输时，数据包所经过的灭一个主机几点都会读取数据包中的目标主机地址信息，以便选择朝着什么地方传输数据包</p>

<p>今天，绝大多数的数据包仍旧是IPv4的，每一个IPV4的地址的长度是32位的，常见采用dotted-decimal(点分十进制)表示法，具体形式如下：198.51.100.42</p>

<p>新的IPv6标准也正在逐渐推广中。它有更大的地址空间：长度为128位，这使得数据包在网络中传输中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，注入网络地址转换等问题也迎刃而解。IPv6的表示形式为:八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2>IP Header</h2>

<p>一个ip数据包通常包含header（报头信息）和payload（有效载荷）</p>

<p>payload中的内容即是要传输的真正信息，而header承载的是与传输数据有关的元数据(metadata)</p>

<h3>IPV4 Header</h3>

<p>ipv4的header信息内容如下：</p>

<pre><code>IPv4 Header Format
Offsets  Octet    0                       1                       2                       3
Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
 0         0     |Version    |IHL        |DSCP            |ECN  |Total Length                                   |
 4        32     |Identification                                |Flags   |Fragment Offset                       |
 8        64     |Time To Live           |Protocol              |Header Checksum                                |
12        96     |Source IP Address                                                                             |
16       128     |Destination IP Address                                                                        |
20       160     |Options (if IHL &gt; 5)                                                                          |
</code></pre>

<p>header长度为20字节（不包含极少用到的可选信息）</p>

<p>header信息中最关键的是源和目标IP地址，除此之外，版本信息是4，代表ipv4.protocol(协议区)代表payload采用的传输协议。TCP的协议号是6.Total Length(总长度区)表明了header加payload整个数据包的大小</p>

<h3>Ipv6 Header</h3>

<p>ipv6的地址长度为128位，IPv6的header信息内容如下：</p>

<pre><code>Offsets  Octet    0                       1                       2                       3
Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
 0         0     |Version    |Traffic Class         |Flow Label                                                 |
 4        32     |Payload Length                                |Next Header            |Hop Limit              |
 8        64     |Source Address                                                                                |
12        96     |                                                                                              |
16       128     |                                                                                              |
20       160     |                                                                                              |
24       192     |Destination Address                                                                           |
28       224     |                                                                                              |
32       256     |                                                                                              |
36       288     |                                                                                              |
</code></pre>

<p>Ipv6 header采用固定长度40字节。经过多年来对Ipv4使用的总结，如今Ipv6的header信息简化了很多。</p>

<p>除了源和目标地址这种必备信息外，IPv6提供专门的next header区域来指明紧跟header的数据是什么。也就是说，Ipv6允许在数据包中将header链接起来，每一个被链接的Ipv6 header 都会有一个next header 字段，直到到达实际的payload数据，比如说，当next header的值为6(TCP的协议号)时，数据包的其它信息就是tcp协议要传输的数据</p>

<h2>Fragmentation(数据分片)</h2>

<p>由于底部链路层对所传输的数据帧有最大长度限制，所以有时候IPV4需要对所传数据包进行分片。具体表现为，如果数据包尺寸超过了索要经过的数据链路层的最大传输限制，路由就会对数据包进行分片，当分片数据到达目标主机后，可以根据分片信息进行数据重组。当然，数据发送源有权决定路由是否启用对传输数据包进行分片，加入所传输的数据超过了输送限制，又禁止了路由分片，发送源会收到<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>的数据帧超长报告信息</p>

<p>在Ipv6中，如果数据包超限制，路由会直接丢弃数据包并且向发送源回传ICMP6的数据帧超长报告信息。源和目标两端会基于这个特性进行<a href="https://en.wikipedia.org/wiki/Path_MTU">路径MTU发现</a>，以此寻找两端之间最大传输单元所在的路由，找到MTU路由后，仅当上层数据包的最小payload确实超过了MTU,IPV6才会进行分片传输，对于IPV6下的tCp来说，这不会造成什么问题。</p>

<h2>TCP-传输控制协议(Transmission Control Protocol)</h2>

<p>TCP层位于IP层之上，是最受欢迎的因特网通讯协议之一，人们通常用TCP/IP来泛指整个因特网协议族。</p>

<p>刚刚提到，IP协议允许两个主机之间传送单一的数据包，为了保证对所传送数据包达到尽力服务的目的，最终的传输结果可能是数据包乱序，重复甚至丢包。</p>

<p>TCP是基于IP 层的协议。但是TCP是可靠地，有序的，有错误检查机制的基于字节流传输的协议。这样当两个设备上的应用通过TCP来传递数据的时候，总能够保证目标接收方收到的数据的顺序和内容与发送方所发出的是一致的。TCP做的这些事看起来很平常，但是比起IP层的粗犷处理方式已经是显著的进步了。</p>

<p>应用程序之间可以通过TCP建立链接，TCP建立的是双向连接，通信双方可以同时进行数据的传输。连接的双方都不需要操心数据是否分块，或者是否采用了尽力服务等。TCP会确保所传输的数据的正确性，即接受方收到的数据与发出方的数据一致。</p>

<p>HTTP是典型的TCP应用，用户浏览器(应用1)与web服务器(应用2)建立连接后，浏览器可以通过连接发送服务请求，web服务器可以通过同样的连接请求作出响应。</p>

<p>同一个host主机上可以有多个应用同时使用TCP协议。TCP用不同的端口来区分应用，作为连接的两端，发送源和接收目标分别拥有自己的IP地址和端口号，凭借这样一对IP地址和端口号，就可以唯一标识一个连接。</p>

<p>使用HTTPS的web服务器会监听443端口，浏览器作为发送源会启用一个临时端口结合自己的IP地址与目标服务器对应的端口和IP地址建立TCP连接。</p>

<p>TCP在IPv4和Ipv6上是无差别运行的。所以如果ipv4和protocol活IPv6的Next Header的协议号被设置为6，表示执行TCP协议。</p>

<h2>TCP Segments (TCP 报文段)</h2>

<p>主机之间传输的数据流一般会先被分块，再转为为TCP报文段，最终会生成IP数据包中的payload的载荷数据</p>

<p>每个TCP报文段都有header信息和对应的载荷payload.payload信息就是待传输的数据块。TCP报文段的header信息中主要包含的是源和目标端口号，至于说源和目标的IP地址信息则已经包含在IP header信息中了。</p>

<p>TCP的报文段header信息中还有报文序列号，确认号等其他一些用于管理连接的信息。</p>

<p>所谓序列号信息，其实就是为每个报文段分配的唯一编号，第一个报文段的序列号是随机的，比如1721092979，其后的每一个报文段的序列号都以此号为基础以此加1，1721092980，1721092981 等等。至于确认号，是目标端反馈给源的确认信息，通知源目前已经接到那些报文段了。由于TCP是双向的，所以数据和确认信息发送也都是双向的。</p>

<h2>TCP连接</h2>

<p>连接管理是TCP的核心功能之一，而且协议需要解决由于IP层采用不可靠传输引发的一系列复杂问题。下面会分别介绍TCP的连接简历，数据传输以及连接终止的详细过程。</p>

<p>TCP连接全过程的状态变化是复杂的，但是大多数情况下还是比较简单的。</p>

<h3>连接建立</h3>

<p>TCP连接都是简历在两个主机之间的。所以，每个连接建立过程中都存在两个角色：一端（例如web服务器）监听连接，另一端(例如应用)主动连接正在监听的一端(web服务器).服务器端的这种监听行为被称为passive open(被动打开)。客户端主动连接服务器的行为称为active open(主动打开)</p>

<p>TCP会通过三次握手来完成连接建立，具体过程是这样的：</p>

<ol>
<li>客户端首先向服务器端发送一个SYn包和一个随机序列号A</li>
<li>服务器端收到回回复客户端一个SYn_ACK包以及各一个确认号（用于确认收到SYN）A+1,同时再发送一个随机序列号B</li>
<li>客户端收到后会发送一个ACK包以及确认号（用于确认收到SYN-ACK）B+1和序列号A+1给服务端</li>
</ol>


<p>SYN是Synchronize sequence numbers（同步序列号）的缩写。两端在传递数据时，所传递的每个TCP报文段都有一个序列号。就是利用这种机制，TCP可以确保分块传输的数据包最终都已正确的个数和顺序抵达目标端。在正式传输开始之前，源和目标端需要同步确认第一个报文的序列号。</p>

<p>ACK 是acknowledgment(确认)的缩写。当某一端接到了报文包后，通过回传已报文序列号来确认接收到报文这件事。</p>

<p>运行如下语句：</p>

<pre><code>curl -4 http://www.apple.com/contact/
</code></pre>

<p>这是通过<code>curl</code>命令与www.apple.com 的 80端口创建一个TCPl连接</p>

<p>www.apple.com所在服务器23.63.125.15（注意，整个 IP 不是固定的）会监听80端口。我们自己的IP地址是<code>10.0.1.6</code>，启用的临时端口52181(这个端口是从可用端口中随机选择的)。利用tcpdump(1)输出的三次握手过程是这样的、</p>

<pre><code>% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15
18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0
18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0
18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0
</code></pre>

<p>这里的信息量很大，下面要逐个分析一下：</p>

<p>最左边的是系统时间。当执行命令的时间是晚上18:31。后面的IP代表的是这些都是IP协议数据包。</p>

<p>接下来看这段10.0.1.6.52181 > 23.63.125.15.80，这一对是源和目标端的IP地址+端口。第一行和第三行是客户端发向服务端的信息，第二行是服务端发向客户端的。tcpdump会自动把端口号加到IP地址后头，比如 10.0.1.6.52181 表示 IP 地址为 10.0.1.6，端口号为 52181。</p>

<p><code>Flags</code>表示TCP报文段header信息中的一些缩写标识：<code>S</code>代表SYN,<code>.</code>代表ACK,<code>P</code>代表PUSH,F是FIN.还有一些其他的标识，这边就不罗列了。注意上面三行Flags中先是携带SYN,接着是SYN-ACK,最后是ACK,这就是三次握手确认的全过程。</p>

<p>另外，第一行中客户端发送了一个随机序列号1721092979（就是上文中所说的A）给服务器，第二行展示的是服务器回传给客户端的确认号<code>1721092980 (A+1)</code>和一个随机序列号 673593777 (B).最后在第三行，客户端将自己的确认号 673593778 (B+1) 发送给服务端.</p>

<h2>其他选项</h2>

<p>当然，在连接建立过程中还会配置一些其他信息。比如第一行中客户端发送的内容:</p>

<pre><code>[mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol]
</code></pre>

<p>还有第二行服务端发送的：</p>

<pre><code>[mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1]
</code></pre>

<p>其中<code>TS val / ecr</code>是TCP用来创建RTT 往返时间(round-trip time)的。TS val 是发送方的时间戳，ECR 是相应应答时间戳，通常情况下就是发送方收到的最后时间戳。TCP以RTT作为其拥塞控制算法 (congestion-control algorithms) 的依据</p>

<p>连接的两端都发送 sackOK.这样会启用选择性确认(Selective Acknowledagement)机制，使连接双方能够确认收到的字节返回。一般情况下，确认机制只是确认接受方已收到的数据的字节总数。</p>

<p><code>mss</code>选项声明了最大报文长度，表示接收端希望接收的单个报文的最大长度。wscale是窗口放大因子。</p>

<h2>数据传输</h2>

<p>一旦建立了连接，双方就可以互发数据了。发送端所发出的每个报文段都有一个序列号，这个序列号与当下已传送的字节总数有关。接收端会针对已接收的数据包向源端发送确认报文，确认信息同样是由报文header所携带的ACK</p>

<p>假设现在传送的信息是除最后一个报文5字节外，其它都是10字节。具体是这样的：</p>

<pre><code>host A sends segment with seq 10
host A sends segment with seq 20
host A sends segment with seq 30    host B sends segment with ack 10
host A sends segment with seq 35    host B sends segment with ack 20
                                    host B sends segment with ack 30
                                    host B sends segment with ack 35
</code></pre>

<p>整个机制是双向运转的，A主机会持续的发送数据包。B收到数据包后会向A发送确认信息。A发送数据包的过程不需要等待B的确认。</p>

<p>TCP将流量控制和其它一系列复杂机制结合起来进行拥塞控制。需要处理以下问题：针对丢失的报文采用重发机制，同时还需要动态的调整发送报文的频率。</p>

<p>流量控制的原则是发送方发送数据的速度不能比接收方处理数据的速度快。接收方，也就是所谓的接收窗口会告知发送方自身接收窗口数据缓冲区的大小。从上面tcpdump的输出看，窗口大小是 <code>win 65535</code>,<code>wscale</code>（窗口放大因子）是4.这些数字的意思是说：<code>10.0.1.6</code>主机的接收窗口大小是4＊64 kB = 256 kB,<code>23.63.125.15</code>主机的<code>win</code>是<code>14480</code>,<code>wscale</code>是1，接收窗口约为14kb.总之，不管哪一方作为数据接收方，都会向对方通报自己的接收窗口的大小。</p>

<p>拥塞控制要更负责一些，所有拥塞控制的目标都是要计算出当前网络中数据传输的最佳速率。所谓最佳速率就是要达到一种微妙的平衡。一方面，是希望速度越快越好，另一方面，速度快意味着数据传输多，这样处理性能会打打打折甚至崩溃。而这种超负荷崩溃是分组交换网络的固有特点。当负载过大，数据包之间会产生拥塞，直接导致丢包率急速上升。</p>

<p>拥塞控制还需要充分考虑对流量的影响。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部IP协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估RTT往返时间，然后基于RTT去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致TCP需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP连接往往会是短暂而低效的。在简历连接的初期，TCP协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况作出实时的合理的评估。</p>

<p>之前展示了客户单和服务端之间交换的三段报文，再看看关于连接的其它信息：</p>

<pre><code>18:31:29.150955 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [P.], seq 1721092980:1721093065, ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 85
18:31:29.161213 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], ack 1721093065, win 7240, options [nop,nop,TS val 1433256633 ecr 743929773], length 0
</code></pre>

<p>客户端<code>10.0.1.6</code>发送的第一段报文长度是85 bytes(http请求)。由于在上一个报文发送后没有收到来自服务端的信息，所以ACK确认号值不变。</p>

<p>服务端 <code>23.63.125.15</code>只是对接收客户端的数据进行确认回复，没有向客户端发送数据，所以length为0，由于当前连接是采用选择性确认，所以序列号和确认好之间的字节长度从1721092980到1721093065，也就是85 bytes.接收方发送的ACK确认号是1721093065,这代表目前已接收的数据确认累计到1721093065字节了。至于说为什么数字会如此之大，这要说道初次握手时发出的随机数，数字的范围和那个初始数字是相关的。</p>

<p>这种模式会一直持续到全部数据传送完成：</p>

<pre><code>18:31:29.189335 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673593778:673595226, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190280 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673595226:673596674, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190350 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673596674, win 8101, options [nop,nop,TS val 743929811 ecr 1433256660], length 0
18:31:29.190597 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673596674:673598122, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190601 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673598122:673599570, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190614 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673599570:673601018, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190616 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673601018:673602466, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190617 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673602466:673603914, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190619 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673603914:673605362, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190621 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673605362:673606810, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.190679 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673599570, win 8011, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190683 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673602466, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190688 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190703 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190743 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673606810, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
18:31:29.190870 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673606810:673608258, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
18:31:29.198582 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [P.], seq 673608258:673608401, ack 1721093065, win 7240, options [nop,nop,TS val 1433256670 ecr 743929811], length 143
18:31:29.198672 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608401, win 8183, options [nop,nop,TS val 743929819 ecr 1433256660], length 
</code></pre>

<h2>终止连接</h2>

<p>最终连接会终止(或结束)，连接的每一端都会发送FIN标识给另一端来声明结束传输，接着另一端会对收到的FIN进行通知，当连接两端均发送完各自FIN和做出相应的确认后，连接将会彻底关闭：</p>

<pre><code>18:31:29.199029 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [F.], seq 1721093065, ack 673608401, win 8192, options [nop,nop,TS val 743929819 ecr 1433256660], length 0
18:31:29.208416 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [F.], seq 673608401, ack 1721093066, win 7240, options [nop,nop,TS val 1433256680 ecr 743929819], length 0
18:31:29.208493 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608402, win 8192, options [nop,nop,TS val 743929828 ecr 1433256680], length 0
</code></pre>

<p>这里值得注意的是第二行，<code>23.63.125.15</code>发送了FIN，同时在这个报文信息中还对第一行中的另一端发送的FIN予以ACK(以.代表)确认。</p>

<h2>HTTP-超文本传输协议（Hypertext Transfer Protocol）</h2>

<p>1989年，Tim Berners lee 在<a href="https://en.wikipedia.org/wiki/CERN">CERN</a>担任软件咨询师的时候，开发了一套程序，奠定了万维网的基础。HyperText Transform Protocol（超文本转移协议，即HTTP）,是用于从WWW服务器传输超文件到本地浏览器的传送协议。<a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 定义了今天普通使用的一个版本:HTTP 1.1</p>

<h3>请求与响应</h3>

<p>HTTP采用简单的请求和响应机制，在safari输入<code>http://www.apple.com</code>时，会向www.apple.com所在的服务器发送一个http请求。服务器会在对请求作出一个响应，将请求结果信息返回给Safari.</p>

<p>每一个请求都有一个对应的响应信息。请求和响应遵从同样的格式，第一行是请求行或者响应状态行，接下来是header信息，header信息之后会有一个空行。空行之后是body请求信息体</p>

<h3>一个简答请求</h3>

<p>当safari加载html页面<a href="http://www.objc.io/about.html">http://www.objc.io/about.html</a>的时候，先是发送HTTP请求到<code>www.objc.io</code>,请求的内容是:</p>

<pre><code>GET /about.html HTTP/1.1
Host: www.objc.io
Accept-Encoding: gzip, deflate
Connection: keep-alive
If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.74.9 (KHTML, like Gecko) Version/7.0.2 Safari/537.74.9
Referer: http://www.objc.io/
DNT: 1
Accept-Language: en-us
</code></pre>

<p>第一样是请求行，它包含三部分信息：动作，资源信息，还有HTTP的版本</p>

<p>本例中，动作是GET,所谓动作也就是常说的HTTP请求方法， 资源信息表明所请求的资源。例子中的资源信息是 /about.html,这表示我们想get服务器的在/about.html位置中的文档。当前HTTP版本是HTTP/1.1</p>

<p>接下来10行是HTTP header信息。跟着是一行空行。例子中请求没有body信息。</p>

<p>header的作用是向服务器传递一些额外的辅助信息，它的内容比较宽泛，维基百科中又<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">常用HTTP header关键字</a>信息的清单。例子中的header信息:<code>Host: www.objc.io</code>表示告诉服务器，本次请求的服务器名称是什么。这样可以让同一个服务器处理针对多个域名的请求。</p>

<p>下面是一些常见的header信息：</p>

<pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us
</code></pre>

<p>服务器可能具备返回多种媒体类型的能力，Accept表示safari希望接收的媒体格式类型，text/html是胡亮媒体，也被称为MIME类型或者是内容类型(Content-TYpes).<code>q=0.9</code>表示Safari对给定媒体类型的优先级要求。Accept_Lanaguage 代表Safari希望接收的自然语言清单。这回要求服务器尽可能的根据清单要求去匹配相应的语言。</p>

<pre><code>Accept-Encoding: gzip, deflate
</code></pre>

<p>通过这个header,Safari告诉服务器可以对响应boday做压缩处理，如果header信息中没有设置压缩标识，那么服务器就必须返回没有压缩过的信息。压缩可以大大减少数据的传输量，在文本信息(比如HTML)中尤为明显。</p>

<pre><code>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</code></pre>

<p>这两行信息表明Safari已经对请求结果做过缓存，如果服务器上的请求内容在2月10号以后发生过变化或者是etag与<code>a54907f38b306fe3ae4f32c003ddd507</code>不匹配，这就表示请求结果与当前缓存信息不一致，需要服务器返回最新的请求结果。</p>

<p>user-agent 是告知服务器当前发送请求的客户端类型。</p>

<h3>一个简单响应</h3>

<p>作为上面的请求的响应，服务器的返回是：</p>

<pre><code>HTTP/1.1 304 Not Modified
Connection: keep-alive
Date: Mon, 03 Mar 2014 21:09:45 GMT
Cache-Control: max-age=3600
ETag: "a54907f38b306fe3ae4f32c003ddd507"
Last-Modified: Mon, 10 Feb 2014 18:08:48 GMT
Age: 6
X-Cache: Hit from cloudfront
Via: 1.1 eb67cb25620df959ba21a943fbc49ef6.cloudfront.net (CloudFront)
X-Amz-Cf-Id: dDSBgR86EKBemW6el-pBI9kAnuYJEaPQYEqGmBnilD12CbixCuZYVQ==
</code></pre>

<p>第一行是状态航，它包括HTTP版本，状态码(204)和状态信息</p>

<p>HTTP定义了一系列状态码，他们各有用途，本利中的304表示所请求的信息自上次访问以来没有变化</p>

<p>响应中没有包含body信息。也就说服务器通知客户端：你的版本已经是最新的了，可以直接使用当前缓存信息</p>

<h3>关闭缓存</h3>

<p>用curl 发送一个请求:</p>

<pre><code>% curl http://www.apple.com/hotnews/ &gt; /dev/null
</code></pre>

<p><code>curl</code>没有使用本地缓存，整个请求会是这样:</p>

<pre><code>GET /hotnews/ HTTP/1.1
User-Agent: curl/7.30.0
Host: www.apple.com
Accept: */*
</code></pre>

<p>这个请求与之前Safari发的请求很类似，但是curl请求的header信息中没有<code>If-None-Match</code>,所以服务器必须将请求结果返回。</p>

<p>此处<code>curl</code>头信息中声明的<code>Accept: */*</code>表示可以接收任何媒体类型。</p>

<p>来自www.apple.com的响应：</p>

<pre><code>HTTP/1.1 200 OK
Server: Apache
Content-Type: text/html; charset=UTF-8
Cache-Control: max-age=424
Expires: Mon, 03 Mar 2014 21:57:55 GMT
Date: Mon, 03 Mar 2014 21:50:51 GMT
Content-Length: 12342
Connection: keep-alive

&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
</code></pre>

<p>后面还会有一些，现在收到的响应里body中包含了HTML文档信息</p>

<p>Apple服务器响应的状态码是200,这是标准的表示HTTP请求成功的状态码。</p>

<p>服务器同时还告知响应媒体类型是 <code>text/html</code>;字符集<code>charset=utf-t</code>；内容长度：<code>Content-length:12342</code>,还代表了body信息的大小</p>

<h2>HTTPS-安全的HTTP</h2>

<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>(安全传输层协议，TLS)是一种基于TCP的加密协议，它支持两件事情：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于TLS的HTTP请求就是HTTPS</p>

<p>用https去替代http,在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。</p>

<h3>TLS 1.2</h3>

<p>如果服务器支持的话，你应该讲<code>TLSMinmumSupportedProtocol</code>设置为<code>kTLSProtocol12</code>,以要求使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2"><code>TLS1.2</code></a>版本，这能有效的防御<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a></p>

<h2>证书锁定(Certificate Pinning)</h2>

<p>如果不确定数据接收方的身份，那么即便对所传输数据进行加密也没什么意义。服务器的证书可以表明服务器的身份，只允许好持有某个特定证书的一方建立连接，就是<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">证书锁定</a></p>

<p>如果一个客户端通过TLS和服务器建立连接，操作系统会验证服务器证书的有效性。当然，有很多手段可以绕开这个校验，最直接的是在iOS设备上安装证书并且将其设置为可信的，这种情况下，实施<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">中间人攻击</a>也不是什么难事。</p>

<p>可以使用证书锁定来规避这种风险。当监理TLS连接后，应立即检查服务器的证书，不仅要验证证书的有效性，还需要确定证书和其持有者是否匹配。考到应用和服务器需要同时升级证书的要求，这种方式比较适合应用在访问自家服务器的情况下。</p>

<p>为了实现证书锁定，在建立连接的过程中需要对服务器进行信任检查，每当通过NSURLSession创建了连接，<code>NSUrlSession</code>的代理就会收到一个
<code>-URLSession:didReceiveChallenge:completionHandler:</code>的调用。传递的参数<code>NSURLAuthenticationChallenge</code>有一个属性<code>protectionSpace</code>，它是<code>NSURLProtectionSpace</code>的实例，它有一个<code>serverTrust</code>属性。</p>

<p><code>serverTrust</code>是一个<code>SecTrustRef</code>对象，<code>Security</code>框架提供了很多方法用于验证<code>SecTrustRef</code>。<code>AFNetworking</code>项目中的<code>AFSecurityPolicy</code>就是一个不错的使用。一如既往的提醒大家，如果要自己构建全验证相关的代码，请一定要认真做好代码审查，千万不要再出现诸如<code>goto fail</code>这类bug</p>

<h2>综合讨论</h2>

<p>现在大家多IP，TCP，和http的工作原理有了一定的了解了。下面说说还可以做些什么</p>

<h3>有效地使用连接</h3>

<p>TCP连接容易在两个时点出现问题：初始设置，以及通过连接传输的最后一部分报文</p>

<h3>建立连接</h3>

<p>连接设置可能会非常耗时，正如前文所说，TCPj建立连接的过程中需要进行三次握手，这个过程中本身没有太多的数据需要传递，但是，对于移动网络来说，从手机端向服务器端发送一个数据包普遍需要250ms,也就是四分之一秒。推及到三次握手，也就是说在还没有传送任何数据之前，光建立连接就花费了750ms</p>

<p>https的情况更夸张，由于Https是基于TLS的http,而http又基于TCP,TCP连接就要执行三次握手，然后到了TLS层还会再握手三次，估算一下，建立一个HTTPS连接的耗时只要是创建一个https连接的两倍。如果RTT时间是500ms(假设单程250ms)，HTTPS建立连接累计总耗时1.5秒</p>

<p>不管建立连接后传递多少数据，建立连接本身都太过耗时了。</p>

<p>另一个影响TCP连接的因素是传送大规模的数据。如果要在网络情况未知的条件下传送报文，TCP需要侦测当前网络的能力。换句话说，TCP得花费一定的事件去计算此网络最佳传输速率。上文提到过，TCP需要逐步调整以便找到最佳速度。这种算法成为<a href="https://en.wikipedia.org/wiki/Slow-start">慢启动</a>。还有一点值得注意，慢启动策略在那些数据链路层传输质量较差的网络环境中的表现更差，无线网络就是典型的例子</p>

<h3>结束连接</h3>

<p>另一个问题主要存在于数据传输的最后阶段。每当客户端发起HTTP请求某些资源的时候，服务器会持续的向客户端发送TCP报文数据，客户端收到数据后会给服务器反馈ACK报文数据，客户端收到数据后会给服务器反馈ACK确认信息。假如某个报文在传输过程中发生丢包，那么服务器也就不会收到该包的确认ACK.一旦服务器发现现有数据包没有ACK反馈，就会触发快速重传。</p>

<p>每当某个数据包丢失，数据接收方在收到下个数据包后发出的确认ACK与所接收的前一个数据包的确认ACK相同。那么数据发送方自然就会收到重复的ACK.除了报文丢失，还有很多网络状况会导致重复ACK的问题。一般情况下，如果数据发送方连续收到3个重复的ACK就会立即进行快速重发</p>

<p>这所导致的问题将发生在数据传输的收尾阶段。如果发送方完成数据发送，接受方自然会停止发送ACK确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包丢失问题的（以为不会收到三个相同的确认ACK,所以不能界定传输丢包），在常规的网络环境下，四个数据包相当于5.7kb的数据规模。总之，在这最后的5.7kb的传输过程中，快速重发机制是无效的。针对这种情况，TCP会启用其它机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>

<h3>长连接和管线化</h3>

<p>HTTP有两种策略来解决这些问题，最简单的是<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP持久连接(persistent connection)</a>，也被称为长连接。具体就是,每当HTTP完成一组请求-响应后，还会继续复用相同的TCP连接。而HTTPS会复用同样的TLS连接：</p>

<pre><code>open connection
client sends HTTP request 1 -&gt;
                            &lt;- server sends HTTP response 1
client sends HTTP request 2 -&gt;
                            &lt;- server sends HTTP response 2
client sends HTTP request 3 -&gt;
                            &lt;- server sends HTTP response 3
close connection
</code></pre>

<p>第二部就是利用了<a href="https://en.wikipedia.org/wiki/Http_pipelining">HTTP管线</a>处理，即允许客户端利用同样的连接并行发送多个请求，也就是说无需等待上一个请求的响应完成可以发下一个请求。这表示能同时处理请求和响应，请求处理的顺序采用先进先出的原则，响应结果会按照请求发出的顺序依次返回给客户端</p>

<p>稍微简化一下，看起来会是这样：</p>

<pre><code>open connection
client sends HTTP request 1 -&gt;
client sends HTTP request 2 -&gt;
client sends HTTP request 3 -&gt;
client sends HTTP request 4 -&gt;
                            &lt;- server sends HTTP response 1
                            &lt;- server sends HTTP response 2
                            &lt;- server sends HTTP response 3
                            &lt;- server sends HTTP response 4
close connection
</code></pre>

<p>注意，服务器发出的响应是实时的，不会等到接收完全请求才处理。</p>

<p>可以利用这个特点来提升TCP的效率，只需要在简建立连接初始阶段执行握手，而后一直复用同样的连接。这样TCP就可以最大限度的利用带宽，此种情况下，拥塞控制也会随之提升。因为快速重复机制无法处理的最末四个报文丢失情况只会发生在使用本地连接的最后一个请求-响应中，而不是像之前那样每一个请求-响应都需要建立自己的连接，每个连接中都可能出现最后四个报文丢失的问题。</p>

<p>HTTP管线化对高网络延迟连接的通讯性能提升尤为显著，在你的iPhone没有通过wifi访问网络的时候，此类网络连接就属于高延迟范畴。实际上，有调差显示，在移动网络环境下，<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>的通讯性能并不优于HTTP管线。</p>

<p><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>指明，在与同一个服务器通讯的时候，如果启用了http管线，建议启用两个连接。按照说明所述，这样能获得最优的响应效率，能最大限度避免拥塞，增加更多的连接也不会再对性能有什么明显改善。</p>

<p>遗憾的是，还有相当多的服务器不支持管线话，由于这个原因，HTTP管线在<code>NSURlSession</code>中默认是关闭的，如果想要开启HTTP管线，需要将<code>NSURLSessionConfiguration</code>中的<code>HTTPShouldUsePipelining</code>设置为YES.另外，建议服务器最好还是支持管线化</p>

<h3>超时处理</h3>

<p>我们都有在网络不太好的情况下使用app的经历，很多app大概15s左右就会结束请求并且反馈一个超时信息，这种设计其实是很不好有的。应该给用户一个他们理解的友好提示，比如：“你好，现在网络状态不太好，你需要多等一会”。但是即便网络状况良好，只要连接还在，TCP都会保证将请求发出去并且会一直等待响应的返回，只是时间长短问题。</p>

<p>从另一个角度来说，在较慢的网络中，请求-响应的RTT时间可能会有17秒。如果15秒就决定终止请求，就算用户有足够的耐心，他们也没积水等到想要的操作结果，反过来，如果我们给出用户响应的提示信息，而他们又刚好愿意多等一会，用户可能会更喜欢使用这样的应用。</p>

<p>一直以来都有一种误解，用重发请求来解决上面的问题，注意，这不是问题的关键，因为TCP有自己的重复机制。</p>

<p>正确的处理方式应该是：没放发起一个请求的时候，同时启动一个10秒计时器，如果请求在10秒之内返回，就把计时器关掉。如果超过10秒，可以给用户一个提示：“网络不好请稍后”。我建议再给用户一个取消按钮，让他们可以自行选择等待还是取消请求，当然提示信息的具体内容和是否配备取消按钮，这个可以视各app的情况去决定。总而言之，开发者最好不要直接替用户做决定，比如直接终止他们的请求。</p>

<p>只要连接双方的IP地址是不变的，可用的，连接就一定是活跃的。如果把iPhone从wifi连接切换到3G网络，这样连接就会变得不可用，因为的IP地址发生了变化，基于原IP地址创建的路由自然是失效的。</p>

<h2>缓存</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的热修复]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong/"/>
    <updated>2016-11-07T16:46:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong</id>
    <content type="html"><![CDATA[<h2>背景需求</h2>

<h3>为什么我们需要热修复</h3>

<ul>
<li>工作中容易犯错，bug难以避免</li>
<li>开发和测试人力有限</li>
<li>苹果AppStore审核周期太长，一旦出现严重bug难以快速上线新版本</li>
</ul>


<h2>JSPatch简介</h2>

<p>JSPatch诞生于2015年5月，最初是腾讯广研高级ios开发@bang的人格项目。它能够使用JavaScripit调用Objective-C的原声接口，从而动态植入代码来替换旧代码，以实现修复线上bug.</p>

<h2>JSPatch与wax对比</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3d1af75ebfe7de01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最关键的是JSpath可实现方法粒度的线上代码替换，能修复一切代码引起的bug.而Wax无法实现。</p>

<h2>JSPatch实现原理</h2>

<h3>基础原理</h3>

<p>Objective-C是动态语言，具有运行时特性，该特性可通过类名称和方法名的字符换获取该类和该方法，并实例化调用</p>

<pre><code>Class class = NSClassFromString(“UIViewController");
id viewController = [[class alloc] init];  
SEL selector = NSSelectorFromString(“viewDidLoad");
[viewController performSelector:selector];
</code></pre>

<p>也可以替换某个类的方法为新的实现：</p>

<pre><code>static void newViewDidLoad(id slf, SEL sel) {}
class_replaceMethod(class, selector, newViewDidLoad, @"");
</code></pre>

<p>还可以注册一个类，为类添加方法：</p>

<pre><code>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
objc_registerClassPair(cls);
class_addMethod(cls, selector, implement, typedesc);
</code></pre>

<h3>JavaScript调用</h3>

<p>我们可以用JavaScript对象定义一个Objective-C类：</p>

<pre><code>{
  __isCls: 1,
  __clsName: "UIView"
}
</code></pre>

<p>在OC执行JS脚本前，通过正则把所有方法调用都改成__c()函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>

<pre><code>UIView.alloc().init()
-&gt;
UIView.__c('alloc')().__c('init')()
</code></pre>

<p>给JS对象基类Object的prototype加上c成员，这样所有对象都可以调用到c,根据当前对象类型判断进行不同操作：</p>

<pre><code>Object.prototype.__c = function(methodName) {
  if (!this.__obj &amp;&amp; !this.__clsName) return this[methodName].bind(this);
  var self = this
  return function(){
    var args = Array.prototype.slice.call(arguments)
    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
  }
}
</code></pre>

<h2>互传消息</h2>

<p>JS和OC是通过JavaScriptCore互传消息的。OC端在启动JSPatch引擎会创建一个JSContext实例，JSContext是js代码的执行环境，可以给JSContext添加方法。JS通过调用JSContext定义的方法把数据传给OC,OC通过返回值传回给JS.调用这种方法，它的参数/返回值 javaScripotCore都会自动转换，OC里的NSArray,NSdictionary
,NSString,NSNumber,NSBlock会分别转为JS端的数组/对象/字符串/数字/函数类型  对于一个自定义ID对象，JavaScriptCore会把这个自定义对象的指针传给JS,这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象声明周期的管理，如果JS有变量引用时，这个OC对象引用计数就加1，JS变量的引用释放了就减一，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>

<h2>方法替换</h2>

<ol>
<li>把UIViewContrller的 <code>-viewWillAppear:</code>方法通过<code>class_replaceMethod()</code>接口指向<code>_objc_msgForward</code>,这是一个全局IMP,OC调用方法不存在时都会转发到这个IMP上，这里直接把方法替换成这个IMP,这样调用这个方法时就会走到<code>-forwardInvocation:</code></li>
<li>为UIViewController添加<code>-ORIGviewWillAppear:</code>和<code>-_JPviewWillAppear:</code>两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数</li>
<li>改写UIViewController的<code>-forwardInvocation:</code>方法为自定义实现。一旦OC里调用UIViewController的<code>-viewWillAppear:</code>方法，经过上面的处理会把这个调用转发到<code>forwardInvocation:</code>，这时已经组装好了一个NSInvocation,包含了这个调用的参数。在这里把参数从NSInvocation反解出来，待着参数调用删除新增加的方法<code>-JPviewWillAppear:</code>,在这个新方法里获取到参数传给JS,调用JS的实现函数，整个调用过程就结束了，整个过程图示如下：</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-d079409a185f394c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最后一个问题，我们把UIViewController的<code>-forwardInvocation:</code>方法的实现给替换掉了，如果程序里挣得有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现了做个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程</p>

<h2>JSPatch代码示例</h2>

<p>jspatch在oc上的调用十分简单</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
[JPEngine startEngine]; 
NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; 
NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; 
[JPEngine evaluateScript:script];
}
</code></pre>

<p>一个JavaScript修复Objective-C的bug的示例:</p>

<pre><code>@implementation JPTableViewController

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
  [self.navigationController pushViewController:ctrl];
}

@end
</code></pre>

<p>上述代码中取数组元素出可能会超出数组范围导致crash.如果在项目里引用了JSPatch,就可以发JS脚本修复这个bug:</p>

<pre><code>defineClass("JPTableViewController", {
  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
    var row = indexPath.row()
    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
      var content = self.dataArr()[row];
      var ctrl = JPViewController.alloc().initWithContent(content);
      self.navigationController().pushViewController(ctrl);
    }
  }
}, {})
</code></pre>

<h2>热修复的解决方案</h2>

<ol>
<li><p>版本更新策略</p></li>
<li><p>考虑到下一个提交的App版本已经修复了上一个版本的bug,所以不同的App版本对应的补丁肯定也不同，同一个App版本下，可以出现递增的补丁版本</p></li>
<li>补丁为全量更新，即最新的版本补丁包括旧版的补丁的内容，更新后新版补丁覆盖旧版补丁</li>
<li>补丁分为可选补丁和必选补丁，必选补丁用于重大bug的修复，如果不更新必须补丁则App无法继续使用。如下图2中，补丁版本v1234对应各自版本的用户，补丁v3为必须更新，补丁v1,v2,v4为可选补丁，则v1,v2必须更新到v4才可使用；而v3的哟过户可先使用，同事后台静默更新到v4</li>
</ol>


<h2>安全策略</h2>

<p>安全问题在于JS脚本可能被中间人攻击替换代码。可采取一下三种方法</p>

<ol>
<li>对称加密： 如zip的加密压缩，Aes等加密算法。优点是简单，缺点是安全性低，易被破解。若客户端被反编译，密码字段泄露，则完全破解。</li>
<li><a href="HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82">HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82</a></li>
<li>RSA校验：安全性高，部署简单</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-14723080a9823ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>详细校验步骤如下：</p>

<ol>
<li>服务器计算出脚本文件的MD5值，作为这个文件的数字签名</li>
<li>服务器通过私钥加密算出的MD5值，得到一个加密后的md5值</li>
<li>把脚本文件和加密后的md5值一起发给客户端</li>
<li>客户端拿到加密后的md5值，通过保存在客户端的公钥解密</li>
<li>客户端计算脚本文件的md5值</li>
<li>对比第 4/5 步的两个md5值(分别是客户端和服务器端计算出来的MD5值)，若相等则通过校验</li>
</ol>


<h2>客户端策略</h2>

<p>客户端具体策略如下图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3f5d0d89e0b3833d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<ol>
<li>用户打开App时，同步进行本地补丁的加载</li>
<li>用户打开App时，后台进程发起异步网络请求，获取服务器中当前App版本所对应的最新补丁版本和必须的补丁版本</li>
<li>获取补丁版本的请求回来后，跟本地的补丁版本进行对比</li>
<li>如果本地补丁版本小于必须版本，则提示用户，展示下载补丁界面，进行进程同步的补丁下载。下载完成后重新加载App和最新补丁，再进入App</li>
<li>如果本地补丁版本不小于必须版本，但小于最新版本，则进入App,不影响用户操作。同时进行后台进程异步静默下载，下载后补丁保存在本地，下次App启动时再加载最新补丁。</li>
<li>如果版本为最新，则进入App</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UserNotifications]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications/"/>
    <updated>2016-10-17T09:53:08+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications</id>
    <content type="html"><![CDATA[<p>ios10以前杂乱的和通知相关的API都被统一了，现在开发者可以使用独立的UserNotificaitons.framework来集中管理和使用iOS系统中通知的功能。在此基础上，Apple还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知UI等一系列功能。</p>

<!--more-->


<p>对于开发者来说，想比较于之前版本，iOS10提供了一套非常易用通知处理接口，是SDK的一次重大重构，而之前的绝大部分通知相关API都已经被标为弃用(deprecated)</p>

<p>您可以在WWDC16的 <a href="https://developer.apple.com/videos/play/wwdc2016/707/">introducaion to Notifications</a>和<a href="https://developer.apple.com/videos/play/wwdc2016/708/">Advanced Notifications</a>这两个Session中找到详细信息；另外也不要忘了参考<a href="https://developer.apple.com/reference/usernotifications">UserNotifications官方文档</a></p>

<h2>UserNOtifications框架解析</h2>

<h3>基本流程</h3>

<p>iOS10中通知相关的操作遵循下面的流程:</p>

<p><code>审核和注册</code>-><code>创建和发起</code>-><code>展示和处理</code></p>

<p>首先你需要向用户请求推送权限，然后发送通知。对于发送出的通知，如果你的应用位于后台或者没有运行的话，系统将通过用户允许的方法（弹窗，横幅，或者是在通知中心）进行展示。如果你的应用已经位于前台正在运行，你可以自行决定要不要显示这个通知。最后，如果你希望用户点击通知能有打开应用以外的额外功能的话，你也需要进行处理。</p>

<h2>权限申请</h2>

<p>iOS8之前，本地推送和远程推送（Remote Notificaiton）是区分对待的，应用只需要在进行远程推送是获取用户同意。iOS8对这一行为进行了规范，因为无论是本地推送还是远程推送，其实在用户看来表现是一致的，都是打断用户的行为。因此从iOS8开始，这两种通知都需要申请权限。ios10里进一步消除了本地通知和推送通知的区别。向用户申请通知权限非常简单：</p>

<pre><code>UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {
    granted, error in
    if granted {
        // 用户允许进行通知
    }
}
</code></pre>

<p>当然，在使用UN开头的API的时候，不要忘记导入<code>UserNotifications</code>框架：</p>

<p><code>import UserNotifications</code></p>

<p>第一次调用这个方法时，会弹出一个系统弹窗.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-0.png" alt="1" /></p>

<p>要注意的是，一旦用户拒绝了这个请求，再次调用该方法时也不会进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知，而这往往是不可能的。因此，在合适的是偶弹出请求窗，在请求权限前预先进行说明，而不是直接粗暴地在启动的时候就进行弹窗，会是更明智的选择。</p>

<h2>远程推送</h2>

<p>一旦用户同意后，你就可以再应用中发送本地通知了。不过如果你通过服务器发送远程通知的话，还需要多一个获取用户token的操作，你的服务器可以使用这个token将用向Apple push Notification的服务器提交请求，然后APNS通过token识别设备和应用，将通知推给用户。</p>

<p>提交token请求和获得token的回调是现在"唯一"不在新框架中的API,我们使用<code>UIApplication</code>的<code>registerForRemoteNotifications</code>来注册远程通知，在<code>AppDelegate</code>的<code>application(_:didRegisterForRemoteNotificationsWithDeviceToken)</code>中获取用户token:</p>

<pre><code>// 向 APNs 请求 token：
UIApplication.shared.registerForRemoteNotifications()

// AppDelegate.swift
 func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let tokenString = deviceToken.hexString
    print("Get Push token: \(tokenString)")
}
</code></pre>

<p>获取得到的<code>deviceToken</code>是一个<code>Data</code>类型，为了方便使用和传递，我们一般会选择将它转换为一个字符串。swift3中可以使用下面的<code>data</code>扩展来构造适合传递给Apple的字符串：</p>

<pre><code>extension Data {
    var hexString: String {
        return withUnsafeBytes {(bytes: UnsafePointer&lt;UInt8&gt;) -&gt; String in
            let buffer = UnsafeBufferPointer(start: bytes, count: count)
            return buffer.map {String(format: "%02hhx", $0)}.reduce("", { $0 + $1 })
        }
    }
}
</code></pre>

<h3>权限设置</h3>

<p>用户可以再系统设置中修改你的应用的通知权限，除了打开和关闭全部通知权限外，用户也可以限制你的应用智能进行某种形式的通知显示，比如值允许横幅而不允许弹窗及通知中心显示灯。一般来说你不应该对用户的选择进行干涉，但是如果你的应用确实需要某种特定场景的推送的话，你可以对当前用户进行的设置进行检查:</p>

<pre><code>UNUserNotificationCenter.current().getNotificationSettings {
    settings in 
    print(settings.authorizationStatus) // .authorized | .denied | .notDetermined
    print(settings.badgeSetting) // .enabled | .disabled | .notSupported
    // etc...
}
</code></pre>

<h2>发送通知</h2>

<p>UserNOtifications中对通知进行了统一。我们通过通知的内容（<code>UNNotificaitonsContent</code>）,发送的时机<code>UNNotifiationTrigger</code>以及一个发送通知的<code>String</code>类型的标识符，来生成一个<code>UNNotificationRequest</code>类型的发送请求。最后，我们将这个请求添加到<code>UNUserNotificationCenter.current()</code>中，就可以等待通知到达了：</p>

<pre><code>// 1. 创建通知内容
let content = UNMutableNotificationContent()
content.title = "Time Interval Notification"
content.body = "My first notification"

// 2. 创建发送触发
let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)

// 3. 发送请求标识符
let requestIdentifier = "com.onevcat.usernotification.myFirstNotification"

// 4. 创建一个发送请求
let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)

// 将请求添加到发送中心
UNUserNotificationCenter.current().add(request) { error in
    if error == nil {
        print("Time Interval Notification scheduled: \(requestIdentifier)")
    }
}
</code></pre>

<ol>
<li>iOS10中通知不仅支持简单的一行文字，你还可以添加<code>title</code>和 <code>subtitle</code>,来用粗体字的形式强调通知的目的。对于远程推送，iOS10之前一般只含有消息的推送；payload是这样的：</li>
</ol>


<pre><code>{
  "aps":{
    "alert":"Test",
    "sound":"default",
    "badge":1
  }
}
</code></pre>

<p>如果我们想要加入<code>title</code>和<code>subtitle</code>的话，则需要将<code>alert</code>从字符串换为字典，新的payload是:</p>

<pre><code>
  "aps":{
    "alert":{
      "title":"I am title",
      "subtitle":"I am subtitle",
      "body":"I am body"
    },
    "sound":"default",
    "badge":1
  }
}
</code></pre>

<p>好消息是，后一种字典的方法其实在iOS8.2的时候就已经存在了，虽然当时<code>title</code>只是用在Apple Watch上的，但是设置好<code>body</code>的话在iOS上还是可以显示的，所以针对iOS10添加标题时是可以保证向前兼容的。</p>

<p>另外，如果要进行本地化对应，在设置这些内容文本时，本地可以使用<code>String.localizedUserNotificationString(forKey: "your_key", arguments: [])</code>的方式来从<code>Localizable.strings</code>文件中取出本地化字符串，而远程推送的话，也可以再payload的alert中使用<code>loc-key</code>或者<code>title-loc-key</code>来进行指定</p>

<ol>
<li><p>触发器是只对本地通知而言的，远程推送的通知的话默认会在收到后立即显示。现在<code>UserNotifications</code>框架中提供了三种触发器，分别是：在一定时间后触发<code>UNTimeIntervalNotificationTrigger</code>,在某月某日某时触发<code>UNCalendarNotificationTrigger</code>,以及在用户进入或者离开某个区域时触发<code>UNLocationNotificationTrigger</code></p></li>
<li><p>请求标识符可以用来区分不同的通知请求，在将一个通知请求提交后，通过特定的API我们能够使用这个标识符来取消或者更新这个通知。我们将在稍后提到具体方法</p></li>
<li><p>在新版本的通知框架中，Apple借用了一部分网络请求的概念，我们组织并发送一个通知请求，然后将这个请求提交给<code>UNUserNotificationCenter</code>进行处理。我们会在delegate中接收到这个通知请求对应的responst,另外我们也有机会再应用的extension中对request进行处理</p></li>
</ol>


<p>在提交请求后，我们锁屏或者将应用切到后台，并等待设定的时间后，就能看到我们的通知出现在通知中心或者屏幕横幅了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-1.png" alt="1" /></p>

<h2>取消和更新</h2>

<p>在创建通知请求时，我们已经制定了标识符。这个标识符可以用来管理通知，在iOS10之前，我们很难取消掉某一个特定的通知，也不能主动移除或者更新已经展示的通知。</p>

<p>iOS10中，UserNotifications框架提供了一系列管理通知的API,你可以做到:</p>

<ul>
<li>取消还未展示的通知</li>
<li>更新还未展示的通知</li>
<li>移除已经展示过的通知</li>
<li>更新已经展示过的通知</li>
</ul>


<p>其中关键就是创建请求时使用同样的标识符：</p>

<p>比如，从通知中心移除一个展示过得通知：</p>

<pre><code>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
let identifier = "com.onevcat.usernotification.notificationWillBeRemovedAfterDisplayed"
let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)

UNUserNotificationCenter.current().add(request) { error in
    if error != nil {
        print("Notification request added: \(identifier)")
    }
}

delay(4) {
    print("Notification request removed: \(identifier)")
    UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [identifier])
}
</code></pre>

<p>类似的，我们可以使用<code>removePendingNotificationRequests</code>，来取消还未展示的通知请求。对于更新通知，不论是否已经展示，都和一开始添加请求时一样，再次将请求提交给<code>UNUserNotificationCenter</code>即可：</p>

<pre><code>// let request: UNNotificationRequest = ...
UNUserNotificationCenter.current().add(request) { error in
    if error != nil {
        print("Notification request added: \(identifier)")
    }
}

delay(2) {
    let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)

    // Add new request with the same identifier to update a notification.
    let newRequest = UNNotificationRequest(identifier: identifier, content:newContent, trigger: newTrigger)
    UNUserNotificationCenter.current().add(newRequest) { error in
        if error != nil {
            print("Notification request updated: \(identifier)")
        }
    }
}
</code></pre>

<p>远程推送可以进行通知的更新，在使用Provider API向APNS提交请求时，在HTTP2的header中<code>apns-collapse-id</code>key的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新</p>

<h2>处理通知</h2>

<h3>应用内展示通知</h3>

<p>现在系统可以在应用处于后台或者退出的时候向用户展示通知了。不过，当应用处于前台时，收到的通知是无法进行展示的。如果我们希望在应用内也能显示通知的话，需要额外的工作。</p>

<p><code>UNUserNotificationCenterDelegate</code>提供了两个方法，分别对应如何在应用内展示通知，和收到通知响应时要如何处理的工作。我们可以实现这个借口中的对应方法来在应用内展示通知：</p>

<pre><code>class NotificationHandler: NSObject, UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, 
                       willPresent notification: UNNotification, 
                       withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) 
    {
        completionHandler([.alert, .sound])

        // 如果不想显示某个通知，可以直接用空 options 调用 completionHandler:
        // completionHandler([])
    }
}
</code></pre>

<p>实现后，将<code>NotificationHandler</code>的实例赋值给<code>UNUserNotificationCenter</code>的<code>delegate</code>属性就可以了。没有特殊理由的话，AppDelegate的<code>application(_:didFinishLaunchingWithOptions:)</code>就是一个不错的选择：</p>

<pre><code>class AppDelegate: UIResponder, UIApplicationDelegate {
    let notificationHandler = NotificationHandler()
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
        UNUserNotificationCenter.current().delegate = notificationHandler
        return true
    }
}
</code></pre>

<h2>对通知进行响应</h2>

<p><code>UNUserNotificationCenterDelegate</code>中还有一个方法,<code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>这个代理方法会在用户与你推送的通知进行交互时被调用，包括用户通过通知打开了你的应用，或者点击或者触发了某个Action。因为涉及到打开应用的行为，所以事先了这个方法的delegate必须在<code>applicationDidFinishLaunching:</code>返回前就完成设置，这也是我们之前推荐将<code>NotificationHandler</code>今早进行赋值的理由。</p>

<p>一个最简单的事先自然什么也不错，直接告诉系统你已经完成了所有工作。</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
    completionHandler()
}
</code></pre>

<p>在该方法里，我们将获取到这个推送请求对应的response,<code>UNNotificationResponse</code>是一个几乎包括了通知的所有信息的对象，从中我们可以再次获取到<code>userInfo</code>中的信息:</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
    if let name = response.notification.request.content.userInfo["name"] as? String {
        print("I know it's you! \(name)")
    }
    completionHandler()
}
</code></pre>

<p>更好的消息是，远程推送的payload内的内容也会出现在这个<code>userInfo</code>中，这样一来，不论是本地推送还是远程推送，处理的路径得到了统一。通过<code>userInfo</code>的内容来决定页面跳转或者是进行其他操作，都会有很大空间。</p>

<h2>Actionable通知发送和处理</h2>

<h3>注册Category</h3>

<p>iOS8和9中Apple引入了可以交互的通知，这是通过将一簇action放到了一个category中，将这个category进行注册，最后在发送通知时将通知的category设置为要使用的category来实现的。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-2.png" alt="1" /></p>

<p>注册一个category非常容易：</p>

<pre><code>private func registerNotificationCategory() {
    let saySomethingCategory: UNNotificationCategory = {
        // 1
        let inputAction = UNTextInputNotificationAction(
            identifier: "action.input",
            title: "Input",
            options: [.foreground],
            textInputButtonTitle: "Send",
            textInputPlaceholder: "What do you want to say...")

        // 2
        let goodbyeAction = UNNotificationAction(
            identifier: "action.goodbye",
            title: "Goodbye",
            options: [.foreground])

        let cancelAction = UNNotificationAction(
            identifier: "action.cancel",
            title: "Cancel",
            options: [.destructive])

        // 3
        return UNNotificationCategory(identifier:"saySomethingCategory", actions: [inputAction, goodbyeAction, cancelAction], intentIdentifiers: [], options: [.customDismissAction])
    }()

    UNUserNotificationCenter.current().setNotificationCategories([saySomethingCategory])
}
</code></pre>

<ol>
<li><code>UNTextInputNotificationAction</code>代表一个输入文本的action,你可以自定义框的按钮title和placeholder,你稍后会使用<code>identifier</code>来对action进行区分。</li>
<li>普通的<code>UNNotificationAction</code>对应标准的按钮</li>
<li>为category指定一个<code>identifier</code>,我们将在实际发送通知的时候用这个标识符进行设置，这样系统就知道对应哪个category了。</li>
</ol>


<p>当然，不要忘了在程序启动时调用这个方法进行注册</p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
    registerNotificationCategory()
    UNUserNotificationCenter.current().delegate = notificationHandler
    return true
}
</code></pre>

<h3>发送一个带有action的通知</h3>

<p>在完成category注册后，发送一个actionable通知就非常简单了，只需要在创建<code>UNNotificationContent</code>时把<code>categoryIdentifier</code>设置为需要的categoryId即可：</p>

<pre><code>content.categoryIdentifier = "saySomethingCategory"
</code></pre>

<p>尝试展示这个通知，在下拉或者使用3D touch展开通知后，就可以看到对应的action了：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-3.png" alt="1" /></p>

<p>远程推送也可以使用category,只需要在payload中添加<code>category</code>字段，并指定预先定义的category id 就可以了:</p>

<pre><code>{
  "aps":{
    "alert":"Please say something",
    "category":"saySomething"
  }
}
</code></pre>

<h3>处理actionable通知</h3>

<p>和普通的通知并无二致力，actionable通知也会走到<code>didReceive</code>的delegate方法，我们通过request中包含的<code>categoryIdentifier</code>和response里的<code>actionIdentifier</code>就可以轻易判定是那个通知的那个操作被执行了。对于<code>UNTextInputNotificationAction</code>触发的response,直接将它转换为一个<code>UNTextInputNotificationResponse</code>，就可以拿到其中的用户输入了：</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {

    if let category = UserNotificationCategoryType(rawValue: response.notification.request.content.categoryIdentifier) {
        switch category {
        case .saySomething:
            handleSaySomthing(response: response)
        }
    }
    completionHandler()
}

private func handleSaySomthing(response: UNNotificationResponse) {
    let text: String

    if let actionType = SaySomethingCategoryAction(rawValue: response.actionIdentifier) {
        switch actionType {
        case .input: text = (response as! UNTextInputNotificationResponse).userText
        case .goodbye: text = "Goodbye"
        case .none: text = ""
        }
    } else {
        // Only tap or clear. (You will not receive this callback when user clear your notification unless you set .customDismissAction as the option of category)
        text = ""
    }

    if !text.isEmpty {
        UIAlertController.showConfirmAlertFromTopViewController(message: "You just said \(text)")
    }
}
</code></pre>

<p>上面的代码先判断通知响应是否属于<code>saySomething</code>，然后从用户输入或者是选择中提取字符串，并且弹出一个alert作为响应结果。当然，更多请苦情下我们会发送一个网络请求，或者是根据用户操作更新一些UI等。</p>

<h2>Notificiaton Extension</h2>

<p>iOS10中添加了很多extention,作为应用与系统整合的入口。与通知相关的extension有两个：Service Extension和Content Extension.前者可以让我们有机会在收到远程推送的通知后，展示之前对通知内容进行修改：后者可以用来自定义通知视图的样式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-extensions.png" alt="1" /></p>

<h3>截取并修改通知内容</h3>

<p><code>NotificationService</code>的模板已经为我们进行了基本的实现:</p>

<pre><code>class NotificationService: UNNotificationServiceExtension {

    var contentHandler: ((UNNotificationContent) -&gt; Void)?
    var bestAttemptContent: UNMutableNotificationContent?

    // 1
    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)

        if let bestAttemptContent = bestAttemptContent {
            if request.identifier == "mutableContent" {
                bestAttemptContent.body = "\(bestAttemptContent.body), Andrew"
            }
            contentHandler(bestAttemptContent)
        }
    }

    // 2
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }
}
</code></pre>

<ol>
<li><code>didReceive:</code>方法中有一个等待发送的通知请求，我们通过修改这个请求中的content内容，然后在限制的时间内将修改后的内容调用通过<code>contentHandler</code>返还给系统，就可以显示这个修改过得通知了</li>
<li>在一定时间内没有调用<code>contentHandler</code>的话，系统会调用这个方法，来告诉你大限已到。你可以选择什么都不做，这样的话系统将当做什么都没发生，简单地显示原来的通知，可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用<code>contentHandler</code>来显示一个变更"中途"的通知</li>
</ol>


<p>Service Extentsion现在只对远程推送的通知起效，你可以在推送payload中增加一个<code>mutable-content</code>的值为1的项来启用内容修改：</p>

<pre><code>{
  "aps":{
    "alert":{
      "title":"Greetings",
      "body":"Long time no see"
    },
    "mutable-content":1
  }
}
</code></pre>

<p>这个payload的推送得到的结果就是推送的内容+“Andrew”</p>

<p>使用在本机截取推送并替换内容的方式，可以完成端到端(end-to-end)的推送加密。你在服务器推送payload中加入加密过得文本，在客户端接到通知后使用预先定义或者获取过得秘钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>

<h2>在通知中展示图片/视频</h2>

<p>相比于旧版本的通知，iOS10中另一个亮眼功能室多媒体的推送，开发者现在可以在通知中嵌入图片或者视频，这极大丰富了推送内容的可读性和趣味性。</p>

<p>为本地通知添加多媒体内容十分简单，只需要通过本地磁盘上的文件URL创建一个<code>UNNotificationAttachment</code>对象，然后将这个对象放到数组中赋值给<code>content</code>的<code>attachments</code>属性就行了：</p>

<pre><code>let content = UNMutableNotificationContent()
content.title = "Image Notification"
content.body = "Show me an image!"

if let imageURL = Bundle.main.url(forResource: "image", withExtension: "jpg"),
   let attachment = try? UNNotificationAttachment(identifier: "imageAttachment", url: imageURL, options: nil)
{
    content.attachments = [attachment]
}
</code></pre>

<p>在显示时，横幅或者弹窗将附带设置的图片，使用3D Touch pop通知或者下拉通知显示详细内容时，图片也会被放大显示：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-4.png" alt="2" /></p>

<p>除了图片之外，通知还支持音频以及视频。你可以将MP3或者MP4这样的文件提供给系统来在通知中进行展示和播放，不过，这些文件都有尺寸的限制，比如图片不能超过5MB,视频不能超过50MB,不过对于一般的能在通知中展示的内容来说，这个尺寸应该是绰绰有余了。关于支持的文件格式和尺寸，可以在文档中进行确认。在创建<code>UNNotificationAttachment</code>时，如果遇到了不支持的格式，SDK也会抛出错误。</p>

<p>通过远程推送的方式，你也可以显示图片等多媒体内容，这要借助于上一节所提到的通过<code>Notification Service Extension</code>来修改涂松通知内容的技术。一般做法是，我们在推送payload中指定需要加载的图片资源地址，这个地址可以是应用bundle内已经存在的资源，也可以是网络的资源。不过因为在创建<code>UNNotificationAttachment</code>时偶们只能使用本地资源，所以如果多媒体还不在本地的话，我们需要先将其下载到本地，在完成<code>UNNotificationAttachment</code>创建后，我们就可以和本地通知一样，将它设置给<code>attachments</code>属性，然后调用<code>contentHandler</code>了。</p>

<p>简单的实例 payload如下：</p>

<pre><code>{
  "aps":{
    "alert":{
      "title":"Image Notification",
      "body":"Show me an image from web!"
    },
    "mutable-content":1
  },
  "image": "https://onevcat.com/assets/images/background-cover.jpg"
}
</code></pre>

<p><code>mutable-content</code>表示偶们会在接收到通知时对内容进行更改，<code>image</code>指明了目标图片的地址。</p>

<p>在<code>NotificationService</code>里，加入如下代码来下载图片，并将其保存到磁盘缓存中：</p>

<pre><code>private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {
    let task = URLSession.shared.dataTask(with: url, completionHandler: {
        data, res, error in

        var localURL: URL? = nil

        if let data = data {
            let ext = (url.absoluteString as NSString).pathExtension
            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)
            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)

            if let _ = try? data.write(to: url) {
                localURL = url
            }
        }

        handler(localURL)
    })

    task.resume()
}
</code></pre>

<p>然后再<code>didReceive:</code>中，接收到这类通知时提取图片地址，下载，并生成attachment,进行通知展示：</p>

<pre><code>if let imageURLString = bestAttemptContent.userInfo["image"] as? String,
   let URL = URL(string: imageURLString)
{
    downloadAndSave(url: URL) { localURL in
        if let localURL = localURL {
            do {
                let attachment = try UNNotificationAttachment(identifier: "image_downloaded", url: localURL, options: nil)
                bestAttemptContent.attachments = [attachment]
            } catch {
                print(error)
            }
        }
        contentHandler(bestAttemptContent)
    }
}
</code></pre>

<p>关于在通知中展示图案品或者视频，有几点想补充说明：</p>

<ol>
<li><code>UNNotificationContent</code>的<code>attachments</code>虽然是一个数组，但是系统只会展示第一个attachmen对象的内容。不过你依然可以发送多个<code>attachments</code>,然后再要展示的时候再重新安排他们的顺序，以显示最符合情景的图片或者视频。另外，你也可能会在自定义通知展示UI时用到多个<code>attachment</code>,我们接下来一节中会看到一个相关的例子。</li>
<li>在当前iOS10中，<code>serviceExtensionTimeWillExpire</code>被条用之前，你有30秒时间来处理和更改通知内容，对于一般的图片来说，这个时间是足够的，但是如果你推送的体积较大的视频内容，用户又恰巧在糟糕的网络环境的话，很有可能无法及时下载完成。</li>
<li>如果你想在远程推送来的通知中显示应用bundle内的资源的话，要注意extension的bundle和app main bundle并不是一回事，你可以选择将图片资源放到extension bundle中，也可以选择放在main bundle里，总之，你需要保证能够获取到正确的，并且你具有读取权限的url</li>
<li>系统在创建<code>attachement</code>时会根据提供的url后缀确定文件类型，如果没有后缀，或者后缀无法不正确的话，你可以在创建时通过<code>UNNotificationAttachmentOptionsTypeHintKey</code>来<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachmentoptionstypehintkey">指定资源类型</a></li>
<li>如果使用的图片和视频文件不在你的bundle内部，它们将被移动到系统的负责通知的文件夹下，然后当同志被移除后删除。如果媒体文件在bundle内部，它们将被负责到通知文件夹下。每个应用能使用的媒体文件大小总和是有限制，超过限制后创建<code>attachment</code>时将抛出异常。可能的所有错误可以再<code>UNError</code>中找到</li>
<li>你可以访问一个已经创建的<code>attachment</code>的内容，但是要注意权限问题，可以使用<code>startAccessingSecurityScopedResource</code>来暂时获取以创建的<code>attachment</code>的访问权限。比如：</li>
</ol>


<pre><code>let content = notification.request.content
if let attachment = content.attachments.first {  
    if attachment.url.startAccessingSecurityScopedResource() {  
        eventImage.image = UIImage(contentsOfFile: attachment.url.path!)  
        attachment.url.stopAccessingSecurityScopedResource()  
    }  
}  
</code></pre>

<h2>自定义通知视图样式</h2>

<p>ioS10 SDK 新加的另一个<code>Content Extension</code>可以用来自定义通知的详细页面的视图，新建一个<code>Notification Content Extension</code>,Xcode为我们准备的模板中包含了一个实现了<code>UNNotificationContentExtension</code>的<code>UIViewController</code>子类。这个extension中有个一必须实现的方法<code>didReceive(_:)</code>,在系统需要显示自定义样式的通知详情视图时，这个方法将被调用，你需要在其中配置你的UI.而UI本身可以通过这个extension中的<code>MainInterface.storyboard</code>来进行定义。自定义UI的通知是和通知category绑定的，我们需要在<code>extension</code>的info.plist里指定这个通知样式所对应的category标识符：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-content-info.png" alt="1" /></p>

<p>系统在接收到通知后会先查找有没有能够处理这类通知的content extension,如果存在，那么就交给extensionl来进行处理，另外，在构建UI时，我们可以通过Info.plist控制通知详细视图的尺寸，以及是否显示原始的通知。关于Content Extension中的info.plist的key,可以在<a href="https://developer.apple.com/reference/usernotificationsui/unnotificationcontentextension">这个文档</a>中找到详细信息。</p>

<p>虽然我们可以使用包括按钮在内的各种UI，但是系统不允许我们队这些UI进行交互，点击通知视图UI本身会将我们导航到应用中，不过我们可以通过action的方式来对自定义UI进行更新。<code>UNNotificationContentExtension</code>为我们提供了一个可选方法<code>didReceive(_:completionHandler:)</code>，它会在用户选择了某个action时被调用，你有机会在这里更新通知的UI，如果有UI更新，那么在方法的<code>completionHandler</code>中，开发者可以选择传递<code>. doNotDismiss</code>来保持通知继续呗显示。如果没有继续显示的必要，可以选择<code>. dismissAndForwardAction</code>或者<code>. dismiss</code>，前者将把通知的action继续传递给应用的<code>UNUserNotificationCenterDelegate</code>中的<code>userNotificationCenter(:didReceive:withCompletionHandler)</code>，而后者将直接解散这个通知</p>

<p>如果你的自定义UI包含视频等，你还可以实现<code>UNNotificationContentExtension</code>里的<code>media</code>开头的一系列属性，它将为你提供一些视频播放的控件和相关方法。</p>

<h2>总结</h2>

<p>iOS10 SDk中对通知这块进行了IOS系统发布以来最大的一次重构，很多"老朋友"都被标记为了 deprecated:</p>

<h2>iOS10中被标记弃用的API</h2>

<ul>
<li>UILocalNotification</li>
<li>UIMutableUserNotificationAction</li>
<li>UIMutableUserNotificationCategory</li>
<li>UIUserNotificationAction</li>
<li>UIUserNotificationCategory</li>
<li>UIUserNotificationSettings</li>
<li>handleActionWithIdentifier:forLocalNotification:</li>
<li>handleActionWithIdentifier:forRemoteNotification:</li>
<li>didReceiveLocalNotification:withCompletion:</li>
<li>didReceiveRemoteNotification:withCompletion:</li>
</ul>


<p>等一系列在<code>UIKIT</code>中的发送和处理通知的类型及方法</p>

<p>相比较于iOS早期时代的API,新的APi展现了高度的模块化和统一特性，易用性也非常好，是一套更加先进的API,如果有可能，特别是如果你的应用是重度依赖通知特性的话，直接从iOS10开始可以让你充分使用在新同志体系的各种特性。</p>

<p>虽然原来的API都被标为弃用了，但是如果需要支持iOS10之前系统的话，你还是需要使用原来的API,我们可以使用</p>

<pre><code>if #available(iOS 10.0, *) {
    // Use UserNotification
}
</code></pre>

<p>的方式来对iOS10进行新通知的适配，并让iOS10的用户享受到新通知带来的便利特性，然后在将来版本升级到只支持iOS10以上时再移除掉所有被启用的代码。对于优化和梳理通知相关代码来说，新API对代码设计和祖上上带来的好处足以弥补适配上的麻烦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS中的内存分配]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei/"/>
    <updated>2016-10-09T17:16:16+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei</id>
    <content type="html"><![CDATA[<p>内存分配可以分为5个区</p>

<h2>栈区（stack）</h2>

<p>这个一般由编译器操作，或者说是系统管理，会存一些局部变量，这些系统都会帮我们自动实现，无需我们干预，所以大量的局部变量，深递归，函数循环调用都可以耗尽栈内存而程序崩溃</p>

<h2>堆区（heap）</h2>

<p>一般由程序员管理，比如alloc申请内存，free释放内存，我们创建的对象也都放在这里</p>

<h2>全局区(静态区 static)</h2>

<p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。</p>

<h2>常量区</h2>

<p>常量字符串就是放在这里的，还有const常量</p>

<h2>代码区</h2>

<p>存放代码，app程序会拷贝到这里，程序不是在</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1475976705224479.png" alt="1" /></p>

<p>图中各个区并不连续</p>

<p>当一个app启动后，代码区，常量区，全局区地址已经固定，因此指向这些区的指针不会为空而产生崩溃性的错误，而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入和弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS推送]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/21/iostui-song/"/>
    <updated>2016-09-21T16:25:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/21/iostui-song</id>
    <content type="html"><![CDATA[<p>推送服务可以说是所有App的标配，不论是那种类型的App,推送都从很大程度上决定了App的打开率，使用率，存活率。因此熟知并掌握推送原理及方法,对每一个开发者来说都是必备技能，对每一个依赖App的公司都至关重要</p>

<p>从ios10新增的<code>UserNotifications Framework</code>可以发现，Apple整合了原有散乱的API,并且增加了很多强大的功能。以Apple官方的角度来看，也必然是相当重视推送服务对App的影响，以及对Apple生态圈长远发展的影响。</p>

<!--more-->


<h2>准备</h2>

<h3>Tip 1：推送通知（Push Notification）必须购买Apple开发者账号，并使用特定的推送证书</h3>

<ul>
<li>使用免费账号不能推送</li>
<li>如果我们使用的是第三方推送服务，比如 &lt;极光推送>,也必须购买开发者账号，因为所有的第三方都会将推送请求发至 <code>APNS</code>(Apple push Notification service，苹果推送通知服务)，所有的推送都是由Apns发送的</li>
<li>如果注册及正确的配置证书，参考这里<a href="http://docs.jiguang.cn/client/ios_tutorials/#ios_1">ios证书设置指南</a></li>
</ul>


<h2>原理</h2>

<h3>Tip2:推送通知本身是iOS系统的行为，所以在App没有运行的时候：</h3>

<ul>
<li>仍然能够推送及接收(通知中心通知，顶部横幅，刷新App右上角小圆点等都会由系统控制和展示)</li>
<li>收到推送时，是无法再App的代码中获取到通知内容的。因为沙盒机制，此时App的任何代码都不可能被执行</li>
</ul>


<h3>Tip3:手机向APNS注册推送服务</h3>

<ol>
<li>在代码中注册推送服务:</li>
</ol>


<pre><code> #ifdef __IPHONE_8_0
 if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {
     UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge| UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];
     [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
 } else {
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
}
 #else
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
 #endif
</code></pre>

<ol>
<li>在第一次触发这段代码的时候，会有一个系统弹窗，询问你是否允许该App要给你推送信息。当你选择允许时，系统会打包App+手机唯一标识+证书信息 发送至Apns服务器注册推送服务，APNs系统会对该手机安装的该App是否有推送权限进行验证，所以必须要加入了Apple Device的手机，使用对应App的推送证书才能够成功注册。</li>
<li>如果注册成功，则可以在<code>AppDelegate.swift</code>的如下方法中获取到<code>deviceToken</code>,它是对该手机+该App组合的一个唯一标识，当使用远程推送时，只需将推送消息发给指定的<code>deviceToken</code>即可使推送消息传达给指定手机的指定App上。因此如果你使用第三方，就需要在这里将<code>deviceToken</code>传给第三方。（在ios9为了更好的保护用户隐私，会出现多次重复删除/安装App导致<code>deviceToken</code>不断变化的情况。有时会出现一条推送手机会受到2次的问题，属于iOS9系统问题）</li>
</ol>


<pre><code> -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
     [JPUSHService registerDeviceToken:deviceToken];//将 deviceToken 传给极光推送
 }
</code></pre>

<ol>
<li><p>如果以上步骤都成功，此时你能够获取到第三方提供的设备注册的id，能够获取到该id值，可以作为判断设备是否能够成功推送的标准，因此当你获取到该值时：</p></li>
<li><p>推送证书配置正确（你拥有了推送权限）</p></li>
<li>设备成功在Apns注册并返回了<code>deviceToken</code>（Apns能识别你的设备了）</li>
<li><p>返回的<code>deviceTOken</code>传给第三方，成功在第三方生成了唯一标识注册id（第三方能将你的设备信息传给APNS了）</p></li>
<li><p>综上，注册及接受推送必须使用真机，必须连网</p></li>
</ol>


<h3>Tip4:推送通知从服务端->App代码的过程</h3>

<ol>
<li>使用你们公司或第三方的服务端向APNs发送推送请求（请参考苹果APNS相关资料，或者使用第三方提供的Rest Api）</li>
<li>APNS接受并验证推送请求</li>
<li>APNS找到设备下发推送</li>
<li><p>手机收到推送通知，系统根据App状态进行处理：</p></li>
<li><p>前台收到：</p>

<ul>
<li>系统会将通知内容传到 <code>didReceiveRemoteNotification</code></li>
</ul>
</li>
<li><p>后台收到:</p>

<ul>
<li>如果开启了<code>Remote Notification</code>,系统将推送传到<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>,否则此时代码中收不到推送</li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
<li><p>退出收到:</p>

<ul>
<li>如果点击推送横幅/通知中心而启动App,系统将通知传到<code>didFinishLaunchingWithOptions</code></li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
</ol>


<h2>推送通知内容篇</h2>

<h3>Tip5:推送通知分为本地/远程 2种类型:</h3>

<ul>
<li>本地通知，可指定推送时间，在该时间准时弹出推送通知。</li>
<li><p>远程推送通知，分为普通推送/后台推送/静默推送3种类型。存在延迟问题（由于Tip1的第2点，APNS的不稳定及高峰时段的巨量请求所致）</p>

<ul>
<li><p>普通推送</p>

<ul>
<li>就是我们在手机上平时见到的推送通知</li>
<li>包括声音，横幅，角标，自定义字段</li>
<li><p>App:</p>

<ul>
<li>处于前台，不会显示横幅，可通过 <code>didReceiveRemoteNotification</code>（ios7 before）,<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>(ios7 after)获取通知内容</li>
<li>处于后台，会展示横幅，无法获取通知内容</li>
<li>处于退出，会展示横幅，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击通知横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>
</li>
</ul>
</li>
<li>通知内容类似如下:</li>
</ul>


<pre><code class="``">  {
"_j_msgid" = 200806057;  // 第三方附带的 id，用于统计点击
aps =     {
  alert = "显示内容";
  badge = 1;  // App 角标，可推送 n、+n、-n 来实现角标的固定、增加、减少
  sound = default;  // 推送声音，默认系统三全音，如需使用自己的声音，需要将声音文件拖拽&amp;拷贝至 Xcode 工程目录任意位置，并在推送时指定其文件名
};
key1 = value1;  // 自定义字段，可设置多组，用于处理内部逻辑
key2 = value2;
}
</code></pre></li>
<li><p>后台推送</p>

<ul>
<li>各种显示效果跟普通推送完全一样</li>
<li>必须携带<code>content-available</code> = 1</li>
<li>必须携带 alter ,badge ,sound 至少一个字段</li>
<li>仅 ios7以后支持</li>
<li>必须在Xcode工程中 <code>TARGETS – Capabilities – Background Modes – Remote notifications</code>开启该功能，具体可参照 <a href="http://docs.jiguang.cn/client/ios_tutorials/#ios-7-background-remote-notification"> iOS 7 Background Remote Notification</a></li>
</ul>
</li>
</ul>


<h3>App</h3>

<ul>
<li>处于前台，可通过<code>didReceiveRemoteNotification</code>(iOS7 before) ，didReceiveRemoteNotification:fetchCompletionHandler: （iOS 7 after）获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中于普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下没执行一些代码，大概提供几分钟的时间，可以用来偷偷地刷新UI，切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击推送横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<pre><code>{
  "_j_msgid" = 2090737306;
  aps =     {
    alert = "显示内容";
    badge = 1;
    "content-available" = 1;  // 必带字段
    sound = default;
  };
  key1 = value1;
}
</code></pre>

<h3>静默推送</h3>

<ul>
<li>没有任何展示效果</li>
<li>必须携带<code>"content-available" = 1</code>，因此静默必然是后台的</li>
<li>必须不携带 alert,badge,sound</li>
<li>可携带自定义字段</li>
</ul>


<p><em>App:</em></p>

<ul>
<li>处于前台，可以通过<code>didReceiveRemoteNotification</code>(iOS7 before),<code>didReceiveRemoteNotification:fetchCompletionHandler:</code> (ios 7 after)获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中与普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下，执行一些代码，大概提供几分钟的时间，可以用来偷偷的刷新UI,切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<pre><code>{
    "_j_msgid" = 3938587719;
    aps =     {
        alert = "";
        "content-available" = 1;  // 必带字段
    };
    key1 = value1;
}
</code></pre>

<h2>推送目标篇</h2>

<p>别名，标签，RegistrationID均是第三方提供的用于更方便地指定推送目标的功能</p>

<h3>Tip6:推送根据目标的不同可以分为:</h3>

<ul>
<li>广播

<ul>
<li>无差别发送给所有用户</li>
</ul>
</li>
<li><p>别名alias推送</p>

<ul>
<li>第三方提供的功能</li>
<li>一个手机的一款App只能设置一个 alias(可修改)</li>
<li>建议对每一个用户都取不同的别名，以此来确定唯一的用户</li>
<li>推送时可指定多个alias来发送同一内容</li>
<li>仅指定alias的用户能够收到推送</li>
</ul>
</li>
<li><p>标签tag推送</p>

<ul>
<li>第三方提供的功能</li>
<li>可以设置多个，可增加，清空</li>
<li>用于指定多样的属性，如 『1000』+『daily』+『discount』 可用于表示月消费超过 1k、喜欢购买日用品、偏好折扣商品的用户</li>
<li>如果要删除，需要在上次设置时，将设置的tags保存至<code>NSUserDefaults</code>，本次剔除不需要的tag后，再重新设置</li>
<li>推送时可指定多个tag来发同一个内容</li>
<li>手机如果设置了推送指定的多个 tag 中任一个tag，都能够收到推送消息。如指定 『1000』+『globe』+『original』 （千元级消费者、全球购、原价），那么设置了 『100』+『globe』+『discount』（百元级消费者、全球购、折扣价）的用户可以收到该推送消息。</li>
</ul>
</li>
<li><p>Registration ID 推送</p>

<ul>
<li>第三方提供的功能</li>
<li>在Tip 3的第三步时将<code>deviceToken</code>提供给第三方之后，其服务器会自动生成的指向该手机的唯一id</li>
<li>可在推送时指定多个id来下发消息</li>
<li>可用于对核心用户，旗舰用户的精准推送</li>
</ul>
</li>
</ul>


<h2>应用消息篇</h2>

<h3>Tip 7:应用内消息和推送通知的区别，消息:</h3>

<ul>
<li>不需要Apple推送证书</li>
<li>由第三方服务器下发，而不是APNS</li>
<li>相比通知，更快速，几乎没有延迟，可用于IM消息的即使传达</li>
<li>能够长时间保留离线消息，可获取所有历史消息内容</li>
<li>通过长连接技术下发消息，因此：

<ul>
<li>手机必须启动并与第三方服务器简历连接</li>
<li>如果手机启动立刻切换到后台，很可能连接没有建立</li>
<li>手机必须处于前台才能收到消息</li>
<li>手机从后台切回前台，会自动重新简历连接，并收到离线消息</li>
</ul>
</li>
<li>没有任何展示（横幅，通知中心，角标，声音），因此可以：

<ul>
<li>完全自定义字段实现UI效果</li>
<li>完全在静默的情况下处理App内部逻辑</li>
<li>使用一些App Store审核不会通过的功能，在审核时关闭功能，上架后通过接收消息，开启相关功能</li>
</ul>
</li>
</ul>


<h2>组合大招</h2>

<h3>Tip 8:tags的组合技巧</h3>

<ul>
<li>见 Tip5 - 标签tag 推送</li>
<li>可以再服务器端来统计分析用户行为，然后将指定的tags发送至手机，手机接收后再为用户打上对应的tags</li>
</ul>


<h3>Tip 9:通知 + 消息的组合技巧</h3>

<ul>
<li>首先来看通知和消息的特性对比</li>
</ul>


<table>
<thead>
<tr>
<th>XX </th>
<th>  通知  </th>
<th>             消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>送达时间 </td>
<td> 可能存在几秒延迟  </td>
<td> 几乎没延迟</td>
</tr>
<tr>
<td>获取时机  </td>
<td> 处于前台或后台 能获取内容</td>
<td>仅处于前台能获取内容</td>
</tr>
<tr>
<td>离线内容</td>
<td> 保留一段时间，过期会抛弃，无法查询历史内容</td>
<td>始终保留，可查询全部历史内容</td>
</tr>
<tr>
<td>系统展示</td>
<td>会展示（静默推送或App处于前台不展示）</td>
<td>不展示</td>
</tr>
</tbody>
</table>


<p><em>由于各自的特性都存在差异，因此二者结合使用使得App推送性能最大化的必然选择：</em></p>

<ul>
<li>情景一</li>
</ul>


<p>QQ/微信聊天，会同时下发一组通知+消息，如果用户没有启动QQ,虽有延迟但必须能够先收到通知，在收到通知的提醒之后，用户打开App,此时收到了离线消息，即使更新UI，与好友即使地发送/接收消息，（在收到通知后，断网，然后启动APP，你会发现此时手机里并不会显示刚刚通知的内容，因为它是依靠拉取消息来刷新页面的，而不是不够稳定的通知）</p>
]]></content>
  </entry>
  
</feed>
