<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-04-29T13:48:19+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ViewController转场动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua/"/>
    <updated>2016-04-28T15:54:40+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua</id>
    <content type="html"><![CDATA[<h2>自定义转场动画</h2>

<p>ios7中最让我激动的特性之一就是提供了新的API来支持自定义ViewController之间的转场动画。</p>

<!--more-->


<p>在开始研究新的API之间，我们先看看ios7中 navigation controller之间默认的行为发生了那些改变:在navigation controller中，切换两个view controller的动画变得更有交互性。比方说你想要pop一个view controller出去，你可以用手指从屏幕的左边缘开始拖动，慢慢地把当前的viewcontroller向右拖出屏幕去.</p>

<p>接下来，我们来看看这个新API。很有趣，这部分API大量的使用了协议而不是具体的对象。这初看起来有点奇怪，但是我更喜欢这样的设计，因为这种设计给我们这些开发者更大的灵活性。下面，让我们来做件简单的事情:在Navigation Controller中，实现一个自定义的push动画效果，为了完成这个任务，需要实现UINavigationControllerDelegate中的新方法:</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
                   navigationController:(UINavigationController *)navigationController
        animationControllerForOperation:(UINavigationControllerOperation)operation
                     fromViewController:(UIViewController*)fromVC
                       toViewController:(UIViewController*)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.animator;
    }
    return nil;
}
</code></pre>

<p>从上面的代码可以看出，我们可以根据不同的操作(push或pop)返回不同的animator.我们可以把anmitor存到一个属性中，从而在多个操作之间实现共享，或者我们也可以为每个操作都创建一个新的animator对象，这里的灵活性很多。</p>

<p>为了让动画运行起来，我们创建一个自定义类，并且实现<code>UIViewControllerAnimatedTransitioning</code>这个协议:</p>

<pre><code>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end
</code></pre>

<p>这个协议要求我们实现两个方法，其中一个定义了动画的持续时间:</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    return 0.25;
}
</code></pre>

<p>另一个方法描述整个动画的执行效果 ：</p>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;

    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];

    }];

}
</code></pre>

<p>从上面的例子汇总，你可以看到如何运用洗衣的：这个方法中通过接受一个类型为<code>id&lt;UIViewControllerContextTransitioning&gt;</code>的参数，来获取transition context.值的注意的是，执行完动画之后，我们需要调用transitionContext的<code>completeTransition :</code>这个方法来更新ViewController的状态。剩下的代码和ios7之前的一样了，我们从transition context 中得到了需要做转场的两个View controller,然后使用最简单的Uiview animation来实现转场动画。这就是全部代码了，我们已经实现了缩放效果的转场动画了。</p>

<p>注意，这里只是为push操作实现了自定义效果的转场动画，对于pop操作，还是会使用默认的滑动效果，另外，上面我们实现的转场动画无法交互，下面我们就来看看解决这个问题。</p>

<h2>交互式的转场动画</h2>

<p>想要动画变地交互非常简单，我们只需要覆盖另一个UINavigationControllerDelegate的方法:</p>

<pre><code>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return self.interactionController;
}
</code></pre>

<p>注意，在非交互式动画效果中，该方法返回nil.</p>

<p>这里返回的interaction controller是<code>UIPercentDrivenInteractionTransition</code>类的一个实例，开发者不需要任何配置就可以工作。我们创建了一个拖动收拾(Pan REcognizer),下面是处理该手势的代码:</p>

<pre><code>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
    }
} 
</code></pre>

<p>只有当用户从屏幕的右半部分开始触摸的时候，我们才把下一次动画效果设置为交互的（通过设置interactionController这个属性来实现），然后执行方法performSegueWithIdentifier:（如果你不是使用的storyboards,那么就直接调用pushViewController&hellip;这类方法）。为了让转场动画持续进行，我们需要调用 interaction controller的一个方法:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
    [interactionController updateInteractiveTransition:d];
} 
</code></pre>

<p>该方法会根据用户手指拖动的距离计算一个百分比，切换的动画效果也随着这个百分比来走，最酷的是，interaction controller会和animation controller一起协作，我们只使用了简单的UIView animation的动画效果，但是interaction controller却控制了动画的执行进度，我们并不需要吧interaction controller和Animation controller关联起来，因为所有这些系统都以一种解耦的方式自动地替我们完成了。</p>

<p>最后,我们需要更具用户收拾的停止状态来判断该操作是结束还是取消，先调用interaction controller 中对应的方法:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
        [interactionController finishInteractiveTransition];
    } else {
        [interactionController cancelInteractiveTransition];
    }
    navigationControllerDelegate.interactionController = nil;
}
</code></pre>

<p>注意，当切换完成或者取消的时候，记得把interaction controller设置为nil.因为如果下一次的转场是非交互的，我们不应该返回这个旧的interaction controller。</p>

<p>现在我们已经实现了一个完全自定义的可交互的转场动画了。通过简单的手势识别和UIKIT提供的一个类，用几行代码就达到完成了。对于大部分的应用场景，你读到这就够用了，使用上面提到的方法就可以达到你想要的动画效果了。但如果你想更深入了解转场动画或者交互效果进行深度定制，请继续阅读下面的内容。</p>

<h2>使用GPUImage定制动画</h2>

<p>下面我们就看看如何真正的，彻底的定制动画效果。这一次我们不实用UIviw animation,甚至连Core Animation也不用，完全自己来实现所有的动画效果。</p>

<p>我们使用 <a href="https://github.com/BradLarson/GPUImage">GPUImage</a>来实现一个非常漂亮的动画效果，这里我们实现的转场动画效果是：两个View controller像素化，然后相互消融在一起。实现方法是先对两个view controller进行截屏，然后再用GPUImage的图片滤镜（filter）处理这两张截图。</p>

<p>首先，我们先创建一个自定义类，这个类实现了UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning这两个协议：</p>

<pre><code>@interface GPUImageAnimator : NSObject
  &lt;UIViewControllerAnimatedTransitioning,
   UIViewControllerInteractiveTransitioning&gt;

@property (nonatomic) BOOL interactive;
@property (nonatomic) CGFloat progress;

- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@end
</code></pre>

<p>为了加速动画的运行，我们可以图片一次加载到GPU中，然后所有的处理和绘图都直接在GPU上执行，不需要再传送到CPU上处理（这种数据传输很慢）。通过使用GPUImageview，我们就可以直接使用OPenGL画图。</p>

<p>创建滤镜链(Filter chain)也非常的直观，我们可以直接在样例代码的setup方法中看到如何构造它。比较有挑战的是如何让滤镜也<code>动</code>起来。GPUImage没有直接提供给我们动画效果，因此我们需要每渲染一帧就更新一下滤镜来实现动态的滤镜效果。使用<em>CADisplayLink</em>可以完成这个工作：</p>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
</code></pre>

<p>在frame方法中，我们可以根据时间来更新动画进度，并相应地更新滤镜:</p>

<pre><code>- (void)frame:(CADisplayLink*)link
{
    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
    self.blend.mix = self.progress;
    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
    [self triggerRenderOfNextFrame];
}
</code></pre>

<p>好了，基本上这样就完成了。如果你想要实现交互式的转场效果，那么在这里，就不能使用时间，而是要根据手势来更新动画进度，其它的代码基本差不多。</p>

<p>这个功能非常强大，你可以使用GPUImage中任何已有的滤镜，或者写一个自己的OpenGL来达到你想要的效果。</p>

<h2>结论</h2>

<p>本文只探讨了在navigation controller中的两个view controller之间的转场动画，但是这些做法在tab bar  controller或者任何你自己定义的view controller容器中也是通用的。另外，在ios7中，<em>UIcollectionViewController</em>也进行了扩展，现在你可以在布局之间进行自动以及交互的动画切换，背后使用的也是同样的机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ColletionView布局]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju/"/>
    <updated>2016-04-24T21:05:32+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju</id>
    <content type="html"><![CDATA[<p>UICollectionView在ios6中第一次被引入，也是UIKit <a href="http://oleb.net/blog/2012/09/uicollectionview/">视图类中的一颗新星</a>
。它和UITableview共享一套API设计，但也在UItableView上做了一些扩展。UICOllectionView最强大，同时显著超出UITableView的特色就是其完全灵活的布局结构。这这篇文章中，<!--more--> 我们将会实现一个相当复杂的自定义Collection view布局，并且顺便讨论一下这个类设计的重要部分，项目的实例代码在 <a href="https://github.com/objcio/issue-3-collection-view-layouts">GitHub</a>上。</p>

<h2>布局对象(Layout Objects)</h2>

<p>UITableView和UICollectionView都是 data-source和delegate驱动的。他们在显示其子视图集的过程中仅扮演容器角色,且对子视图集真正的内容毫不知情。</p>

<p>UICollectioNView在此之上进行了进一步抽象。它将子视图的位置，大小和外观的控制权拖过给一个单独的布局对象。通过提供一个自定义布局对象，你技术可以实现任何你能想象到的布局。布局继承自UICollectionVieLayout抽象基类.IOS6中以UICollectionViewFloyLayout类的形式提出了一个具体的布局实现。</p>

<p>我们可以使用flow layout实现一个标准的gridview,这可能是colle tion view中最常见的使用案例了。尽管大多数人都这么想，但是Apple很聪明，没有明确的命名这个类为UIColletionViewGridLayout,而使用了更为通用的术语 flow layout,更好的描述了该类的功能：它通过一个接一个的放置cell来建立自己的布局，当需要的时候，插入横排或竖排的分栏符。通过自定义滚动方向，大小和cell之间的间距，flow layout 也可以在单行或单列中布局cell。实际上，UITableView的布局可以想象成flow layout的一种特殊情况。</p>

<p>在你准备自己写一个UICollectionViewLayout的子类之前，你需要问你自己，你是否能够使用UICollectionViewFlowlayout实现你心里的布局。这个类是<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout">很容易定制的</a>,并且可以继承本身进行进一步的定制，感兴趣的看<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4">这篇文章</a></p>

<h2>Cells和其他Views</h2>

<p>为了适应任意布局,collection view简历了一个类似，但比 table view更灵活的视图层级，像往常一样，你的主要内容显示在cell中，cell可以被任意分组到section中。CollectionView的cell必须是UICollectionViewCell的子类。除了cell，collection view额外管理着两种视图:supplementary views和decoration views.</p>

<p>collection view中的Supplemnetary views相当于table view的section header和footer views.像cells一样，他们的内容都有数据源对象驱动，然而和tableview 中用法不一样，supplementary view并不一定会作为header或footer view;他们的数量和位置完全由布局控制.</p>

<p>Decoration views纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从dataSource 获取的contents.当布局对象指定需要一个decoration view的时候，collection view会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views和decoration views必须是UICollectionReusableView的子类。布局使用的每个视图类都需要在collection view中注册，这样当data Source让它们从reuse pool中出列时，它们才能够创建新的实例。如果你是使用的interface Builder，则可以通过在可视化编辑器中拖拽一个cell到collection view上完成cell在collection view中的注册。同样的方法也可以用在supplementary view上，前提是你使用了UIcollectionviewFlowLayout.如果没有，你只能通过调用 <code>registerClass:</code>或者<code>registerNib:</code>方法手动注册视图类了。你需要在<code>viewDidload</code>中做这些操作.</p>

<h2>自定义布局</h2>

<p>作为一个非常有意义的自定义collection view布局的例子，我们不妨想一个典型的日历应用程序中的周视图。日历一次显示一周，星期中的每一天现在列中，每一个日历事件将会在我们的colleectio view中以一个cell显示，位置和大小代表事件起始日期事件和持续时间。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/calendar-collection-view-layout.png" alt="test" />
一般有两种类型的 collection view布局:</p>

<ol>
<li>独立于内容的布局计算.这正是你所知道的像UITableview和UIcollectionViewFlowLayout这些情况。每个cell的位置和外观不是基于其显示的内容，但所有cell的显示顺序是基于内容的顺序。可以把默认的flow layout作为例子。每个cell都是基于前一个cell的放置(或者如果没有足够的空间，则从下一行开始).布局对象不必访问实际数据来计算布局.</li>
<li>基于内容的布局计算。我们的日历视图正式这样类型的例子。为了计算显示事件的气势和街二叔事件，布局对象需要直接访问 collection view的数据源。在很多情况下，布局对象不仅需要取出当前可见cell的数据，还需要从所有记录中取出一些决定当前那些cell可见的数据。</li>
</ol>


<p>在我们的日历示例中，布局对象如果访问某一个矩形内的cells的属性，那就必须迭代数据源提供的所有事件来决定那些位于要求的时间窗口个中。与一些相对简单，数据源独立计算的flow layout比起来，这足够计算出cell在一个矩形内的index paths了（假设网格中所有的cells的大小都一样）.</p>

<p>如果有一个依赖内容的布局，那就是暗示你需要些自定义的布局类了，同时不能使用自定义的UICOllectionViewFlowLayout，所以这正是我们需要做的事情。</p>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html">UICollectionViewLayout文档</a>列出了子类需要重写的方法.</p>

<h2>collectionViewContentSize</h2>

<p>由于 collection view对它的content并不知情，所以布局首先要提供的信息就是滚动区域的大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。注意，尽管大多数经典的collection view限制在一个轴方向上滚动(正如UIcollectionviewFlowLayout一样)，但是这不是必须的。</p>

<p>在我们的日历示例中，我们想要视图垂直的滚动。比如，如果我们想要在垂直空间上一个小时占去100点，这样显示一整天的内容高度就是2400点。注意，我们不能够水平滚动，这就意味这我们collectionview只能显示一周。为了能够在日历中的多个星期间分页，我们可以在一个独立的scroll view中（可以使用U<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html">IPageViewController</a>）中使用多个 collection view（一周一个）,或者坚持使用一个collection view并且返回足够大的内容宽度，这回使得用户感觉在两个方向上滑动自由。</p>

<pre><code>- (CGSize)collectionViewContentSize
{
    // Don't scroll horizontally
    CGFloat contentWidth = self.collectionView.bounds.size.width;

    // Scroll vertically to display a full day
    CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay);

    CGSize contentSize = CGSizeMake(contentWidth, contentHeight);
    return contentSize;
}
</code></pre>

<p>为了简单起见，我选择布局在一个非常简单的模型上：假定每周天数相同，每天时长相同，也就是说天数用0-6表示。在一个真实的日历程序中，布局将会为自己的几段大量使用基于 <code>NSCalendaar</code>的日期</p>

<h2>layoutAttributesForElementsInRect：</h2>

<p>这是任何布局类中最重要的方法了，同时可能也是最容易让人迷惑的方法。collection view调用这个方法并传递一个自身坐标系统中的矩形过去。这个矩形代表了这个视图的可见矩形区域(也即是它的bounds)，你需要准备好处理传给你的任何矩形。</p>

<p>你的视线必须返回一个包含 UICollectionviewLayoutAttributes对象的数组，为每一个cell包含一个这样的对象，supplementary View或decoration view在矩形区域内是可见的。UICollectionViewLayoutAttributes类包含了colletion view内item的所有相关的布局属性。默认情况下，这个类包含 frame,center,size,transform3D,alpha,Zindex和hidden属性。如果你的布局想要控制其他视图的属性(比如背景颜色)，你可以创建一个UICollectionViewLayoutAttributes的子类，然后加上你自己的属性。</p>

<p>布局属性对象(Layout attributes objects)通过indexPath属性和他们对应的cell,supplementary view或者decoration view关联在一起。collection view为所有items从布局对象中请求到布局属性后，它将会实例化所有视图，并将对应的属性应用到每个视图上去。</p>

<p>注意!这个方法涉及到所有类型的视图，也就是cell,supplementary views和decoration views.一个幼稚的实现可能会选择忽略传入的矩形，并且为collection view中所有的视图返回布局属性。在原型设计和开发布局阶段，这是一个有效的方法。但是，这将会性能产生非常坏的影响，特别是可见cell远少于所有cell数量的时候，collection view和布局对象将会为那些不可见的而试图做额外不必要的工作。</p>

<p>你的视线需要做这几步:</p>

<ol>
<li>创建一个空的可变数组来存放所有的布局属性</li>
<li>确定index paths中那些cells的frame完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你视线的<code>layoutattributesForItemIndexPath:</code>方法为每个index path创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</li>
<li>如果你的布局包含supplementary views,计算矩形内可见supplementary view的index paths.在循环中调用你实现的<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>,并且将这些对象加到数组中。通过为kind参数传递你选择的不同字符，你可以却分出不同种类的supplementary views(比如headers和footers)。当需要创建视图时，collectionview会将kind字符传回到你的数据源。记住supplermentary 和decoration views的数量和种类完全有布局控制。你不会受到headers和footers的限制.</li>
<li>如果布局包含decoration views，计算矩形内可见decoration views的index paths.在循环中调用你实现的<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>
，并且将这些对象加到数组中</li>
<li>返回数组</li>
</ol>


<p>我们自定义的布局没有使用 decoration views,但是使用了两种supplermentary views(column headers和row headers):</p>

<pre><code>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
{
    NSMutableArray *layoutAttributes = [NSMutableArray array];
    // Cells
    // We call a custom helper method -indexPathsOfItemsInRect: here
    // which computes the index paths of the cells that should be included
    // in rect.
    NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect];
    for (NSIndexPath *indexPath in visibleIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForItemAtIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }

    // Supplementary views
    NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect];
    for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForSupplementaryViewOfKind:@"DayHeaderView"
                               atIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }

    NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect];
    for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForSupplementaryViewOfKind:@"HourHeaderView"
                               atIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }
    return layoutAttributes;
}
</code></pre>

<h2>layoutAttributesFor…IndexPath</h2>

<p>有时，collection view会为某个特殊的cell,supplementary 或者decoration view向布局对象请求布局属性，而非所有可见的对象。这就是当其他三个方法开始起作用时，你实现的<code>layoutAttributesForItemAtIndexPath:</code>需要创建并返回一个单独的布局属性对象，这样才能正确的格式化传给你的index path 所对应的cell.</p>

<p>你可以通过调用<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，然后根据index path修改属性。为了得到需要显示在这个index path内的数据，你可能需要访问collection view的数据源。到目前为止，至少确保设置了frame尚需经，除非你所有的cell都位于彼此上方。</p>

<pre><code>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
{
    CalendarDataSource *dataSource = self.collectionView.dataSource;
    id event = [dataSource eventAtIndexPath:indexPath];
    UICollectionViewLayoutAttributes *attributes =
    [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
    attributes.frame = [self frameForEvent:event];
    return attributes;
}
</code></pre>

<p>如果你正在使用自动布局，你可能会赶到惊讶，我们正在直接修改布局参数的frame属性，而不是和约束共事，但这正是UIcollectionViewLayout的工作。尽管你坑你使用自动布局来定义collection view的frame和它内部每个cel的布局，但cells的frames还是需要通过老式的方法计算出来。</p>

<p>类似的，<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>和<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>方法分别需要为supplementary 和decoration views做相同的事。只有你的布局包含这样的视图你才需要实现这两个方法。UICollectionViewlayoutAttributes包含另外两个工厂方法，</p>

<p><code>+layoutAttributesForSupplementaryViewOfKind:withIndexPath:</code> 和 <code>+layoutAttributesForDecorationViewOfKind:withIndexPath:</code>，用他们来创建正确的布局属性对象</p>

<h2>shouldInvalidateLayoutForBoundsChange:</h2>

<p>最后，当collection view的bounds改变时，布局需要告诉collection view是否需要重新计算布局。我的猜想是：当collectionview改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个优质的实现可能只会简单的返回YES。芮然实现功能很重要，但是scrollview的bounds在滚动时也会改变，这意味着你的布局美妙会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。</p>

<p>当collection view的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view将它的bounds传给<code>shouldInvalidateLayoutForBoundsChange:</code>方法，这样我们便能比较视图当前的bounds和新的bounds来确定返回值</p>

<pre><code>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
{
    CGRect oldBounds = self.collectionView.bounds;
    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
        return YES;
    }
        return NO;
}
</code></pre>

<h2>动画</h2>

<h3>插入和删除</h3>

<p>UITableview中的cell自带了一套非常漂亮的插入和删除的动画。但是当为UIcollectionView增加和删除cell定义动画功能时，UIKit工程师们遇到这样一个问题：如果Collection view的布局是完全可变的，那么预先定义好的动画就没办法和开发者自定义的布局很好的融合。他们提出了一个优雅的方法：当一个cell(或者supplementary 或者 decoration View)被插入到collection view中时，collection View不仅向其布局请求cell正常正常状态下的布局尚需经，同时还请求其初始的布局尚需经，比如，需要在开始有插入动画的cell。CollectionView会简单的创建一个anmiation block,并在这个block中，将所有cell的属性从初始状态改变到常态</p>

<p>通过提供不同的初始布局属性，你可以完全自定义插入动画。比如设置初始的alpha为0将会产生一个淡入的动画。同时设置一个平移或者缩放将会产生移动缩放的效果。</p>

<p>同样的原理应用到删除上，这次动画是从常态到一些列你设置的最终布局属性。这些逗你需要在布局类中为initial或final布局参数实现的方法:</p>

<pre><code>initialLayoutAttributesForAppearingItemAtIndexPath:

initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:

initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:

finalLayoutAttributesForDisappearingItemAtIndexPath:

finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:

finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:
</code></pre>

<h2>布局间切换</h2>

<p>可以通过类似的方式将一个collection view布局动态的切换到另外一个布局。当发送一个<code>setCollectionViewLayout:animated:</code>消息时，collection view会为cells在新的布局中查询新的布局参数，然后动态的将每个cell从旧参数变换到新的布局参数。你不需要做任何事情。</p>

<h2>结论</h2>

<p>根据自定义collection view布局的复杂性，写一个通常很不容易。确切的说，本质上这和从头写一个完整的实现相同布局自定义视图类一样困难了。因为所涉及的计算需要确定去那些子视图是当前可见的，以及他们的位置。尽管如此，使用UIcollectionview还是给你带来了一些很好的效果，比如cell重用，自动支持动画，更不要提整洁的独立布局，子视图管理。</p>

<p>自定义collection view布局也是向<a href="http://objccn.io/issue-1-1/">轻量级view Controller</a>迈出了很好的异步，正如你的view controller不要包含任何布局代码。应该和一二个独立的dataSource类结合在一起，collection view的视图控制器将很难再包含任何代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OHHTTPStubs介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao/"/>
    <updated>2016-04-22T17:18:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>是一个模拟网络请求的一个框架，它使用起来非常方便和强大，它能帮你</p>

<ol>
<li>测试你的app仿真一个服务器（比如加载一个本地文件）,模拟网络慢的情况等</li>
<li>使用伪造的网络数据编写单元测试</li>
</ol>


<!--more-->


<h2>简单用法</h2>

<h2>在Objc中</h2>

<pre><code>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
  return [request.URL.host isEqualToString:@"mywebservice.com"];
} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {
  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
  NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
            statusCode:200 headers:@{@"Content-Type":@"application/json"}];
}];
</code></pre>

<h2>在swift中</h2>

<pre><code>stub(isHost("mywebservice.com")) { _ in
  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
  let stubPath = OHPathForFile("wsresponse.json", self.dynamicType)
  return fixture(stubPath!, headers: ["Content-Type":"application/json"])
}
</code></pre>

<h2>语法讲解</h2>

<p><code>OHHTTPStubs stubRequestsPassingTest:</code>方法创建了模拟服务器，<code>request</code>是请求的标准判断，比如</p>

<pre><code>[request.URL.host isEqualToString:@"mywebservice.com"]
</code></pre>

<p>意思就是如果请求的url是<code>mywebservice.com</code>，我们就返回response,要不然不执行</p>

<pre><code> NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
            statusCode:200 headers:@{@"Content-Type":@"application/json"}];
</code></pre>

<p>返回一个respoinse,其中包含了返回的数据，</p>

<ol>
<li>获取的一个本地文件</li>
<li>返回的状态码 200  (200表示正确返回)</li>
<li>headers：返回的头,如果是json一般是:@{@&ldquo;Content-Type&rdquo;:@&ldquo;application/json&rdquo;}</li>
</ol>


<h1>快速开始一个Demo</h1>

<h2>创建一个空工程</h2>

<p>用xcode创建一个工程，用pods创建一个Podfile</p>

<p>内容如下:</p>

<pre><code>pod 'OHHTTPStubs', '~&gt; 5.0.0'

target :OHHTTPStubsDemoTests, :exclusive =&gt; true do
    link_with 'OHHTTPStubsDemoTests'

    pod 'OHHTTPStubs'
end
</code></pre>

<p>执行 <code>pod install</code></p>

<p>成功安装OHHTTPStubs后，在OHHTTPStubsDemoTests目录中编写测试类:</p>

<h3>创建session</h3>

<p>在顶部声明一个变量session</p>

<pre><code>@property (nonatomic,strong) NSURLSession *session;
</code></pre>

<p>在setUp方法中，创建该变量实例:</p>

<pre><code>self.session=[NSURLSession sharedSession];
</code></pre>

<p>在 testExample()方法中：</p>

<pre><code>/**
 *  返回自定义的普通文本
 */
- (void)testExample {

    //开始模拟服务器
    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
        //发送请求的url后缀必须是.com结尾的
        return [request.URL.pathExtension isEqualToString:@"com"];
    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
        //创建一个字符串
        NSData * stubData = [@"hello world" dataUsingEncoding:NSUTF8StringEncoding];
        //响应数据
        /**
         *  responseWithData:返回的数据
            statusCode:状态码,200表示成功
            headers:http的header
         */
        return [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:@{@"Content-Type":@"text/plain"}];
    }];


    //在XCT测试框架中，这个表示期望值，因为这个期望值是支持异步测试的，我们是异步请求，所以一定要是使用XCTestExpectation这个特性
     XCTestExpectation *expectation=[self expectationWithDescription:@"sessionDataTask expectation"];

    //创建session任务
    NSURLSessionDataTask *dataTask=[self.session dataTaskWithURL:[NSURL URLWithString:@"hello.com"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {

        //解析返回的字符串
        NSString *resultStr=[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];

        NSLog(@"返回的数据:%@",resultStr);

        XCTAssert(resultStr!=nil);

        //断言返回的字符串是hello world,如果不是，则断言失败
        XCTAssertTrue([resultStr isEqualToString:@"hello world"]);

        //在想异步测试的地方加上下面这行代码
        [expectation fulfill];
    }];
    //启动任务
    [dataTask resume];


    //使用XCTestExpectation,必须设置如下的waitForExpectationsWithTimeout方法，如果超时则失败
    [self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) {
        if(error){
            NSLog(@"出错了:%s",__FUNCTION__);
        }
    }];


}
</code></pre>

<p>这里面使用到了 <code>XCTestExpectation</code>，这是特性是用来测试异步程序代码的。在想测试异步代码的地方加上<code>[expectation fulfill];</code>,
最后，要加上<code>waitForExpectationsWithTimeout</code>方法，它们是配对出现的。</p>

<p>OHHTTPStubs创建了模拟服务器后，下面发的任何网络请求都会被模拟服务器返回，正如上面的代码所示，测试结果:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-3.png" alt="test" />
断言成功！</p>

<h2>添加本地文件</h2>

<ol>
<li>在本地创建一个stub.txt的文本文件，内容自定</li>
<li>在本地创建一个stub.jpg的图片，图片自定</li>
</ol>


<p>图片
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-5.png" alt="1" /></p>

<p>文本
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-4.png" alt="2" /></p>

<h3>创建文本的TextStub</h3>

<pre><code>/**
 *  创建文本的TextStub
 */
-(void)createTextStub{
    // #1
    static id&lt;OHHTTPStubsDescriptor&gt; textStub = nil;

    // #2
    textStub= [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
        return [request.URL.pathExtension isEqualToString:@"txt"];
    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {

        NSString *path = OHPathForFile(@"stub.txt",self.class);

       //#3
        return [[OHHTTPStubsResponse responseWithFileAtPath:path
                                                 statusCode:200 headers:@{@"Content-Type":@"text/plain"}]
                requestTime:1.0f
                responseTime:OHHTTPStubsDownloadSpeedWifi];

    }];
    //#4
    textStub.name = @"text stub";
}
</code></pre>

<p>上面代码意义如下:</p>

<ol>
<li>声明一个返回的OHHTTPStubsDescriptor,这是创建模拟服务器的返回结果描述</li>
<li>开始创建模拟服务器</li>
<li>返回response，其中设置了返回数据，状态码，请求时间等</li>
<li>给textStub起个名字</li>
</ol>


<h2>测试文本的模拟服务器</h2>

<p>创建一个testStubTextTask方法:</p>

<pre><code>/**
 *  测试文本的Stub任务
 */
-(void)testStubTextTask{
    //创建文本的模拟服务器
    [self createTextStub];
    //创建一个期望值
    XCTestExpectation *expection=[self expectationWithDescription:@"high expection"];

    NSURLSession *session=[NSURLSession sharedSession];

    NSString *urlString=@"stub.txt";
    NSURLSessionDataTask *dataTask = [session dataTaskWithURL:[NSURL URLWithString:urlString] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {

        NSString* receivedText = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
        NSLog(@"返回的结果:%@",receivedText);

        XCTAssert(receivedText!=nil);

        [expection fulfill];
    }];

    [dataTask resume];

    [self waitForExpectationsWithTimeout:5 handler:^(NSError * _Nullable error) {
        if(error){
            NSLog(@"出错了:%@",error.description);
        }
    }];
}
</code></pre>

<h2>创建图片的stub</h2>

<pre><code>/**
 *  创建Image的stub
 */
-(void)createImageStub{
    static id&lt;OHHTTPStubsDescriptor&gt; imageStub = nil;

    imageStub=[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
        return [request.URL.pathExtension isEqualToString:@"png"];
    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
        return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFile(@"stub.jpg", self.class) statusCode:200 headers:@{@"Content-Type":@"image/jpeg"}];
    }];

    imageStub.name=@"Image stub";
}
</code></pre>

<h2>测试Image的模拟服务器</h2>

<pre><code>/**
 *  测试Image的模拟服务器
 */
- (void)testImageStubTask{

    [self createImageStub];

    XCTestExpectation *expection=[self expectationWithDescription:@"Image Expection"];

    NSURLSessionDataTask *dataStask=[self.session dataTaskWithURL:[NSURL URLWithString:@"test.png" relativeToURL:nil] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {

        UIImage *image=[UIImage imageWithData:data];

        NSLog(@"返回的image:%@",image.description);

        XCTAssert(image!=nil);

        [expection fulfill];

    }];

    [dataStask resume];

    [self waitForExpectationsWithTimeout:3 handler:^(NSError * _Nullable error) {
        if(error){
            NSLog(@"出错了:%@",error.description);
        }
    }];

}
</code></pre>

<h2>完整工程</h2>

<p><a href="https://github.com/TLOpenSpring/OHHTTPStubsDemo/archive/master.zip">完整工程在这里下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试并发程序]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu/"/>
    <updated>2016-04-21T17:38:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试时一个很重要的工具。在过去，当并发不是应用程序架构中重要组成部分的时候，测试就想单简单。随着这几年的发展，使用并发设计模式变得越来越重要了，想要测试好并发应用程序，已成了一个不小的挑战.</p>

<!--more-->


<p>测试并发代码最主要的困难在于程序或信息流不是反应在调用堆栈上。函数并不会立即返回给调用者，而是通过回调函数block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然后，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h1>异步测试的问题</h1>

<p>首先，我们来看一个简单地同步单元测试的例子，两个数求和的方法.</p>

<pre><code>+ (int)add:(int)a to:(int)b {
    return a + b;
}
</code></pre>

<p>测试这个方法很简单，只需要比较该方法返回值是否和期望值相同，如果不相同，则测试失败。</p>

<pre><code>- (void)testAddition {
    int result = [Calculator add:2 to:2];
    STAssertEquals(result, 4, nil);
}
</code></pre>

<p>接下来，我们利用block将该方法改成异步返回结果，为了模拟测试失败，我们会在方法实现中故意添加一个bug.</p>

<pre><code>+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
        block(a - b); // 带有bug的实现
    }];
}
</code></pre>

<p>虽然这是一个人为的例子，但是它却真实的反映了编程中可能经常遇到的问题，只不过实际过程更加复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到Block中。尽管我们的方法实现中存在bug,但是这种测试永远不是失败的；</p>

<pre><code>// 千万不要使用这些代码！
- (void)testAdditionAsync {
    [Calculator add:2 to:2 block:^(int result) {
        STAssertEquals(result, 4, nil); // 永远不会被调用到
    }];
}
</code></pre>

<p>这里的断言为什么没失败呢？</p>

<h1>关于SenTestingKit</h1>

<p>在老版本的xcode中所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKit-call-stack.png" alt="test" /></p>

<p>在测试框架在主run loop开始运行之后，主要执行了一下几个步骤:</p>

<ol>
<li>配置一个包含所有相关测试的测试包</li>
<li>运行测试包，内部会调用所有以test开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。</li>
<li>调用exit()退出测试</li>
</ol>


<p>这其中我们最感兴趣的是单个测试时如何被调用的。在异步测试中，包含断言的Block会被加到run loop。当所有的测试执行完毕后，测试框架就会退出，而block却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方法来解决这个问题。但是素有的方法都必须在住run loop中运行，而且在测试方法返回和比较结果之前需要处理已入队的所有操作。</p>

<p><a href="https://github.com/allending/Kiwi">kiwi</a>使用测试轮询，它可以在测试方法中被滴啊用。<a href="https://github.com/gabriel/gh-unit/">GHUnit</a>编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接受一个通知。以上两种方式都是通过编写相应的代码来确保异步异步测试方法在测试结束之前都不会返回。</p>

<h1>SenTesgingKit的异步扩展</h1>

<p>我们对这个问题的解决方案是对SenTestingKit添加一个扩展，它在栈上使用同步执行，并把每个部分加入到主队列中。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或失败的Block就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKitAsync-call-stack.png" alt="test" /></p>

<p>如果测试方法以Async结尾，框架就睡认为该方法是异步测试。此外，在异步测试中，我们必须手动的报告测试成功，同时为了防止Block永远不会被调用，我们还需要添加了一个超时方法，之前的错误的测试方法修改如下:</p>

<pre><code>- (void)testAdditionAsync {
    [Calculator add:2 to:2 block^(int result) {
        STAssertEquals(result, 4, nil);
        STSuccess(); // 通过调用这个宏来判断是否测试成功
    }];
    STFailAfter(2.0, @"Timeout");
}
</code></pre>

<h1>设计异步测试</h1>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的Bug,在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识.</p>

<p>为了运行到实际中，我们创建了一个实例框架: <a href="sd">AsyncTestDemo</a>,它从一个虚拟的服务器获取图像信息，框架中包含了一个资源管理器，它对外提供了一个可以根据图像Id获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/PinacotecaCore.png" alt="test" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试:</p>

<ol>
<li>模型层</li>
<li>模拟服务器请求的服务器接口控制器(API Controller)</li>
<li>管理Core data堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>


<h2>模型层</h2>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的core data堆栈，并在其中执行各自的操作。</p>

<p>在这个测试实例中，我们就是在 setup 方法中设置core data堆栈，然后检查 PCImage实体的描述是否存在，如果不存在就构造一个，并更新它的值，当然这和异步测试没有关系，我们就不深入细说了。</p>

<h2>服务器接口控制器</h2>

<p>框架中的第二个组件就是服务器接口控制器，它主要处理服务器请求以及服务器API到模型的映射关系。让我们来看一下下面这个方法:</p>

<pre><code>- [PCServerAPIController fetchImageWithId:queue:completionHandler:]
</code></pre>

<p>调用它需要三个形参：一个图片对象Id，所在的执行队列，以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好<a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个bundle,发送给客户端。</p>

<p>为了能stub请求，OHHTTPStubs需要在测试类初始化时或者 setup方法中进行配置。首先我们需要加载一个包含请求响应对象(response)的bundle:</p>

<pre><code>NSURL *url = [[NSBundle bundleForClass:[self class]]
                        URLForResource:@"ServerAPIResponses"
                         withExtension:@"bundle"];

NSBundle *bundle = [NSBundle url];
</code></pre>

<p>然后我们从bundle加载response对象，作为请求的响应值:</p>

<pre><code>OHHTTPStubsResponse *response;
response = [OHHTTPStubsResponse responseNamed:@"images/123"
                                   fromBundle:responsesBundle
                                 responseTime:0.1];

[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
    return YES /* 如果所返回的request是我们所期望的，就返回YES */;
} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
    return response;
}];
</code></pre>

<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m">测试服务器接口控制器</a>如下:</p>

<pre><code>- (void)testFetchImageAsync
{
    [self.server
        fetchImageWithId:@"123"
                   queue:[NSOperationQueue mainQueue]
       completionHandler:^(id imageData, NSError *error) {
          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
          STAssertNil(error, [error localizedDescription]);
          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);

          // 检查返回的字典中的值.

          STSuccess();
       }];
    STFailAfter(2.0, nil);    
}
</code></pre>

<h2>资源管理器</h2>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和膜形成呢个联系起来，还管理着core data堆栈。下面我们想测试获取一个图片对象的方法:</p>

<pre><code>-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]
</code></pre>

<p>该方法根据Id返回一个图片对象。如果图片在数据库中不存在，它会创建一个包含Id的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用<a href="http://ocmock.org/">OCMock</a>来模拟，如果要做方法的部分stub,它是一个理想的框架.如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m">资源管理器测试</a>:</p>

<pre><code>OCMockObject *mo;
mo = [OCMockObject partialMockForObject:self.resourceManager.server];

id exp = [[serverMock expect] 
             andCall:@selector(fetchImageWithId:queue:completionHandler:)
            onObject:self];
[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];
</code></pre>

<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们卸载测试类中的方法。</p>

<p>用上面的作坊，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的使我们模拟的服务器接口控制器的方法，这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<pre><code>- (void)testGetImageAsync
{
    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
    __block PCImage *img;
    img = [self.resourceManager imageWithId:@"123"
                  usingManagedObjectContext:ctx
                                      queue:[NSOperationQueue mainQueue]
                              updateHandler:^(NSError *error) {
                                       // 检查error是否为空以及image是否已经被更新 
                                       STSuccess();
                                   }];    
    STAssertNotNil(img, nil);
    STFailAfter(2.0, @"Timeout");
}
</code></pre>

<h1>总结</h1>

<p>刚开始的时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了他们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>😀fun~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中的多任务]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu/"/>
    <updated>2016-04-19T10:17:49+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu</id>
    <content type="html"><![CDATA[<p>在ios7之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限，除了VOIP和基于地理位置特性之外，唯一能做的地方就是后台任务(background tasks)让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，或者备份用户的照片到你的服务器上，你都仅能完成一部分工作.</p>

<p> <!--more--></p>

<p>ios7添加了两个新的API以便你的程序可以在后台更新界面以及内容。首先是后台获取(background Fetch)，它允许你定义地从网络获取新的内容。第二个API就是远程通知(Remote Notifications)，这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务(Background Trasnfer service)中执行定期的任务，也允许你在进程之外可以执行网络传输(下载和上传)工作</p>

<p>后台获取(Background Fetch)和远程通知(Remote notification)基于简单的 ApplicationDelegate钩子，在应用程序挂起之前的30秒时间执行工作。它们不是用于CPU频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>

<p>对于用户来说,多任务处理有点显而易见的改变就是新的应用切换程序，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的&ndash;现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络，新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>

<h2>后台获取</h2>

<p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前出发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午一点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你想系统报告新数据无法获取，ios会适应并使用此信息避免会继续获取。</p>

<p>开启后台获取的第一步是在info plist文件中对UIBackgroundModes键指定特定的值。最简单的途径是在Xcode的project editor中新的Capabilities标签页设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/capabilities-on-bgfetch.jpg" alt="logo" /></p>

<p>或者你可以手动配置这个值</p>

<pre><code>&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;
    &lt;string&gt;fetch&lt;/string&gt;
&lt;/array&gt;  
</code></pre>

<p>接下来，告诉IOS多久进行一次数据获取</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];

    return YES;
}
</code></pre>

<p>ios默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该制定一个你想要的时间间隔。例如，一个天气的应用程序，可能只需要几个小时更新一次，IOS将会在后台获取之间至少等待你指定的时间间隔。</p>

<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把minimumBackgroundFetchInterval设置为UIApplicationBackgroundFetchIntervalNever,专业那个可以节省资源。</p>

<p>最后一步是在应用程序委托中实现下列方法:</p>

<pre><code>- (void)                application:(UIApplication *)application 
  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];

    NSURL *url = [[NSURL alloc] initWithString:@"http://yourserver.com/data.json"];
    NSURLSessionDataTask *task = [session dataTaskWithURL:url 
                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

        if (error) {
            completionHandler(UIBackgroundFetchResultFailed);
            return;
        }

        // 解析响应/数据以决定新内容是否可用
        BOOL hasNewData = ...
        if (hasNewData) {
            completionHandler(UIBackgroundFetchResultNewData);
        } else {
            completionHandler(UIBackgroundFetchResultNoData);
        }
    }];

    // 开始任务
    [task resume];
}
</code></pre>

<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有30秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面，30秒时间应该足够去网络获取数据和获取界面的缩略图，但是最多只有30秒，当完成了网络请求和更新界面后，你应该执行完成的回调。</p>

<p>完成回调的执行有两个目的，首先，系统会估量你的进程消耗的电量，并根据你传递的UIBackgroundFetchResult参数记录新数据是否可用，其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器，当用户在应用间切换时，用户将会看到新内容，这种通过completion handler来报告并且生成截图的方法，在新的多任务处理API中是很常见的。</p>

<p>在实际的应用中，你应该将completionHandler传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>

<p>在这里，你可能想知道ios是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的声明周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想象为用户从Springboard启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>

<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看UIAppcation的applicationState属性来判断应用是不是从后台启动。</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSLog(@"Launched in background %d", UIApplicationStateBackground == application.applicationState);

    return YES;
}
</code></pre>

<h2>测试后台数据获取</h2>

<p>有两种可以模拟后台获取的途径。最简单是从Xcode运行你的应用，当应用运行时，在Xcode的Debug菜单选择Simulate Background Fetch.</p>

<p>第二种方法，使用scheme更改Xcode运行程序的方式。在Xcode菜单的Product选项，选择Scheme然后选择Manager Schemes.在这里，你可以编辑或者添加一个新的scheme,然后选中Launch due to a background fetch event ,如下图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/edit-scheme-simulate-background-fetch.png" alt="logo" /></p>

<h2>远程通知</h2>

<p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时消息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载一遍离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中有两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候的才会启动。</p>

<p>一条远程通知实际上只是一条普通的带有content-available 标志的推送通知。你可以发送一条带有提醒消息的推送去告诉用户有事情发生了，同时在后台对界面进行更新。但远程通知也可以做到安静的，没有提醒消息或者任何声音 的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>

<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。ios和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，知道设备下次发送保持活动状态的数据包，或者受到另外一个通知。</p>

<h2>发送远程通知</h2>

<p>要发送一条远程通知，需要在推送通知的有效负载设置content－available 标志。content－available 标志和用来通知报刊应用的键值是一样的。因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>

<p>我建议在开发的时候，使用<a href="http://nomad-cli.com/#houston">Nomand CLI&rsquo;s Houston</a>工具发送推送消息，当然你可以使用你喜欢的库或者脚本。</p>

<p>你可以通过nomad-cli ruby gem来安装Houston</p>

<pre><code>gem install nomad-cli
</code></pre>

<p>然后通过包含在Noman的apn实用工具发送一条通知:</p>

<pre><code># Send a Push Notification to your Device
apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42
</code></pre>

<p>在这里，-n标志指定应该包含content-available 健值,-d标志允许添加我们自定义的数据键值到有效负荷.
通知的有效负荷(payload)结果和下面类似:</p>

<pre><code>{
    "aps" : {
        "content-available" : 1
    },
    "content-id" : 42
}
</code></pre>

<p>ios7中添加了新的应用程序委托方法，当接收到一条带有 content－available的推送通知时，下面的方法会被调用:</p>

<pre><code>- (void)application:(UIApplication *)application 
  didReceiveRemoteNotification:(NSDictionary *)userInfo 
        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSLog(@"Remote Notification userInfo is %@", userInfo);

    NSNumber *contentID = userInfo[@"content-id"];
    // 根据 content ID 进行操作
    completionHandler(UIBackgroundFetchResultNewData);
}
</code></pre>

<p>和后台抓取一样，应用程序进入后台启动，也有30秒时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>

<h2>NSurlSession和后台传输服务(Background Transfer Service)</h2>

<p>NSURLSession是ios7添加的一个新类，它也是Foundation Networking中的新技术。作为NSURLConnection的替代品，一些熟悉的概念和类都保留下来了，例如NSURL,NSURLRequest,NSURLResponse.所以，你可以使用NSURLSessionTask这一NSURLConnnection的替代品，来处理网络请求及响应。一共有3种回话任务：数据，下载和上传。每一种都向NSURLSessionTask添加了语法糖，根据你的需要，适当选择一种。</p>

<p>一个NSURLSession对象协调一个或多个NSURLSessionTask对象，并根据NSURLSessionTask创建的NSURLSessionConfiguration实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的NSURLSessionTask对象。要利用后台传输服务，你将会使用<code>[NSURLSessionConfiguration backgroundSessionConfiguration]</code>来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>

<p>NSURLSessionConfiguration允许你设置默认的HTTP头，配置缓存策略，限制使用蜂窝煤数据等等。其中一个选项是discretionary标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备足够电量时，设备才通过wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>

<p>目前为止，我们大概了解了NSURLSession，以及一个后台回话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传入服务的下载队列。当下载完成后，我们会通知用户该文件已经可以用了。</p>

<h2>NSURLSessionDownloadTask</h2>

<p>首先，我们先处理一条远程通知，并把一个NSURLSessionDownloadTask添加到后台传输服务的队列。在backgroundURLSession方法张，我们根据后台回话配置，创建一个NSURLSession对象，并把application delegate作为回话的委托对象。文档不建议对于相同的标识符(identifier)创建多个回话对象，所以我们使用dispatch_once来避免潜在的问题：</p>

<pre><code>- (NSURLSession *)backgroundURLSession
{
    static NSURLSession *session = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        NSString *identifier = @"io.objc.backgroundTransferExample";
        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
        session = [NSURLSession sessionWithConfiguration:sessionConfig 
                                                delegate:self 
                                           delegateQueue:[NSOperationQueue mainQueue]];
    });

    return session;
}

- (void)           application:(UIApplication *)application 
  didReceiveRemoteNotification:(NSDictionary *)userInfo 
        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSLog(@"Received remote notification with userInfo %@", userInfo);

    NSNumber *contentID = userInfo[@"content-id"];
    NSString *downloadURLString = [NSString stringWithFormat:@"http://yourserver.com/downloads/%d.mp3", [contentID intValue]];
    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];

    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];
    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];
    task.taskDescription = [NSString stringWithFormat:@"Podcast Episode %d", [contentID intValue]];
    [task resume];

    completionHandler(UIBackgroundFetchResultNewData);
}
</code></pre>

<p>我们使用NSURLSession类方法创建爱你一个下载任务，配置请求，并提供说明供以后使用。因为所有回话任务一开始处于挂起状态，你必须谨记要调用[task resume]保证开始了任务。</p>

<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现NSURLSessionDelegate或NSURLSessionTaskDelegate的方法，你应该阅读Apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42">Life Cycle of a URL Session with Custom Delegates</a>文档，它讲解了所有类型回话任务的完成生命周期。</p>

<p>NSURLSessionDownloadDelegate中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时URL.你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>

<pre><code>#Pragma Mark - NSURLSessionDownloadDelegate

- (void)         URLSession:(NSURLSession *)session 
               downloadTask:(NSURLSessionDownloadTask *)downloadTask
  didFinishDownloadingToURL:(NSURL *)location
{
    NSLog(@"downloadTask:%@ didFinishDownloadingToURL:%@", downloadTask.taskDescription, location);

    // 用 NSFileManager 将文件复制到应用的存储中
    // ...

    // 通知 UI 刷新
}

- (void)  URLSession:(NSURLSession *)session 
        downloadTask:(NSURLSessionDownloadTask *)downloadTask 
   didResumeAtOffset:(int64_t)fileOffset 
  expectedTotalBytes:(int64_t)expectedTotalBytes
{
}

- (void)         URLSession:(NSURLSession *)session 
               downloadTask:(NSURLSessionDownloadTask *)downloadTask 
               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten 
  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
}
</code></pre>

<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会受到一系列消息。App delegate的: handleEventsForBackgroundURLSession：方法会在这些NSURLSession委托的消息发送前被调用，然后URLSessionDidFinishEventsForBackgroundURLSession在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler）,并在后面的方法中执行回调以便更新界面:</p>

<pre><code>- (void)                  application:(UIApplication *)application 
  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
{
    // 你必须重新建立一个后台 seesiong 的参照
    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为
    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession
    NSURLSession *backgroundSession = [self backgroundURLSession];

    NSLog(@"Rejoining session with identifier %@ %@", identifier, backgroundSession);

    // 保存 completion handler 以在处理 session 事件后更新 UI
    [self addCompletionHandler:completionHandler forSession:identifier];
}

- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
{
    NSLog(@"Background URL session %@ finished events.\n", session);

    if (session.configuration.identifier) {
        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler
        [self callCompletionHandlerForSession:session.configuration.identifier];
    }
}

- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier
{
    if ([self.completionHandlerDictionary objectForKey:identifier]) {
        NSLog(@"Error: Got multiple handlers for a single session identifier.  This should not happen.\n");
    }

    [self.completionHandlerDictionary setObject:handler forKey:identifier];
}

- (void)callCompletionHandlerForSession: (NSString *)identifier
{
    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];

    if (handler) {
        [self.completionHandlerDictionary removeObjectForKey: identifier];
        NSLog(@"Calling completion handler for session %@", identifier);

        handler();
    }
}
</code></pre>

<p>如果当后台传输完成时，应用程序不再停留在前台，那么对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用陈谷根本没有在运行，ios将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在application:didFinishLaunchingWithOptions: 方法被调用之后被调用.</p>

<h2>配置和限制</h2>

<p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读NSURLSessionConfiguration部分，以便最好滴满足你的使用场景。例如:NSURLSessionTasks通过NSURLSessionConfiguration的timeoutIntervalForResource属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限wifi宽带的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>

<p>除了下载任务，NSURLSession也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像ios6那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要再后台运行，一个比较好的做法是,把NSURLSessionConfiguration的sessionSendsLaunchEvents属性设置为NO。高效利用系统资源，是一件让Ios和用户都高兴的事。</p>

<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对NSURLSession的使用简单的基于block的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用Http重定向。后台传输服务只支持HTTP和HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>

<p>另外，要注意的是在后台回话中，NSURLSessionDataTasks是完全不支持的，你应该只处于短期的，小请求为目的的使用这些任务，而不是用来下载或上传。</p>

<h2>总结</h2>

<p>在ios7中强大的多任务和网络API为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的API，一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>

<ul>
<li>使用适当的新的API来为你的应用程序提供内容</li>
<li>尽可能早地调用completion handler以提高效率</li>
<li>让completion hander为应用程序更新界面快照</li>
</ul>

]]></content>
  </entry>
  
</feed>
