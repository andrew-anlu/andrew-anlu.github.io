<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-11-04T21:51:06+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ios10 UserNotifications]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications/"/>
    <updated>2016-10-17T09:53:08+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications</id>
    <content type="html"><![CDATA[<p>ios10以前杂乱的和通知相关的API都被统一了，现在开发者可以使用独立的UserNotificaitons.framework来集中管理和使用iOS系统中通知的功能。在此基础上，Apple还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知UI等一系列功能。</p>

<!--more-->


<p>对于开发者来说，想比较于之前版本，iOS10提供了一套非常易用通知处理接口，是SDK的一次重大重构，而之前的绝大部分通知相关API都已经被标为弃用(deprecated)</p>

<p>您可以在WWDC16的 <a href="https://developer.apple.com/videos/play/wwdc2016/707/">introducaion to Notifications</a>和<a href="https://developer.apple.com/videos/play/wwdc2016/708/">Advanced Notifications</a>这两个Session中找到详细信息；另外也不要忘了参考<a href="https://developer.apple.com/reference/usernotifications">UserNotifications官方文档</a></p>

<h2>UserNOtifications框架解析</h2>

<h3>基本流程</h3>

<p>iOS10中通知相关的操作遵循下面的流程:</p>

<p><code>审核和注册</code>-><code>创建和发起</code>-><code>展示和处理</code></p>

<p>首先你需要向用户请求推送权限，然后发送通知。对于发送出的通知，如果你的应用位于后台或者没有运行的话，系统将通过用户允许的方法（弹窗，横幅，或者是在通知中心）进行展示。如果你的应用已经位于前台正在运行，你可以自行决定要不要显示这个通知。最后，如果你希望用户点击通知能有打开应用以外的额外功能的话，你也需要进行处理。</p>

<h2>权限申请</h2>

<p>iOS8之前，本地推送和远程推送（Remote Notificaiton）是区分对待的，应用只需要在进行远程推送是获取用户同意。iOS8对这一行为进行了规范，因为无论是本地推送还是远程推送，其实在用户看来表现是一致的，都是打断用户的行为。因此从iOS8开始，这两种通知都需要申请权限。ios10里进一步消除了本地通知和推送通知的区别。向用户申请通知权限非常简单：</p>

<pre><code>UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {
    granted, error in
    if granted {
        // 用户允许进行通知
    }
}
</code></pre>

<p>当然，在使用UN开头的API的时候，不要忘记导入<code>UserNotifications</code>框架：</p>

<p><code>import UserNotifications</code></p>

<p>第一次调用这个方法时，会弹出一个系统弹窗.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-0.png" alt="1" /></p>

<p>要注意的是，一旦用户拒绝了这个请求，再次调用该方法时也不会进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知，而这往往是不可能的。因此，在合适的是偶弹出请求窗，在请求权限前预先进行说明，而不是直接粗暴地在启动的时候就进行弹窗，会是更明智的选择。</p>

<h2>远程推送</h2>

<p>一旦用户同意后，你就可以再应用中发送本地通知了。不过如果你通过服务器发送远程通知的话，还需要多一个获取用户token的操作，你的服务器可以使用这个token将用向Apple push Notification的服务器提交请求，然后APNS通过token识别设备和应用，将通知推给用户。</p>

<p>提交token请求和获得token的回调是现在"唯一"不在新框架中的API,我们使用<code>UIApplication</code>的<code>registerForRemoteNotifications</code>来注册远程通知，在<code>AppDelegate</code>的<code>application(_:didRegisterForRemoteNotificationsWithDeviceToken)</code>中获取用户token:</p>

<pre><code>// 向 APNs 请求 token：
UIApplication.shared.registerForRemoteNotifications()

// AppDelegate.swift
 func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let tokenString = deviceToken.hexString
    print("Get Push token: \(tokenString)")
}
</code></pre>

<p>获取得到的<code>deviceToken</code>是一个<code>Data</code>类型，为了方便使用和传递，我们一般会选择将它转换为一个字符串。swift3中可以使用下面的<code>data</code>扩展来构造适合传递给Apple的字符串：</p>

<pre><code>extension Data {
    var hexString: String {
        return withUnsafeBytes {(bytes: UnsafePointer&lt;UInt8&gt;) -&gt; String in
            let buffer = UnsafeBufferPointer(start: bytes, count: count)
            return buffer.map {String(format: "%02hhx", $0)}.reduce("", { $0 + $1 })
        }
    }
}
</code></pre>

<h3>权限设置</h3>

<p>用户可以再系统设置中修改你的应用的通知权限，除了打开和关闭全部通知权限外，用户也可以限制你的应用智能进行某种形式的通知显示，比如值允许横幅而不允许弹窗及通知中心显示灯。一般来说你不应该对用户的选择进行干涉，但是如果你的应用确实需要某种特定场景的推送的话，你可以对当前用户进行的设置进行检查:</p>

<pre><code>UNUserNotificationCenter.current().getNotificationSettings {
    settings in 
    print(settings.authorizationStatus) // .authorized | .denied | .notDetermined
    print(settings.badgeSetting) // .enabled | .disabled | .notSupported
    // etc...
}
</code></pre>

<h2>发送通知</h2>

<p>UserNOtifications中对通知进行了统一。我们通过通知的内容（<code>UNNotificaitonsContent</code>）,发送的时机<code>UNNotifiationTrigger</code>以及一个发送通知的<code>String</code>类型的标识符，来生成一个<code>UNNotificationRequest</code>类型的发送请求。最后，我们将这个请求添加到<code>UNUserNotificationCenter.current()</code>中，就可以等待通知到达了：</p>

<pre><code>// 1. 创建通知内容
let content = UNMutableNotificationContent()
content.title = "Time Interval Notification"
content.body = "My first notification"

// 2. 创建发送触发
let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)

// 3. 发送请求标识符
let requestIdentifier = "com.onevcat.usernotification.myFirstNotification"

// 4. 创建一个发送请求
let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)

// 将请求添加到发送中心
UNUserNotificationCenter.current().add(request) { error in
    if error == nil {
        print("Time Interval Notification scheduled: \(requestIdentifier)")
    }
}
</code></pre>

<ol>
<li>iOS10中通知不仅支持简单的一行文字，你还可以添加<code>title</code>和 <code>subtitle</code>,来用粗体字的形式强调通知的目的。对于远程推送，iOS10之前一般只含有消息的推送；payload是这样的：</li>
</ol>


<pre><code>{
  "aps":{
    "alert":"Test",
    "sound":"default",
    "badge":1
  }
}
</code></pre>

<p>如果我们想要加入<code>title</code>和<code>subtitle</code>的话，则需要将<code>alert</code>从字符串换为字典，新的payload是:</p>

<pre><code>
  "aps":{
    "alert":{
      "title":"I am title",
      "subtitle":"I am subtitle",
      "body":"I am body"
    },
    "sound":"default",
    "badge":1
  }
}
</code></pre>

<p>好消息是，后一种字典的方法其实在iOS8.2的时候就已经存在了，虽然当时<code>title</code>只是用在Apple Watch上的，但是设置好<code>body</code>的话在iOS上还是可以显示的，所以针对iOS10添加标题时是可以保证向前兼容的。</p>

<p>另外，如果要进行本地化对应，在设置这些内容文本时，本地可以使用<code>String.localizedUserNotificationString(forKey: "your_key", arguments: [])</code>的方式来从<code>Localizable.strings</code>文件中取出本地化字符串，而远程推送的话，也可以再payload的alert中使用<code>loc-key</code>或者<code>title-loc-key</code>来进行指定</p>

<ol>
<li><p>触发器是只对本地通知而言的，远程推送的通知的话默认会在收到后立即显示。现在<code>UserNotifications</code>框架中提供了三种触发器，分别是：在一定时间后触发<code>UNTimeIntervalNotificationTrigger</code>,在某月某日某时触发<code>UNCalendarNotificationTrigger</code>,以及在用户进入或者离开某个区域时触发<code>UNLocationNotificationTrigger</code></p></li>
<li><p>请求标识符可以用来区分不同的通知请求，在将一个通知请求提交后，通过特定的API我们能够使用这个标识符来取消或者更新这个通知。我们将在稍后提到具体方法</p></li>
<li><p>在新版本的通知框架中，Apple借用了一部分网络请求的概念，我们组织并发送一个通知请求，然后将这个请求提交给<code>UNUserNotificationCenter</code>进行处理。我们会在delegate中接收到这个通知请求对应的responst,另外我们也有机会再应用的extension中对request进行处理</p></li>
</ol>


<p>在提交请求后，我们锁屏或者将应用切到后台，并等待设定的时间后，就能看到我们的通知出现在通知中心或者屏幕横幅了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-1.png" alt="1" /></p>

<h2>取消和更新</h2>

<p>在创建通知请求时，我们已经制定了标识符。这个标识符可以用来管理通知，在iOS10之前，我们很难取消掉某一个特定的通知，也不能主动移除或者更新已经展示的通知。</p>

<p>iOS10中，UserNotifications框架提供了一系列管理通知的API,你可以做到:</p>

<ul>
<li>取消还未展示的通知</li>
<li>更新还未展示的通知</li>
<li>移除已经展示过的通知</li>
<li>更新已经展示过的通知</li>
</ul>


<p>其中关键就是创建请求时使用同样的标识符：</p>

<p>比如，从通知中心移除一个展示过得通知：</p>

<pre><code>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
let identifier = "com.onevcat.usernotification.notificationWillBeRemovedAfterDisplayed"
let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)

UNUserNotificationCenter.current().add(request) { error in
    if error != nil {
        print("Notification request added: \(identifier)")
    }
}

delay(4) {
    print("Notification request removed: \(identifier)")
    UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [identifier])
}
</code></pre>

<p>类似的，我们可以使用<code>removePendingNotificationRequests</code>，来取消还未展示的通知请求。对于更新通知，不论是否已经展示，都和一开始添加请求时一样，再次将请求提交给<code>UNUserNotificationCenter</code>即可：</p>

<pre><code>// let request: UNNotificationRequest = ...
UNUserNotificationCenter.current().add(request) { error in
    if error != nil {
        print("Notification request added: \(identifier)")
    }
}

delay(2) {
    let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)

    // Add new request with the same identifier to update a notification.
    let newRequest = UNNotificationRequest(identifier: identifier, content:newContent, trigger: newTrigger)
    UNUserNotificationCenter.current().add(newRequest) { error in
        if error != nil {
            print("Notification request updated: \(identifier)")
        }
    }
}
</code></pre>

<p>远程推送可以进行通知的更新，在使用Provider API向APNS提交请求时，在HTTP2的header中<code>apns-collapse-id</code>key的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新</p>

<h2>处理通知</h2>

<h3>应用内展示通知</h3>

<p>现在系统可以在应用处于后台或者退出的时候向用户展示通知了。不过，当应用处于前台时，收到的通知是无法进行展示的。如果我们希望在应用内也能显示通知的话，需要额外的工作。</p>

<p><code>UNUserNotificationCenterDelegate</code>提供了两个方法，分别对应如何在应用内展示通知，和收到通知响应时要如何处理的工作。我们可以实现这个借口中的对应方法来在应用内展示通知：</p>

<pre><code>class NotificationHandler: NSObject, UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, 
                       willPresent notification: UNNotification, 
                       withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) 
    {
        completionHandler([.alert, .sound])

        // 如果不想显示某个通知，可以直接用空 options 调用 completionHandler:
        // completionHandler([])
    }
}
</code></pre>

<p>实现后，将<code>NotificationHandler</code>的实例赋值给<code>UNUserNotificationCenter</code>的<code>delegate</code>属性就可以了。没有特殊理由的话，AppDelegate的<code>application(_:didFinishLaunchingWithOptions:)</code>就是一个不错的选择：</p>

<pre><code>class AppDelegate: UIResponder, UIApplicationDelegate {
    let notificationHandler = NotificationHandler()
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
        UNUserNotificationCenter.current().delegate = notificationHandler
        return true
    }
}
</code></pre>

<h2>对通知进行响应</h2>

<p><code>UNUserNotificationCenterDelegate</code>中还有一个方法,<code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>这个代理方法会在用户与你推送的通知进行交互时被调用，包括用户通过通知打开了你的应用，或者点击或者触发了某个Action。因为涉及到打开应用的行为，所以事先了这个方法的delegate必须在<code>applicationDidFinishLaunching:</code>返回前就完成设置，这也是我们之前推荐将<code>NotificationHandler</code>今早进行赋值的理由。</p>

<p>一个最简单的事先自然什么也不错，直接告诉系统你已经完成了所有工作。</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
    completionHandler()
}
</code></pre>

<p>在该方法里，我们将获取到这个推送请求对应的response,<code>UNNotificationResponse</code>是一个几乎包括了通知的所有信息的对象，从中我们可以再次获取到<code>userInfo</code>中的信息:</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
    if let name = response.notification.request.content.userInfo["name"] as? String {
        print("I know it's you! \(name)")
    }
    completionHandler()
}
</code></pre>

<p>更好的消息是，远程推送的payload内的内容也会出现在这个<code>userInfo</code>中，这样一来，不论是本地推送还是远程推送，处理的路径得到了统一。通过<code>userInfo</code>的内容来决定页面跳转或者是进行其他操作，都会有很大空间。</p>

<h2>Actionable通知发送和处理</h2>

<h3>注册Category</h3>

<p>iOS8和9中Apple引入了可以交互的通知，这是通过将一簇action放到了一个category中，将这个category进行注册，最后在发送通知时将通知的category设置为要使用的category来实现的。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-2.png" alt="1" /></p>

<p>注册一个category非常容易：</p>

<pre><code>private func registerNotificationCategory() {
    let saySomethingCategory: UNNotificationCategory = {
        // 1
        let inputAction = UNTextInputNotificationAction(
            identifier: "action.input",
            title: "Input",
            options: [.foreground],
            textInputButtonTitle: "Send",
            textInputPlaceholder: "What do you want to say...")

        // 2
        let goodbyeAction = UNNotificationAction(
            identifier: "action.goodbye",
            title: "Goodbye",
            options: [.foreground])

        let cancelAction = UNNotificationAction(
            identifier: "action.cancel",
            title: "Cancel",
            options: [.destructive])

        // 3
        return UNNotificationCategory(identifier:"saySomethingCategory", actions: [inputAction, goodbyeAction, cancelAction], intentIdentifiers: [], options: [.customDismissAction])
    }()

    UNUserNotificationCenter.current().setNotificationCategories([saySomethingCategory])
}
</code></pre>

<ol>
<li><code>UNTextInputNotificationAction</code>代表一个输入文本的action,你可以自定义框的按钮title和placeholder,你稍后会使用<code>identifier</code>来对action进行区分。</li>
<li>普通的<code>UNNotificationAction</code>对应标准的按钮</li>
<li>为category指定一个<code>identifier</code>,我们将在实际发送通知的时候用这个标识符进行设置，这样系统就知道对应哪个category了。</li>
</ol>


<p>当然，不要忘了在程序启动时调用这个方法进行注册</p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
    registerNotificationCategory()
    UNUserNotificationCenter.current().delegate = notificationHandler
    return true
}
</code></pre>

<h3>发送一个带有action的通知</h3>

<p>在完成category注册后，发送一个actionable通知就非常简单了，只需要在创建<code>UNNotificationContent</code>时把<code>categoryIdentifier</code>设置为需要的categoryId即可：</p>

<pre><code>content.categoryIdentifier = "saySomethingCategory"
</code></pre>

<p>尝试展示这个通知，在下拉或者使用3D touch展开通知后，就可以看到对应的action了：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-3.png" alt="1" /></p>

<p>远程推送也可以使用category,只需要在payload中添加<code>category</code>字段，并指定预先定义的category id 就可以了:</p>

<pre><code>{
  "aps":{
    "alert":"Please say something",
    "category":"saySomething"
  }
}
</code></pre>

<h3>处理actionable通知</h3>

<p>和普通的通知并无二致力，actionable通知也会走到<code>didReceive</code>的delegate方法，我们通过request中包含的<code>categoryIdentifier</code>和response里的<code>actionIdentifier</code>就可以轻易判定是那个通知的那个操作被执行了。对于<code>UNTextInputNotificationAction</code>触发的response,直接将它转换为一个<code>UNTextInputNotificationResponse</code>，就可以拿到其中的用户输入了：</p>

<pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {

    if let category = UserNotificationCategoryType(rawValue: response.notification.request.content.categoryIdentifier) {
        switch category {
        case .saySomething:
            handleSaySomthing(response: response)
        }
    }
    completionHandler()
}

private func handleSaySomthing(response: UNNotificationResponse) {
    let text: String

    if let actionType = SaySomethingCategoryAction(rawValue: response.actionIdentifier) {
        switch actionType {
        case .input: text = (response as! UNTextInputNotificationResponse).userText
        case .goodbye: text = "Goodbye"
        case .none: text = ""
        }
    } else {
        // Only tap or clear. (You will not receive this callback when user clear your notification unless you set .customDismissAction as the option of category)
        text = ""
    }

    if !text.isEmpty {
        UIAlertController.showConfirmAlertFromTopViewController(message: "You just said \(text)")
    }
}
</code></pre>

<p>上面的代码先判断通知响应是否属于<code>saySomething</code>，然后从用户输入或者是选择中提取字符串，并且弹出一个alert作为响应结果。当然，更多请苦情下我们会发送一个网络请求，或者是根据用户操作更新一些UI等。</p>

<h2>Notificiaton Extension</h2>

<p>iOS10中添加了很多extention,作为应用与系统整合的入口。与通知相关的extension有两个：Service Extension和Content Extension.前者可以让我们有机会在收到远程推送的通知后，展示之前对通知内容进行修改：后者可以用来自定义通知视图的样式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-extensions.png" alt="1" /></p>

<h3>截取并修改通知内容</h3>

<p><code>NotificationService</code>的模板已经为我们进行了基本的实现:</p>

<pre><code>class NotificationService: UNNotificationServiceExtension {

    var contentHandler: ((UNNotificationContent) -&gt; Void)?
    var bestAttemptContent: UNMutableNotificationContent?

    // 1
    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)

        if let bestAttemptContent = bestAttemptContent {
            if request.identifier == "mutableContent" {
                bestAttemptContent.body = "\(bestAttemptContent.body), Andrew"
            }
            contentHandler(bestAttemptContent)
        }
    }

    // 2
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }
}
</code></pre>

<ol>
<li><code>didReceive:</code>方法中有一个等待发送的通知请求，我们通过修改这个请求中的content内容，然后在限制的时间内将修改后的内容调用通过<code>contentHandler</code>返还给系统，就可以显示这个修改过得通知了</li>
<li>在一定时间内没有调用<code>contentHandler</code>的话，系统会调用这个方法，来告诉你大限已到。你可以选择什么都不做，这样的话系统将当做什么都没发生，简单地显示原来的通知，可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用<code>contentHandler</code>来显示一个变更"中途"的通知</li>
</ol>


<p>Service Extentsion现在只对远程推送的通知起效，你可以在推送payload中增加一个<code>mutable-content</code>的值为1的项来启用内容修改：</p>

<pre><code>{
  "aps":{
    "alert":{
      "title":"Greetings",
      "body":"Long time no see"
    },
    "mutable-content":1
  }
}
</code></pre>

<p>这个payload的推送得到的结果就是推送的内容+“Andrew”</p>

<p>使用在本机截取推送并替换内容的方式，可以完成端到端(end-to-end)的推送加密。你在服务器推送payload中加入加密过得文本，在客户端接到通知后使用预先定义或者获取过得秘钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>

<h2>在通知中展示图片/视频</h2>

<p>相比于旧版本的通知，iOS10中另一个亮眼功能室多媒体的推送，开发者现在可以在通知中嵌入图片或者视频，这极大丰富了推送内容的可读性和趣味性。</p>

<p>为本地通知添加多媒体内容十分简单，只需要通过本地磁盘上的文件URL创建一个<code>UNNotificationAttachment</code>对象，然后将这个对象放到数组中赋值给<code>content</code>的<code>attachments</code>属性就行了：</p>

<pre><code>let content = UNMutableNotificationContent()
content.title = "Image Notification"
content.body = "Show me an image!"

if let imageURL = Bundle.main.url(forResource: "image", withExtension: "jpg"),
   let attachment = try? UNNotificationAttachment(identifier: "imageAttachment", url: imageURL, options: nil)
{
    content.attachments = [attachment]
}
</code></pre>

<p>在显示时，横幅或者弹窗将附带设置的图片，使用3D Touch pop通知或者下拉通知显示详细内容时，图片也会被放大显示：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-4.png" alt="2" /></p>

<p>除了图片之外，通知还支持音频以及视频。你可以将MP3或者MP4这样的文件提供给系统来在通知中进行展示和播放，不过，这些文件都有尺寸的限制，比如图片不能超过5MB,视频不能超过50MB,不过对于一般的能在通知中展示的内容来说，这个尺寸应该是绰绰有余了。关于支持的文件格式和尺寸，可以在文档中进行确认。在创建<code>UNNotificationAttachment</code>时，如果遇到了不支持的格式，SDK也会抛出错误。</p>

<p>通过远程推送的方式，你也可以显示图片等多媒体内容，这要借助于上一节所提到的通过<code>Notification Service Extension</code>来修改涂松通知内容的技术。一般做法是，我们在推送payload中指定需要加载的图片资源地址，这个地址可以是应用bundle内已经存在的资源，也可以是网络的资源。不过因为在创建<code>UNNotificationAttachment</code>时偶们只能使用本地资源，所以如果多媒体还不在本地的话，我们需要先将其下载到本地，在完成<code>UNNotificationAttachment</code>创建后，我们就可以和本地通知一样，将它设置给<code>attachments</code>属性，然后调用<code>contentHandler</code>了。</p>

<p>简单的实例 payload如下：</p>

<pre><code>{
  "aps":{
    "alert":{
      "title":"Image Notification",
      "body":"Show me an image from web!"
    },
    "mutable-content":1
  },
  "image": "https://onevcat.com/assets/images/background-cover.jpg"
}
</code></pre>

<p><code>mutable-content</code>表示偶们会在接收到通知时对内容进行更改，<code>image</code>指明了目标图片的地址。</p>

<p>在<code>NotificationService</code>里，加入如下代码来下载图片，并将其保存到磁盘缓存中：</p>

<pre><code>private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {
    let task = URLSession.shared.dataTask(with: url, completionHandler: {
        data, res, error in

        var localURL: URL? = nil

        if let data = data {
            let ext = (url.absoluteString as NSString).pathExtension
            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)
            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)

            if let _ = try? data.write(to: url) {
                localURL = url
            }
        }

        handler(localURL)
    })

    task.resume()
}
</code></pre>

<p>然后再<code>didReceive:</code>中，接收到这类通知时提取图片地址，下载，并生成attachment,进行通知展示：</p>

<pre><code>if let imageURLString = bestAttemptContent.userInfo["image"] as? String,
   let URL = URL(string: imageURLString)
{
    downloadAndSave(url: URL) { localURL in
        if let localURL = localURL {
            do {
                let attachment = try UNNotificationAttachment(identifier: "image_downloaded", url: localURL, options: nil)
                bestAttemptContent.attachments = [attachment]
            } catch {
                print(error)
            }
        }
        contentHandler(bestAttemptContent)
    }
}
</code></pre>

<p>关于在通知中展示图案品或者视频，有几点想补充说明：</p>

<ol>
<li><code>UNNotificationContent</code>的<code>attachments</code>虽然是一个数组，但是系统只会展示第一个attachmen对象的内容。不过你依然可以发送多个<code>attachments</code>,然后再要展示的时候再重新安排他们的顺序，以显示最符合情景的图片或者视频。另外，你也可能会在自定义通知展示UI时用到多个<code>attachment</code>,我们接下来一节中会看到一个相关的例子。</li>
<li>在当前iOS10中，<code>serviceExtensionTimeWillExpire</code>被条用之前，你有30秒时间来处理和更改通知内容，对于一般的图片来说，这个时间是足够的，但是如果你推送的体积较大的视频内容，用户又恰巧在糟糕的网络环境的话，很有可能无法及时下载完成。</li>
<li>如果你想在远程推送来的通知中显示应用bundle内的资源的话，要注意extension的bundle和app main bundle并不是一回事，你可以选择将图片资源放到extension bundle中，也可以选择放在main bundle里，总之，你需要保证能够获取到正确的，并且你具有读取权限的url</li>
<li>系统在创建<code>attachement</code>时会根据提供的url后缀确定文件类型，如果没有后缀，或者后缀无法不正确的话，你可以在创建时通过<code>UNNotificationAttachmentOptionsTypeHintKey</code>来<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachmentoptionstypehintkey">指定资源类型</a></li>
<li>如果使用的图片和视频文件不在你的bundle内部，它们将被移动到系统的负责通知的文件夹下，然后当同志被移除后删除。如果媒体文件在bundle内部，它们将被负责到通知文件夹下。每个应用能使用的媒体文件大小总和是有限制，超过限制后创建<code>attachment</code>时将抛出异常。可能的所有错误可以再<code>UNError</code>中找到</li>
<li>你可以访问一个已经创建的<code>attachment</code>的内容，但是要注意权限问题，可以使用<code>startAccessingSecurityScopedResource</code>来暂时获取以创建的<code>attachment</code>的访问权限。比如：</li>
</ol>


<pre><code>let content = notification.request.content
if let attachment = content.attachments.first {  
    if attachment.url.startAccessingSecurityScopedResource() {  
        eventImage.image = UIImage(contentsOfFile: attachment.url.path!)  
        attachment.url.stopAccessingSecurityScopedResource()  
    }  
}  
</code></pre>

<h2>自定义通知视图样式</h2>

<p>ioS10 SDK 新加的另一个<code>Content Extension</code>可以用来自定义通知的详细页面的视图，新建一个<code>Notification Content Extension</code>,Xcode为我们准备的模板中包含了一个实现了<code>UNNotificationContentExtension</code>的<code>UIViewController</code>子类。这个extension中有个一必须实现的方法<code>didReceive(_:)</code>,在系统需要显示自定义样式的通知详情视图时，这个方法将被调用，你需要在其中配置你的UI.而UI本身可以通过这个extension中的<code>MainInterface.storyboard</code>来进行定义。自定义UI的通知是和通知category绑定的，我们需要在<code>extension</code>的info.plist里指定这个通知样式所对应的category标识符：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-content-info.png" alt="1" /></p>

<p>系统在接收到通知后会先查找有没有能够处理这类通知的content extension,如果存在，那么就交给extensionl来进行处理，另外，在构建UI时，我们可以通过Info.plist控制通知详细视图的尺寸，以及是否显示原始的通知。关于Content Extension中的info.plist的key,可以在<a href="https://developer.apple.com/reference/usernotificationsui/unnotificationcontentextension">这个文档</a>中找到详细信息。</p>

<p>虽然我们可以使用包括按钮在内的各种UI，但是系统不允许我们队这些UI进行交互，点击通知视图UI本身会将我们导航到应用中，不过我们可以通过action的方式来对自定义UI进行更新。<code>UNNotificationContentExtension</code>为我们提供了一个可选方法<code>didReceive(_:completionHandler:)</code>，它会在用户选择了某个action时被调用，你有机会在这里更新通知的UI，如果有UI更新，那么在方法的<code>completionHandler</code>中，开发者可以选择传递<code>. doNotDismiss</code>来保持通知继续呗显示。如果没有继续显示的必要，可以选择<code>. dismissAndForwardAction</code>或者<code>. dismiss</code>，前者将把通知的action继续传递给应用的<code>UNUserNotificationCenterDelegate</code>中的<code>userNotificationCenter(:didReceive:withCompletionHandler)</code>，而后者将直接解散这个通知</p>

<p>如果你的自定义UI包含视频等，你还可以实现<code>UNNotificationContentExtension</code>里的<code>media</code>开头的一系列属性，它将为你提供一些视频播放的控件和相关方法。</p>

<h2>总结</h2>

<p>iOS10 SDk中对通知这块进行了IOS系统发布以来最大的一次重构，很多"老朋友"都被标记为了 deprecated:</p>

<h2>iOS10中被标记弃用的API</h2>

<ul>
<li>UILocalNotification</li>
<li>UIMutableUserNotificationAction</li>
<li>UIMutableUserNotificationCategory</li>
<li>UIUserNotificationAction</li>
<li>UIUserNotificationCategory</li>
<li>UIUserNotificationSettings</li>
<li>handleActionWithIdentifier:forLocalNotification:</li>
<li>handleActionWithIdentifier:forRemoteNotification:</li>
<li>didReceiveLocalNotification:withCompletion:</li>
<li>didReceiveRemoteNotification:withCompletion:</li>
</ul>


<p>等一系列在<code>UIKIT</code>中的发送和处理通知的类型及方法</p>

<p>相比较于iOS早期时代的API,新的APi展现了高度的模块化和统一特性，易用性也非常好，是一套更加先进的API,如果有可能，特别是如果你的应用是重度依赖通知特性的话，直接从iOS10开始可以让你充分使用在新同志体系的各种特性。</p>

<p>虽然原来的API都被标为弃用了，但是如果需要支持iOS10之前系统的话，你还是需要使用原来的API,我们可以使用</p>

<pre><code>if #available(iOS 10.0, *) {
    // Use UserNotification
}
</code></pre>

<p>的方式来对iOS10进行新通知的适配，并让iOS10的用户享受到新通知带来的便利特性，然后在将来版本升级到只支持iOS10以上时再移除掉所有被启用的代码。对于优化和梳理通知相关代码来说，新API对代码设计和祖上上带来的好处足以弥补适配上的麻烦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS中的内存分配]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei/"/>
    <updated>2016-10-09T17:16:16+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei</id>
    <content type="html"><![CDATA[<p>内存分配可以分为5个区</p>

<h2>栈区（stack）</h2>

<p>这个一般由编译器操作，或者说是系统管理，会存一些局部变量，这些系统都会帮我们自动实现，无需我们干预，所以大量的局部变量，深递归，函数循环调用都可以耗尽栈内存而程序崩溃</p>

<h2>堆区（heap）</h2>

<p>一般由程序员管理，比如alloc申请内存，free释放内存，我们创建的对象也都放在这里</p>

<h2>全局区(静态区 static)</h2>

<p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。</p>

<h2>常量区</h2>

<p>常量字符串就是放在这里的，还有const常量</p>

<h2>代码区</h2>

<p>存放代码，app程序会拷贝到这里，程序不是在</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1475976705224479.png" alt="1" /></p>

<p>图中各个区并不连续</p>

<p>当一个app启动后，代码区，常量区，全局区地址已经固定，因此指向这些区的指针不会为空而产生崩溃性的错误，而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入和弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS推送]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/21/iostui-song/"/>
    <updated>2016-09-21T16:25:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/21/iostui-song</id>
    <content type="html"><![CDATA[<p>推送服务可以说是所有App的标配，不论是那种类型的App,推送都从很大程度上决定了App的打开率，使用率，存活率。因此熟知并掌握推送原理及方法,对每一个开发者来说都是必备技能，对每一个依赖App的公司都至关重要</p>

<p>从ios10新增的<code>UserNotifications Framework</code>可以发现，Apple整合了原有散乱的API,并且增加了很多强大的功能。以Apple官方的角度来看，也必然是相当重视推送服务对App的影响，以及对Apple生态圈长远发展的影响。</p>

<!--more-->


<h2>准备</h2>

<h3>Tip 1：推送通知（Push Notification）必须购买Apple开发者账号，并使用特定的推送证书</h3>

<ul>
<li>使用免费账号不能推送</li>
<li>如果我们使用的是第三方推送服务，比如 &lt;极光推送>,也必须购买开发者账号，因为所有的第三方都会将推送请求发至 <code>APNS</code>(Apple push Notification service，苹果推送通知服务)，所有的推送都是由Apns发送的</li>
<li>如果注册及正确的配置证书，参考这里<a href="http://docs.jiguang.cn/client/ios_tutorials/#ios_1">ios证书设置指南</a></li>
</ul>


<h2>原理</h2>

<h3>Tip2:推送通知本身是iOS系统的行为，所以在App没有运行的时候：</h3>

<ul>
<li>仍然能够推送及接收(通知中心通知，顶部横幅，刷新App右上角小圆点等都会由系统控制和展示)</li>
<li>收到推送时，是无法再App的代码中获取到通知内容的。因为沙盒机制，此时App的任何代码都不可能被执行</li>
</ul>


<h3>Tip3:手机向APNS注册推送服务</h3>

<ol>
<li>在代码中注册推送服务:</li>
</ol>


<pre><code> #ifdef __IPHONE_8_0
 if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {
     UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge| UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];
     [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
 } else {
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
}
 #else
     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
 #endif
</code></pre>

<ol>
<li>在第一次触发这段代码的时候，会有一个系统弹窗，询问你是否允许该App要给你推送信息。当你选择允许时，系统会打包App+手机唯一标识+证书信息 发送至Apns服务器注册推送服务，APNs系统会对该手机安装的该App是否有推送权限进行验证，所以必须要加入了Apple Device的手机，使用对应App的推送证书才能够成功注册。</li>
<li>如果注册成功，则可以在<code>AppDelegate.swift</code>的如下方法中获取到<code>deviceToken</code>,它是对该手机+该App组合的一个唯一标识，当使用远程推送时，只需将推送消息发给指定的<code>deviceToken</code>即可使推送消息传达给指定手机的指定App上。因此如果你使用第三方，就需要在这里将<code>deviceToken</code>传给第三方。（在ios9为了更好的保护用户隐私，会出现多次重复删除/安装App导致<code>deviceToken</code>不断变化的情况。有时会出现一条推送手机会受到2次的问题，属于iOS9系统问题）</li>
</ol>


<pre><code> -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
     [JPUSHService registerDeviceToken:deviceToken];//将 deviceToken 传给极光推送
 }
</code></pre>

<ol>
<li><p>如果以上步骤都成功，此时你能够获取到第三方提供的设备注册的id，能够获取到该id值，可以作为判断设备是否能够成功推送的标准，因此当你获取到该值时：</p></li>
<li><p>推送证书配置正确（你拥有了推送权限）</p></li>
<li>设备成功在Apns注册并返回了<code>deviceToken</code>（Apns能识别你的设备了）</li>
<li><p>返回的<code>deviceTOken</code>传给第三方，成功在第三方生成了唯一标识注册id（第三方能将你的设备信息传给APNS了）</p></li>
<li><p>综上，注册及接受推送必须使用真机，必须连网</p></li>
</ol>


<h3>Tip4:推送通知从服务端->App代码的过程</h3>

<ol>
<li>使用你们公司或第三方的服务端向APNs发送推送请求（请参考苹果APNS相关资料，或者使用第三方提供的Rest Api）</li>
<li>APNS接受并验证推送请求</li>
<li>APNS找到设备下发推送</li>
<li><p>手机收到推送通知，系统根据App状态进行处理：</p></li>
<li><p>前台收到：</p>

<ul>
<li>系统会将通知内容传到 <code>didReceiveRemoteNotification</code></li>
</ul>
</li>
<li><p>后台收到:</p>

<ul>
<li>如果开启了<code>Remote Notification</code>,系统将推送传到<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>,否则此时代码中收不到推送</li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
<li><p>退出收到:</p>

<ul>
<li>如果点击推送横幅/通知中心而启动App,系统将通知传到<code>didFinishLaunchingWithOptions</code></li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
</ol>


<h2>推送通知内容篇</h2>

<h3>Tip5:推送通知分为本地/远程 2种类型:</h3>

<ul>
<li>本地通知，可指定推送时间，在该时间准时弹出推送通知。</li>
<li><p>远程推送通知，分为普通推送/后台推送/静默推送3种类型。存在延迟问题（由于Tip1的第2点，APNS的不稳定及高峰时段的巨量请求所致）</p>

<ul>
<li><p>普通推送</p>

<ul>
<li>就是我们在手机上平时见到的推送通知</li>
<li>包括声音，横幅，角标，自定义字段</li>
<li><p>App:</p>

<ul>
<li>处于前台，不会显示横幅，可通过 <code>didReceiveRemoteNotification</code>（ios7 before）,<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>(ios7 after)获取通知内容</li>
<li>处于后台，会展示横幅，无法获取通知内容</li>
<li>处于退出，会展示横幅，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击通知横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>
</li>
</ul>
</li>
<li>通知内容类似如下:</li>
</ul>


<pre><code class="``">  {
"_j_msgid" = 200806057;  // 第三方附带的 id，用于统计点击
aps =     {
  alert = "显示内容";
  badge = 1;  // App 角标，可推送 n、+n、-n 来实现角标的固定、增加、减少
  sound = default;  // 推送声音，默认系统三全音，如需使用自己的声音，需要将声音文件拖拽&amp;拷贝至 Xcode 工程目录任意位置，并在推送时指定其文件名
};
key1 = value1;  // 自定义字段，可设置多组，用于处理内部逻辑
key2 = value2;
}
</code></pre></li>
<li><p>后台推送</p>

<ul>
<li>各种显示效果跟普通推送完全一样</li>
<li>必须携带<code>content-available</code> = 1</li>
<li>必须携带 alter ,badge ,sound 至少一个字段</li>
<li>仅 ios7以后支持</li>
<li>必须在Xcode工程中 <code>TARGETS – Capabilities – Background Modes – Remote notifications</code>开启该功能，具体可参照 <a href="http://docs.jiguang.cn/client/ios_tutorials/#ios-7-background-remote-notification"> iOS 7 Background Remote Notification</a></li>
</ul>
</li>
</ul>


<h3>App</h3>

<ul>
<li>处于前台，可通过<code>didReceiveRemoteNotification</code>(iOS7 before) ，didReceiveRemoteNotification:fetchCompletionHandler: （iOS 7 after）获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中于普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下没执行一些代码，大概提供几分钟的时间，可以用来偷偷地刷新UI，切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击推送横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<pre><code>{
  "_j_msgid" = 2090737306;
  aps =     {
    alert = "显示内容";
    badge = 1;
    "content-available" = 1;  // 必带字段
    sound = default;
  };
  key1 = value1;
}
</code></pre>

<h3>静默推送</h3>

<ul>
<li>没有任何展示效果</li>
<li>必须携带<code>"content-available" = 1</code>，因此静默必然是后台的</li>
<li>必须不携带 alert,badge,sound</li>
<li>可携带自定义字段</li>
</ul>


<p><em>App:</em></p>

<ul>
<li>处于前台，可以通过<code>didReceiveRemoteNotification</code>(iOS7 before),<code>didReceiveRemoteNotification:fetchCompletionHandler:</code> (ios 7 after)获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中与普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下，执行一些代码，大概提供几分钟的时间，可以用来偷偷的刷新UI,切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<pre><code>{
    "_j_msgid" = 3938587719;
    aps =     {
        alert = "";
        "content-available" = 1;  // 必带字段
    };
    key1 = value1;
}
</code></pre>

<h2>推送目标篇</h2>

<p>别名，标签，RegistrationID均是第三方提供的用于更方便地指定推送目标的功能</p>

<h3>Tip6:推送根据目标的不同可以分为:</h3>

<ul>
<li>广播

<ul>
<li>无差别发送给所有用户</li>
</ul>
</li>
<li><p>别名alias推送</p>

<ul>
<li>第三方提供的功能</li>
<li>一个手机的一款App只能设置一个 alias(可修改)</li>
<li>建议对每一个用户都取不同的别名，以此来确定唯一的用户</li>
<li>推送时可指定多个alias来发送同一内容</li>
<li>仅指定alias的用户能够收到推送</li>
</ul>
</li>
<li><p>标签tag推送</p>

<ul>
<li>第三方提供的功能</li>
<li>可以设置多个，可增加，清空</li>
<li>用于指定多样的属性，如 『1000』+『daily』+『discount』 可用于表示月消费超过 1k、喜欢购买日用品、偏好折扣商品的用户</li>
<li>如果要删除，需要在上次设置时，将设置的tags保存至<code>NSUserDefaults</code>，本次剔除不需要的tag后，再重新设置</li>
<li>推送时可指定多个tag来发同一个内容</li>
<li>手机如果设置了推送指定的多个 tag 中任一个tag，都能够收到推送消息。如指定 『1000』+『globe』+『original』 （千元级消费者、全球购、原价），那么设置了 『100』+『globe』+『discount』（百元级消费者、全球购、折扣价）的用户可以收到该推送消息。</li>
</ul>
</li>
<li><p>Registration ID 推送</p>

<ul>
<li>第三方提供的功能</li>
<li>在Tip 3的第三步时将<code>deviceToken</code>提供给第三方之后，其服务器会自动生成的指向该手机的唯一id</li>
<li>可在推送时指定多个id来下发消息</li>
<li>可用于对核心用户，旗舰用户的精准推送</li>
</ul>
</li>
</ul>


<h2>应用消息篇</h2>

<h3>Tip 7:应用内消息和推送通知的区别，消息:</h3>

<ul>
<li>不需要Apple推送证书</li>
<li>由第三方服务器下发，而不是APNS</li>
<li>相比通知，更快速，几乎没有延迟，可用于IM消息的即使传达</li>
<li>能够长时间保留离线消息，可获取所有历史消息内容</li>
<li>通过长连接技术下发消息，因此：

<ul>
<li>手机必须启动并与第三方服务器简历连接</li>
<li>如果手机启动立刻切换到后台，很可能连接没有建立</li>
<li>手机必须处于前台才能收到消息</li>
<li>手机从后台切回前台，会自动重新简历连接，并收到离线消息</li>
</ul>
</li>
<li>没有任何展示（横幅，通知中心，角标，声音），因此可以：

<ul>
<li>完全自定义字段实现UI效果</li>
<li>完全在静默的情况下处理App内部逻辑</li>
<li>使用一些App Store审核不会通过的功能，在审核时关闭功能，上架后通过接收消息，开启相关功能</li>
</ul>
</li>
</ul>


<h2>组合大招</h2>

<h3>Tip 8:tags的组合技巧</h3>

<ul>
<li>见 Tip5 - 标签tag 推送</li>
<li>可以再服务器端来统计分析用户行为，然后将指定的tags发送至手机，手机接收后再为用户打上对应的tags</li>
</ul>


<h3>Tip 9:通知 + 消息的组合技巧</h3>

<ul>
<li>首先来看通知和消息的特性对比</li>
</ul>


<table>
<thead>
<tr>
<th>XX </th>
<th>  通知  </th>
<th>             消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>送达时间 </td>
<td> 可能存在几秒延迟  </td>
<td> 几乎没延迟</td>
</tr>
<tr>
<td>获取时机  </td>
<td> 处于前台或后台 能获取内容</td>
<td>仅处于前台能获取内容</td>
</tr>
<tr>
<td>离线内容</td>
<td> 保留一段时间，过期会抛弃，无法查询历史内容</td>
<td>始终保留，可查询全部历史内容</td>
</tr>
<tr>
<td>系统展示</td>
<td>会展示（静默推送或App处于前台不展示）</td>
<td>不展示</td>
</tr>
</tbody>
</table>


<p><em>由于各自的特性都存在差异，因此二者结合使用使得App推送性能最大化的必然选择：</em></p>

<ul>
<li>情景一</li>
</ul>


<p>QQ/微信聊天，会同时下发一组通知+消息，如果用户没有启动QQ,虽有延迟但必须能够先收到通知，在收到通知的提醒之后，用户打开App,此时收到了离线消息，即使更新UI，与好友即使地发送/接收消息，（在收到通知后，断网，然后启动APP，你会发现此时手机里并不会显示刚刚通知的内容，因为它是依靠拉取消息来刷新页面的，而不是不够稳定的通知）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组合与继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng/"/>
    <updated>2016-09-10T08:45:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng</id>
    <content type="html"><![CDATA[<h2>何时使用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的UITableViewCell,那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不管代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

<!--more-->


<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个<code>OBJDevice</code>类，让一些子类如 <code>OBJIPhoneDevice</code>和<code>OBJIPadDevice</code>,甚至更深层次的子类如<code>OBJIPhone5Device</code>来继承，并让这些子类重写特定的方法，例如，你的<code>OBJDevice</code>类可能包含了函数<code>applyRoundedCornersToView:withRadius</code>,它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类可能很有用的场景是模型对象（model object）.绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code>,<code>hash</code>,<code>copyWithzone:</code>,和<code>description</code>等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找这样的一个基类，可以考虑使用<a href="https://github.com/mantle/mantle">Mantle</a>,它就是这么做的，并且做的更多）</p>

<h2>何时不适用子类</h2>

<p>在以往工作过得很多工程中，我见过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。</p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代的方案可选。在下面的章节中，我们会逐个进行更详细的描述。如果你的子类只是使用相同的接口，协议会是非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有的对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h1>替代方案</h1>

<h2>协议(Protocols)</h2>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在app中你有一个播放器对象，它可以播放视频。现在你想添加对YouTube的支持，使用相同的接口，但是具体实现不同。你可以像这样用子类来实现:</p>

<pre><code>@class Player : NSObject

- (void)play;
- (void)pause;

@end


@class YouTubePlayer : Player

@end
</code></pre>

<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的昂奋。可以这样用协议来写你的代码：</p>

<pre><code>@protocol VideoPlayer &lt;NSObject&gt;

- (void)play;
- (void)pause;

@end


@class Player : NSObject &lt;VideoPlayer&gt;

@end


@class YouTubePlayer : NSObject &lt;VideoPlayer&gt;

@end
</code></pre>

<p>这样，<code>YouTubePlayer</code>类就不必知道<code>Player</code>类内部实现了</p>

<h2>替代方案:代理(delegate)</h2>

<p>再一次假设你有一个像上面例子中的<code>Player</code>类，现在，你想在开始播放的时候在某个地方执行一个自定的函数。这么做相对容易一些：创建一个自定义的子类，重写<code>play</code>方法，调用<code>[super play]</code>，然后开始做你自定义的工作。这么做是一种方法，另外一种方法是，改动你的<code>Player</code>对象，然后给它设置一个代理。如下：</p>

<pre><code>@class Player;

@protocol PlayerDelegate

- (void)playerDidStartPlaying:(Player *)player;

@end


@class Player : NSObject

@property (nonatomic,weak) id&lt;PlayerDelegate&gt; delegate;

- (void)play;
- (void)pause;

@end
</code></pre>

<p>现在，在播放器的<code>play</code>方法里，就可以给代理发<code>playerDidStartPlaying :</code>消息了。这个<code>Player</code>类的任何使用者都可以仅仅实现这个代理协议，而不用继承该类，<code>Player</code>类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像<code>UITextField</code>这样的类，还有<code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如<code>UITableView</code>,它不仅有个一个代理(delegate),还有一个数据源(dataSource)</p>

<h2>替代方案：类别(Categories)</h2>

<p>有时候，你可能会想给你一个对象增加一点点额外的功能，比如你想给NSArray增加一个方法<code>arrayByRemovingFirstObject</code>.不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<pre><code>@interface NSArray (OBJExtras)

- (void)obj_arrayByRemovingFirstObject;

@end
</code></pre>

<p>在用类别扩展一个不是你自己的类的时候，在方法前欠佳前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有一个另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h2>替代方案:配置对象(Configuration Objects)</h2>

<p>在我经常犯的错误中，其中一条就是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。假如，在一个幻灯片应用里，你有一个主题类<code>Theme</code>,它含有几个属性，比如<code>backgroundColor</code>和<code>Font</code>，还有一些在一张幻灯片上如何布局的逻辑函数</p>

<p>然后，对每种主题，你都创建一个<code>Theme</code>的子类，重写某个函数(例如 <code>setup</code>)并且配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如 幻灯片布局）放在<code>Theme</code>类中，把属性的配置放到比较简单的对象中，这些对象中只包含有这些属性。</p>

<p>例如，类<code>ThemeConfiguration</code>具有<code>backgroundColor</code>和<code>font</code>属性，而类<code>Theme</code>在其初始化函数中获取一个配置类<code>ThemeConfiguration</code>的值</p>

<h2>替代方案:组合</h2>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不像共享同样的接口，组合就是你的首选武器，例如，假设你要设计一个缓存类:</p>

<pre><code>@interface OBJCache : NSObject

- (void)cacheValue:(id)value forKey:(NSString *)key;
- (void)removeCachedValueForKey:(NSString *)key;

@end
</code></pre>

<p>简单点的做法是直接继承<code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法.</p>

<pre><code>@interface OBJCache : NSDictionary
</code></pre>

<p>但是这么做有几个弊端，它本来是应该被详细实现的，但只是通过字典来实现，现在，在任何需要一个<code>NSDictionary</code>参数的时候，你可以直接提供一个<code>OBJCache</code>值。但如果你想把它转为其它完全不同的东西，你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性(或者实例变量)中，对外仅仅暴露这两个<code>cache</code>方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo/"/>
    <updated>2016-07-19T13:44:10+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在ios中，所有的View都是由一个底层的layer来驱动的。View和它的layer之间有着紧密的联系，View其实直接从layer对象中获取了绝大多数它所需要的数据。在ios中也有一些单独的layer,比如<code>AVCaptureVideoPreviewLayer</code>和<code>CAShapeLayer</code>，它们不需要附加到view上就可以在屏幕上显示内容。两种情况下都是layer起决定作用。当然了，附加到view上的layer和单独的layer在行为上还是稍有不同的。</p>

<!--more-->


<p>基本上你改变一个单独的layer的任何属性的时候，都会触发一个从旧值过渡到新值的简单动画（就是所谓的动画<code>animatable</code>）。然而，如果你改变的是view中layer的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有layer,但是当layer附加在view上时，它的默认的隐式动画的layer行为就不起作用了。</p>

<blockquote><p><em>注意</em>
animatable 几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以'animatable'结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，设置也囊括了像isHidden和doubleSides这样的布尔值。像paths这样的属性也是animatable的。但是它不支持隐式动画。</p></blockquote>

<p>在 Core Animation 编程指南的"How to Animate Layer-Backed Views"中，对为什么会这样做出了一个解释:</p>

<blockquote><p>UIView默认情况下进制了layer动画，但是在animation block中又重新启用了它们</p></blockquote>

<p>这正是我们所看到的额行为，当一个属性在动画block之外被改变时，没有动画，但是当属性在动画block内改变时，就带上了动画。对于这是如何发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了view和layer之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的layer属性改变时，layer都会寻找并运行何时的'Action'来实行这个改变。在core Animation的专业术语中就把这样的动画统称为动作(Action,或者CAAction)</p>

<blockquote><p>CAAction:从技术上来说，这是一个接口，并可以用来做各种事情，但是实际上，某种程度上你可以只把它理解为用来处理动画</p></blockquote>

<p>layer将像文档中缩写的那样去寻找动作，整个过程分为5个步骤。第一步中的view和layer中交互的部分是最有意思的：</p>

<p>layer通过向它的代理发送 <code>actionForLayer:forKey:</code>消息来询问提供一个对应属性变化的action.delegate可以通过返回以下三者之一来进行响应:</p>

<ol>
<li>它可以返回一个动作对象，这种情况下layer将使用这个动作</li>
<li>它可以返回一个nil,这样layer就会到其他地方继续寻找</li>
<li>它可以返回一个NShull对象，告诉layer这里不需要执行一个动作，搜索也会就此停止</li>
</ol>


<p>而让这一切变得有趣的是，当layer在背后支持一个view的时候，view就是它的delegate;</p>

<blockquote><p>在ios中，如果layer与一个UIview对象关联时，这个属性必须被设置为持有这个layer的那个view</p></blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了；属性改变时layer会向View请求一个动作，而一般情况下view将返回一个NSNull,只有当属性改变发生在动画block中时，view才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的layer属性向view询问动作就可以了，比如对于'position':</p>

<pre><code>NSLog(@"outside animation block: %@",
      [myView actionForLayer:myView.layer forKey:@"position"]);

[UIView animateWithDuration:0.3 animations:^{
    NSLog(@"inside animation block: %@",
          [myView actionForLayer:myView.layer forKey:@"position"]);
}];
</code></pre>

<p>运行上面的代码，可以看到在block外view返回的是NSNull对象，而在block中时返回的是一个CABasicAnimation.很优雅，对吧?值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))：</p>

<pre><code>outside animation block: &lt;null&gt;
inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;
</code></pre>

<p>对于view中的layer来说，对动作的搜索只会到第一步为止。对于单独的layer来说，剩余的4个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer</a>actionForKey: 文档中找到。</p>

<h2>从UIKit中学习</h2>

<p>我很确定我们都会同意UIview动画是一组非常优秀的API,它简洁明确，实际上，它使用了Core Animation来执行动画，这给了我们一个绝佳的积水来深入研究UIKit是如何使用Core Animation的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴.</p>

<p>当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forKey:方法将添加到layer中，就像显示地添加动画那样。再一次，别直接相信我，让我们实践检验一下</p>

<p>归功于UIview的layerClass 类方法，View和layer之间的交互很容易被观测到。通过这个方法我们可以在为View创建layer时为其指定要使用的类。通过子类一个UIView,以及用这个方法返回一个自定义的layer类，我们就可以重写layer子类中的 <code>addAnimaiton:ForKey:</code>并输出一些东西来验证它是佛确实被调用。唯一要记住的是我们需要调用super方法，不然的话我们就把要观测的行为完全改变了：</p>

<pre><code>@interface DRInspectionLayer : CALayer
@end

@implementation DRInspectionLayer
- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
{
    NSLog(@"adding animation: %@", [anim debugDescription]);
    [super addAnimation:anim forKey:key];
}
@end


@interface DRInspectionView : UIView
@end

@implementation DRInspectionView
+ (Class)layerClass
{
    return [DRInspectionLayer class];
}
@end
</code></pre>

<p>通过输出动画的debug信息，我们不仅可以验证它确实如逾期一样被调用了，还可以看到动画是如何组织构建的：</p>

<pre><code>&lt;CABasicAnimation:0x8c73680; 
    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
    fillMode = both; 
    timingFunction = easeInEaseOut; 
    duration = 0.3; 
    fromValue = NSPoint: {5, 5}; 
    keyPath = position
&gt;
</code></pre>

<p>当动画被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue(也就是当前值)被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的行为应该是:</p>

<blockquote><p>只有FromValue不是nil时，在fromvalue和属性当前显示层的值之间进行插值</p></blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到layer上：</p>

<pre><code>CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@"opacity"];
fadeIn.duration  = 0.75;
fadeIn.fromValue = @0;

myLayer.opacity = 1.0; // 更改 model 的值 ...
// ... 然后添加动画对象
[myLayer addAnimation:fadeIn forKey:@"fade in slowly"];
</code></pre>

<p>这很简洁，你也不需要再动画被移除的时候做什么额外的操作，如果动画是在一段延迟后才开始的话，你可以使用backward填充模式(或者'both'填充模式)，就像UIKit所创建的动画那样</p>

<p>可能你看见上面输出中的动画的delegate了，想知道这个类是用来做什么的呢？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a>,它主要用来维护动画的一些状态(持续时间，延时，重复次数等等)，它还负责对一个栈做push和pop,这是为了在多个动画block嵌套时能够获取正确的动画状态。这些都是事先细节，除非你想要写一套自己的基于block的动画API,否则可能你不会用到它们</p>

<p>然后真正有意思的是这个delegate事先了 animationDidStart: 和 animationDidStop:finished: 并将信息传给了它自己的delegate</p>

<blockquote><p>这里不太容易理解，加以说明:从上面的头文件可以看出，作为CAAnimation的delegate的私有类UIViewAnimationState中还有个<code>_delegate</code>成员，并且<code>animationDidStart</code>和<code>animationDidStop:finished:</code>也是典型的delegate的实现方法.</p></blockquote>

<p>通过打印这个delegate的delegate,我们可以发现它也是一个私有类：<code>UIViewAnimationBlockDelegate</code>。同样进行<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且进行相应的block.如果我们使用自己的Core Animation代码，并且选阿泽block而不是delegate做回调的话，添加这个是很容易的：</p>

<pre><code>@interface DRAnimationBlockDelegate : NSObject

@property (copy) void(^start)(void);
@property (copy) void(^stop)(BOOL);

+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
                                   completion:(void(^)(BOOL finished))completion;

@end

@implementation DRAnimationBlockDelegate

+ (instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
                                    completion:(void (^)(BOOL))completion
{
    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
    result.start = beginning;
    result.stop  = completion;
    return result;
}

- (void)animationDidStart:(CAAnimation *)anim
{
    if (self.start) {
        self.start();
    }
    self.start = nil;
}

- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    if (self.stop) {
        self.stop(flag);
    }
    self.stop = nil;
}

@end
</code></pre>

<p>虽然是我的个人喜好，但是我觉得像这样的基于block的回调风格可能会比实现一个delegate回调更适合你的代码:</p>

<pre><code>fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
    NSLog(@"beginning to fade in");
} completion:^(BOOL finished) {
    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
}];
</code></pre>

<h2>自定义基于block的动画APIS</h2>

<p>一旦你知道了<code>actionForKey:</code>的原理之后，UIview就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于block的动画Apis。我所设计的动画将通过block中用一个很激进的时间曲线来做动画，以吸引用户对该View的注意，之后做一个缓慢的动画回到原始状态。你可以把它看做一种类似pop的行为。与一般使用<code>UIViewAnimationOptionAutoreverse</code>的动画block不同，因为动画设计和概念上的需要，我自己实现了将model值改变回原始值的过程。自定义的动画API的使用方法就像这样:</p>

<pre><code>[UIView DR_popAnimationWithDuration:0.7
                             animations:^{
                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
                                }];
</code></pre>

<p>当我们完成后，效果是这样样子的(对四个不同的View为位置，尺寸，颜色和旋转进行动画)</p>

<p><img src="http://7xsn4e.com1.z0.glb.clouddn.com/2014-05-01-view-layer-synergy-custom-block-animations.gif" alt="1" /></p>

<p>要开始实现它，我们首先要做的是当一个layer属性变化时获取delegate的回调，因为我们无法实现预测layer要改变什么，所以我选择在一个UIView的category中的swizzle<code>actionForLayer:forKey:</code>方法:</p>

<pre><code>@implementation UIView (DR_CustomBlockAnimations)

+ (void)load
{        
    SEL originalSelector = @selector(actionForLayer:forKey:);
    SEL extendedSelector = @selector(DR_actionForLayer:forKey:);

    Method originalMethod = class_getInstanceMethod(self, originalSelector);
    Method extendedMethod = class_getInstanceMethod(self, extendedSelector);

    NSAssert(originalMethod, @"original method should exist");
    NSAssert(extendedMethod, @"exchanged method should exist");

    if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
        class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, extendedMethod);
    }
}
</code></pre>

<p>为了保证我们不破坏其他依赖于<code>actionForLayer:forKey:</code>的回调代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子莱索一个简单的Bool其实就够了，但是如果我们之后要写更多内容的话，上下文的话要灵活得多了：</p>

<pre><code>static void *DR_currentAnimationContext = NULL;
static void *DR_popAnimationContext     = &amp;DR_popAnimationContext;

- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
{
    if (DR_currentAnimationContext == DR_popAnimationContext) {
        // 这里写我们自定义的代码...
    }

    // 调用原始方法
    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
}
</code></pre>

<p>在我们的实现中，我们要确保在执行动画block之前设置动画的上下文，并且在执行后恢复上下文：</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;
     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();
     /* 一会儿再添加 */
     DR_currentAnimationContext = NULL;
 }
</code></pre>

<p>如果我们想要做的不过是添加一个从旧值向新值过渡的动画的话，我们可以直接在delegate的回调中来做。然后因为我们想要更精确的控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓</p>

<p>有意思的是，ios添加的一个基于block的动画API也遇到了同样了问题，使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每一个关键帧，在属性变化时，view返回nil,但是却存储下需要的状态。这样就能在所有关键帧block执行后创建一个<code>CAKeyframeAnimationz</code>对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么layer被更改了，什么key path的值被改变了，以及原来的值是什么:</p>

<pre><code> @interface DRSavedPopAnimationState : NSObject

 @property (strong) CALayer  *layer;
 @property (copy)   NSString *keyPath;
 @property (strong) id        oldValue;

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath;

 @end

 @implementation DRSavedPopAnimationState

 + (instancetype)savedStateWithLayer:(CALayer *)layer
                             keyPath:(NSString *)keyPath
 {
     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
     savedState.layer    = layer;
     savedState.keyPath  = keyPath;
     savedState.oldValue = [layer valueForKeyPath:keyPath];
     return savedState;
 }

 @end
</code></pre>

<p>接下来，在我们的交换后的delegate回调中，我们简单地讲被变更的属性的状态存入一个静态可变数组中：</p>

<pre><code> if (DR_currentAnimationContext == DR_popAnimationContext) {
       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
                                                                                 keyPath:event]];

       // 没有隐式的动画 (稍后添加)
       return (id&lt;CAAction&gt;)[NSNull null];
   }
</code></pre>

<p>在动画block执行完毕后，所有的属性都被变更了，它们的状态也被保存了，现在，创建关键帧动画:</p>

<pre><code> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
                          animations:(void (^)(void))animations
 {
     DR_currentAnimationContext = DR_popAnimationContext;

     // 执行动画 (它将触发交换后的 delegate 方法)
     animations();

     [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
         DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
         CALayer *layer    = savedState.layer;
         NSString *keyPath = savedState.keyPath;
         id oldValue       = savedState.oldValue;
         id newValue       = [layer valueForKeyPath:keyPath];

         CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];

         CGFloat easing = 0.2;
         CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
         CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];

         anim.duration = duration;
         anim.keyTimes = @[@0, @(0.35), @1];
         anim.values = @[oldValue, newValue, oldValue];
         anim.timingFunctions = @[easeIn, easeOut];

         // 不带动画地返回原来的值
         [CATransaction begin];
         [CATransaction setDisableActions:YES];
         [layer setValue:oldValue forKeyPath:keyPath];
         [CATransaction commit];

         // 添加 "pop" 动画
         [layer addAnimation:anim forKey:keyPath];

     }];

     // 扫除工作 (移除所有存储的状态)
     [[self DR_savedPopAnimationStates] removeAllObjects];

     DR_currentAnimationContext = nil;
 }
</code></pre>

<p>注意老的model值被设置到了layer上，所以在当动画结束和移除后，model的值和persentation的值是相符合的。</p>

<p>创建像这样的你自己的API不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂UIview block动画的APis,特别是你已经在core Animation的舒适区的时候，这非常有助于你的提高。</p>
]]></content>
  </entry>
  
</feed>
