<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-05-26T15:12:40+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为iOS建立Travis CI]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci/"/>
    <updated>2016-05-23T14:30:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci</id>
    <content type="html"><![CDATA[<p>你是否曾经试着为ios项目搭建一台支持<a href="http://baike.baidu.com/link?url=9m9zB2m909wrZ82wdNWMhtPBTt14PduTPIyi78YL0sS7ccrE-DN22S55wCuEhuobFZ0dL5T4MhKmQzFLx1q4-K">持续集成</a>的服务器，从我的个人经验而言，这可不是一个轻松的活。首先需要准备一台MAc电脑，并安装好全部所需的软件和插件。你要负责管理所有的用户账户，并提供安全保护。你需要授予访问仓库的权限，并配置所有的编译步骤和证书，在项目的运行时期，你需要保持服务器稳健和最新。</p>

<!--more-->


<p>最后，原本你想节省时间，会发现你花费了大量的时间去维护这台服务器，不过如果你的项目托管在github上，现在有了新的希望：<a href="https://travis-ci.org/">Travis CI</a>.该服务可以为你的项目提供持续集成的支持，也就意味着它会负责好托管一个项目的所有细节。在ruby的世界中，Travis CI以久负盛名。从2013年4月起，Travs也开始支持ios和mac平台</p>

<p>在这篇文章中，我将向你展示如何一步步的在项目中集成Travis.不仅包括项目的编译的单元测试运行，还包括将应用部署到你所有的测试设备上。</p>

<h2>GITHub集成</h2>

<p>我最喜欢Travis的一点就是它与GitHub的webUI集成的非常好，例如pull请求，Travis会为每次请求都执行编译操作。如果一切正常，pull请求在Github上看起来这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_ready_to_merge.jpg" alt="e" /></p>

<p>万一编译不成功，Github页面会修改相应的颜色。给予提醒:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_merge_with_caution.jpg" alt="1" /></p>

<h2>链接 Travis 和 GitHub</h2>

<p>让我们看一下如何将Github项目与Travis链接上，使用Github账号登录 <a href="https://travis-ci.org/">Travis 站点</a>。对于私有仓库，需要注册一个Travis 专业版账号</p>

<p>登录成功后，需要为项目开启Travis支持，导航到<a href="https://travis-ci.org/profile">属性页面</a>,该页面列出了所有的github项目，不过要注意，如果此后创建了一个新的仓库，要使用 sync now 按钮进行同步。Travis只会偶尔更新的项目列表.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_travis_flick.jpg" alt="test" /></p>

<p>现在只需要打开这个开关就可以在你的项目添加Travis服务，之后你会看到Travis会和Github项目设置关联。下一步就是告诉Travis，当它收到项目改动通知之后该做什么。</p>

<h2>最简单的项目配置</h2>

<p>Tranvis CI 需要项目的一些基本信息。在项目的根目录创建一个名为 .travis.yml的文件，文件中内容如下：</p>

<pre><code>language: objective-c
</code></pre>

<p>Travis 编译器运行在虚拟机环境下，该编译器已经利用 <code>Ruby</code>,<code>homebrew</code>,<code>CocoaPods</code>和一些默认的编译脚本进行过<a href="http://about.travis-ci.org/docs/user/osx-ci-environment/">预配置</a>.上述的配置项已经足够编译你的项目了。</p>

<p>预装的编译脚本会分析你的Xcode项目，并对每个target进行编译。如果所有文件都没有编译错误，并且测试也没有被打断，那么项目就编译成功了。现在可以将改动push到GitHub上看看能否成功编译。</p>

<p>虽然上述配置过程真的很简单，不过对你的项目不一定适用。这里几乎没有什么文档来指导用户如何配置默认的编译行为。例如：有一次我没有用 iphonesimulator SDK 导致代码签名错误。如果刚刚那个最简单的配置对你的项目不适用的话，让我们来看一下如何对Travis使用自定义的编译命令</p>

<h3>自定义编译命令</h3>

<p>Travis 使用命令行对项目进行编译。因此，第一步就是使项目能够在本地编译。作为Xcode命令行工具的一部分，Apple提供了<code>xcodebuild</code>命令</p>

<p>打开终端并输入:</p>

<pre><code>xcodebuild --help
</code></pre>

<p>上述命令会列出xcodebuild所有可用的参数。如果命令执行失败了，确保命令行工具已经成功安装。一个常见的编译命令看起来是这样的：</p>

<pre><code>'xcodebuild -project {project}.xcodeproj -target {target} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>使用 iphonesimulator SDK是为了避免签名错误，知道我们稍后引入证书之前，这一步是必须的。通过设置<code>ONLY_ACTIVE_ARCH=NO</code>我们可以确保利用模拟器架构编译工程。你也可以设置额外的属性，例如<code>configuration</code>,输入 man xcodebuild查看相关文档。</p>

<p>对于使用 CocoaPods的项目，需要用下面的命令来指定 workspace和scheme:</p>

<pre><code>xcodebuild -workspace {workspace}.xcworkspace -scheme {scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>schemes 是由Xcode自动生成的，但这在服务器上不会发生。确保所有的scheme都被设置为 shared并加入到仓库中，否则它只会在本地工作而不会被Travis CI识别。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_shared_schemes.jpg" alt="w" /></p>

<p>我们实例项目下的 .travis.yml文件现在看起来应该是这样</p>

<pre><code>language: objective-c
script: xcodebuild -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<h2>运行测试</h2>

<p>对月测试来说，通常使用如下这个命令(注意 test 属性)</p>

<pre><code>xcodebuild test -workspace {workspace}.xcworkspace -scheme {test_scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>不幸的是，xcodebuild对于ios来说，并不能正确支持target和应用程序的测试。<a href="http://www.raingrove.com/2012/03/28/running-ocunit-and-specta-tests-from-command-line.html">这里有一些解决方案</a>不过我建议使用Xctool.</p>

<h3>Xctool</h3>

<p><a href="https://github.com/facebook/xctool">Xctool</a>是来自FaceBook的命令行工具，它可以简化程序的编译和测试。它的彩色输出信息比 xcodebuild更加简洁美观。同时还添加了对逻辑测试，应用测试的支持。</p>

<p>Travis中已经预装了xctool。要在本地测试的话，需要用homebrew安装xctool:</p>

<p>xctool用法非常简单，它使用的参数跟xcodebuild相同：</p>

<pre><code>xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>一旦相关命令在本地能正常工作，那么就是时候把它们添加到 .travis.yml中了：</p>

<pre><code>language: objective-c
script:
  - xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
  - xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</code></pre>

<p>到此为止，介绍的内容对于使用Travis的library工程来说，已经足够了。我们可以确保项目正常编译并测试通过。但对于ios应用来说，我们希望能在真实的物理设备上进行测试。也就说我们需要将应用部署到我们的所有测试设备上。当然，我们希望Travis能自动完成这项任务。首先，我们需要给程序签名</p>

<h1>应用程序的签名</h1>

<p>为了在Travis中能给程序签名，我们需要准备好所有必须的证书和配置文件。就像每个ios开发人员指导的那样，这可能是最困难的一步。后面，我将写一些脚本在服务器上给应用程序签名。</p>

<h2>证书和配置文件</h2>

<h3>1.苹果全球开发者关系认证</h3>

<p>从<a href="http://developer.apple.com/certificationauthority/AppleWWDRCA.cer">苹果官网</a>或者从钥匙串中导出。并将保存到项目的目录<code>scripts/certs/apple.cer</code>中。</p>

<h3>2.iPhone发布证书 + 私钥</h3>

<p>如果还没有发布证书的话，先创建一个。登录<a href="https://developer.apple.com/account/overview.action">苹果开发者账号</a>,按照步骤，创建一个新的生产环境证书(<em>Certificates</em>)><em>Production</em>><em>Add</em>><em>App Store and ad hoc</em>)。然后下载并安装证书。之后，可以在钥匙串中找到它。打开Mac中的钥匙串应用程序：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/dist_cert_keychain.jpg" alt="key" /></p>

<p>右键单击证书，选择<code>Export ....</code>将证书导出至<code>scripts/certs/dist.cer</code>.然后导出私钥并保存至<code>cripts/certs/dist.p12</code>.记得输入私钥的密码.</p>

<p>由于Travis需要知道私钥密码，因此我们要把这个密码存储在某个地方，当然，我们不希望已明文的形式存储。我们可以用<a href="http://about.travis-ci.org/docs/user/build-configuration/#Secure-environment-variables">Travis的安全环境变量</a>。打开终端，并定位到包含 .travis.yml文件所在目录。首先用 <code>gem install travis</code>命令安装Travis gem.之后用下面的命令添加秘钥密码:</p>

<pre><code>travis encrypt "KEY_PASSWORD={password}" --add
</code></pre>

<p>上面的命令会安装一个叫做<code>Key_Password</code>的加密环境变量到 .travis.yml 配置文件中。这样就可以在被 Travis CI执行的脚本中使用这个变量</p>

<h3>3.ios 配置文件(发布)</h3>

<p>如果还没有用于发布的配置文件，那么也创建一个新的。根据开发者账号类型，可以选择创建 <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/TestingYouriOSApp/TestingYouriOSApp.html">ADHoc</a>或<a href="https://developer.apple.com/programs/ios/enterprise/gettingstarted/">IN House</a>配置文件<em>(Provisioning Profiles > Distribution > Add > Ad Hoc or In House)</em>.然后将其下载保存到<code>scripts/profile/</code>目录。</p>

<p>由于Travis需要访问这个配置文件，所以我们需要将这个文件的名字存储为一个全局变量。并将其添加到.travis.yml文件的全局环境变量section中。例如，如果配置文件的名字是 <code>TravisExample_Ad_Hoc.mobileprovision</code>,那么按照如下进行添加:</p>

<pre><code>env:
  global:
  - APP_NAME="TravisExample"
  - 'DEVELOPER_NAME="iPhone Distribution: {your_name} ({code})"'
  - PROFILE_NAME="TravisExample_Ad_Hoc"
</code></pre>

<p>上面还声明了两个环境变量。第三行中的<code>APP_name</code>通常为项目默认的target的名字。第四行的<code>DEVELOPER_NAME</code>是xcode中，默认target里面Build Settings的Code Signing Identity > Release 对应的名字。然后搜索程序的<code>Ad Hod</code>或者<code>In house</code>配置文件，将其中黑体文字取出，根据设置的不同，括弧中可能不会有任何信息。</p>

<h2>加密证书和配置文件</h2>

<p>如果你的GitHub仓库是公开的，你可能希望对证书和配置文件进行加密。如果你的是私有仓库，可以跳过这一节</p>

<p>首先，我们需要一个密码来对所有的文件进行加密。在我们的实例中，密码为"foo",记住在你的工程中设置的密码应该更加复杂。在命令行汇总，我们使用<code>openssl</code>加密所有的敏感文件：</p>

<pre><code>openssl aes-256-cbc -k "foo" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -a
openssl aes-256-cbc -k "foo" -in scripts/certs/dist.cer -out scripts/certs/dist.cer.enc -a
openssl aes-256-cbc -k "foo" -in scripts/certs/dist.p12 -out scripts/certs/dist.cer.p12 -a
</code></pre>

<p>通过上面的命令，可以创建出以 .enc结尾的加密文件。之后可以把原始文件忽略或者移除掉。至少不要把原始文件提交到GitHub中，否则原始文件会显示在GitHub中。如果你不小心把原始文件提交上去了，那么请看这里<a href="https://help.github.com/articles/remove-sensitive-data">如何解决</a></p>

<p>现在，我们的文件已经被加密了，接下来我们需要告诉Travis对文件进行解密。解密过程，需要用到密码。具体释放方法跟之前创建的<code>KEY_PASSOWORD</code>变量一样:</p>

<pre><code>travis encrypt "ENCRYPTION_SECRET=foo" --add
</code></pre>

<p>最后，我们需要告诉Travis那些文件需要进行解密.将下面的命令添加到 .travis.yml文件中的before-script部分：</p>

<pre><code>before_script:
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -d -a -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12
- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12
</code></pre>

<p>就这样，在GitHub上面的文件就安全了，并且Travis依旧能读取并使用这些加密后的文件。但是有一个安全问题你需要知道，在Travis的编译日志中可能会显示出解密环境变量。不过对pull请求来说不会出现</p>

<h2>添加脚本</h2>

<p>现在我们需要确保证书都导入到了Travis CI的钥匙串中。为此，我们需要在scripts文件夹中添加一个名为 <code>add-key.sh</code>的文件：</p>

<pre><code>#!/bin/sh
security create-keychain -p travis ios-build.keychain
security import ./scripts/certs/apple.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
security import ./scripts/certs/dist.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
security import ./scripts/certs/dist.p12 -k ~/Library/Keychains/ios-build.keychain -P $KEY_PASSWORD -T /usr/bin/codesign
mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
cp ./scripts/profile/$PROFILE_NAME.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/
</code></pre>

<p>通过上面的命令创建了一个名为<code>ios-build</code>的临时钥匙串，里面包含了所有证书。注意，这里我们使用了<code>$Key_PASSWORD</code>来导入私钥。最后一步是将配置文件拷贝到LIbrary文件夹。</p>

<p>创建好文件之后，确保其授予了可执行的权限：在命令行输入:<code>chmod a+x scripts/add-key.sh</code>即可。为了正常使用脚本，必须要这样处理一下。</p>

<p>至此，已经导入了所有的证书和配置文件，我们可以开始给应用程序签名了。注意，在给程序签名之前必须对程序进行编译。由于我们需要知道编译结果存储在磁盘的具体位置，我建议在编译命令中使用<code>OBJROOT</code>和<code>SYMROOT</code>来指定输出目录，另外，为了创建 release版本，还需要把SDK设置为 iphones,以及configuration修改为 Release:</p>

<pre><code>xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO 'CODE_SIGN_RESOURCE_RULES_PATH=$(SDKROOT)/ResourceRules.plist'
</code></pre>

<p>如果运行了上面的命令，那么编译完成之后，可以在<code>build/Release-iphoneos</code>目录中找到对应程序的二进制文件。接下来，就可以对其签名，并创建IPA文件了。为此，我们创建了一个新的脚本：</p>

<pre><code>#!/bin/sh
if [[ "$TRAVIS_PULL_REQUEST" != "false" ]]; then
  echo "This is a pull request. No deployment will be done."
  exit 0
fi
if [[ "$TRAVIS_BRANCH" != "master" ]]; then
  echo "Testing on a branch other than master. No deployment will be done."
  exit 0
fi

PROVISIONING_PROFILE="$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_NAME.mobileprovision"
OUTPUTDIR="$PWD/build/Release-iphoneos"

xcrun -log -sdk iphoneos PackageApplication "$OUTPUTDIR/$APPNAME.app" -o "$OUTPUTDIR/$APPNAME.ipa" -sign "$DEVELOPER_NAME" -embed "$PROVISIONING_PROFILE"
</code></pre>

<p>第二行至第九行非常重要。我们并不希望在某个特性分支上创建新的release.对Pull请求也一样的。由于安全环境变量被禁用，所有pull请求也不会编译。</p>

<p>第十四行，才是真正的签名操作。这个命令会在<code>build/Release-iphoneos</code>目录下生成2个文件：<code>TravisExample.ipa</code>和<code>TravisExample.app.dsym</code>。第一个文件包含了分发至手机上的应用程序。dsym文件包含了二进制文件的调试信息。这个文件对于记录设备上的crash信息非常重要。之后当我们部署应用程序的时候，会用到这两个文件。</p>

<p>最后一个脚本是移除之前创建的临时钥匙串，并删除配置文件。虽然这不是必须的，不过这有助于进行本地测试。</p>

<pre><code>#!/bin/sh
security delete-keychain ios-build.keychain
rm -f ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_NAME.mobileprovision
</code></pre>

<p>最后一步，我们必须告诉Travis什么时候执行这三个脚本，在应用程序编译，签名和清楚等之前，需要先添加私钥。在 .travis.yml文件中添加如下内容：</p>

<pre><code>before_script:
- ./scripts/add-key.sh
- ./scripts/update-bundle.sh
script:
- xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO
after_success:
- ./scripts/sign-and-upload.sh
after_script:
- ./scripts/remove-key.sh
</code></pre>

<p>完成上面的所有操作之后，我们就可将所有内容push到GItHub上，等待Travis对应用程序进行签名，我们可以在工程页面下的Travis控制台验证是否一切正常，如果一切正常的话，下面来看看如何将签名好的应用程序部署给测试人员。</p>

<h2>部署应用程序</h2>

<p>这里有两个知名的服务可以帮你发布应用程序:<a href="http://testflightapp.com/">TestFlight</a>和<a href="http://hockeyapp.net/">HockyeyApp</a>。不管选择哪个都能满足需求。就我个人而言，推荐使用 HockeyApp,不过这里我会对这两个服务都做介绍。</p>

<p>首先我们队 sign-and-build.sh脚本做一个扩充&ndash;在里面添加一些release记录:</p>

<pre><code>RELEASE_DATE=`date '+%Y-%m-%d %H:%M:%S'`
RELEASE_NOTES="Build: $TRAVIS_BUILD_NUMBER\nUploaded: $RELEASE_DATE"
</code></pre>

<p>注意这里使用了一个Travis的全局变量<code>TRAVIS_BUILD_NUMBER</code>.</p>

<h2>TestFlight</h2>

<p>创建一个<a href="https://testflightapp.com/register/">TestFlight账号</a>，并配置好应用程序。为了使用TestFlight的API,首先需要获得<a href="https://testflightapp.com/account/#api">apitoken</a>和<a href="https://testflightapp.com/dashboard/team/edit/?next=/api/doc/">teamtoken</a>。再强调一次，我们需要确保它们是加密的。在命令行中执行如下命令:</p>

<pre><code>travis encrypt "TESTFLIGHT_API_TOKEN={api_token}" --add
travis encrypt "TESTFLIGHT_TEAM_TOKEN={team_token}" --add
</code></pre>

<p>现在我们可以调用相应的API了。并将下面的内容添加到<code>sign-and-build.sh:</code></p>

<pre><code>curl http://testflightapp.com/api/builds.json \
  -F file="@$OUTPUTDIR/$APPNAME.ipa" \
  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
  -F api_token="$TESTFLIGHT_API_TOKEN" \
  -F team_token="$TESTFLIGHT_TEAM_TOKEN" \
  -F distribution_lists='Internal' \
  -F notes="$RELEASE_NOTES"
</code></pre>

<p>千万不要使用verbose标记(-v)&ndash;这会暴露加密tokens.</p>

<h2>HOckeyApp</h2>

<p>注册一个<a href="http://hockeyapp.net/plans">HockeyApp账号</a>，并创建一个新的应用程序。然后在概述页面获取一个AppId.接下来，我们必须创建一个Api Token.打开<a href="https://rink.hockeyapp.net/manage/auth_tokens">这个页面</a>并创建一个。如果你希望自动的将新版本部署给所有的测试人员，那么请选择 Full Access版本。</p>

<p>对App Id 和token进行加密:</p>

<pre><code>travis encrypt "HOCKEY_APP_ID={app_id}" --add
travis encrypt "HOCKEY_APP_TOKEN={api_token}" --add
</code></pre>

<p>然后在sign-and-build.sh文件中调用相关的API:</p>

<pre><code>curl https://rink.hockeyapp.net/api/2/apps/$HOCKEY_APP_ID/app_versions \
  -F status="2" \
  -F notify="0" \
  -F notes="$RELEASE_NOTES" \
  -F notes_type="0" \
  -F ipa="@$OUTPUTDIR/$APPNAME.ipa" \
  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
  -H "X-HockeyAppToken: $HOCKEY_APP_TOKEN"
</code></pre>

<p>注意我们还上传了dsym文件。如果集成了TestFlight或HockeyAppSdk，我们可以立即收集到易读的crash报告。</p>

<h2>Travis故障排除</h2>

<p>知道如何不通过直接访问编译环境就能找出问题是非常重要的。</p>

<p>在写本文的时候，还没有可以下载的虚拟机映像。如果Travis不能正常编译，首先试着在本地重现问题。在本地执行跟Travis相同的编译命令：</p>

<pre><code>xctool ...
</code></pre>

<p>为了调试shell脚本，首先需啊哟定义环境变量。我的做法是创建一个新的shell脚本来设置所有的环境变量。记得将这个脚本添加到 .gitignore文件中&ndash;因为我们不希望将该文件公开暴露出去。支队示例工程来说， config.sh脚本文件看起来是这样的：</p>

<pre><code>#!/bin/bash

# Standard app config
export APP_NAME=TravisExample
export DEVELOPER_NAME=iPhone Distribution: Mattes Groeger
export PROFILE_NAME=TravisExample_Ad_Hoc
export INFO_PLIST=TravisExample/TravisExample-Info.plist
export BUNDLE_DISPLAY_NAME=Travis Example CI

# Edit this for local testing only, DON'T COMMIT it:
export ENCRYPTION_SECRET=...
export KEY_PASSWORD=...
export TESTFLIGHT_API_TOKEN=...
export TESTFLIGHT_TEAM_TOKEN=...
export HOCKEY_APP_ID=...
export HOCKEY_APP_TOKEN=...

# This just emulates Travis vars locally
export TRAVIS_PULL_REQUEST=false
export TRAVIS_BRANCH=master
export TRAVIS_BUILD_NUMBER=0
</code></pre>

<p>为了暴露所有的环境变量，执行如下命令(确保config.sh是可执行的)</p>

<pre><code>. ./config.sh
</code></pre>

<p>然后试着运行 <code>echo $APP_NAME</code>,以此检查脚本是否正确。如果正确的话，那么现在我们不用做任何修改，就能在本地运行所有的shell脚本了。</p>

<p>如果在本地得到的是不同的编译信息，那么可能是使用了不同的库和gems.尽量试着将配置信息设置和Travis VM 相同的信息。Travis在这里列出了其所有的安装的软件版本，你也可以在travis的配置文件中添加调试信息得到所有库文件的版本。</p>

<pre><code>gem cocoapod --version
brew --version
xctool -version
xcodebuild -version -sdk
</code></pre>

<p>在本地安装好与服务器完全相同的软件之后，再重新编译项目。</p>

<p>如果获取的编译信息仍然不一样，试着将项目check out到一个新目录。并确保所有的缓存都已清空。每次编译程序时，Travis都会创建一个全新的虚拟机，所以不存在缓存的问题，但在你的本地机器上可能会出现。</p>

<p>一旦在本地重现出和服务器相同的错误，就可以开始调差具体问题了。当然导致问题的原因取决于具体问题。一般来说，通过Google都能找到引发问题的根源。</p>

<p>如果一个问题影响到了Travis上的其它项目，那么可能是Travis环境配置的原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/catransform3d/"/>
    <updated>2016-05-04T17:25:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/catransform3d</id>
    <content type="html"><![CDATA[<h1>图层的几个坐标系</h1>

<p>对于ios来说，坐标系的(0,0)点在左下角，就是越往下，Y值越大。越向右，X值就越大.</p>

<!--more-->


<p>一个图层的frame,它是position,bounds,anchorPoint和transform尚需经的一部分。</p>

<p>设置一个新的frame将会相应的改变图层的position和bounds,但是frame本身并没有保存。</p>

<h3>position</h3>

<p>是一个CGPoint值，它指定图层相当于它父图层的位置，该值基于父图层的坐标系</p>

<h3>bounds</h3>

<p>是一个CGRect值，指定图层的大小(bounds.size)和图层的原点(bounds.origin)，这个坐标系是基于自身的。如果改变bounds的origin,那么在该图层的子图层，左边会跟着改变。也就是说，改变自身的坐标系，本身在福图层的位置不变，但它上面的自图层位置变化</p>

<h3>anchorPoint</h3>

<p>是一个CGPoint值，它是指定了一个基于bounds的符合坐标系的位置。锚点(anchor point)制定了bounds相对于position的值，同时也作为一个变化时候的中心点。锚点使用空间坐标系取值范围是0-1之间的数。默认是0.5,也就是图标的中心点，如果是(0,0)那么图层向左上方移动。如果是(1,1)就向右下方移动。</p>

<p>看下面的两个图，就能够清晰的看出锚点变化所带来的不一样。（此图为Mac OS 坐标系，如果是iOS，那么（0，0）点在图的左上方。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-ec88270eb7d8c9a0.png" alt="1" /></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-bfe77d9ab6636ce0.png" alt="2" /></p>

<p>对于anchorPoint的解释在ios中如图:</p>

<p>下图中的红点位置就是锚点的位置，默认是(0.5,0.5)。在对图像进行变化时，都是按照这个店来进行缩放，偏移等。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-76ff5832ae84e2f6.png" alt="1" /></p>

<p>一旦修改锚点位置为:(0,0),那么图像就会变成下图.各种变换就会按照这个点来运动.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-e6bcb36d43e12c4d.png" alt="2" /></p>

<p>所以说在ios系统中，锚点的坐标系是:左上角为(0,0),右下角为(1,1)。</p>

<p>根据此图，再理解上面的定义，就直观多了。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-47294f41d81081da.png" alt="1" /></p>

<h1>图层的几何变换</h1>

<p>可以通过矩阵来改变一个图层的几何形状。</p>

<p><em>CATransform3D</em>的数据结构定义了一个同质的三维变换(4*4 CGFloat值的矩阵),用于图层的旋转，缩放，偏移和应用的透视。</p>

<p>图层的2歌属性指定了变换矩阵:transform和sublayerTransform。</p>

<h3>transform</h3>

<p>是结合anchorPoint的位置来对图层和图层上的子图层进行变化</p>

<h3>sublayerTransform</h3>

<p>是结合anchorPoint的位置来对图层的子图层进行变化，不包括本身</p>

<h3>CATransform3DIdentity</h3>

<p>是单位矩阵，该矩阵没有缩放，旋转，歪斜，透视。该矩阵应用到图层上，就是设置默认值。</p>

<h1>变换函数</h1>

<h3>CATransform3DMakeTranslation</h3>

<p>官方文档:</p>

<pre><code>Returns a transform that translates by '(tx, ty, tz)'. t' = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].

CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)。
</code></pre>

<p>对于CATransform3D来说，它是一个4*4的 CGFloat的矩阵。而上面的值:<code>[1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].</code>给竖起来后，就发现:</p>

<pre><code>1    0    0    0

0    1    0    0

0    0    1    0

tx   ty   tz   1
</code></pre>

<p>竖起来就很明显了。</p>

<p>CATransform3D又是一个结构，他有自己的一个公式，可以进行套用.</p>

<pre><code>struct CATransform3D

{

CGFloat    m11（x缩放）,    m12（y切变）,      m13（旋转）,   m14（）;

CGFloat    m21（x切变）,    m22（y缩放）,      and（）   ,   m24（）;

CGFloat    m31（旋转）  ,    m32（ ）  ,      m33（z轴缩放）   ,   m34（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;

CGFloat    m41（x平移）,    m42（y平移）,      m43（z平移） ,   m44（）;

};
</code></pre>

<p>根据这个公式就一目了然了。</p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)参数的意思就是 <em>tx:：x平移。  ty：y平移。  tz：z平移</em></p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</p>

<pre><code>tx：X轴偏移位置，往下为正数。

ty：Y轴偏移位置，往右为正数。

tz：Z轴偏移位置，往外为正数。
</code></pre>

<p>举个栗子:</p>

<p>如果有两个图层，一个是绿色的，一个是红色的，先加载绿色，后加载红色</p>

<p>tx,ty的偏移就先不说了</p>

<p>如果绿色的tz为-10，红色的tz为0，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-7d642630070e7554.png" alt="1" /></p>

<p>如果绿色的tz为0,红色的tz为-10，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-29ecdd06f03578f4.png" alt="2" /></p>

<p>对于tz来说，tz越大，那么图层就越靠近屏幕，值越小，图层越往里（离屏幕越远）</p>

<h4>CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz);</h4>

<p>t:就是上一个函数，其它都一样
就可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);</h4>

<p><em>sx:</em> x轴缩放，代表一个缩放比例，一般都是0-1之间的数字
<em>sy:</em> y轴上缩放
<em>sz:</em> 整体比例变换时，也就是m11(sx) == m22(sy)时，若m33(sz) > 1时，图形整体缩小，若0&lt;1,图形整体放大，若m33(sz) &lt; 0时，发生关于原点的对称等比变换。</p>

<p>当sx = 1时，sy = 1时，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-04771b49561f6d76.png" alt="1" /></p>

<p>当sx=0.5,sy=0.5时，如图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-6023b3794fd9917d.png" alt="2" /></p>

<h4>CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz)</h4>

<p>t：就是上一个函数。其他的都一样。</p>

<p>就可以理解为：函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>旋转效果</p>

<p>angle：旋转的弧度，所以要把角度转换成弧度：角度 * M_PI / 180</p>

<p>x:向X轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>y:向Y轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>z:向Z轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>原始图像如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-1.png" alt="1" /></p>

<p>例如：向X轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-2.png" alt="1" /></p>

<p>向Y轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-3.png" alt="1" /></p>

<p>向z轴方向旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-4.png" alt="test" /></p>

<p>向x轴和y轴都旋转60度，就是沿着对角线旋转</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-5.png" alt="t" /></p>

<h4>CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>t:就是上一个函数
可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DInvert (CATransform3D t);</h4>

<p>翻转效果</p>

<p>原始效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-6.png" alt="test" /></p>

<p>调用翻转后的效果:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-7.png" alt="result" /></p>

<h4>CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t);</h4>

<p>仿射效果</p>

<p>就是把一个CATransform3D对象转化成一个CGAffineTransform对象，也就是把CATransform3D矩阵转化成CGAffineTransform矩阵</p>

<p>变换函数同时提供了可以比较一个变换矩阵是否是单位矩阵，或者两个矩阵是否相等。</p>

<h4>bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);</h4>

<p>判断两个变换的矩阵是否相等</p>

<p>也可以通过修改数据结构和键值来设置变换效果</p>

<pre><code>struct CATransform3D

{

CGFloat m11, m12, m13, m14；

CGFloat m21, m22, m23, m24；

CGFloat m31, m32, m33, m34；

CGFloat m41, m42, m43, m44；

}
</code></pre>

<p>可以直接修改其中一个值，来达到相同的效果</p>

<p>或者修改键值</p>

<pre><code>[myLayer setValue:[NSNumber numberWithInt:0] forKeyPath:@"transform.rotation.x"];
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-43f4b4134597cd19.png" alt="e" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime运行时入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men/"/>
    <updated>2016-05-04T14:36:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men</id>
    <content type="html"><![CDATA[<h2>什么是Rumtime</h2>

<p>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target dosomething]</code>会被转化成 <code>objc_msgSend(target,@selector(doSomething));</code>.</p>

<!--more-->


<p>oc中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，实际上一个类本质上也是一个对象，在runTime中用结构体表示:</p>

<pre><code>/// 描述类中的一个方法
typedef struct objc_method *Method;

/// 实例变量
typedef struct objc_ivar *Ivar;

/// 类别Category
typedef struct objc_category *Category;

/// 类中声明的属性
typedef struct objc_property *objc_property_t;
</code></pre>

<p>类在rumtime中的表示:</p>

<pre><code>//类在runtime中的表示
struct objc_class {
    Class isa;//指针，顾名思义，表示是一个什么，
    //实例的isa指向类对象，类对象的isa指向元类

#if !__OBJC2__
    Class super_class;  //指向父类
    const char *name;  //类名
    long version;
    long info;
    long instance_size
    struct objc_ivar_list *ivars //成员变量列表
    struct objc_method_list **methodLists; //方法列表
    struct objc_cache *cache;//缓存
    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
    struct objc_protocol_list *protocols //协议列表
    #endif
} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */
</code></pre>

<h2>获取列表</h2>

<p>有时会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配).</p>

<p>我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表，方法列表，成员变量等)</p>

<pre><code> unsigned int count;
    //获取属性列表
    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);
    for (unsigned int i=0; i&lt;count; i++) {
        const char *propertyName = property_getName(propertyList[i]);
        NSLog(@"property----&gt;%@", [NSString stringWithUTF8String:propertyName]);
    }

    //获取方法列表
    Method *methodList = class_copyMethodList([self class], &amp;count);
    for (unsigned int i; i&lt;count; i++) {
        Method method = methodList[i];
        NSLog(@"method----&gt;%@", NSStringFromSelector(method_getName(method)));
    }

    //获取成员变量列表
    Ivar *ivarList = class_copyIvarList([self class], &amp;count);
    for (unsigned int i; i&lt;count; i++) {
        Ivar myIvar = ivarList[i];
        const char *ivarName = ivar_getName(myIvar);
        NSLog(@"Ivar----&gt;%@", [NSString stringWithUTF8String:ivarName]);
    }

    //获取协议列表
    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);
    for (unsigned int i; i&lt;count; i++) {
        Protocol *myProtocal = protocolList[i];
        const char *protocolName = protocol_getName(myProtocal);
        NSLog(@"protocol----&gt;%@", [NSString stringWithUTF8String:protocolName]);
    }
</code></pre>

<p><em>注意：不要忘记在类的顶部导入头文件<code>#import &lt;objc/runtime.h&gt;</code></em></p>

<h2>方法调用</h2>

<p>让我们看一下在运行时方法的调用</p>

<p>如果用实例对象调用实例方法，回到实例的isa指针指向的对象（也就是类对象）操作。如果调用的是类方法，就回到类对象的isa指针指向的对象（也就是元类对象）中操作。</p>

<ol>
<li>首先，在相应操作的对象中的缓存方法列表汇总找调用的方法，如果找到，转向相应实现并执行</li>
<li>如果没有找到，在相应操作的对象 中的方法列表中找调用的方法，如果找到，转向相应的实现执行</li>
<li>如果没有找到，去父类指针所指向的对象中执行1,2</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用</li>
<li>如果没有重写拦截调用的方法，程序报错</li>
</ol>


<h2>拦截调用</h2>

<p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。
什么是拦截调用呢</p>

<p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写 NSObject的四个方法来处理.</p>

<pre><code>+ (BOOL)resolveClassMethod:(SEL)sel;
+ (BOOL)resolveInstanceMethod:(SEL)sel;
//后两个方法需要转发到其他的类处理
- (id)forwardingTargetForSelector:(SEL)aSelector;
- (void)forwardInvocation:(NSInvocation *)anInvocation;
</code></pre>

<ul>
<li>第一个方法是当你调用一个不存在的类或者方法的时候，会调用这个方法，默认返回NO,你可以加上自己的处理然后返回YES</li>
<li>第二个方法和第一个相似，只不过处理的是实例方法</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target</li>
<li>第四个方法是将你调用的不存在的方法打包成<code>NSinvocation</code>传给你，做完你自己的处理后，调用<em>invokeWithTarget:</em>方法让某个target触发这个方法</li>
</ul>


<h2>动态添加方法</h2>

<p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢?
有一个办法就是根据传进来的<em>sel</em>类型的selector动态添加一个方法。</p>

<p>首先从外部隐式调用一个不存在的方法:</p>

<pre><code>//隐式调用方法
[target performSelector:@selector(resolveAdd:) withObject:@"test"];
</code></pre>

<p>然后，在target对象内部重写拦截调用的方法，动态添加方法：</p>

<pre><code>void runAddMethod(id self, SEL _cmd, NSString *string){
    NSLog(@"add C IMP ", string);
}
+ (BOOL)resolveInstanceMethod:(SEL)sel{

    //给本类动态添加一个方法
    if ([NSStringFromSelector(sel) isEqualToString:@"resolveAdd:"]) {
        class_addMethod(self, sel, (IMP)runAddMethod, "v@:*");
    }
    return YES;
}
</code></pre>

<p>其中<code>class_addMethod</code>的四个参数分别是:</p>

<ol>
<li><em>Class cls</em>给那个类添加方法，本例中是self</li>
<li><em>SEL name</em>添加的方法，本例中是重写的拦截调用传进来selector</li>
<li><em>IMP imp</em>方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现</li>
<li><code>"v@:*"</code>方法的签名，代表有一个参数的方法，返回值是void,如果是<code>i</code>，就是返回int</li>
</ol>


<h2>关联对象</h2>

<p>现在你准备用系统的一个类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。</p>

<p>这种情况的一般解决办法就是继承。</p>

<p>但是只增加一个属性，就去继承一个类，总是觉得太麻烦</p>

<p>这个时候，runtime的关联属性就发挥它的作用了。</p>

<pre><code>//首先定义一个全局变量，用它的地址作为关联对象的key
static char associatedObjectKey;
//设置关联对象
objc_setAssociatedObject(target, &amp;associatedObjectKey, @"添加的字符串属性", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象
NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);
NSLog(@"AssociatedObject = %@", string);
</code></pre>

<p><code>objc_setAssociatedObject</code>的四个参数:</p>

<ol>
<li><em>id object</em> 给谁设置关联对象</li>
<li><code>const void *key</code>关联对象唯一的key,获取时会用到</li>
<li><em>id value</em>关联对象</li>
<li><em>objc_AssociationPolicy</em>关联策略，共有以下几种策略</li>
</ol>


<pre><code>enum {
    OBJC_ASSOCIATION_ASSIGN = 0,
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, 
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
    OBJC_ASSOCIATION_RETAIN = 01401,
    OBJC_ASSOCIATION_COPY = 01403 
};
</code></pre>

<p>如果你熟悉OC，看名字就能知道几种策略的意思了吧</p>

<p><code>objc_getAssociatedObject</code>用来获取关联属性，它用到了两个参数:</p>

<ol>
<li><em>id object</em>获取谁的关联对象</li>
<li><code>const void *key</code>根据这个唯一的key获取关联对象</li>
</ol>


<p>其实，你还可以吧添加和获取关联对象的方法卸载你需要用到这个功能类的类别中，方便调用:</p>

<pre><code>//添加关联对象
- (void)addAssociatedObject:(id)object{
    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
//获取关联对象
- (id)getAssociatedObject{
    return objc_getAssociatedObject(self, _cmd);
}
</code></pre>

<blockquote><p><em>注意</em></p>

<p>这里我们把<code>getAssociatedObject</code>方法的地址作为唯一的key,<em>_cmd</em>代表当前调用方法的地址</p></blockquote>

<h2>方法交换</h2>

<p>方法交换，顾名思义，及时将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法的代码，反之亦然。</p>

<p>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。
方式一:继承系统的类，重写方法.
方式二:使用runtime,交换方法.</p>

<p>参考网上的代码:</p>

<pre><code>#import "UIViewController+swizzling.h"
#import &lt;objc/runtime.h&gt;

@implementation UIViewController (swizzling)

//load方法会在类第一次加载的时候被调用
//调用的时间比较靠前，适合在这个方法里做方法交换
+ (void)load{
    //方法交换应该被保证，在程序中只会执行一次
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{

        //获得viewController的生命周期方法的selector
        SEL systemSel = @selector(viewWillAppear:);
        //自己实现的将要被交换的方法的selector
        SEL swizzSel = @selector(swiz_viewWillAppear:);
        //两个方法的Method
        Method systemMethod = class_getInstanceMethod([self class], systemSel);
        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);

        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
        if (isAdd) {
            //如果成功，说明类中不存在这个方法的实现
            //将被交换方法的实现替换到这个并不存在的实现
            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
        }else{
            //否则，交换两个方法的实现
            method_exchangeImplementations(systemMethod, swizzMethod);
        }

    });
}

- (void)swiz_viewWillAppear:(BOOL)animated{
    //这时候调用自己，看起来像是死循环
    //但是其实自己的实现已经被替换了
    [self swiz_viewWillAppear:animated];
    NSLog(@"swizzle");
}

@end
</code></pre>

<p>在一个自己定义的视图控制器中重写<em>viewWillAppear</em></p>

<pre><code>- (void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    NSLog(@"viewWillAppear");
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewController转场动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua/"/>
    <updated>2016-04-28T15:54:40+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua</id>
    <content type="html"><![CDATA[<h2>自定义转场动画</h2>

<p>ios7中最让我激动的特性之一就是提供了新的API来支持自定义ViewController之间的转场动画。</p>

<!--more-->


<p>在开始研究新的API之间，我们先看看ios7中 navigation controller之间默认的行为发生了那些改变:在navigation controller中，切换两个view controller的动画变得更有交互性。比方说你想要pop一个view controller出去，你可以用手指从屏幕的左边缘开始拖动，慢慢地把当前的viewcontroller向右拖出屏幕去.</p>

<p>接下来，我们来看看这个新API。很有趣，这部分API大量的使用了协议而不是具体的对象。这初看起来有点奇怪，但是我更喜欢这样的设计，因为这种设计给我们这些开发者更大的灵活性。下面，让我们来做件简单的事情:在Navigation Controller中，实现一个自定义的push动画效果，为了完成这个任务，需要实现UINavigationControllerDelegate中的新方法:</p>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
                   navigationController:(UINavigationController *)navigationController
        animationControllerForOperation:(UINavigationControllerOperation)operation
                     fromViewController:(UIViewController*)fromVC
                       toViewController:(UIViewController*)toVC
{
    if (operation == UINavigationControllerOperationPush) {
        return self.animator;
    }
    return nil;
}
</code></pre>

<p>从上面的代码可以看出，我们可以根据不同的操作(push或pop)返回不同的animator.我们可以把anmitor存到一个属性中，从而在多个操作之间实现共享，或者我们也可以为每个操作都创建一个新的animator对象，这里的灵活性很多。</p>

<p>为了让动画运行起来，我们创建一个自定义类，并且实现<code>UIViewControllerAnimatedTransitioning</code>这个协议:</p>

<pre><code>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;

@end
</code></pre>

<p>这个协议要求我们实现两个方法，其中一个定义了动画的持续时间:</p>

<pre><code>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    return 0.25;
}
</code></pre>

<p>另一个方法描述整个动画的执行效果 ：</p>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
{
    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    [[transitionContext containerView] addSubview:toViewController.view];
    toViewController.view.alpha = 0;

    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
        toViewController.view.alpha = 1;
    } completion:^(BOOL finished) {
        fromViewController.view.transform = CGAffineTransformIdentity;
        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];

    }];

}
</code></pre>

<p>从上面的例子汇总，你可以看到如何运用洗衣的：这个方法中通过接受一个类型为<code>id&lt;UIViewControllerContextTransitioning&gt;</code>的参数，来获取transition context.值的注意的是，执行完动画之后，我们需要调用transitionContext的<code>completeTransition :</code>这个方法来更新ViewController的状态。剩下的代码和ios7之前的一样了，我们从transition context 中得到了需要做转场的两个View controller,然后使用最简单的Uiview animation来实现转场动画。这就是全部代码了，我们已经实现了缩放效果的转场动画了。</p>

<p>注意，这里只是为push操作实现了自定义效果的转场动画，对于pop操作，还是会使用默认的滑动效果，另外，上面我们实现的转场动画无法交互，下面我们就来看看解决这个问题。</p>

<h2>交互式的转场动画</h2>

<p>想要动画变地交互非常简单，我们只需要覆盖另一个UINavigationControllerDelegate的方法:</p>

<pre><code>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return self.interactionController;
}
</code></pre>

<p>注意，在非交互式动画效果中，该方法返回nil.</p>

<p>这里返回的interaction controller是<code>UIPercentDrivenInteractionTransition</code>类的一个实例，开发者不需要任何配置就可以工作。我们创建了一个拖动收拾(Pan REcognizer),下面是处理该手势的代码:</p>

<pre><code>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
    }
} 
</code></pre>

<p>只有当用户从屏幕的右半部分开始触摸的时候，我们才把下一次动画效果设置为交互的（通过设置interactionController这个属性来实现），然后执行方法performSegueWithIdentifier:（如果你不是使用的storyboards,那么就直接调用pushViewController&hellip;这类方法）。为了让转场动画持续进行，我们需要调用 interaction controller的一个方法:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
    [interactionController updateInteractiveTransition:d];
} 
</code></pre>

<p>该方法会根据用户手指拖动的距离计算一个百分比，切换的动画效果也随着这个百分比来走，最酷的是，interaction controller会和animation controller一起协作，我们只使用了简单的UIView animation的动画效果，但是interaction controller却控制了动画的执行进度，我们并不需要吧interaction controller和Animation controller关联起来，因为所有这些系统都以一种解耦的方式自动地替我们完成了。</p>

<p>最后,我们需要更具用户收拾的停止状态来判断该操作是结束还是取消，先调用interaction controller 中对应的方法:</p>

<pre><code>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
        [interactionController finishInteractiveTransition];
    } else {
        [interactionController cancelInteractiveTransition];
    }
    navigationControllerDelegate.interactionController = nil;
}
</code></pre>

<p>注意，当切换完成或者取消的时候，记得把interaction controller设置为nil.因为如果下一次的转场是非交互的，我们不应该返回这个旧的interaction controller。</p>

<p>现在我们已经实现了一个完全自定义的可交互的转场动画了。通过简单的手势识别和UIKIT提供的一个类，用几行代码就达到完成了。对于大部分的应用场景，你读到这就够用了，使用上面提到的方法就可以达到你想要的动画效果了。但如果你想更深入了解转场动画或者交互效果进行深度定制，请继续阅读下面的内容。</p>

<h3>完整工程下载</h3>

<p><a href="https://github.com/TLiOSDemo/CustomTransitionController/archive/master.zip">完整的代码在这里下载</a></p>

<h2>使用GPUImage定制动画</h2>

<p>下面我们就看看如何真正的，彻底的定制动画效果。这一次我们不实用UIviw animation,甚至连Core Animation也不用，完全自己来实现所有的动画效果。</p>

<p>我们使用 <a href="https://github.com/BradLarson/GPUImage">GPUImage</a>来实现一个非常漂亮的动画效果，这里我们实现的转场动画效果是：两个View controller像素化，然后相互消融在一起。实现方法是先对两个view controller进行截屏，然后再用GPUImage的图片滤镜（filter）处理这两张截图。</p>

<p>首先，我们先创建一个自定义类，这个类实现了UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning这两个协议：</p>

<pre><code>@interface GPUImageAnimator : NSObject
  &lt;UIViewControllerAnimatedTransitioning,
   UIViewControllerInteractiveTransitioning&gt;

@property (nonatomic) BOOL interactive;
@property (nonatomic) CGFloat progress;

- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@end
</code></pre>

<p>为了加速动画的运行，我们可以图片一次加载到GPU中，然后所有的处理和绘图都直接在GPU上执行，不需要再传送到CPU上处理（这种数据传输很慢）。通过使用GPUImageview，我们就可以直接使用OPenGL画图。</p>

<p>创建滤镜链(Filter chain)也非常的直观，我们可以直接在样例代码的setup方法中看到如何构造它。比较有挑战的是如何让滤镜也<code>动</code>起来。GPUImage没有直接提供给我们动画效果，因此我们需要每渲染一帧就更新一下滤镜来实现动态的滤镜效果。使用<em>CADisplayLink</em>可以完成这个工作：</p>

<pre><code>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
</code></pre>

<p>在frame方法中，我们可以根据时间来更新动画进度，并相应地更新滤镜:</p>

<pre><code>- (void)frame:(CADisplayLink*)link
{
    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
    self.blend.mix = self.progress;
    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
    [self triggerRenderOfNextFrame];
}
</code></pre>

<p>好了，基本上这样就完成了。如果你想要实现交互式的转场效果，那么在这里，就不能使用时间，而是要根据手势来更新动画进度，其它的代码基本差不多。</p>

<p>这个功能非常强大，你可以使用GPUImage中任何已有的滤镜，或者写一个自己的OpenGL来达到你想要的效果。</p>

<h2>结论</h2>

<p>本文只探讨了在navigation controller中的两个view controller之间的转场动画，但是这些做法在tab bar  controller或者任何你自己定义的view controller容器中也是通用的。另外，在ios7中，<em>UIcollectionViewController</em>也进行了扩展，现在你可以在布局之间进行自动以及交互的动画切换，背后使用的也是同样的机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ColletionView布局]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju/"/>
    <updated>2016-04-24T21:05:32+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju</id>
    <content type="html"><![CDATA[<p>UICollectionView在ios6中第一次被引入，也是UIKit <a href="http://oleb.net/blog/2012/09/uicollectionview/">视图类中的一颗新星</a>
。它和UITableview共享一套API设计，但也在UItableView上做了一些扩展。UICOllectionView最强大，同时显著超出UITableView的特色就是其完全灵活的布局结构。这这篇文章中，<!--more--> 我们将会实现一个相当复杂的自定义Collection view布局，并且顺便讨论一下这个类设计的重要部分，项目的实例代码在 <a href="https://github.com/objcio/issue-3-collection-view-layouts">GitHub</a>上。</p>

<h2>布局对象(Layout Objects)</h2>

<p>UITableView和UICollectionView都是 data-source和delegate驱动的。他们在显示其子视图集的过程中仅扮演容器角色,且对子视图集真正的内容毫不知情。</p>

<p>UICollectioNView在此之上进行了进一步抽象。它将子视图的位置，大小和外观的控制权拖过给一个单独的布局对象。通过提供一个自定义布局对象，你技术可以实现任何你能想象到的布局。布局继承自UICollectionVieLayout抽象基类.IOS6中以UICollectionViewFloyLayout类的形式提出了一个具体的布局实现。</p>

<p>我们可以使用flow layout实现一个标准的gridview,这可能是colle tion view中最常见的使用案例了。尽管大多数人都这么想，但是Apple很聪明，没有明确的命名这个类为UIColletionViewGridLayout,而使用了更为通用的术语 flow layout,更好的描述了该类的功能：它通过一个接一个的放置cell来建立自己的布局，当需要的时候，插入横排或竖排的分栏符。通过自定义滚动方向，大小和cell之间的间距，flow layout 也可以在单行或单列中布局cell。实际上，UITableView的布局可以想象成flow layout的一种特殊情况。</p>

<p>在你准备自己写一个UICollectionViewLayout的子类之前，你需要问你自己，你是否能够使用UICollectionViewFlowlayout实现你心里的布局。这个类是<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout">很容易定制的</a>,并且可以继承本身进行进一步的定制，感兴趣的看<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4">这篇文章</a></p>

<h2>Cells和其他Views</h2>

<p>为了适应任意布局,collection view简历了一个类似，但比 table view更灵活的视图层级，像往常一样，你的主要内容显示在cell中，cell可以被任意分组到section中。CollectionView的cell必须是UICollectionViewCell的子类。除了cell，collection view额外管理着两种视图:supplementary views和decoration views.</p>

<p>collection view中的Supplemnetary views相当于table view的section header和footer views.像cells一样，他们的内容都有数据源对象驱动，然而和tableview 中用法不一样，supplementary view并不一定会作为header或footer view;他们的数量和位置完全由布局控制.</p>

<p>Decoration views纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从dataSource 获取的contents.当布局对象指定需要一个decoration view的时候，collection view会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views和decoration views必须是UICollectionReusableView的子类。布局使用的每个视图类都需要在collection view中注册，这样当data Source让它们从reuse pool中出列时，它们才能够创建新的实例。如果你是使用的interface Builder，则可以通过在可视化编辑器中拖拽一个cell到collection view上完成cell在collection view中的注册。同样的方法也可以用在supplementary view上，前提是你使用了UIcollectionviewFlowLayout.如果没有，你只能通过调用 <code>registerClass:</code>或者<code>registerNib:</code>方法手动注册视图类了。你需要在<code>viewDidload</code>中做这些操作.</p>

<h2>自定义布局</h2>

<p>作为一个非常有意义的自定义collection view布局的例子，我们不妨想一个典型的日历应用程序中的周视图。日历一次显示一周，星期中的每一天现在列中，每一个日历事件将会在我们的colleectio view中以一个cell显示，位置和大小代表事件起始日期事件和持续时间。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/calendar-collection-view-layout.png" alt="test" />
一般有两种类型的 collection view布局:</p>

<ol>
<li>独立于内容的布局计算.这正是你所知道的像UITableview和UIcollectionViewFlowLayout这些情况。每个cell的位置和外观不是基于其显示的内容，但所有cell的显示顺序是基于内容的顺序。可以把默认的flow layout作为例子。每个cell都是基于前一个cell的放置(或者如果没有足够的空间，则从下一行开始).布局对象不必访问实际数据来计算布局.</li>
<li>基于内容的布局计算。我们的日历视图正式这样类型的例子。为了计算显示事件的气势和街二叔事件，布局对象需要直接访问 collection view的数据源。在很多情况下，布局对象不仅需要取出当前可见cell的数据，还需要从所有记录中取出一些决定当前那些cell可见的数据。</li>
</ol>


<p>在我们的日历示例中，布局对象如果访问某一个矩形内的cells的属性，那就必须迭代数据源提供的所有事件来决定那些位于要求的时间窗口个中。与一些相对简单，数据源独立计算的flow layout比起来，这足够计算出cell在一个矩形内的index paths了（假设网格中所有的cells的大小都一样）.</p>

<p>如果有一个依赖内容的布局，那就是暗示你需要些自定义的布局类了，同时不能使用自定义的UICOllectionViewFlowLayout，所以这正是我们需要做的事情。</p>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html">UICollectionViewLayout文档</a>列出了子类需要重写的方法.</p>

<h2>collectionViewContentSize</h2>

<p>由于 collection view对它的content并不知情，所以布局首先要提供的信息就是滚动区域的大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。注意，尽管大多数经典的collection view限制在一个轴方向上滚动(正如UIcollectionviewFlowLayout一样)，但是这不是必须的。</p>

<p>在我们的日历示例中，我们想要视图垂直的滚动。比如，如果我们想要在垂直空间上一个小时占去100点，这样显示一整天的内容高度就是2400点。注意，我们不能够水平滚动，这就意味这我们collectionview只能显示一周。为了能够在日历中的多个星期间分页，我们可以在一个独立的scroll view中（可以使用U<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html">IPageViewController</a>）中使用多个 collection view（一周一个）,或者坚持使用一个collection view并且返回足够大的内容宽度，这回使得用户感觉在两个方向上滑动自由。</p>

<pre><code>- (CGSize)collectionViewContentSize
{
    // Don't scroll horizontally
    CGFloat contentWidth = self.collectionView.bounds.size.width;

    // Scroll vertically to display a full day
    CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay);

    CGSize contentSize = CGSizeMake(contentWidth, contentHeight);
    return contentSize;
}
</code></pre>

<p>为了简单起见，我选择布局在一个非常简单的模型上：假定每周天数相同，每天时长相同，也就是说天数用0-6表示。在一个真实的日历程序中，布局将会为自己的几段大量使用基于 <code>NSCalendaar</code>的日期</p>

<h2>layoutAttributesForElementsInRect：</h2>

<p>这是任何布局类中最重要的方法了，同时可能也是最容易让人迷惑的方法。collection view调用这个方法并传递一个自身坐标系统中的矩形过去。这个矩形代表了这个视图的可见矩形区域(也即是它的bounds)，你需要准备好处理传给你的任何矩形。</p>

<p>你的视线必须返回一个包含 UICollectionviewLayoutAttributes对象的数组，为每一个cell包含一个这样的对象，supplementary View或decoration view在矩形区域内是可见的。UICollectionViewLayoutAttributes类包含了colletion view内item的所有相关的布局属性。默认情况下，这个类包含 frame,center,size,transform3D,alpha,Zindex和hidden属性。如果你的布局想要控制其他视图的属性(比如背景颜色)，你可以创建一个UICollectionViewLayoutAttributes的子类，然后加上你自己的属性。</p>

<p>布局属性对象(Layout attributes objects)通过indexPath属性和他们对应的cell,supplementary view或者decoration view关联在一起。collection view为所有items从布局对象中请求到布局属性后，它将会实例化所有视图，并将对应的属性应用到每个视图上去。</p>

<p>注意!这个方法涉及到所有类型的视图，也就是cell,supplementary views和decoration views.一个幼稚的实现可能会选择忽略传入的矩形，并且为collection view中所有的视图返回布局属性。在原型设计和开发布局阶段，这是一个有效的方法。但是，这将会性能产生非常坏的影响，特别是可见cell远少于所有cell数量的时候，collection view和布局对象将会为那些不可见的而试图做额外不必要的工作。</p>

<p>你的视线需要做这几步:</p>

<ol>
<li>创建一个空的可变数组来存放所有的布局属性</li>
<li>确定index paths中那些cells的frame完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你视线的<code>layoutattributesForItemIndexPath:</code>方法为每个index path创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</li>
<li>如果你的布局包含supplementary views,计算矩形内可见supplementary view的index paths.在循环中调用你实现的<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>,并且将这些对象加到数组中。通过为kind参数传递你选择的不同字符，你可以却分出不同种类的supplementary views(比如headers和footers)。当需要创建视图时，collectionview会将kind字符传回到你的数据源。记住supplermentary 和decoration views的数量和种类完全有布局控制。你不会受到headers和footers的限制.</li>
<li>如果布局包含decoration views，计算矩形内可见decoration views的index paths.在循环中调用你实现的<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>
，并且将这些对象加到数组中</li>
<li>返回数组</li>
</ol>


<p>我们自定义的布局没有使用 decoration views,但是使用了两种supplermentary views(column headers和row headers):</p>

<pre><code>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
{
    NSMutableArray *layoutAttributes = [NSMutableArray array];
    // Cells
    // We call a custom helper method -indexPathsOfItemsInRect: here
    // which computes the index paths of the cells that should be included
    // in rect.
    NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect];
    for (NSIndexPath *indexPath in visibleIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForItemAtIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }

    // Supplementary views
    NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect];
    for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForSupplementaryViewOfKind:@"DayHeaderView"
                               atIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }

    NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect];
    for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) {
        UICollectionViewLayoutAttributes *attributes =
        [self layoutAttributesForSupplementaryViewOfKind:@"HourHeaderView"
                               atIndexPath:indexPath];
        [layoutAttributes addObject:attributes];
    }
    return layoutAttributes;
}
</code></pre>

<h2>layoutAttributesFor…IndexPath</h2>

<p>有时，collection view会为某个特殊的cell,supplementary 或者decoration view向布局对象请求布局属性，而非所有可见的对象。这就是当其他三个方法开始起作用时，你实现的<code>layoutAttributesForItemAtIndexPath:</code>需要创建并返回一个单独的布局属性对象，这样才能正确的格式化传给你的index path 所对应的cell.</p>

<p>你可以通过调用<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，然后根据index path修改属性。为了得到需要显示在这个index path内的数据，你可能需要访问collection view的数据源。到目前为止，至少确保设置了frame尚需经，除非你所有的cell都位于彼此上方。</p>

<pre><code>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
{
    CalendarDataSource *dataSource = self.collectionView.dataSource;
    id event = [dataSource eventAtIndexPath:indexPath];
    UICollectionViewLayoutAttributes *attributes =
    [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
    attributes.frame = [self frameForEvent:event];
    return attributes;
}
</code></pre>

<p>如果你正在使用自动布局，你可能会赶到惊讶，我们正在直接修改布局参数的frame属性，而不是和约束共事，但这正是UIcollectionViewLayout的工作。尽管你坑你使用自动布局来定义collection view的frame和它内部每个cel的布局，但cells的frames还是需要通过老式的方法计算出来。</p>

<p>类似的，<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>和<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>方法分别需要为supplementary 和decoration views做相同的事。只有你的布局包含这样的视图你才需要实现这两个方法。UICollectionViewlayoutAttributes包含另外两个工厂方法，</p>

<p><code>+layoutAttributesForSupplementaryViewOfKind:withIndexPath:</code> 和 <code>+layoutAttributesForDecorationViewOfKind:withIndexPath:</code>，用他们来创建正确的布局属性对象</p>

<h2>shouldInvalidateLayoutForBoundsChange:</h2>

<p>最后，当collection view的bounds改变时，布局需要告诉collection view是否需要重新计算布局。我的猜想是：当collectionview改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个优质的实现可能只会简单的返回YES。芮然实现功能很重要，但是scrollview的bounds在滚动时也会改变，这意味着你的布局美妙会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。</p>

<p>当collection view的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view将它的bounds传给<code>shouldInvalidateLayoutForBoundsChange:</code>方法，这样我们便能比较视图当前的bounds和新的bounds来确定返回值</p>

<pre><code>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
{
    CGRect oldBounds = self.collectionView.bounds;
    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
        return YES;
    }
        return NO;
}
</code></pre>

<h2>动画</h2>

<h3>插入和删除</h3>

<p>UITableview中的cell自带了一套非常漂亮的插入和删除的动画。但是当为UIcollectionView增加和删除cell定义动画功能时，UIKit工程师们遇到这样一个问题：如果Collection view的布局是完全可变的，那么预先定义好的动画就没办法和开发者自定义的布局很好的融合。他们提出了一个优雅的方法：当一个cell(或者supplementary 或者 decoration View)被插入到collection view中时，collection View不仅向其布局请求cell正常正常状态下的布局尚需经，同时还请求其初始的布局尚需经，比如，需要在开始有插入动画的cell。CollectionView会简单的创建一个anmiation block,并在这个block中，将所有cell的属性从初始状态改变到常态</p>

<p>通过提供不同的初始布局属性，你可以完全自定义插入动画。比如设置初始的alpha为0将会产生一个淡入的动画。同时设置一个平移或者缩放将会产生移动缩放的效果。</p>

<p>同样的原理应用到删除上，这次动画是从常态到一些列你设置的最终布局属性。这些逗你需要在布局类中为initial或final布局参数实现的方法:</p>

<pre><code>initialLayoutAttributesForAppearingItemAtIndexPath:

initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:

initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:

finalLayoutAttributesForDisappearingItemAtIndexPath:

finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:

finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:
</code></pre>

<h2>布局间切换</h2>

<p>可以通过类似的方式将一个collection view布局动态的切换到另外一个布局。当发送一个<code>setCollectionViewLayout:animated:</code>消息时，collection view会为cells在新的布局中查询新的布局参数，然后动态的将每个cell从旧参数变换到新的布局参数。你不需要做任何事情。</p>

<h2>结论</h2>

<p>根据自定义collection view布局的复杂性，写一个通常很不容易。确切的说，本质上这和从头写一个完整的实现相同布局自定义视图类一样困难了。因为所涉及的计算需要确定去那些子视图是当前可见的，以及他们的位置。尽管如此，使用UIcollectionview还是给你带来了一些很好的效果，比如cell重用，自动支持动画，更不要提整洁的独立布局，子视图管理。</p>

<p>自定义collection view布局也是向<a href="http://objccn.io/issue-1-1/">轻量级view Controller</a>迈出了很好的异步，正如你的view controller不要包含任何布局代码。应该和一二个独立的dataSource类结合在一起，collection view的视图控制器将很难再包含任何代码</p>
]]></content>
  </entry>
  
</feed>
