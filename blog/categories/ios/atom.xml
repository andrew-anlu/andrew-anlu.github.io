<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-04-21T08:58:48+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ios中的多任务]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu/"/>
    <updated>2016-04-19T10:17:49+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu</id>
    <content type="html"><![CDATA[<p>在ios7之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限，除了VOIP和基于地理位置特性之外，唯一能做的地方就是后台任务(background tasks)让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，或者备份用户的照片到你的服务器上，你都仅能完成一部分工作.</p>

<p> <!--more--></p>

<p>ios7添加了两个新的API以便你的程序可以在后台更新界面以及内容。首先是后台获取(background Fetch)，它允许你定义地从网络获取新的内容。第二个API就是远程通知(Remote Notifications)，这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务(Background Trasnfer service)中执行定期的任务，也允许你在进程之外可以执行网络传输(下载和上传)工作</p>

<p>后台获取(Background Fetch)和远程通知(Remote notification)基于简单的 ApplicationDelegate钩子，在应用程序挂起之前的30秒时间执行工作。它们不是用于CPU频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>

<p>对于用户来说,多任务处理有点显而易见的改变就是新的应用切换程序，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的&ndash;现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络，新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>

<h2>后台获取</h2>

<p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前出发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午一点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你想系统报告新数据无法获取，ios会适应并使用此信息避免会继续获取。</p>

<p>开启后台获取的第一步是在info plist文件中对UIBackgroundModes键指定特定的值。最简单的途径是在Xcode的project editor中新的Capabilities标签页设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/capabilities-on-bgfetch.jpg" alt="logo" /></p>

<p>或者你可以手动配置这个值</p>

<pre><code>&lt;key&gt;UIBackgroundModes&lt;/key&gt;
&lt;array&gt;
    &lt;string&gt;fetch&lt;/string&gt;
&lt;/array&gt;  
</code></pre>

<p>接下来，告诉IOS多久进行一次数据获取</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];

    return YES;
}
</code></pre>

<p>ios默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该制定一个你想要的时间间隔。例如，一个天气的应用程序，可能只需要几个小时更新一次，IOS将会在后台获取之间至少等待你指定的时间间隔。</p>

<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把minimumBackgroundFetchInterval设置为UIApplicationBackgroundFetchIntervalNever,专业那个可以节省资源。</p>

<p>最后一步是在应用程序委托中实现下列方法:</p>

<pre><code>- (void)                application:(UIApplication *)application 
  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];

    NSURL *url = [[NSURL alloc] initWithString:@"http://yourserver.com/data.json"];
    NSURLSessionDataTask *task = [session dataTaskWithURL:url 
                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {

        if (error) {
            completionHandler(UIBackgroundFetchResultFailed);
            return;
        }

        // 解析响应/数据以决定新内容是否可用
        BOOL hasNewData = ...
        if (hasNewData) {
            completionHandler(UIBackgroundFetchResultNewData);
        } else {
            completionHandler(UIBackgroundFetchResultNoData);
        }
    }];

    // 开始任务
    [task resume];
}
</code></pre>

<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有30秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面，30秒时间应该足够去网络获取数据和获取界面的缩略图，但是最多只有30秒，当完成了网络请求和更新界面后，你应该执行完成的回调。</p>

<p>完成回调的执行有两个目的，首先，系统会估量你的进程消耗的电量，并根据你传递的UIBackgroundFetchResult参数记录新数据是否可用，其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器，当用户在应用间切换时，用户将会看到新内容，这种通过completion handler来报告并且生成截图的方法，在新的多任务处理API中是很常见的。</p>

<p>在实际的应用中，你应该将completionHandler传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>

<p>在这里，你可能想知道ios是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的声明周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想象为用户从Springboard启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>

<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看UIAppcation的applicationState属性来判断应用是不是从后台启动。</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    NSLog(@"Launched in background %d", UIApplicationStateBackground == application.applicationState);

    return YES;
}
</code></pre>

<h2>测试后台数据获取</h2>

<p>有两种可以模拟后台获取的途径。最简单是从Xcode运行你的应用，当应用运行时，在Xcode的Debug菜单选择Simulate Background Fetch.</p>

<p>第二种方法，使用scheme更改Xcode运行程序的方式。在Xcode菜单的Product选项，选择Scheme然后选择Manager Schemes.在这里，你可以编辑或者添加一个新的scheme,然后选中Launch due to a background fetch event ,如下图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/edit-scheme-simulate-background-fetch.png" alt="logo" /></p>

<h2>远程通知</h2>

<p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时消息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载一遍离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中有两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候的才会启动。</p>

<p>一条远程通知实际上只是一条普通的带有content-available 标志的推送通知。你可以发送一条带有提醒消息的推送去告诉用户有事情发生了，同时在后台对界面进行更新。但远程通知也可以做到安静的，没有提醒消息或者任何声音 的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>

<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。ios和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，知道设备下次发送保持活动状态的数据包，或者受到另外一个通知。</p>

<h2>发送远程通知</h2>

<p>要发送一条远程通知，需要在推送通知的有效负载设置content－available 标志。content－available 标志和用来通知报刊应用的键值是一样的。因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>

<p>我建议在开发的时候，使用<a href="http://nomad-cli.com/#houston">Nomand CLI&rsquo;s Houston</a>工具发送推送消息，当然你可以使用你喜欢的库或者脚本。</p>

<p>你可以通过nomad-cli ruby gem来安装Houston</p>

<pre><code>gem install nomad-cli
</code></pre>

<p>然后通过包含在Noman的apn实用工具发送一条通知:</p>

<pre><code># Send a Push Notification to your Device
apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42
</code></pre>

<p>在这里，-n标志指定应该包含content-available 健值,-d标志允许添加我们自定义的数据键值到有效负荷.
通知的有效负荷(payload)结果和下面类似:</p>

<pre><code>{
    "aps" : {
        "content-available" : 1
    },
    "content-id" : 42
}
</code></pre>

<p>ios7中添加了新的应用程序委托方法，当接收到一条带有 content－available的推送通知时，下面的方法会被调用:</p>

<pre><code>- (void)application:(UIApplication *)application 
  didReceiveRemoteNotification:(NSDictionary *)userInfo 
        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSLog(@"Remote Notification userInfo is %@", userInfo);

    NSNumber *contentID = userInfo[@"content-id"];
    // 根据 content ID 进行操作
    completionHandler(UIBackgroundFetchResultNewData);
}
</code></pre>

<p>和后台抓取一样，应用程序进入后台启动，也有30秒时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>

<h2>NSurlSession和后台传输服务(Background Transfer Service)</h2>

<p>NSURLSession是ios7添加的一个新类，它也是Foundation Networking中的新技术。作为NSURLConnection的替代品，一些熟悉的概念和类都保留下来了，例如NSURL,NSURLRequest,NSURLResponse.所以，你可以使用NSURLSessionTask这一NSURLConnnection的替代品，来处理网络请求及响应。一共有3种回话任务：数据，下载和上传。每一种都向NSURLSessionTask添加了语法糖，根据你的需要，适当选择一种。</p>

<p>一个NSURLSession对象协调一个或多个NSURLSessionTask对象，并根据NSURLSessionTask创建的NSURLSessionConfiguration实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的NSURLSessionTask对象。要利用后台传输服务，你将会使用<code>[NSURLSessionConfiguration backgroundSessionConfiguration]</code>来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>

<p>NSURLSessionConfiguration允许你设置默认的HTTP头，配置缓存策略，限制使用蜂窝煤数据等等。其中一个选项是discretionary标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备足够电量时，设备才通过wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>

<p>目前为止，我们大概了解了NSURLSession，以及一个后台回话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传入服务的下载队列。当下载完成后，我们会通知用户该文件已经可以用了。</p>

<h2>NSURLSessionDownloadTask</h2>

<p>首先，我们先处理一条远程通知，并把一个NSURLSessionDownloadTask添加到后台传输服务的队列。在backgroundURLSession方法张，我们根据后台回话配置，创建一个NSURLSession对象，并把application delegate作为回话的委托对象。文档不建议对于相同的标识符(identifier)创建多个回话对象，所以我们使用dispatch_once来避免潜在的问题：</p>

<pre><code>- (NSURLSession *)backgroundURLSession
{
    static NSURLSession *session = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        NSString *identifier = @"io.objc.backgroundTransferExample";
        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
        session = [NSURLSession sessionWithConfiguration:sessionConfig 
                                                delegate:self 
                                           delegateQueue:[NSOperationQueue mainQueue]];
    });

    return session;
}

- (void)           application:(UIApplication *)application 
  didReceiveRemoteNotification:(NSDictionary *)userInfo 
        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
{
    NSLog(@"Received remote notification with userInfo %@", userInfo);

    NSNumber *contentID = userInfo[@"content-id"];
    NSString *downloadURLString = [NSString stringWithFormat:@"http://yourserver.com/downloads/%d.mp3", [contentID intValue]];
    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];

    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];
    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];
    task.taskDescription = [NSString stringWithFormat:@"Podcast Episode %d", [contentID intValue]];
    [task resume];

    completionHandler(UIBackgroundFetchResultNewData);
}
</code></pre>

<p>我们使用NSURLSession类方法创建爱你一个下载任务，配置请求，并提供说明供以后使用。因为所有回话任务一开始处于挂起状态，你必须谨记要调用[task resume]保证开始了任务。</p>

<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现NSURLSessionDelegate或NSURLSessionTaskDelegate的方法，你应该阅读Apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42">Life Cycle of a URL Session with Custom Delegates</a>文档，它讲解了所有类型回话任务的完成生命周期。</p>

<p>NSURLSessionDownloadDelegate中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时URL.你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>

<pre><code>#Pragma Mark - NSURLSessionDownloadDelegate

- (void)         URLSession:(NSURLSession *)session 
               downloadTask:(NSURLSessionDownloadTask *)downloadTask
  didFinishDownloadingToURL:(NSURL *)location
{
    NSLog(@"downloadTask:%@ didFinishDownloadingToURL:%@", downloadTask.taskDescription, location);

    // 用 NSFileManager 将文件复制到应用的存储中
    // ...

    // 通知 UI 刷新
}

- (void)  URLSession:(NSURLSession *)session 
        downloadTask:(NSURLSessionDownloadTask *)downloadTask 
   didResumeAtOffset:(int64_t)fileOffset 
  expectedTotalBytes:(int64_t)expectedTotalBytes
{
}

- (void)         URLSession:(NSURLSession *)session 
               downloadTask:(NSURLSessionDownloadTask *)downloadTask 
               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten 
  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
}
</code></pre>

<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会受到一系列消息。App delegate的: handleEventsForBackgroundURLSession：方法会在这些NSURLSession委托的消息发送前被调用，然后URLSessionDidFinishEventsForBackgroundURLSession在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler）,并在后面的方法中执行回调以便更新界面:</p>

<pre><code>- (void)                  application:(UIApplication *)application 
  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
{
    // 你必须重新建立一个后台 seesiong 的参照
    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为
    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession
    NSURLSession *backgroundSession = [self backgroundURLSession];

    NSLog(@"Rejoining session with identifier %@ %@", identifier, backgroundSession);

    // 保存 completion handler 以在处理 session 事件后更新 UI
    [self addCompletionHandler:completionHandler forSession:identifier];
}

- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
{
    NSLog(@"Background URL session %@ finished events.\n", session);

    if (session.configuration.identifier) {
        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler
        [self callCompletionHandlerForSession:session.configuration.identifier];
    }
}

- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier
{
    if ([self.completionHandlerDictionary objectForKey:identifier]) {
        NSLog(@"Error: Got multiple handlers for a single session identifier.  This should not happen.\n");
    }

    [self.completionHandlerDictionary setObject:handler forKey:identifier];
}

- (void)callCompletionHandlerForSession: (NSString *)identifier
{
    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];

    if (handler) {
        [self.completionHandlerDictionary removeObjectForKey: identifier];
        NSLog(@"Calling completion handler for session %@", identifier);

        handler();
    }
}
</code></pre>

<p>如果当后台传输完成时，应用程序不再停留在前台，那么对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用陈谷根本没有在运行，ios将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在application:didFinishLaunchingWithOptions: 方法被调用之后被调用.</p>

<h2>配置和限制</h2>

<p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读NSURLSessionConfiguration部分，以便最好滴满足你的使用场景。例如:NSURLSessionTasks通过NSURLSessionConfiguration的timeoutIntervalForResource属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限wifi宽带的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>

<p>除了下载任务，NSURLSession也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像ios6那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要再后台运行，一个比较好的做法是,把NSURLSessionConfiguration的sessionSendsLaunchEvents属性设置为NO。高效利用系统资源，是一件让Ios和用户都高兴的事。</p>

<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对NSURLSession的使用简单的基于block的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用Http重定向。后台传输服务只支持HTTP和HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>

<p>另外，要注意的是在后台回话中，NSURLSessionDataTasks是完全不支持的，你应该只处于短期的，小请求为目的的使用这些任务，而不是用来下载或上传。</p>

<h2>总结</h2>

<p>在ios7中强大的多任务和网络API为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的API，一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>

<ul>
<li>使用适当的新的API来为你的应用程序提供内容</li>
<li>尽可能早地调用completion handler以提高效率</li>
<li>让completion hander为应用程序更新界面快照</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解RunLoop]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/"/>
    <updated>2016-03-29T17:29:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<pre><code>function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code></pre>

<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<pre><code>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;

/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&amp;loopsLock);

    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }

    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));

    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }

    OSSpinLockUnLock(&amp;loopsLock);
    return loop;
}

CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}

CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
</code></pre>

<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></pre>

<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<pre><code>struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};

struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
</code></pre>

<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<pre><code>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
CFRunLoopRunInMode(CFStringRef modeName, ...);
</code></pre>

<p>Mode暴露的管理Mode Item的有下面几个:</p>

<pre><code>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</code></pre>

<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<pre><code>CFRunLoop {
    current mode = kCFRunLoopDefaultMode
    common modes = {
        UITrackingRunLoopMode
        kCFRunLoopDefaultMode
    }

    common mode items = {

        // source0 (manual)
        CFRunLoopSource {order =-1, {
            callout = _UIApplicationHandleEventQueue}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventSignalCallback }}
        CFRunLoopSource {order = 0, {
            callout = FBSSerialQueueRunLoopSourceHandler}}

        // source1 (mach port)
        CFRunLoopSource {order = 0,  {port = 17923}}
        CFRunLoopSource {order = 0,  {port = 12039}}
        CFRunLoopSource {order = 0,  {port = 16647}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventCallback}}
        CFRunLoopSource {order = 0, {port = 2407,
            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
        CFRunLoopSource {order = 0, {port = 1c03,
            callout = __IOHIDEventSystemClientAvailabilityCallback}}
        CFRunLoopSource {order = 0, {port = 1b03,
            callout = __IOHIDEventSystemClientQueueCallback}}
        CFRunLoopSource {order = 1, {port = 1903,
            callout = __IOMIGMachPortPortCallback}}

        // Ovserver
        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
            callout = _wrapRunLoopWithAutoreleasePoolHandler}
        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
            callout = _UIGestureRecognizerUpdateObserver}
        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _afterCACommitHandler}
        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
            callout = _wrapRunLoopWithAutoreleasePoolHandler}

        // Timer
        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
            next fire date = 453098071 (-4421.76019 @ 96223387169499),
            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
    },

    modes ＝ {
        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = 0, {
                    callout = FBSSerialQueueRunLoopSourceHandler}}
            },
            sources1 = (null),
            observers = {
                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
            )},
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventSignalCallback}}
            },
            sources1 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventCallback}}
            },
            observers = (null),
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = (null),
            sources1 = (null),
            observers = (null),
            timers = (null),
        }
    }
}
</code></pre>

<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<pre><code>{
    /// 1. 通知Observers，即将进入RunLoop
    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
    do {

        /// 2. 通知 Observers: 即将触发 Timer 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

        /// 4. 触发 Source0 (非基于port的) 回调。
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

        /// 6. 通知Observers，即将进入休眠
        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);

        /// 7. sleep to wait msg.
        mach_msg() -&gt; mach_msg_trap();


        /// 8. 通知Observers，线程被唤醒
        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);

        /// 9. 如果是被Timer唤醒的，回调Timer
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);

        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);

        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);


    } while (...);

    /// 10. 通知Observers，即将退出RunLoop
    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
}
</code></pre>

<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<pre><code>CFSocket
CFNetwork       -&gt;ASIHttpRequest
NSURLConnection -&gt;AFNetworking
NSURLSession    -&gt;AFNetworking2, Alamofire
</code></pre>

<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<pre><code>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
</code></pre>

<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<pre><code>- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
</code></pre>

<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUrlSession详解]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie/"/>
    <updated>2016-03-27T18:48:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie</id>
    <content type="html"><![CDATA[<p>NSUrlSession是NSUrlConnection的替代品。</p>

<p>NSUrlConennection指的是一组构成 Foundation框架中URL加载系统的相互关联的组件:NSURLRequest,NSUrlResponse,NSURlProtocol等,在协商发送一个请求到服务器的过程中，该服务器可发出验证质询，这可以由共享的cookie，证书存储（credential storage）或通过连接委托自动处理。必要的时候，为了无缝地改变装载行为，传出请求也可以被注册的NSURLProtocol对象截获.</p>

<!--more-->


<p>不管怎样，考虑到NSURLConnection作为一个网络基础架构，成千上万的Cocoa和Cocoa Touch应用程序从中获益，它已经表现得相当好。但是，这些年来，iPhone和iPad新兴的用例，特别是有一些已经向NSURLConnection的几个核心设想提出了挑战，对其重构已经迫在眉睫。</p>

<p>在2013年的WWDC上，Apple揭开了NSURLConnection继任者的面纱：NSURLSession.</p>

<p>与NSUrlConnection类似，除了同名类 NSUrlsession,NSUrlSession指的是一组相互依赖的类，NSURlSession包括与之前相同的组件，例如NSUrlRequest,NSURLCatch等等。
　　</p>

<h2>NSURlconenction 与 NSSession的不同</h2>

<p>　　与NSUrlConnection相比，NSUrlSession最直接的改善就是提供了配置每个回话的缓存，协议，cookie和证书策略(credential policies),甚至跨应用程序共享它们的能力。这使得框架的网络基础架构和部分应用程序独立工作，而不会相互干扰，每一个NSUrlSession对象都是根据一个NSURlSessionConfiguration初始化的，
　　
　　</p>

<p>该NSURlSessionConfiguration指定了上面提到的策略，一级一系列为了提高移动设备性能而专门添加的新选项。</p>

<p>NSUrlSession的另一个重要组成部分就是会话任务，它负责处理数据的加载，以及客户端与服务器之间的文件和数据的上传和下载。</p>

<h2>NSURLSession简介</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="logo" /></p>

<p>NSURLsession关键对象负责接收和发送http请求，创建NSURlSessionConfiguration,这里有三种方式:</p>

<ul>
<li><code>defaultSessionConfiguration</code>创建一个默认的配置文件，用户可以存储缓存，创建证书和缓存cookie等</li>
<li><code>ephemeralSessionConfiguration</code>和默认配置文件很相似，除了它可以在内存中存储之外，它更像是一个私有的session</li>
<li><code>backgroundSessionConfiguration</code>这个配置文件支持上传和下载任务在后台。当程序挂起或者被终止之后任务可以继续执行。</li>
</ul>


<p><code>NSURLSessionConfiguration</code>依然可以让你配置session的属性，比如设置超时时间，缓存策略和http请求头等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration">这里</a>有完整的配置文档。</p>

<p><code>NSURLSessionTask</code>是一个抽象的任务符号,一个session创建一个任务，它不仅可以请求数据，还可以上传和下载。</p>

<p>这里有三种类型的任务：</p>

<ul>
<li><code>NSURLSessionDataTask</code>：用这个任务可以发送http请求，从而从服务器得到返回的数据</li>
<li><code>NSURLSessionUploadTask</code>：用这个任务可以从本地硬盘上往服务器上传文件，一般是HTTP post请求或者PUT请求.</li>
<li><code>NSURLSessionDownloadTask</code>:用这个任务可以从远程服务器上下载文件</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="logo" /></p>

<p>你可以挂起，回滚和取消任务，<code>NSURLSessionDownloadTask</code>还有一个特性就是支持断点下载。</p>

<p>一般来讲, NSURLSession 有两种方式返回数据：</p>

<ol>
<li>利用completion handler,当任务完成之后，不管是成功返回还是产生错误；</li>
<li>还有一种就是利用NSSession的代理，依然可以捕获到返回的数据;</li>
</ol>


<h2>编写实例Demo</h2>

<p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip">启动工程在这里下载</a>,</p>

<p>开始做一个 在Itunes搜索歌曲，通过<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">Itunes API</a>下载歌曲的这么个小工程，支持暂停，下载功能。</p>

<p>下完工程，运行效果如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt="itunes" /></p>

<h3>开始编写代码</h3>

<p>你可以添加代码去查询itunes中的歌曲，通过查找 Itunes search Api.</p>

<p>在<code>SearchViewController.swift</code>文件中，添加如下代码:</p>

<pre><code>// 1
let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
// 2
var dataTask: NSURLSessionDataTask?
</code></pre>

<p>上面的代码做了如下工作:</p>

<ol>
<li>用默认的配置文件创建NSURLSession</li>
<li>你定义了一个<code>NSURLSessionDataTask</code>变量，用它发送http请求，这个任务将会被重复初始化和重复利用在用户创建一个新查询的时候</li>
</ol>


<p>现在，替换<code>searchBarSearchButtonClicked(_:)</code>里面的代码:</p>

<pre><code>func searchBarSearchButtonClicked(searchBar: UISearchBar) {
  dismissKeyboard()

  if !searchBar.text!.isEmpty {
    // 1
    if dataTask != nil {
      dataTask?.cancel()
    }
    // 2
    UIApplication.sharedApplication().networkActivityIndicatorVisible = true
    // 3
    let expectedCharSet = NSCharacterSet.URLQueryAllowedCharacterSet()
    let searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!
    // 4
    let url = NSURL(string: "https://itunes.apple.com/search?media=music&amp;entity=song&amp;term=\(searchTerm)")
    // 5
    dataTask = defaultSession.dataTaskWithURL(url!) {
      data, response, error in
      // 6
      dispatch_async(dispatch_get_main_queue()) {
        UIApplication.sharedApplication().networkActivityIndicatorVisible = false
      }
      // 7
      if let error = error {
        print(error.localizedDescription)
      } else if let httpResponse = response as? NSHTTPURLResponse {
        if httpResponse.statusCode == 200 {
          self.updateSearchResults(data)
        }
      }
    }
    // 8
    dataTask?.resume()
  }
}
</code></pre>

<p>运行后代码如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160401-1.png" alt="logo" /></p>

<p>如果出现错误<code>An SSL error has occurred and a secure connection to the server cannot be made.</code></p>

<p>请在info.plist中配置，在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为 YES</p>

<p>上面的代码步骤意义如下:</p>

<ol>
<li>检查用户每一次查询，dataTask是否已经初始化，如果没有，则取消该任务</li>
<li>设置的状态栏上的转子运行起来，证明数据正在请求当中</li>
<li>当用户输入查询参数之前，调用 请求字符串的<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>,确保是一个正确的URL.　(这个 text 的类型是 String ，常用于搜索功能，在  URL 中包含被搜的关键字，如果不处理搜中文或者带空格的英文会直接崩溃);</li>
<li>下一步创建一个NSURL用上面的（安全的）字符串，使用GET请求去调用Itunes Search API</li>
<li>从创建的Session中，你初始化<code>NSURLSessionDataTask</code>去处理http请求，这个<code>NSURLSessionDataTask</code>任务使用completion handler （回调函数）去响应服务器返回的数据</li>
<li>异步调用主线程，在主线程上隐藏网络请求的转子</li>
<li>如果http请求是成功的，你可以调用<code>updateSearchResults(_:)</code>来刷新表格数据，返回数据是NSData类型的，需要在updateSearchResults方法中进行处理</li>
<li>所有任务默认是挂起状态，需要你调用 <code>resume()</code>去启动任务</li>
</ol>


<h2>下载</h2>

<p>看着搜索到的歌曲，感觉页面不错，但是如果我们能够通过点击 download,然后把歌曲下载到本地是不是更爽呢?下一步让我实现这个功能点.</p>

<p>用多线程实现下载是容易的。首先你要创建一个新的文件命名为 <code>Download.swift</code>. 打开这个文件，添加如下代码:</p>

<pre><code>class Download: NSObject {

  var url: String
  var isDownloading = false
  var progress: Float = 0.0

  var downloadTask: NSURLSessionDownloadTask?
  var resumeData: NSData?

  init(url: String) {
    self.url = url
  }
}
</code></pre>

<p>属性说明如下:</p>

<ul>
<li>URL:下载文件的url地址，它也扮演着唯一的标识符在下载过程中</li>
<li>isDownloading:是否正在下载或暂停</li>
<li>progress : 下载的进度,[0-1]</li>
<li>downloadTask: NSURLSessionDownloadTask下载任务</li>
<li>resumeData:当你暂停一个下载任务时，它负责存储此时的数据量；如果后台服务器支持的话，当用户再次点击继续下载，它会从这里开始继续下载这个文件，俗称 断点下载</li>
</ul>


<p>切换到 <code>SearchViewController.swift</code>，添加如下代码:</p>

<pre><code>var activeDownloads = [String: Download]()
</code></pre>

<h2>创建下载任务</h2>

<p>准备工作做得差不多了，现在你只需实现下载，首先你要创建一个session去实现下载任务.</p>

<p>在 <code>SearchViewController.swift</code>文件中，在<code>viewDidLoad():</code>之前添加如下代码:</p>

<pre><code>lazy var downloadsSession: NSURLSession = {
  let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
  let session = NSURLSession(configuration: configuration, delegate: self, delegateQueue: nil)
  return session
}()
</code></pre>

<p>这里初始化了一个session,用默认的配置文件，去处理所有的下载任务，你也可以指定delegate,这将会使你收到 <code>NSURLSession</code>的代理调用，这个是很有用的，它能有效的跟踪下载任务下载的进度和是否下载完成等。</p>

<p>设置代理的队列是nil,会促使session创建一个操作队列，默认的去调用代理方法和回调方法.</p>

<p>在创建<code>downloadsSession</code>属性的时候，我们加了<code>lazy</code>特性，这会让你延迟加载这个session直到你需要它的时候，更重要的是，它会通过<code>self</code>作为代理参数去初始化，假如<code>self</code>还没有初始化。</p>

<p>在<code>SearchViewController.swift</code>文件中，找到空的<code>NSURLSessionDownloadDelegate</code>并且扩展如下:</p>

<pre><code>extension SearchViewController: NSURLSessionDownloadDelegate {
  func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
    print("Finished downloading.")
  }
}
</code></pre>

<p><code>NSURLSessionDownloadDelegate</code>定义了代理方法你需要去实现，在你使用 NSURLSession 下载任务的时候，这个唯一的不是可选的代理方法是 <code>URLSession(_:downloadTask:didFinishDownloadingToURL:),</code>,当下载完成的时候，将会执行这个代理方法，打印简答的一句话.</p>

<p>在<code>SearchViewController.swift</code>文件中，替换<code>startDownload(_:)</code>这个方法的代码如下:</p>

<pre><code>func startDownload(track: Track) {
  if let urlString = track.previewUrl, url =  NSURL(string: urlString) {
    // 1
    let download = Download(url: urlString)
    // 2
    download.downloadTask = downloadsSession.downloadTaskWithURL(url)
    // 3
    download.downloadTask!.resume()
    // 4
    download.isDownloading = true
    // 5
    activeDownloads[download.url] = download
  }
}
</code></pre>

<p>当你点击 <code>Download</code>按钮的时候，你将会调用<code>startDownload(_:)</code>函数去执行下载命令，上面的代码执行的步骤如下:</p>

<ol>
<li>你用URL去初始化一个DownLoad对象</li>
<li>使用上面的NSURL和downloadsSession去初始化<code>NSURLSessionDownloadTask</code></li>
<li>调用resume()去启动一个下载任务</li>
<li>设置下载标识 为true</li>
<li>最后，你把下载的URL作为key,download对象作为值放到一个字典中</li>
</ol>


<p>编译运行你的项目，查询出来的歌曲中，点击 Download按钮，你将会看到一个消息打印在控制台。
<code>Finished downloading.</code></p>

<h2>保存&amp;播放</h2>

<p>当下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>提供了一个URL存储临时文件路径，你的工作就是移动它到你程序的沙盒当中，在这个方法返回之前。当然，这个过程当中你需要删除全局字典中正在下载的download对象，并且更新表格.</p>

<p>你需要添加一个Helper方法简化这个操作，在<code>SearchViewController.swift</code>中，添加如下方法:</p>

<pre><code>func trackIndexForDownloadTask(downloadTask: NSURLSessionDownloadTask) -&gt; Int? {
  if let url = downloadTask.originalRequest?.URL?.absoluteString {
    for (index, track) in searchResults.enumerate() {
      if url == track.previewUrl! {
        return index
      }
    }
  }
  return nil
}
</code></pre>

<p>这个方法仅仅返回 当前的URL在 searchResults集合中的索引，下一步，替换 URLSession(_:downloadTask:didFinishDownloadingToURL:) 中的代码:</p>

<pre><code>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
  // 1
  if let originalURL = downloadTask.originalRequest?.URL?.absoluteString,
    destinationURL = localFilePathForUrl(originalURL) {

    print(destinationURL)

    // 2
    let fileManager = NSFileManager.defaultManager()
    do {
      try fileManager.removeItemAtURL(destinationURL)
    } catch {
      // Non-fatal: file probably doesn't exist
    }
    do {
      try fileManager.copyItemAtURL(location, toURL: destinationURL)
    } catch let error as NSError {
      print("Could not copy file to disk: \(error.localizedDescription)")
    }
  }

  // 3
  if let url = downloadTask.originalRequest?.URL?.absoluteString {
    activeDownloads[url] = nil
    // 4
    if let trackIndex = trackIndexForDownloadTask(downloadTask) {
      dispatch_async(dispatch_get_main_queue(), {
        self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: trackIndex, inSection: 0)], withRowAnimation: .None)
      })
    }
  }
}
</code></pre>

<p>上面的代码做的事情如下:</p>

<ol>
<li>定义了两个变量，<code>originalURL</code>请求路径的url,<code>destinationURL</code>变量则是通过<code>localFilePathForUrl(_:)</code>方法生成的，该方法会获取当前程序的沙盒路径再追加 传递的URL的最后一个后缀(/)的路径作为返回的参数。作为目标文件夹的路径</li>
<li>使用NSFileManager,在开始拷贝文件之前，先删除目标文件夹下的文件，如果存在的话。然后进行拷贝从本地拷贝到目标文件夹</li>
<li>删除download从全局的download字典中</li>
<li>最后刷新表格对应的哪一行</li>
</ol>


<p>编译运行你的工程，点击搜索然后选中一行进行下载，当下载完成时候，在控制台会打印一行信息,下载的目标路径</p>

<pre><code>file:///Users/Andrew/Library/Developer/CoreSimulator/Devices/875165C2-FA55-4884-96AE-A7C8E3223C12/data/Containers/Data/Application/52B47648-04A2-4C26-8BCF-F41D2C76CA21/Documents/mzm.gyadmzom.aac.p.m4a
</code></pre>

<p>这时下载按钮将会消失，再次点击表格的对应的那行，将会弹出一个 MPMoviePlayerViewController,开始播放音频.</p>

<h2>监视下载进度</h2>

<p>当然，现在你还没有监视下载的进度条，为了提高用户体验，你将要改变你的App去监听下载的进度在每个cell中。</p>

<p>在SearchViewController.swift文件中,找到 <code>NSURLSessionDownloadDelegate</code>的扩展，然后添加如下的代理方法:</p>

<pre><code>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {

    // 1
    if let downloadUrl = downloadTask.originalRequest?.URL?.absoluteString,
      download = activeDownloads[downloadUrl] {
      // 2
      download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
      // 3
      let totalSize = NSByteCountFormatter.stringFromByteCount(totalBytesExpectedToWrite, countStyle: NSByteCountFormatterCountStyle.Binary)
      // 4
      if let trackIndex = trackIndexForDownloadTask(downloadTask), let trackCell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: trackIndex, inSection: 0)) as? TrackCell {
        dispatch_async(dispatch_get_main_queue(), {
          trackCell.progressView.progress = download.progress
          trackCell.progressLabel.text =  String(format: "%.1f%% of %@",  download.progress * 100, totalSize)
        })
    }
  }
}
</code></pre>

<p>通过这个代理方法做的工作如下:</p>

<ol>
<li>使用提供的 downloadTask 找到URL属性，然后从全局激活的下载字典中查找 DownLoad对象</li>
<li>这个方法将会返回总的字节数和已经写入的字节数，你可以利用这个两个值算出当前的下载进度并且实时更新进度条。</li>
<li>NSByteCountFormatter 将会把字节数转化成人类能够看懂的文件大小，有将会使用这个字符串去显示下载的文件大小和百分比</li>
<li>最后，你将要定位到这个Cell,在主线程中更新进度条和显示的百分比</li>
</ol>


<p>下一步，你将要配置这个cell属性去显示进度条</p>

<p>找到下面的代码在 <code>tableView(_:cellForRowAtIndexPath:):</code>中</p>

<pre><code>let downloaded = localFileExistsForTrack(track)
</code></pre>

<p>添加如下代码在这行的上面:</p>

<pre><code>var showDownloadControls = false
if let download = activeDownloads[track.previewUrl!] {
  showDownloadControls = true

  cell.progressView.progress = download.progress
  cell.progressLabel.text = (download.isDownloading) ? "Downloading..." : "Paused"
}
cell.progressView.hidden = !showDownloadControls
cell.progressLabel.hidden = !showDownloadControls
</code></pre>

<p>为了跟踪正在下载的歌曲，你将要设置 showDownloadControls为true,否则，你将要设置为false.你将要显示这进度条和文字。</p>

<p>为了暂停任务，显示"Paused"状态，否则，显示 “Downloading&hellip;.”
最后，替换这行代码:</p>

<pre><code>cell.downloadButton.hidden = downloaded
</code></pre>

<p>使用下面这行代码:</p>

<pre><code>cell.downloadButton.hidden = downloaded || showDownloadControls
</code></pre>

<p>到这，你可以告诉表格是否隐藏下载按钮。</p>

<p>编译运行你的工程，点击下载按钮，你将要看到一个进度条和下载的进度，以及下载的百分比。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-17-at-11.02.03-pm-480x78.png" alt="logo" /></p>

<p>OK,你做到了!😀</p>

<h2>暂停 恢复  取消下载任务</h2>

<p>假如我需要暂停一个任务，或者取消任务？此时该怎么做呢？</p>

<p>在这个章节，你将要实现暂停，恢复，取消任务操作。</p>

<p>你将要开始编写代码，通过允许用户去取消一个正在激活的任务
替换 <code>cancelDownload(_:)</code> 使用下面的代码:</p>

<pre><code>func cancelDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      download.downloadTask?.cancel()
      activeDownloads[urlString] = nil
  }
}
</code></pre>

<p>为了取消任务，你可以从全局激活的字典中取出Download对象，然后调用它的 cancel() 方法，执行取消命令，然后在全局字典中移除它</p>

<p>暂停任务和取消任务非常类似，不同点在于当你暂停一个任务的时候，会产生恢复数据，它包含了足够多的信息去恢复下载数据，当然后台服务器必须要支持这个特性才能完全实现断点下载功能.</p>

<blockquote><p><strong>注意</strong>
你能恢复一个下载任务在一定的控制条件下，例如，从你第一下请求下载开始，这个下载资源就不能再改变了。想要更详细的控制条件，请参考苹果的 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDownloadTask_class/index.html#//apple_ref/occ/instm/NSURLSessionDownloadTask/cancelByProducingResumeData:">官方文档</a></p></blockquote>

<p>现在，替换 <code>pauseDownload(_:)</code>使用下面的代码:</p>

<pre><code>func pauseDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      if(download.isDownloading) {
        download.downloadTask?.cancelByProducingResumeData { data in
          if data != nil {
            download.resumeData = data
          }
        }
        download.isDownloading = false
      }
  }
}
</code></pre>

<p>这个关键字是不同的 cancelByProducingResumeData(_:) 替代了 cancel(),你检索这个恢复的数据从这个方法cancelByProducingResumeData提供的回调函数中，并且把恢复的数据保存到Download的resumeData属性中。并且设置isDownloading=false</p>

<p>下面替换<code>resumeDownload(_:)</code>用下面的代码:</p>

<pre><code>func resumeDownload(track: Track) {
  if let urlString = track.previewUrl,
    download = activeDownloads[urlString] {
      if let resumeData = download.resumeData {
        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)
        download.downloadTask!.resume()
        download.isDownloading = true
      } else if let url = NSURL(string: download.url) {
        download.downloadTask = downloadsSession.downloadTaskWithURL(url)
        download.downloadTask!.resume()
        download.isDownloading = true
      }
  }
}
</code></pre>

<p>当用户恢复一个下载任务时，你检查下当前的Download对象 恢复数据的属性是否有值，如果有值，你将会创建一个新的下载任务通过 <code>downloadTaskWithResumeData(_:)</code>和一个恢复数据的参数，启动<code>resume()</code>恢复数据的命令;如果这个 恢复数据的属性是空的或者其他一些原因，你将要用URL创建一个新的下载任务，启动它.</p>

<p>在上面的案例中，你设置这个isDownloading为true,表明任务正在进行.</p>

<p>还有一件事件要做就是设置这三个函数的工作属性，你需要在cell中显示 或者隐藏 <code>暂停</code>，<code>取消</code>和<code>继续下载</code>按钮。</p>

<p>找到 <code>tableView(_:cellForRowAtIndexPath:)</code>然后找到下面这行代码:</p>

<pre><code>if let download = activeDownloads[track.previewUrl!] {
</code></pre>

<p>然后添加下面的代码:</p>

<pre><code>let title = (download.isDownloading) ? "Pause" : "Resume"
cell.pauseButton.setTitle(title, forState: UIControlState.Normal)
</code></pre>

<p>暂停和继续下载按钮共用一个按钮。</p>

<p>下一步，添加下面的代码在 <code>tableView(_:cellForRowAtIndexPath:)</code>结尾:</p>

<pre><code>cell.pauseButton.hidden = !showDownloadControls
cell.cancelButton.hidden = !showDownloadControls
</code></pre>

<p>当下载任务激活的时候，这里仅仅把按钮显示出来。</p>

<p>编译运行你的工程，下载几个歌曲试试，你可以暂停，继续下载，取消 下载任务。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="logo" /></p>

<h2>支持后台下载</h2>

<p>你的App现在看来已经很不错了，但是还有一个问题，是否支持后台任务下载:当你的程序进入后台模式或者因为别的原因意外终止了，后台任务是否能继续下载?</p>

<p>假如你的App不再运行了，那它怎么能继续工作呢？这儿有一个守护进程在App运行之外，去管理后台任务下载；它发送一个适当的代理方法通知给app让其任务下载继续，当这个app正在下载的时候突然退出，这个任务将要继续下载。</p>

<p>当任务完成的时候，这个守护进程将要重新加载在后台模式中，这个重新加载app将要重新连接这同样的session.收到相关的完成的代理消息并且执行一些要求的动作，比如持久化下载的文件到硬盘上等。</p>

<blockquote><p><em>注意</em>
如果你强制退出app通过app switche，这个系统将要取消所有后台下载的任务，并且不会再视图重启这个app</p></blockquote>

<p>仍然在SearchViewController.swift这个文件中，在初始化 <code>downloadsSession</code>的地方，找到下面这行代码:</p>

<pre><code>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</code></pre>

<p>替换成下面的代码:</p>

<pre><code>let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("bgSessionConfiguration")
</code></pre>

<p>替换默认的session配置文件，指定一个特殊的后台session配置文件，注意你设置了唯一的ID为这个session,这会允许你引用并且重新连接同样的后台session.</p>

<p>下一步，在 viewDidLoad()中，增加如下代码:</p>

<pre><code>_ = self.downloadsSession
</code></pre>

<p>调用懒加载属性<code>downloadsSession</code>,确保应用程序确实创建了一个后台session 的SearchViewController的实例。</p>

<p>当一个后台任务完成的时候，这个App不再运行，这个app将会重新运行到后台进程中，你需要去处理你的app的一些代理方法.</p>

<p>切换到 AppDelegate.swift,添加下面的代码在类的顶部:</p>

<pre><code>var backgroundSessionCompletionHandler: (() -&gt; Void)?
</code></pre>

<p>下一步，添加如下代码在AppDelegate.swift:</p>

<pre><code>func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) {
  backgroundSessionCompletionHandler = completionHandler
}
</code></pre>

<p>提供一个completionHandler作为一个变量在你的App代理方法中，等会会用到。</p>

<p>application(_:handleEventsForBackgroundURLSession:)会唤醒这个App处理完成这个后台任务，你需要去处理两个事情：</p>

<ul>
<li>首先，通过代理方法用这个App去重新连接这个后台session,一旦你创建并且每次使用后台session时，SearchViewController就会被实例化，你已经重新连接了.</li>
<li>第二，你需要去捕获完成的回调方法，在完成的回调函数中，更新你的UI,然后告诉系统你的App已经工作完毕使用后台任务的session.</li>
</ul>


<p>但是什么时候你将会调用完成的回调函数呢？
<code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>将会是一个好的选择，它是NSURLSessionDelegate的一个代理方法，当所有的任务在后台session中完成的时候。</p>

<p>实现下面的扩展在<code>SearchViewController.swift</code>中</p>

<pre><code>extension SearchViewController: NSURLSessionDelegate {

  func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
    if let appDelegate = UIApplication.sharedApplication().delegate as? AppDelegate {
      if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
        appDelegate.backgroundSessionCompletionHandler = nil
        dispatch_async(dispatch_get_main_queue(), {
          completionHandler()
        })
      }
    }
  }
}
</code></pre>

<p>上面的代码仅仅抓取了在APPDelegate中存储的回调函数，并且在主线中调用它.</p>

<p>编译运行你的工程，开始几个下载之后迅速按在home键，使得下载任务进入后台，等几十秒你的下载任务将会完成，然后双击home,关闭当前程序。</p>

<p>下载任务将会完成并且他们将会更新显示状态。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt="logo" /></p>

<p>OK，这个demo已经完备了。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程从 <a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip">这里</a></p>

<p>更多资源</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/">苹果的官方文档</a></li>
<li><a href="https://github.com/Alamofire/Alamofire">AlamoFire</a>是Swift中非常流行的第三方框架，可以学习一下.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue简单介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao/"/>
    <updated>2016-03-26T08:11:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao</id>
    <content type="html"><![CDATA[<p>在iOS中有两种方式来实现多线程:NSOperation和GCD.
其中GCD是基于C的底层的API,而NSOperation则是GCD实现的Object-c的API,随让NSOPeration是基于GCD实现的，但是并不意味着它是一个GCD的重复版本，相反，我们可以用NSOperation轻易的实现一些GCD要写大量代码的事情，因此，NSOperation是被推荐使用的.</p>

<!--more-->


<h2>为什么优先使用NSOperationQuere,而不是GCD</h2>

<p>你可能写过这样的网络请求的代码:</p>

<pre><code>dispatch_async(_Queue, ^{  
    //请求数据 
    NSData *data = [NSData dataWithContentURL:[NSURL URLWithString:@"http://domain.com/a.png"]]; 
    dispatch_async(dispatch_get_main_queue(), ^{ 
        [self refreshViews:data];
     });
});
</code></pre>

<p>这段代码是可以正常工作的，但是有一个很大的缺点，就是<em>这个任务是无法取消的</em></p>

<p><code>dataWithContentURL:</code>是同步拉取数据，它会一直阻塞主线程，直到所有的数据返回之后；这个期间，并发队列就需要为其它任务新建线程，这样可能导致性能下降问题。因此我们不推荐这种写法来从网络上拉取数据。</p>

<p>操作队列是有GCD提供的一个队列模型的Coco对象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了更加方便的功能。NSOperation相对GCD来说有以下优点:</p>

<ul>
<li>提供了GCD中不那么容易复制的有用特性</li>
<li>可以很方便的取消一个NSOperation的执行</li>
<li>可以容易的添加任务的依赖关系</li>
<li>提供了任务的状态:isExecting,isFinished
*</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue就是一个线程队列，可以吧 <code>NSOperation</code>加入到队列中，可以取消或者执行完队列中所有的 <code>NSOperation</code>,我们可以通过<code>maxConcurrentOperationCount</code>属性来控制并发任务的数量，当设置为1时，就是一个串行队列。</p>

<h2>NSOperation</h2>

<p>它是创建线程的对象，系统已经默认提供了<code>NSBlockOperaton</code>和<code>NSInvocationOperation</code>.你也可以实现自己的子类，通过重写
<code>main</code>或者<code>start</code>方法来自定义nsoperation</p>

<p>使用<code>main</code>方法非常简单，不需要管理一些状态属性,当main方法返回的时候，这个operation就执行结束了，所以一般用来执行同步任务。</p>

<p>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么重写<code>start</code>方法，但是注意，在这种情况下，你必须手动的管理操作的状态，只有发送isFinished的KVO消息时，才认为是operaiton结束。</p>

<pre><code>
@implementation YourOperation
- (void)start
{
    self.isExecuting = YES;
    // 任务代码 ...
}
- (void)finish //异步回调
{
    self.isExecuting = NO;
    self.isFinished = YES;
}
@end
</code></pre>

<p><em>当实现了<code>start</code>方法时，默认就会执行start方法，而不执行main方法</em>，为了让操作队列捕获到做的改变，需要将状态的属性配合KVO的方式实现，如果你不使用它们默认的sette来进行设置的话，就需要在合适的时候手动发送KVO消息。</p>

<p>需要手动管理的状态有:</p>

<ol>
<li>isExecuting  代表任务正在进行中</li>
<li>isFinished   代表任务已经执行完成</li>
<li>isCanceled  代表任务已经取消</li>
</ol>


<p>手动发送KVo消息，通知状态:</p>

<pre><code>[self willChangeValueForKey:@"isCancelled"];
_isCancelled = YES;
[self didChangeValueForKey:@"isCancelled"];
</code></pre>

<p>为了能使用队列所提供的取消功能，你需要在长时间操作中不时地检查isCanceled属性，比如在一个长的循环中:</p>

<pre><code>- (void)main
{
    while (notDone &amp;&amp; !self.isCancelled) {
        // 任务处理
    }
}
@end
</code></pre>

<h2>简单使用</h2>

<p>NSOperaiton和NSOperationQueue实现多线程的步骤:</p>

<ol>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装放到一条新线程中执行</li>
</ol>


<p>NSOperation是个抽象类，并不具备封装操作的能力，必须实现它的子类。</p>

<h3>NSInvocationOperation子类</h3>

<pre><code>//创建操作对象，封装要执行的任务
//NSInvocationOperation   封装操作
    NSInvocationOperation *operation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];

    //执行操作
    [operation start];
</code></pre>

<p>一旦执行操作，就会调用target的test方法</p>

<p>操作对象默认在主线程中执行，只有添加到列队中才会开启新的线程，即默认情况下，如果操作没有放到队列queue中，都是同步执行，只有将NSoperation放到一个NSOperationQueue中，才会异步执行.</p>

<h2>NSBlockOoperaiton</h2>

<p>创建对象和添加操作:</p>

<pre><code>//创建NSBlockOperation操作对象
    NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
        //......
    }];

    //添加操作
    [operation addExecutionBlock:^{
        //....
    }];
</code></pre>

<pre><code>//创建NSBlockOperation操作对象
     NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"NSBlockOperation------%@",[NSThread currentThread]);
     }];

     //添加操作
     [operation addExecutionBlock:^{
        NSLog(@"NSBlockOperation1------%@",[NSThread currentThread]);
     }];

     [operation addExecutionBlock:^{
         NSLog(@"NSBlockOperation2------%@",[NSThread currentThread]);
     }];

     //开启执行操作
    [operation start];
</code></pre>

<p>只要NSBlockOperation封装的操作数>1，就会异步操作。</p>

<h2>NSOperationQueue</h2>

<p>NSOperationQueue可以调用start方法来执行任务，但默认是同步执行的。
如果将NSOperation添加到NSOperationQueue中，系统就会自动异步执行NSOPeration中的操作。</p>

<pre><code>
#import "YYViewController.h"

@interface YYViewController ()

@end

@implementation YYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    //创建NSInvocationOperation对象，封装操作
    NSInvocationOperation *operation1=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test1) object:nil];
    NSInvocationOperation *operation2=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test2) object:nil];
    //创建对象，封装操作
    NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{
        NSLog(@"NSBlockOperation3--1----%@",[NSThread currentThread]);
    }];
    [operation3 addExecutionBlock:^{
        NSLog(@"NSBlockOperation3--2----%@",[NSThread currentThread]);
    }];

    //创建NSOperationQueue
    NSOperationQueue * queue=[[NSOperationQueue alloc]init];
    //把操作添加到队列中
    [queue addOperation:operation1];
    [queue addOperation:operation2];
    [queue addOperation:operation3];
}

-(void)test1
{
    NSLog(@"NSInvocationOperation--test1--%@",[NSThread currentThread]);
}

-(void)test2
{
    NSLog(@"NSInvocationOperation--test2--%@",[NSThread currentThread]);
}

@end
</code></pre>

<p>系统自动将NSOperationqueue中的NSOPeration对象取出，将其封装的操作放到一条新的线程中执行，
上面的代码一共有4个任务，operation1和operation2分别有一个任务，operation3有两个任务，一共4个任务，开启了4条线程。</p>

<p>这些任务是并行执行的。</p>

<blockquote><p><strong>提示</strong>
队列的取出时有顺序的，与打印结果并不矛盾，这就好比赛跑，起跑的顺序是A,B,C，但是到达终点的顺序就不一样是 A B  C了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习CAShapeLayer]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer/"/>
    <updated>2016-03-04T14:20:24+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>CAShapeLayer继承自CALayer,因此，可以使用CaLayer的所有属性。但是，CAShapeLayer需要和贝塞尔曲线配合使用才有意义.</p>

<p>CAShapeLayer是在其坐标系统内绘制贝塞尔曲线的。因此使用CAShapeLayer需要与 <code>UIbezierPath</code>一起使用。</p>

<p>它有一个 <code>path</code>属性，而<code>UIBezierPath</code>就是对 <code>CGPathRef</code>类型的封装，因此这两者是绝配</p>

<!--more-->


<h2>CASHapeLayer和drawRect的比较</h2>

<ol>
<li>drawRect : 属于CoreGraphics框架，占用cpu,性能消耗大</li>
<li>CAShapeLayer:属于CoreAnimation框架，通过GPU来渲染图形，节省性能。动画渲染直接提交给手机的GPU,不消耗内存。</li>
</ol>


<p>这两者各有各的用途，而不是说有个CAShapeLayer就不需要drawRect了。</p>

<h2>CAShapeLayer月UIBezierPath的关系</h2>

<ol>
<li>CAShapeLayer中的shape代表形状的意思，所以需要形状才能生效</li>
<li>贝塞尔曲线可以创建矢量的路径，而<code>UIBezierPath</code>类是对 <code>CGPathRef</code>的封装</li>
<li>贝塞尔曲线给 <code>CAShapeLayer</code>提供路径，CAShapelayer在提供的路径中进行渲染。路径会闭环，所以绘制出了 <code>Shape</code></li>
<li>用于<code>CAShapeLayer</code>的贝塞尔曲线作为path,其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线。</li>
</ol>


<h2>CAShapeLayer与UIBezierPath画圆</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-2.png" alt="logo" /></p>

<p>代码:</p>

<pre><code>-(CAShapeLayer*)drawCircle{
    CAShapeLayer *circleLayer=[CAShapeLayer layer];

    circleLayer.frame=CGRectMake(100, 10, 200, 200);
    //设置居中显示
   // circleLayer.position=self.view.center;
    //设置填充颜色
    circleLayer.fillColor=[UIColor clearColor].CGColor;
    //设置线宽
    circleLayer.lineWidth=2;
    //设置线的颜色
    circleLayer.strokeColor=[UIColor redColor].CGColor;

    //使用UIBezierPath创建路径
    CGRect frame=CGRectMake(0, 0, 200, 200);
    UIBezierPath *circlePath=[UIBezierPath bezierPathWithOvalInRect:frame];
    //设置CAShapeLayer与UIBezierPath关联
    circleLayer.path=circlePath.CGPath;

    [self.view.layer addSublayer:circleLayer];

    return circleLayer;

}
</code></pre>

<p>注意，我们这里不是放在-drawRect:方法中调用的。我们直接将这个CAShapeLayer放到self.view.layer上，直接呈现出来。</p>

<p>我们创建一个<code>CAShapeLayer</code>，然后配置相关属性，然后再通过 <code>UIBezierPath</code>的类方法创建一个内切圆路径，然后将路径指定给<code>CAShapeLayer.path</code>,这就将两者关联起来了，最后，将这个层放到了self.view.layer上呈现出来。</p>

<h2>CAShapeLayer与UIBezierPath的简单Loading效果</h2>

<p>代码:</p>

<pre><code>- (void)drawHalfCircle {
  self.loadingLayer = [self drawCircle];

  // 这个是用于指定画笔的开始与结束点
  self.loadingLayer.strokeStart = 0.0;
  self.loadingLayer.strokeEnd = 0.75;

  self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1
                                                target:self
                                              selector:@selector(updateCircle)
                                              userInfo:nil
                                               repeats:YES];
}

- (void)updateCircle {
  if (self.loadingLayer.strokeEnd &gt; 1 &amp;&amp; self.loadingLayer.strokeStart &lt; 1) {
    self.loadingLayer.strokeStart += 0.1;
  } else if (self.loadingLayer.strokeStart == 0) {
    self.loadingLayer.strokeEnd += 0.1;
  }

  if (self.loadingLayer.strokeEnd == 0) {
    self.loadingLayer.strokeStart = 0;
  }

  if (self.loadingLayer.strokeStart &gt;= 1 &amp;&amp; self.loadingLayer.strokeEnd &gt;= 1) {
    self.loadingLayer.strokeStart = 0;
    [self.timer invalidate];
    self.timer = nil;
  }
}
</code></pre>

<p>我们要实现这个效果，是通过 <code>stokeStart</code>和<code>stokeEnd</code>这两个属性好实现的，这两个的取值范围是[0-1],当stokeStart的值慢慢变成1时，我们看到路径是慢慢消失的。这里实现的效果并不好，因为不能一直循环。</p>
]]></content>
  </entry>
  
</feed>
