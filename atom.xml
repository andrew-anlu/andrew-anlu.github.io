<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-09-10T17:05:06+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[组合与继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng/"/>
    <updated>2016-09-10T08:45:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng</id>
    <content type="html"><![CDATA[<h2>何时使用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的UITableViewCell,那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不管代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

<!--more-->


<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个<code>OBJDevice</code>类，让一些子类如 <code>OBJIPhoneDevice</code>和<code>OBJIPadDevice</code>,甚至更深层次的子类如<code>OBJIPhone5Device</code>来继承，并让这些子类重写特定的方法，例如，你的<code>OBJDevice</code>类可能包含了函数<code>applyRoundedCornersToView:withRadius</code>,它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类可能很有用的场景是模型对象（model object）.绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code>,<code>hash</code>,<code>copyWithzone:</code>,和<code>description</code>等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找这样的一个基类，可以考虑使用<a href="https://github.com/mantle/mantle">Mantle</a>,它就是这么做的，并且做的更多）</p>

<h2>何时不适用子类</h2>

<p>在以往工作过得很多工程中，我见过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。</p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代的方案可选。在下面的章节中，我们会逐个进行更详细的描述。如果你的子类只是使用相同的接口，协议会是非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有的对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h1>替代方案</h1>

<h2>协议(Protocols)</h2>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在app中你有一个播放器对象，它可以播放视频。现在你想添加对YouTube的支持，使用相同的接口，但是具体实现不同。你可以像这样用子类来实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Player : NSObject
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class YouTubePlayer : Player
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的昂奋。可以这样用协议来写你的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VideoPlayer &lt;NSObject&gt;
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class Player : NSObject &lt;VideoPlayer&gt;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class YouTubePlayer : NSObject &lt;VideoPlayer&gt;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这样，<code>YouTubePlayer</code>类就不必知道<code>Player</code>类内部实现了</p>

<h2>替代方案:代理(delegate)</h2>

<p>再一次假设你有一个像上面例子中的<code>Player</code>类，现在，你想在开始播放的时候在某个地方执行一个自定的函数。这么做相对容易一些：创建一个自定义的子类，重写<code>play</code>方法，调用<code>[super play]</code>，然后开始做你自定义的工作。这么做是一种方法，另外一种方法是，改动你的<code>Player</code>对象，然后给它设置一个代理。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Player;
</span><span class='line'>
</span><span class='line'>@protocol PlayerDelegate
</span><span class='line'>
</span><span class='line'>- (void)playerDidStartPlaying:(Player *)player;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class Player : NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic,weak) id&lt;PlayerDelegate&gt; delegate;
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>现在，在播放器的<code>play</code>方法里，就可以给代理发<code>playerDidStartPlaying :</code>消息了。这个<code>Player</code>类的任何使用者都可以仅仅实现这个代理协议，而不用继承该类，<code>Player</code>类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像<code>UITextField</code>这样的类，还有<code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如<code>UITableView</code>,它不仅有个一个代理(delegate),还有一个数据源(dataSource)</p>

<h2>替代方案：类别(Categories)</h2>

<p>有时候，你可能会想给你一个对象增加一点点额外的功能，比如你想给NSArray增加一个方法<code>arrayByRemovingFirstObject</code>.不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface NSArray (OBJExtras)
</span><span class='line'>
</span><span class='line'>- (void)obj_arrayByRemovingFirstObject;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在用类别扩展一个不是你自己的类的时候，在方法前欠佳前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有一个另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h2>替代方案:配置对象(Configuration Objects)</h2>

<p>在我经常犯的错误中，其中一条就是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。假如，在一个幻灯片应用里，你有一个主题类<code>Theme</code>,它含有几个属性，比如<code>backgroundColor</code>和<code>Font</code>，还有一些在一张幻灯片上如何布局的逻辑函数</p>

<p>然后，对每种主题，你都创建一个<code>Theme</code>的子类，重写某个函数(例如 <code>setup</code>)并且配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如 幻灯片布局）放在<code>Theme</code>类中，把属性的配置放到比较简单的对象中，这些对象中只包含有这些属性。</p>

<p>例如，类<code>ThemeConfiguration</code>具有<code>backgroundColor</code>和<code>font</code>属性，而类<code>Theme</code>在其初始化函数中获取一个配置类<code>ThemeConfiguration</code>的值</p>

<h2>替代方案:组合</h2>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不像共享同样的接口，组合就是你的首选武器，例如，假设你要设计一个缓存类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface OBJCache : NSObject
</span><span class='line'>
</span><span class='line'>- (void)cacheValue:(id)value forKey:(NSString *)key;
</span><span class='line'>- (void)removeCachedValueForKey:(NSString *)key;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>简单点的做法是直接继承<code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface OBJCache : NSDictionary</span></code></pre></td></tr></table></div></figure>


<p>但是这么做有几个弊端，它本来是应该被详细实现的，但只是通过字典来实现，现在，在任何需要一个<code>NSDictionary</code>参数的时候，你可以直接提供一个<code>OBJCache</code>值。但如果你想把它转为其它完全不同的东西，你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性(或者实例变量)中，对外仅仅暴露这两个<code>cache</code>方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组合继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-ji-cheng/"/>
    <updated>2016-09-10T08:45:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-ji-cheng</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo/"/>
    <updated>2016-07-19T13:44:10+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在ios中，所有的View都是由一个底层的layer来驱动的。View和它的layer之间有着紧密的联系，View其实直接从layer对象中获取了绝大多数它所需要的数据。在ios中也有一些单独的layer,比如<code>AVCaptureVideoPreviewLayer</code>和<code>CAShapeLayer</code>，它们不需要附加到view上就可以在屏幕上显示内容。两种情况下都是layer起决定作用。当然了，附加到view上的layer和单独的layer在行为上还是稍有不同的。</p>

<!--more-->


<p>基本上你改变一个单独的layer的任何属性的时候，都会触发一个从旧值过渡到新值的简单动画（就是所谓的动画<code>animatable</code>）。然而，如果你改变的是view中layer的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有layer,但是当layer附加在view上时，它的默认的隐式动画的layer行为就不起作用了。</p>

<blockquote><p><em>注意</em>
animatable 几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以'animatable'结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，设置也囊括了像isHidden和doubleSides这样的布尔值。像paths这样的属性也是animatable的。但是它不支持隐式动画。</p></blockquote>

<p>在 Core Animation 编程指南的"How to Animate Layer-Backed Views"中，对为什么会这样做出了一个解释:</p>

<blockquote><p>UIView默认情况下进制了layer动画，但是在animation block中又重新启用了它们</p></blockquote>

<p>这正是我们所看到的额行为，当一个属性在动画block之外被改变时，没有动画，但是当属性在动画block内改变时，就带上了动画。对于这是如何发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了view和layer之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的layer属性改变时，layer都会寻找并运行何时的'Action'来实行这个改变。在core Animation的专业术语中就把这样的动画统称为动作(Action,或者CAAction)</p>

<blockquote><p>CAAction:从技术上来说，这是一个接口，并可以用来做各种事情，但是实际上，某种程度上你可以只把它理解为用来处理动画</p></blockquote>

<p>layer将像文档中缩写的那样去寻找动作，整个过程分为5个步骤。第一步中的view和layer中交互的部分是最有意思的：</p>

<p>layer通过向它的代理发送 <code>actionForLayer:forKey:</code>消息来询问提供一个对应属性变化的action.delegate可以通过返回以下三者之一来进行响应:</p>

<ol>
<li>它可以返回一个动作对象，这种情况下layer将使用这个动作</li>
<li>它可以返回一个nil,这样layer就会到其他地方继续寻找</li>
<li>它可以返回一个NShull对象，告诉layer这里不需要执行一个动作，搜索也会就此停止</li>
</ol>


<p>而让这一切变得有趣的是，当layer在背后支持一个view的时候，view就是它的delegate;</p>

<blockquote><p>在ios中，如果layer与一个UIview对象关联时，这个属性必须被设置为持有这个layer的那个view</p></blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了；属性改变时layer会向View请求一个动作，而一般情况下view将返回一个NSNull,只有当属性改变发生在动画block中时，view才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的layer属性向view询问动作就可以了，比如对于'position':</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLog(@"outside animation block: %@",
</span><span class='line'>      [myView actionForLayer:myView.layer forKey:@"position"]);
</span><span class='line'>
</span><span class='line'>[UIView animateWithDuration:0.3 animations:^{
</span><span class='line'>    NSLog(@"inside animation block: %@",
</span><span class='line'>          [myView actionForLayer:myView.layer forKey:@"position"]);
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>运行上面的代码，可以看到在block外view返回的是NSNull对象，而在block中时返回的是一个CABasicAnimation.很优雅，对吧?值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>outside animation block: &lt;null&gt;
</span><span class='line'>inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;</span></code></pre></td></tr></table></div></figure>


<p>对于view中的layer来说，对动作的搜索只会到第一步为止。对于单独的layer来说，剩余的4个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer</a>actionForKey: 文档中找到。</p>

<h2>从UIKit中学习</h2>

<p>我很确定我们都会同意UIview动画是一组非常优秀的API,它简洁明确，实际上，它使用了Core Animation来执行动画，这给了我们一个绝佳的积水来深入研究UIKit是如何使用Core Animation的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴.</p>

<p>当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forKey:方法将添加到layer中，就像显示地添加动画那样。再一次，别直接相信我，让我们实践检验一下</p>

<p>归功于UIview的layerClass 类方法，View和layer之间的交互很容易被观测到。通过这个方法我们可以在为View创建layer时为其指定要使用的类。通过子类一个UIView,以及用这个方法返回一个自定义的layer类，我们就可以重写layer子类中的 <code>addAnimaiton:ForKey:</code>并输出一些东西来验证它是佛确实被调用。唯一要记住的是我们需要调用super方法，不然的话我们就把要观测的行为完全改变了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface DRInspectionLayer : CALayer
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRInspectionLayer
</span><span class='line'>- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
</span><span class='line'>{
</span><span class='line'>    NSLog(@"adding animation: %@", [anim debugDescription]);
</span><span class='line'>    [super addAnimation:anim forKey:key];
</span><span class='line'>}
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@interface DRInspectionView : UIView
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRInspectionView
</span><span class='line'>+ (Class)layerClass
</span><span class='line'>{
</span><span class='line'>    return [DRInspectionLayer class];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>通过输出动画的debug信息，我们不仅可以验证它确实如逾期一样被调用了，还可以看到动画是如何组织构建的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;CABasicAnimation:0x8c73680; 
</span><span class='line'>    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
</span><span class='line'>    fillMode = both; 
</span><span class='line'>    timingFunction = easeInEaseOut; 
</span><span class='line'>    duration = 0.3; 
</span><span class='line'>    fromValue = NSPoint: {5, 5}; 
</span><span class='line'>    keyPath = position
</span><span class='line'>&gt;</span></code></pre></td></tr></table></div></figure>


<p>当动画被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue(也就是当前值)被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的行为应该是:</p>

<blockquote><p>只有FromValue不是nil时，在fromvalue和属性当前显示层的值之间进行插值</p></blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到layer上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@"opacity"];
</span><span class='line'>fadeIn.duration  = 0.75;
</span><span class='line'>fadeIn.fromValue = @0;
</span><span class='line'>
</span><span class='line'>myLayer.opacity = 1.0; // 更改 model 的值 ...
</span><span class='line'>// ... 然后添加动画对象
</span><span class='line'>[myLayer addAnimation:fadeIn forKey:@"fade in slowly"];</span></code></pre></td></tr></table></div></figure>


<p>这很简洁，你也不需要再动画被移除的时候做什么额外的操作，如果动画是在一段延迟后才开始的话，你可以使用backward填充模式(或者'both'填充模式)，就像UIKit所创建的动画那样</p>

<p>可能你看见上面输出中的动画的delegate了，想知道这个类是用来做什么的呢？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a>,它主要用来维护动画的一些状态(持续时间，延时，重复次数等等)，它还负责对一个栈做push和pop,这是为了在多个动画block嵌套时能够获取正确的动画状态。这些都是事先细节，除非你想要写一套自己的基于block的动画API,否则可能你不会用到它们</p>

<p>然后真正有意思的是这个delegate事先了 animationDidStart: 和 animationDidStop:finished: 并将信息传给了它自己的delegate</p>

<blockquote><p>这里不太容易理解，加以说明:从上面的头文件可以看出，作为CAAnimation的delegate的私有类UIViewAnimationState中还有个<code>_delegate</code>成员，并且<code>animationDidStart</code>和<code>animationDidStop:finished:</code>也是典型的delegate的实现方法.</p></blockquote>

<p>通过打印这个delegate的delegate,我们可以发现它也是一个私有类：<code>UIViewAnimationBlockDelegate</code>。同样进行<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且进行相应的block.如果我们使用自己的Core Animation代码，并且选阿泽block而不是delegate做回调的话，添加这个是很容易的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface DRAnimationBlockDelegate : NSObject
</span><span class='line'>
</span><span class='line'>@property (copy) void(^start)(void);
</span><span class='line'>@property (copy) void(^stop)(BOOL);
</span><span class='line'>
</span><span class='line'>+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
</span><span class='line'>                                   completion:(void(^)(BOOL finished))completion;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRAnimationBlockDelegate
</span><span class='line'>
</span><span class='line'>+ (instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
</span><span class='line'>                                    completion:(void (^)(BOOL))completion
</span><span class='line'>{
</span><span class='line'>    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
</span><span class='line'>    result.start = beginning;
</span><span class='line'>    result.stop  = completion;
</span><span class='line'>    return result;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animationDidStart:(CAAnimation *)anim
</span><span class='line'>{
</span><span class='line'>    if (self.start) {
</span><span class='line'>        self.start();
</span><span class='line'>    }
</span><span class='line'>    self.start = nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
</span><span class='line'>{
</span><span class='line'>    if (self.stop) {
</span><span class='line'>        self.stop(flag);
</span><span class='line'>    }
</span><span class='line'>    self.stop = nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>虽然是我的个人喜好，但是我觉得像这样的基于block的回调风格可能会比实现一个delegate回调更适合你的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
</span><span class='line'>    NSLog(@"beginning to fade in");
</span><span class='line'>} completion:^(BOOL finished) {
</span><span class='line'>    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h2>自定义基于block的动画APIS</h2>

<p>一旦你知道了<code>actionForKey:</code>的原理之后，UIview就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于block的动画Apis。我所设计的动画将通过block中用一个很激进的时间曲线来做动画，以吸引用户对该View的注意，之后做一个缓慢的动画回到原始状态。你可以把它看做一种类似pop的行为。与一般使用<code>UIViewAnimationOptionAutoreverse</code>的动画block不同，因为动画设计和概念上的需要，我自己实现了将model值改变回原始值的过程。自定义的动画API的使用方法就像这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[UIView DR_popAnimationWithDuration:0.7
</span><span class='line'>                             animations:^{
</span><span class='line'>                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
</span><span class='line'>                                }];</span></code></pre></td></tr></table></div></figure>


<p>当我们完成后，效果是这样样子的(对四个不同的View为位置，尺寸，颜色和旋转进行动画)</p>

<p><img src="http://7xsn4e.com1.z0.glb.clouddn.com/2014-05-01-view-layer-synergy-custom-block-animations.gif" alt="1" /></p>

<p>要开始实现它，我们首先要做的是当一个layer属性变化时获取delegate的回调，因为我们无法实现预测layer要改变什么，所以我选择在一个UIView的category中的swizzle<code>actionForLayer:forKey:</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UIView (DR_CustomBlockAnimations)
</span><span class='line'>
</span><span class='line'>+ (void)load
</span><span class='line'>{        
</span><span class='line'>    SEL originalSelector = @selector(actionForLayer:forKey:);
</span><span class='line'>    SEL extendedSelector = @selector(DR_actionForLayer:forKey:);
</span><span class='line'>
</span><span class='line'>    Method originalMethod = class_getInstanceMethod(self, originalSelector);
</span><span class='line'>    Method extendedMethod = class_getInstanceMethod(self, extendedSelector);
</span><span class='line'>
</span><span class='line'>    NSAssert(originalMethod, @"original method should exist");
</span><span class='line'>    NSAssert(extendedMethod, @"exchanged method should exist");
</span><span class='line'>
</span><span class='line'>    if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
</span><span class='line'>        class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
</span><span class='line'>    } else {
</span><span class='line'>        method_exchangeImplementations(originalMethod, extendedMethod);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了保证我们不破坏其他依赖于<code>actionForLayer:forKey:</code>的回调代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子莱索一个简单的Bool其实就够了，但是如果我们之后要写更多内容的话，上下文的话要灵活得多了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void *DR_currentAnimationContext = NULL;
</span><span class='line'>static void *DR_popAnimationContext     = &DR_popAnimationContext;
</span><span class='line'>
</span><span class='line'>- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
</span><span class='line'>{
</span><span class='line'>    if (DR_currentAnimationContext == DR_popAnimationContext) {
</span><span class='line'>        // 这里写我们自定义的代码...
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 调用原始方法
</span><span class='line'>    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在我们的实现中，我们要确保在执行动画block之前设置动画的上下文，并且在执行后恢复上下文：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
</span><span class='line'>                          animations:(void (^)(void))animations
</span><span class='line'> {
</span><span class='line'>     DR_currentAnimationContext = DR_popAnimationContext;
</span><span class='line'>     // 执行动画 (它将触发交换后的 delegate 方法)
</span><span class='line'>     animations();
</span><span class='line'>     /* 一会儿再添加 */
</span><span class='line'>     DR_currentAnimationContext = NULL;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>如果我们想要做的不过是添加一个从旧值向新值过渡的动画的话，我们可以直接在delegate的回调中来做。然后因为我们想要更精确的控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓</p>

<p>有意思的是，ios添加的一个基于block的动画API也遇到了同样了问题，使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每一个关键帧，在属性变化时，view返回nil,但是却存储下需要的状态。这样就能在所有关键帧block执行后创建一个<code>CAKeyframeAnimationz</code>对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么layer被更改了，什么key path的值被改变了，以及原来的值是什么:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> @interface DRSavedPopAnimationState : NSObject
</span><span class='line'>
</span><span class='line'> @property (strong) CALayer  *layer;
</span><span class='line'> @property (copy)   NSString *keyPath;
</span><span class='line'> @property (strong) id        oldValue;
</span><span class='line'>
</span><span class='line'> + (instancetype)savedStateWithLayer:(CALayer *)layer
</span><span class='line'>                             keyPath:(NSString *)keyPath;
</span><span class='line'>
</span><span class='line'> @end
</span><span class='line'>
</span><span class='line'> @implementation DRSavedPopAnimationState
</span><span class='line'>
</span><span class='line'> + (instancetype)savedStateWithLayer:(CALayer *)layer
</span><span class='line'>                             keyPath:(NSString *)keyPath
</span><span class='line'> {
</span><span class='line'>     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
</span><span class='line'>     savedState.layer    = layer;
</span><span class='line'>     savedState.keyPath  = keyPath;
</span><span class='line'>     savedState.oldValue = [layer valueForKeyPath:keyPath];
</span><span class='line'>     return savedState;
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'> @end</span></code></pre></td></tr></table></div></figure>


<p>接下来，在我们的交换后的delegate回调中，我们简单地讲被变更的属性的状态存入一个静态可变数组中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> if (DR_currentAnimationContext == DR_popAnimationContext) {
</span><span class='line'>       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
</span><span class='line'>                                                                                 keyPath:event]];
</span><span class='line'>
</span><span class='line'>       // 没有隐式的动画 (稍后添加)
</span><span class='line'>       return (id&lt;CAAction&gt;)[NSNull null];
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>在动画block执行完毕后，所有的属性都被变更了，它们的状态也被保存了，现在，创建关键帧动画:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
</span><span class='line'>                          animations:(void (^)(void))animations
</span><span class='line'> {
</span><span class='line'>     DR_currentAnimationContext = DR_popAnimationContext;
</span><span class='line'>
</span><span class='line'>     // 执行动画 (它将触发交换后的 delegate 方法)
</span><span class='line'>     animations();
</span><span class='line'>
</span><span class='line'>     [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class='line'>         DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
</span><span class='line'>         CALayer *layer    = savedState.layer;
</span><span class='line'>         NSString *keyPath = savedState.keyPath;
</span><span class='line'>         id oldValue       = savedState.oldValue;
</span><span class='line'>         id newValue       = [layer valueForKeyPath:keyPath];
</span><span class='line'>
</span><span class='line'>         CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];
</span><span class='line'>
</span><span class='line'>         CGFloat easing = 0.2;
</span><span class='line'>         CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
</span><span class='line'>         CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];
</span><span class='line'>
</span><span class='line'>         anim.duration = duration;
</span><span class='line'>         anim.keyTimes = @[@0, @(0.35), @1];
</span><span class='line'>         anim.values = @[oldValue, newValue, oldValue];
</span><span class='line'>         anim.timingFunctions = @[easeIn, easeOut];
</span><span class='line'>
</span><span class='line'>         // 不带动画地返回原来的值
</span><span class='line'>         [CATransaction begin];
</span><span class='line'>         [CATransaction setDisableActions:YES];
</span><span class='line'>         [layer setValue:oldValue forKeyPath:keyPath];
</span><span class='line'>         [CATransaction commit];
</span><span class='line'>
</span><span class='line'>         // 添加 "pop" 动画
</span><span class='line'>         [layer addAnimation:anim forKey:keyPath];
</span><span class='line'>
</span><span class='line'>     }];
</span><span class='line'>
</span><span class='line'>     // 扫除工作 (移除所有存储的状态)
</span><span class='line'>     [[self DR_savedPopAnimationStates] removeAllObjects];
</span><span class='line'>
</span><span class='line'>     DR_currentAnimationContext = nil;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>注意老的model值被设置到了layer上，所以在当动画结束和移除后，model的值和persentation的值是相符合的。</p>

<p>创建像这样的你自己的API不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂UIview block动画的APis,特别是你已经在core Animation的舒适区的时候，这非常有助于你的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 ViewController 容器转场]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang/"/>
    <updated>2016-07-19T10:02:19+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang</id>
    <content type="html"><![CDATA[<p>我们在本文讨论navigation controller中的两个view controller之间的转场动画，但是这些做法在 tab bar controller或者任何你自己定义的view controller容器中也是通用的&hellip;</p>

<!--more-->


<p>尽管从技术角度来讲，使用ios7的api,你可以对自定义容器中的view controller做自定义转场，但是这不是能直接使用的，实现这种效果非常不容易。</p>

<p>请注意我正在讨论的自定义视图控制器容器都是UIViewController的直接子类，而不是UITabBarController或者UINavigationController的子类。</p>

<p>对于你自定义的继承与UIViewController的容器子类，并没有现成可用的Api允许一个任意的动画控制器将一个子视图控制器自动转场到另外一个，不管是可交互的转场还是不可交互式的转场。我甚至都觉得苹果根据不想支持这种方式。苹果支持下面的几种转场方式:</p>

<ul>
<li>Navigation Controller推入和推出页面</li>
<li>Tab bar Controller选择的改变</li>
<li>Model页面的展示和消失</li>
</ul>


<p>在本文中，我将向你展示如何自定义视图控制器容器，并且使其支持第三方的动画控制器</p>

<h2>预热准备</h2>

<p>看到这里，你可能对上文我们说到一些问题犯嘀咕，让我来告诉你答案吧:</p>

<p>为什么我们不直接继承UINavigationController或UITabBarController.并且使用它们提供的功能呢？</p>

<p>有些时候这是你不想要的。可能你想要一个非常特殊的外观或者行为，和这些类能够提供给你的差别非常大，因此你必须使用一些黑客式的手段去达到你想要的结果，同时还要担心系统框架的版本更新后这些黑客式的手段是否还仍然有效。或者，你就是想完全控制你的视图控制器容器，避免不得不支持一些特定的功能。</p>

<p>好吧，那么为什么不实用
<code>transitionFromViewController:toViewController:duration:options:animations:completion :</code>去实现呢?</p>

<p>这又是一个好问题，你可能想用这种方式去实现，但是或许你对代码的整洁性比较在意，想把这种转场相关的代码封装在内部。那么为什么不实用一个即存的，被良好验证的设计模式呢？这种设计模式可以非常方便的支持第三方的转场动画。</p>

<h2>介绍相关的API</h2>

<p>在我们开始写代码之前，让我们先花一分钟时间来简单看一下我们需要的组件吧。</p>

<p>ios7自定义视图控制器转场的API基本上都是以协议的方式提供的，这也使其可以非常灵活的使用，因为你可以很简单地讲它们插入到你的类中。最主要的五个组件如下：</p>

<ol>
<li>动画控制器(Animation Controllers)遵从UIViewControllerAnimatedTransitioning协议，并且负责实际执行动画。</li>
<li>交互控制器(Interaction Controllers)通过遵从UIViewControllerInteractiveTransitioning协议来控制可交互式的转场</li>
<li>转场代理(Transitioning Delegates)根据不同的转场类型方便的提供需要的动画控制器和交互控制器</li>
<li>转场上下文(Transitioning Contexts)定义了转场时需要的元数据，比如在转场过程中所参与的视图控制和视图相关属性。转场上下文对象遵从UIViewControllerContextTransitoning协议，并且这是由系统负责生成和提供的。</li>
<li>转场协调器(Transition Coordinators)可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoorinator协议。</li>
</ol>


<p>正如你从其他的阅读材料中得知的那样，转场有不可交互式和可交互式两种方式。在本文红，我们将集中精力于不可交互的转场。这种转场是最简单的转场，也是我们学习的一个好的开始。这意味着我们需要处理上面提到的动画控制器(animation controllers)，转场代理(transioning delegates)和转场上下文(transionging contexts)</p>

<h2>示例工程</h2>

<p>通过三个阶段，我们将要实现一个简单自定义的视图控制器容器，它可以对子视图控制器提供自定义的转场动画的支持。</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions">这里</a>找到这三个阶段的Xcode工程的源代码</p>

<h3>阶段1:基础</h3>

<p>我们应用中的核心类是<code>ContainerViewController</code>，它持有一个UIViewController实例的数组，每个实例是一个普通的ChildViewController。容器视图控制器设置了一个带有可点击图标，并代表每个子视图控制器的私有的子视图:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-1.gif" alt="1" /></p>

<p>我们通过点击图标在不同的子视图控制器之间切换，在这一阶段，子视图控制器之间切换时是没有转场动画的。</p>

<p>你可以在这里查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-1">阶段1</a>的源代码</p>

<h3>阶段2：转场动画</h3>

<p>当我们添加转场动画时，我们想要使用一个遵从 UIViewControllerAnimatedTransitioning协议的动画控制器(animation controllers)。这个协议声明了三个方法，前面的2歌方法是必须实现的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
</span><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
</span><span class='line'>- (void)animationEnded:(BOOL)transitionCompleted;  </span></code></pre></td></tr></table></div></figure>


<p>通过这些方法，我们可以获得我们所需的所有东西。当我们的视图控制器容器准备执行动画时，我们可以从动画冬至器中获取动画的持续时间，并让其去执行真正的动画。当动画执行完毕后，如果动画控制器实现了可选的 <code>animationEnded:</code>方法，我们可以调用动画控制器中的 animationEnded: 方法。</p>

<p>但是，首先我们必须把一件事情搞清楚。正如你在上面的方法签名中看到的那样，上面两个必须实现的方法需要一个转场上下文参数，这是一个遵从 <code>UIViewControllerContextTransionging</code>协议的对象。通常情况下，当我们使用系统内建的类时，系统框架为我们创建了转场上下文对象，并把它传递给动画控制器。但是在我们这种情况下，我们需要自定义转场动画，所以我们需要承担系统框架的责任，自己去创建这个转场上下文对象。</p>

<p>这就是大量使用协议的方便之处。我们可以不用必须复写一个私有类，而复写私有类这种方法是明显不可行的。我们可以定义自己的类，并使其遵从文档中相应的协议就可以了。</p>

<p>尽管在UIViewControllerContextTransioning协议中声明了很多方法，而且他们都是必须要实现的，但是我们现在可以暂时忽略它们中的一些方法，因为我们现在仅仅支持不可交互的转场。</p>

<p>同UIKit类似，我们定义了私有类<code>NSObject &lt;UIViewControllerContextTransitioning&gt;</code>.在我们的特定例子汇总，这个私有类是 PrivateTransitionContext,它的初始化方法如下实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController goingRight:(BOOL)goingRight {
</span><span class='line'>    NSAssert ([fromViewController isViewLoaded] && fromViewController.view.superview, @"The fromViewController view must reside in the container view upon initializing the transition context.");
</span><span class='line'>
</span><span class='line'>    if ((self = [super init])) {
</span><span class='line'>        self.presentationStyle = UIModalPresentationCustom;
</span><span class='line'>        self.containerView = fromViewController.view.superview;
</span><span class='line'>        self.viewControllers = @{
</span><span class='line'>            UITransitionContextFromViewControllerKey:fromViewController,
</span><span class='line'>            UITransitionContextToViewControllerKey:toViewController,
</span><span class='line'>        };
</span><span class='line'>
</span><span class='line'>        CGFloat travelDistance = (goingRight ? -self.containerView.bounds.size.width : self.containerView.bounds.size.width);
</span><span class='line'>        self.disappearingFromRect = self.appearingToRect = self.containerView.bounds;
</span><span class='line'>        self.disappearingToRect = CGRectOffset (self.containerView.bounds, travelDistance, 0);
</span><span class='line'>        self.appearingFromRect = CGRectOffset (self.containerView.bounds, -travelDistance, 0);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们把视图的出现和消失时的状态记录了下来，比如初始状态和最终状态的frame.</p>

<p>请注意一点，我们的初始化方法需要我们提供我们是在向右切换还是向左切换。在我们的<code>ContainerViewController</code>中，按钮是一个接一个水平排列的，转场上下文通过设置每个frame来记录它们之间的位置关系。动画控制器或者说 animator,在生成动画时可以使用这些frame.</p>

<p>我们也可以通过另外的方式去获取这些信息，但是那样的话，就会使animator和<code>ContainerViewController</code>及其视图控制器耦合在一起了，这是不好的，我们并不想这样。animator应该只关心它自己以及传递给它的上下文，因为这样，在理想的情况下，animator可以在不同的上下文中得到复用。</p>

<p>在下一步实现我们自己的动画控制器时，我们应该时刻记住这一点，现在让我们来实现转场上下文吧。</p>

<p>使用Animator类的实例来做转场动画的核心代码如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[fromViewController willMoveToParentViewController:nil];
</span><span class='line'>[self addChildViewController:toViewController];
</span><span class='line'>
</span><span class='line'>Animator *animator = [[Animator alloc] init];
</span><span class='line'>
</span><span class='line'>NSUInteger fromIndex = [self.viewControllers indexOfObject:fromViewController];
</span><span class='line'>NSUInteger toIndex = [self.viewControllers indexOfObject:toViewController];
</span><span class='line'>PrivateTransitionContext *transitionContext = [[PrivateTransitionContext alloc] initWithFromViewController:fromViewController toViewController:toViewController goingRight:toIndex &gt; fromIndex];
</span><span class='line'>
</span><span class='line'>transitionContext.animated = YES;
</span><span class='line'>transitionContext.interactive = NO;
</span><span class='line'>transitionContext.completionBlock = ^(BOOL didComplete) {
</span><span class='line'>    [fromViewController.view removeFromSuperview];
</span><span class='line'>    [fromViewController removeFromParentViewController];
</span><span class='line'>    [toViewController didMoveToParentViewController:self];
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>[animator animateTransition:transitionContext];</span></code></pre></td></tr></table></div></figure>


<p>这其中的大部分是对视图控制器容器的操作，计算出我们是在向左切换还是向右切换，做动画的部分基本上只有3行代码：</p>

<ol>
<li>创建Animator</li>
<li>创建转场上下文</li>
<li>触发动画执行</li>
</ol>


<p>有了上面的代码，转场效果看起来如下图所示:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-2.gif" alt="2" /></p>

<p>非常酷，我们甚至没有写一行动画相关的代码</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-2">阶段2</a>标签下看到这部分代码的变化。</p>

<h3>阶段3：封装</h3>

<p>我想我们最后要做的一件事情是封装 ContainerViewController,使其能够:</p>

<ol>
<li>提供默认的转场动画</li>
<li>提供替换默认动画控制器的代理</li>
</ol>


<p>这意味着我们需要对Animator类的依赖移除，同时需要创建一个代理协议。</p>

<p>我们如下定义这个协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol ContainerViewControllerDelegate &lt;NSObject&gt;
</span><span class='line'>@optional
</span><span class='line'>- (void)containerViewController:(ContainerViewController *)containerViewController didSelectViewController:(UIViewController *)viewController;
</span><span class='line'>- (id &lt;UIViewControllerAnimatedTransitioning&gt;)containerViewController:(ContainerViewController *)containerViewController animationControllerForTransitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><code>containerViewController:didSelectViewController:</code>方法使<code>ContainerViewController</code>可以很容易的集成与功能齐全的应用中。</p>

<p><code>containerViewController:animationControllerForTransitionFromViewController:toViewController:</code>方法挺有趣的，当然，你可以把它和下面的UIKit中的视图控制器容器的代理协议做对比:</p>

<ul>
<li>tabBarController:animationControllerForTransitionFromViewController:toViewController: (UITabBarControllerDelegate)</li>
<li>navigationController:animationControllerForOperation:fromViewController:toViewController: (UINavigationControllerDelegate)</li>
</ul>


<p>所有的这些方法都返回一个id<UIViewControllerAnimatedTransitioning>对象。与之前一直使用一个 Animator 对象不同，我们现在可以从我们的代理那里获取一个动画控制器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id&lt;UIViewControllerAnimatedTransitioning&gt;animator = nil;
</span><span class='line'>if ([self.delegate respondsToSelector:@selector (containerViewController:animationControllerForTransitionFromViewController:toViewController:)]) {
</span><span class='line'>    animator = [self.delegate containerViewController:self animationControllerForTransitionFromViewController:fromViewController toViewController:toViewController];
</span><span class='line'>}
</span><span class='line'>animator = (animator ?: [[PrivateAnimatedTransition alloc] init]);</span></code></pre></td></tr></table></div></figure>


<p>如果我们有代理并且它返回一个Animator,那么我们就使用这个 animator.否则，我们使用内部私有类PrivateAnimatedTransition 创建一个默认的 animator.接下来我们将实现 <code>PrivateAnimatedTransition</code>类。</p>

<p>尽管默认的动画和 Animator有一些不同，但是代码看起来惊人的相似，下面是完整的代码实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation PrivateAnimatedTransition
</span><span class='line'>
</span><span class='line'>static CGFloat const kChildViewPadding = 16;
</span><span class='line'>static CGFloat const kDamping = 0.75f;
</span><span class='line'>static CGFloat const kInitialSpringVelocity = 0.5f;
</span><span class='line'>
</span><span class='line'>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
</span><span class='line'>
</span><span class='line'>    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>
</span><span class='line'>    // When sliding the views horizontally, in and out, figure out whether we are going left or right.
</span><span class='line'>    BOOL goingRight = ([transitionContext initialFrameForViewController:toViewController].origin.x &lt; [transitionContext finalFrameForViewController:toViewController].origin.x);
</span><span class='line'>
</span><span class='line'>    CGFloat travelDistance = [transitionContext containerView].bounds.size.width + kChildViewPadding;
</span><span class='line'>    CGAffineTransform travel = CGAffineTransformMakeTranslation (goingRight ? travelDistance : -travelDistance, 0);
</span><span class='line'>
</span><span class='line'>    [[transitionContext containerView] addSubview:toViewController.view];
</span><span class='line'>    toViewController.view.alpha = 0;
</span><span class='line'>    toViewController.view.transform = CGAffineTransformInvert (travel);
</span><span class='line'>
</span><span class='line'>    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:kDamping initialSpringVelocity:kInitialSpringVelocity options:0x00 animations:^{
</span><span class='line'>        fromViewController.view.transform = travel;
</span><span class='line'>        fromViewController.view.alpha = 0;
</span><span class='line'>        toViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        toViewController.view.alpha = 1;
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
</span><span class='line'>    }];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>需要注意一点的是，上面的代码没有通过设置视图的frame 来反应它们之间的位置关系，但是代码仍然可以正常工作，只不过转场总是在同一个方向上。因此，这个类也可以被其它的代码库使用。</p>

<p>转场动画看起来像是这样:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-3.gif" alt="2" /></p>

<p>在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-3">阶段3</a>代码中，app delegate中设置代理的部分被注释掉了，这样就可以看到默认的动画效果了，你可以将其设置回再使用 Animator类，你可能想查看同<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-2...stage-3">阶段2相比所有的修改</a></p>

<p>我们现在有一个自包含的提供了默认转场动画的 ContainerViewController 类，这个默认的转场动画可以被开发者定义的ios7自定义动画控制器(UIViewControllerAnimatedTransitioning)的对象代替，甚至都可以不用关心我们的源代码就可以方便的替换。</p>

<h2>结论</h2>

<p>在本文中，我们通过使用ios7提供的自定义视图控制器转场的新特性，使得我们自定义的视图控制器容器成为了UIkit的一等公民。</p>

<p>这意味着你可以把自定义的非交互的转场动画应用到自定义的视图控制器容器中。你可以看到我们把7个话题之前使用的转场类直接拿过来使用，而且没有做任何修改。</p>

<p>如果你想让自己的容器视图控制器作为一个类库或者框架，或者仅仅想使你的代码得到更好的复用，这将是非常完美的。</p>

<p>我们现在仅仅支持非交互式的转场，下一步就是对交互式的转场也提供支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的第三方类库&amp;学习资料]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/18/chang-yong-de-di-san-fang-lei-ku-and-xue-xi-zi-liao/"/>
    <updated>2016-07-18T17:57:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/18/chang-yong-de-di-san-fang-lei-ku-and-xue-xi-zi-liao</id>
    <content type="html"><![CDATA[<hr />

<p>自己总结的iOS、mac开源项目及库，持续更新。。。。
github排名 <a href="https://github.com/trending">https://github.com/trending</a>,github搜索：<a href="https://github.com/search">https://github.com/search</a></p>

<!--more-->


<h3>目录</h3>

<ul>
<li><a href="#UI">UI</a>

<ul>
<li><a href="#%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">下拉刷新</a></li>
<li><a href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C">模糊效果</a></li>
<li><a href="#AutoLayout">AutoLayout</a></li>
<li><a href="#%E5%AF%8C%E6%96%87%E6%9C%AC">富文本</a></li>
<li><a href="#%E5%9B%BE%E8%A1%A8">图表</a></li>
<li><a href="#%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%B8%8ETabbar">表相关与Tabbar</a></li>
<li><a href="#%E9%9A%90%E8%97%8F%E4%B8%8E%E6%98%BE%E7%A4%BA">隐藏与显示</a></li>
<li><a href="#HUD%E4%B8%8EToast">HUD与Toast</a></li>
<li><a href="#%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a></li>
<li><a href="#%E5%85%B6%E4%BB%96UI">其他UI</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E7%94%BB">动画</a>

<ul>
<li><a href="#%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E%E6%89%8B%E5%8A%BF">侧滑与右滑返回手势</a></li>
<li><a href="#gif%E5%8A%A8%E7%94%BB">gif动画</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8A%A8%E7%94%BB">其他动画</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">网络相关</a>

<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">网络连接</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E8%8E%B7%E5%8F%96">图像获取</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9">网络聊天</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95">网络测试</a></li>
<li><a href="#%E7%BD%91%E9%A1%B5%E6%A1%86%E6%9E%B6">网页框架</a></li>
<li><a href="#WebView%E4%B8%8EWKWebView">WebView与WKWebView</a></li>
</ul>
</li>
<li><a href="#Model">Model</a></li>
<li><a href="#%E9%80%9A%E8%AE%AF%E5%BD%95">通讯录</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%BA%93">其他库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86">缓存处理</a></li>
<li><a href="#PDF">PDF</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E6%B5%8F%E8%A7%88%E5%8F%8A%E5%A4%84%E7%90%86">图像浏览及处理</a></li>
<li><a href="#%E6%91%84%E5%83%8F%E7%85%A7%E7%9B%B8%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86">摄像照相视频音频处理</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6">响应式框架</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3">消息相关</a>

<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">消息推送客户端</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">消息推送服务器端</a></li>
<li><a href="#%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3">通知相关</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9C%AC%E6%96%B0API%E7%9A%84Demo">版本新API的Demo</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E4%B8%8E%E5%AF%86%E7%A0%81">代码安全与密码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%8F%8A%E8%B0%83%E8%AF%95">测试及调试</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0">动态更新</a></li>
<li><a href="#AppleWatch">AppleWatch</a></li>
<li><a href="#VPN">VPN</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE">完整项目</a></li>
<li><a href="#%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0">好的文章</a></li>
<li><a href="#Xcode%E6%8F%92%E4%BB%B6">Xcode插件</a></li>
<li><a href="#%E7%BE%8E%E5%B7%A5%E8%B5%84%E6%BA%90">美工资源</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90">开发资源</a>

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99">开发资料</a></li>
<li><a href="#swift">swift</a></li>
<li><a href="#%E4%BB%96%E4%BA%BA%E5%BC%80%E6%BA%90%E6%80%BB%E7%BB%93">他人开源总结</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8">开发博客列表</a></li>
</ul>
</li>
</ul>


<hr />

<h3>具体内容 =============================</h3>

<hr />

<h4>UI</h4>

<h5>下拉刷新</h5>

<ul>
<li><a href="https://github.com/enormego/EGOTableViewPullRefresh">EGOTableViewPullRefresh</a> - 最早的下拉刷新控件。</li>
<li><a href="https://github.com/samvermette/SVPullToRefresh">SVPullToRefresh</a> - 下拉刷新控件。</li>
<li><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> - 仅需一行代码就可以为UITableView或者CollectionView加上下拉刷新或者上拉刷新功能。可以自定义上下拉刷新的文字说明。具体使用看“使用方法”。 （国人写）</li>
<li><a href="https://github.com/xhzengAIB/XHRefreshControl">XHRefreshControl</a> - XHRefreshControl 是一款高扩展性、低耦合度的下拉刷新、上提加载更多的组件。（国人写）</li>
<li><a href="https://github.com/coolbeet/CBStoreHouseRefreshControl">CBStoreHouseRefreshControl</a> - 一个效果很酷炫的下拉刷新控件。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - 一个下拉刷新打砖块的开源 Swift 库，能让用户在等待下拉刷新的时候边玩撞球游戏边等待。</li>
<li><a href="https://github.com/KittenYang/KYJellyPullToRefresh">KYJellyPullToRefresh</a> - 实现弹性物理效果的下拉刷新，神奇的贝塞尔曲线，配合UIDynamic写的一个拟物的下拉刷新动画。</li>
<li><a href="https://github.com/michaelhenry/MHYahooParallaxView">MHYahooParallaxView</a> - 类似于Yahoo Weather和News Digest首屏的视差滚动。</li>
<li><a href="https://github.com/gsdios/SDRefreshView">SDRefreshView</a> - 简单易用的上拉和下拉刷新（多版本细节适配）。</li>
<li><a href="https://github.com/MakeZL/ZLSwiftRefresh">ZLSwiftRefresh</a> - swift下拉刷新/上拉加载更多，支持自定义动画，集成简单，兼容UITableView/CollectionView/ScrollView/WebView。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/andreamazz/GearRefreshControl">GearRefreshControl</a> -  swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/jcavar/refresher">refresher</a> -  swift，上拉和下拉刷新。</li>
<li><a href="http://d.cocoachina.com/code/detail/237753">可展开/收缩的下拉菜单&ndash;SvpplyTable</a> -  一个可展开可收缩的下拉菜单，类似Svpply app。</li>
<li><a href="https://github.com/Sephiroth87/ODRefreshControl">ODRefreshControl</a> - 原iOS6上的橡皮糖刷新样式，很有意思。现在也很多大的 App 在用，比如虾米音乐和 QQ 客户端。</li>
<li><a href="https://github.com/Yalantis/PullToMakeSoup">PullToMakeSoup</a> - PullToMakeSoup, 自定义下拉刷新的动画效果：煮饭, Yalantis新作！</li>
<li><a href="https://github.com/cyndibaby905/TwitterCover">TwitterCover</a> -  Twitter iOS客户端的下拉封面模糊效果。</li>
<li><a href="https://github.com/MartinRGB/Replace-iOS">Replace-iOS</a> - Replace-iOS 让人眼前一亮的下拉刷新（iOS）。</li>
<li><a href="https://github.com/fruitcoder/ReplaceAnimation">ReplaceAnimation.swift</a> - 基于 @ZeeYoung欧阳哲 同学的创意下拉刷新动画实现。值得称赞还有额外增加了“取消及滚动”效果支持。</li>
<li><a href="https://github.com/KittenYang/Animations">Animations</a> - 封装了一下，使用的时候只要两行代码。一些动画的飞机稿，都是一些单独分离出来的用于测试的子动画，现在统一归类一下。</li>
<li><a href="https://github.com/entotsu/PullToBounce">PullToBounce</a> - 下拉刷新的动画 for UIScrollView。</li>
<li><a href="https://github.com/li6185377/WaterDropRefresh">WaterDropRefresh</a> - 仿Path 水滴的下拉刷新效果 还有视差滚动。</li>
<li><a href="https://github.com/EnjoySR/ESRefreshControl">ESRefreshControl</a> - 仿新浪微博、百度外卖、网易新闻下拉刷新样式Demo（仅供参考）。</li>
<li><a href="https://github.com/alienjun/AJWaveRefresh">WaveRefresh</a> - 下拉刷新水波纹动画。</li>
<li><a href="https://github.com/gontovnik/DGElasticPullToRefresh">DGElasticPullToRefresh</a> - 是一款带有弹性效果的 iOS 下拉刷新组件。</li>
<li><a href="https://github.com/wuwen1030/CALayerAnimationDemoh">CALayerAnimationDemoh</a> - 双向注水动画下拉刷新组件,使用CALayer的mask实现。</li>
<li><a href="https://github.com/zangqilong198812/BanTangAnimation">BanTangAnimation</a> - 半糖下拉刷新的原理。简单来说是利用CGGlyph，字符图形转换成cgpath，然后绘制strokeEnd动画。把timeoffset和scrolloffset结合就行了。</li>
<li><a href="https://github.com/cbangchen/PullToReflesh-Swift">PullToReflesh-Swift</a> - 一款炫酷的下拉刷新封装库（Mobile page refresh concept inspired by Google and for something like a news app）。<a href="http://cbang.info/2016/03/04/CBReflesh%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析 </a></li>
<li><a href="https://github.com/eggswift/pull-to-refresh">pull-to-refresh.swift</a> - 是一款非常易于开发者使用的下拉刷新和加载更多组件。通过一个 UIScrollView 的扩展，可以轻松为 UIScrollView 的所有子类添加下拉刷新功能。</li>
</ul>


<h5>模糊效果</h5>

<ul>
<li><a href="https://github.com/nicklockwood/FXBlurView">FXBlurView</a> - 是一个UIView子类，支持iOS5.0以上版本，支持静态、动态模糊效果，继承与UIView的模糊特效。</li>
<li><a href="https://github.com/onevcat/VVBlurPresentation">VVBlurPresentation</a> -很简单易用的在原来viewconntroller基础上做模糊，然后present新的viewcontroller的。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;对话框 里面已经收藏。</li>
<li><a href="https://github.com/szk-atmosphere/SABlurImageView">SABlurImageView</a> - 支持渐变动画效果的图像模糊化类库。P.S. 与前几天推存类库 SAHistoryNavigationViewController 是同一位作者。</li>
<li><a href="https://github.com/FlexMonkey/Blurable">Blurable.swift</a> - swift模糊组件。</li>
</ul>


<h5>AutoLayout</h5>

<ul>
<li><a href="https://github.com/SnapKit/Masonry">Masonry</a> - Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性（ <a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/">使用介绍1</a>  <a href="http://ios.jobbole.com/81483/">使用介绍2</a>），<a href="http://www.cocoachina.com/ios/20150702/12217.html">iOS自适应前段库-Masonry的使用</a>），<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。<a href="https://github.com/lcddhr/DDMasonryTest">使用DEMO</a> 视图居中显示、子视图含边距、视图等距离摆放、计算ScrollView的contentsize。</li>
<li><a href="https://github.com/ClassyKit/Classy">Classy</a> - Classy是一个能与UIKit无缝结合stylesheet(样式)系统。它借鉴CSS的思想，但引入新的语法和命名规则，<a href="http://classy.as/getting-started/">Classy官网</a>，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/olegam/ClassyLiveLayout">ClassyLiveLayout</a> - ClassyLiveLayout通过结合Classy stylesheets与Masonry一起使用，能够在运行的模拟器中微调Auto Layout约束实时显示效果的工具，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/SnapKit/SnapKit">Snap</a> - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X。</li>
<li><a href="https://github.com/SnapKit/SnapKit">SnapKit</a> - 就是“snap”， &ndash;swift 喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。</li>
<li><a href="https://github.com/PureLayout/PureLayout">PureLayout</a> - PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。</li>
<li><a href="https://github.com/smileyborg/UIView-AutoLayout">UIView-AutoLayout</a> -
Deprecated in favor of PureLayout, which includes OS X support:<a href="https://github.com/smileyborg/PureLayout%E3%80%82">https://github.com/smileyborg/PureLayout%E3%80%82</a></li>
<li><a href="https://github.com/robb/Cartography">Cartography</a> - Cartography 是用来声明 Swift 中的 Auto Layout，无需输入任何 stringly 就可设置自己 Auto Layout 的约束声明。</li>
<li><a href="https://github.com/philcn/Auto-Layout-Showcase">Auto-Layout-Showcase</a> - swift,AutoLayout 进阶 Demo，宽高比约束、比例约束、不等约束、视差约束、低优先级约束等高级用法，无需写码即可进行复杂页面布局，Demo 还动态模拟了各屏幕下的效果。来自百度知道 iOS 小组的内部分享。</li>
<li><a href="https://github.com/forkingdog/UIView-FDCollapsibleConstraints">UIView-FDCollapsibleConstraints</a> - 一个AutoLayout辅助工具，最优雅的方式解决自动布局中子View的动态显示和隐藏的问题。第二个Demo模拟了一个经典的FlowLayout，任意一个元素隐藏时，底下的元素需要自动“顶”上来，配合这个扩展，你可以在IB里连一连，选一选，不用一行代码就能搞定。</li>
<li><a href="https://github.com/luodezhao/Autolayout_Demo">Autolayout_Demo</a> - 在项目中用自动布局实现的类似抽屉效果。</li>
<li><a href="http://code.cocoachina.com/detail/320405/">当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute</a> - 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute，从而不用大量的代码工作。</li>
<li><a href="https://github.com/gsdios/SDAutoLayout">SDAutoLayout</a> - AutoLayout 一行代码搞定自动布局！支持Cell、Label和Tableview高度自适应，致力于做最简单易用的AutoLayout库。</li>
<li><a href="https://github.com/mamaral/Neon">Neon.swift</a> - 功能强大的 UI 布局神器。</li>
<li><a href="https://github.com/nakiostudio/EasyPeasy">EasyPeasy.swift</a> - 编程方式自动布局框架库。</li>
</ul>


<h5>富文本</h5>

<ul>
<li><a href="https://github.com/topfunky/hpple">TFHpple </a> - TFHpple
解析html的轻量级框架</li>
<li><a href="https://github.com/honcheng/RTLabel">RTLabel</a> - RTLabel 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。32位，很久没有更新了。</li>
<li><a href="https://github.com/bingxue314159/RTLabel">RTLabel</a> - 富文本，RTLabel支持64位。</li>
<li><a href="https://github.com/12207480/TYAttributedLabel">TYAttributedLabel</a> -  TYAttributedLabel。 简单易用的属性文本控件(无需了解CoreText)，支持富文本，图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示。</li>
<li><a href="https://github.com/TinyQ/TQRichTextView">TQRichTextView</a> - 用于做富文本视图控件显示，用于即时通讯的表情显示，以及资源评论的富文本显示。</li>
<li><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel">TTTAttributedLabel</a> - 一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。<a href="http://blog.csdn.net/prevention/article/details/9998575">用TTTAttributedLabel创建变化丰富的UILabel</a> - 网易新闻iOS版使用。</li>
<li><a href="https://github.com/molon/MLEmojiLabel">MLEmojiLabel</a> - 自动识别网址、号码、邮箱、@、#话题#和表情的label。可以自定义自己的表情识别正则，和对应的表情图像。(默认是识别微信的表情符号)，继承自TTTAttributedLabel，所以可以像label一样使用。label的特性全都有，使用起来更友好更方便。</li>
<li><a href="https://github.com/nicklockwood/FXLabel">FXLabel</a> - FXLabel是一个功能强大使用简单的类库，通过提供一个子类改进了标准的UILabel组件，为字体增加了阴影、内阴影和渐变色等，可以被用在任何标准的UILabel中。FXLabel还提供了更多控件，可以对字体行距、字体间距等进行调整。</li>
<li><a href="https://github.com/TigerWf/WFReader">WFReader</a> - 一款简单的coretext阅读器，支持文本选择、高亮以及字体大小选择等。</li>
<li><a href="https://github.com/nigelgrange/WPAttributedMarkup">WPAttributedMarkup</a> - WPAttributedMarkup is a simple utility category that can be used to easily create an attributed string from text with markup tags and a style dictionary。</li>
<li><a href="https://github.com/MoZhouqi/KMPlaceholderTextView">KMPlaceholderTextView</a> - 可显示多行 placeholder 的 textView，可以在IB里面设置 &ndash; swift。</li>
<li><a href="https://github.com/mrchenhao/HHFlashSwitch">HHFlashSwitch</a> - 一个另类的UISwitch，选择后，背景水波扩散变色效果。</li>
<li><a href="https://github.com/zhangyu9050/UUColorSwitch">UUColorSwitch</a> - Switch 开关动画效果,当打开开关时，Switch可实现平滑渲染过渡到父视图的效果。</li>
<li><a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">UITextViewDIYEmojiExample</a> - <a href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/">UITextView编辑时插入自定义表情-简单的图文混编</a>。</li>
<li><a href="https://github.com/facebook/Shimmer">Shimmer</a> - BlingBling闪光效果，酷炫的Label的效果，可以用于加载等待提示。</li>
<li><a href="https://github.com/nnhubbard/ZSSRichTextEditor">ZSSRichTextEditor</a> - 适用于iOS的富文本WYSIWYG编辑器，支持语法高亮和源码查看。ZSSRichTextEditor包含所有WYSIWYG标准的编辑器工具。</li>
<li><a href="https://github.com/cjwirth/RichEditorView">RichEditorView</a> - swift，一套可定制富文本编辑器组件及示例。功能完整、代码简练、实现逻辑巧妙（编辑器核心与 WebView 结合，采用 HTML5 contentEditable 编辑模式，执行JS 配套命令 execCommand 实现富文本编辑功能）。</li>
<li><a href="https://github.com/Cocoanetics/DTCoreText">DTCoreText</a> - 可以解析HTML与CSS最终用CoreText绘制出来，通常用于在一些需要显示富文本的场景下代替低性能的UIWebView。<a href="http://blog.cnbang.net/tech/2630/">DTCoreText源码解析</a>。</li>
<li><a href="https://github.com/cloverstudio/CSGrowingTextView">CSGrowingTextView</a> - 用作即时通讯文本框和评论文本框使用，可以显示多行输入。</li>
<li><a href="https://github.com/indragiek/MarkdownTextView">MarkdownTextView</a> - 显示Markdown的TextView。</li>
<li><a href="https://github.com/SimonFairbairn/SwiftyMarkdown">SwiftyMarkdown.swift</a> - 用swift写的markdown解析库。</li>
<li><a href="https://github.com/macteo/Marklight">Marklight.swift</a> - Markdown 语法高亮显示编辑库（Swift）。</li>
<li><a href="http://d.cocoachina.com/code/detail/300299">高仿微信限定行数文字内容</a> - 采用Autolayout高仿微信纯文字限定行数。</li>
<li><a href="https://github.com/lingochamp/FuriganaTextView">FuriganaTextView</a> - 实现复杂的日文韩文排版。</li>
<li><a href="https://github.com/gmertk/ParkedTextField">ParkedTextField</a> - 带固定文本的输入组件。</li>
<li><a href="https://github.com/lexrus/LTMorphingLabel">LTMorphingLabel</a> - swift 能够实现文字变形动画效果的Label，用Swift写的一个能够实现文字变形动画效果的Label，很炫。</li>
<li><a href="https://github.com/zyprosoft/GJCFCoreText">GJCFCoreText</a> - 图文混排。</li>
<li><a href="https://github.com/KyoheiG3/AttributedLabel">AttributedLabel</a> - 显示性能数量级 UILabel 的 AttributedLabel。无畏无惧、挑战权威。</li>
<li><a href="https://github.com/liufan321/FFLabel">FFLabel</a> - 自动检测 URLs, @username, #topic# 等关链词（提供响应扩展）。实用的标签文本小组件。</li>
<li><a href="https://github.com/raulriera/TextFieldEffects">TextFieldEffects</a> - 标准的UITextField有些枯燥么？来认识一下TextFieldEffects吧！废话不多说，只要看几个例子,是啊，都是些简单的dropin控制器。甚至可以在storyboard中使用IBDesignables。</li>
<li><a href="https://github.com/filipstefansson/AutocompleteField">AutocompleteField</a> - 可应用于 iOS 应用中文字输入框自动补全的场景, 兼容到 iOS 8。</li>
<li><a href="https://github.com/yannickl/Splitflap">Splitflap.swift</a> - 可用于快速给 iOS 应用创建文字翻转的动画效果。</li>
<li><a href="https://github.com/wordpress-mobile/WordPress-Editor-iOS">WordPress-Editor-iOS</a> - 一个文本编辑器 简书和新浪博客都在用。</li>
<li><a href="https://github.com/ibireme/YYText">YYText</a> - 功能强大的 iOS 富文本框架。</li>
<li><a href="http://code.cocoachina.com/view/129099">placeholder_TextView</a> - 带有placeholder的TextView：带有提示信息的textview，使用懒加载的思想，支持扩展、自定义，类似许多APP内部的意见反馈页面 。</li>
<li><a href="https://github.com/FahimF/FloatLabelFields">FloatLabelFields.swift</a> - FloatLabelFields.swift浮动标签输入效果类。</li>
<li><a href="https://github.com/xiangwangfeng/M80AttributedLabel">M80AttributedLabel</a> - M80AttributedLabel实现文字与表情的混排。一般使用气泡作为背景。</li>
<li><a href="https://github.com/yatinsns/HPGrowingTextView">HPGrowingTextView</a> - HPGrowingTextView聊天输入文字，可以根据输入文字的多少自动改变输入框的高度。</li>
<li><a href="https://github.com/mortenjust/cleartext-mac">cleartext-mac.swift</a> - 提供一千个常用单词的编辑器。</li>
<li><a href="https://github.com/kciter/GlitchLabel">GlitchLabel.swift</a> - 可定制“黑（故障）文字标签”类库，熟称晃瞎你的眼文字标签。</li>
</ul>


<h5>图表</h5>

<ul>
<li><a href="https://github.com/kevinzhow/PNChart">PNChart</a> - 国内开源作者，动态的图表。</li>
<li><a href="https://github.com/zemirco/swift-linechart">swift-linechart</a> - 功能完整、实用的折线图组件。使用方便，参数配置简单。是不可多得的优质组件&ndash;swift。</li>
<li><a href="https://github.com/danielgindi/Charts">ios-charts</a> - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。</li>
<li><a href="https://github.com/xhacker/TEAChart">TEAChart</a> - xhacker/TEAChart 一个简洁的 iOS 图表库，支持柱状图、饼图以及日历等。</li>
<li><a href="https://github.com/yasuoza/YOChartImageKit">YOChartImageKit</a> - 支持在watchOS上绘制图表，看它最近更新挺勤快的，可以关注一下。</li>
<li><a href="https://github.com/kevinzhow/RealtimeGradientText">RealtimeGradientText</a> - Fun With CALayer Mask 刚好今天开源了一个有趣的项目 RealtimeGradientText，所以也好聊一下 CALayer 的 Mask，<a href="http://blog.zhowkev.in/2015/07/06/fun-with-mask/">说明</a>。</li>
<li><a href="https://github.com/xyfeng/XYPieChart">XYPieChart</a> -XYPieChart:饼状图,  饼图,  数据统计,  数据可视化,可以在图形上标注数据。效果十分漂亮，而且没有用到一张图片。</li>
<li><a href="https://github.com/Zirkfied/ZFChart">ZFChart</a> - 模仿PNChart写的一个图表库，用法简单，暂时有柱状图，线状图，饼图三种类型，后续可能会更新新的类型。</li>
<li><a href="https://github.com/philackm/Scrollable-GraphView">Scrollable-GraphView.swift</a> - 灵动感十足的自适应、可定制滚动曲（折）线图表库。</li>
<li><a href="https://github.com/danielgindi/Charts">charts</a>国外人写有各种效果的图表，非常强大</li>
<li><a href="https://github.com/xyfeng/XYPieChart">xypieChart</a>带有动画效果的饼状图</li>
<li><a href="https://github.com/zhiyu/chartee">chartee</a>股票K线图示例</li>
<li><a href="https://github.com/dangfm/stockChart">stockChart</a>股票K线图示例</li>
<li><a href="https://github.com/NunchakusHuang/HYStockChart">HYStockChart</a>股票图</li>
<li><a href="https://github.com/chenyk0317/YKLineChartView">YKLineChartView</a>iOS 股票的K线图 分时图 Kline <a href="http://chenyk.com">http://chenyk.com</a></li>
<li><a href="https://github.com/xiaofei86/LPLineChartView">LPLineChartView</a>不错的图形报表</li>
<li><a href="https://github.com/chenxiaoyu3/BBStockChartView">BBStockCharView</a>A full customizable iOS stock chart view, K-Line, volume graph, with gesture supported.</li>
<li><a href="https://github.com/i-schuetz/SwiftCharts">SwiftCharts</a> Easy to use and highly customizable charts library for iOS</li>
<li><a href="https://github.com/q946666800/DrawLineChart">drawLineChart</a>绘制简单折线图</li>
<li><a href="https://github.com/zhmch0329/MCChartView">MCChartview</a>MCChartView is some different charts used in my project! Bar, Line, Pie, Radar, Circle and Coverage chart views.</li>
<li><a href="Line%20and%20Bar%20of%20Chart,%20you%20can%20mark%20the%20range%20of%20value%20you%20want,%20and%20show%20the%20max%20or%20min%20values%20in%20linechart%20with%20the%20form%20style">UUChartView</a></li>
<li><a href="https://github.com/zhuayi/ZCharts">Zcharts</a>ZCharts 是一个图表库， 能够很简单便捷的为应用程序添加有交互性的图表</li>
</ul>


<h5>表相关与Tabbar</h5>

<ul>
<li><a href="https://github.com/onevcat/SWTableViewCell">SWTableViewCell</a> - 国内开源作者，带很多手势的表单元格。</li>
<li><a href="https://github.com/alikaragoz/MCSwipeTableViewCell">MCSwipeTableViewCell</a> - 带很多手势的表单元格。</li>
<li><a href="https://github.com/1000Memories/TMQuiltView">TMQuiltView</a> - 瀑布流。</li>
<li><a href="https://github.com/codingZero/XRWaterfallLayout">XRWaterfallLayout</a> - 超简单的瀑布流实现,<a href="http://www.cocoachina.com/ios/20160407/15872.html">实现说明</a>。</li>
<li><a href="https://github.com/lengmolehongyan/WaterfallFlowDemo">WaterfallFlowDemo</a> - 一个简单的UICollectionView瀑布流布局演示demo。</li>
<li><a href="https://github.com/xmartlabs/XLForm">XLForm</a> - 很多表格类的table,写法更高冷一点，推荐使用。</li>
<li><a href="https://github.com/xmartlabs/Eureka">Eureka.swift</a> - Eureka 是 XLForm 的 Swift 的移植版本, 一个可以帮助开发者们快速构建 iOS 各种复杂表单的库, 具有较高的可扩展性, 方便自定制样式。</li>
<li><a href="https://github.com/romaonthego/RETableViewManager">RETableViewManager</a> - 可以十分方便地生成各种样式、各种功能的TableView。只要开发者能想到的列表效果或者功能，都可以利用这份代码迅速编写出来。比如，之前要实现一个填写各种资料的列表，可能需要很多代码，现在只需要几行代码就可以实现。</li>
<li><a href="https://github.com/TomThorpe/UIScrollSlidingPages">UIScrollSlidingPages</a> - 允许添加多视图控件，并且可以横向滚动。有点类似于Groupon app。</li>
<li><a href="https://github.com/izyhuang/HBHorizontalTableView">HBHorizontalTableView</a> - swift，TableView 横向滚动小示例（仿照 AppStore 应用展示）。</li>
<li><a href="https://github.com/mcelayir/HorizontalScrollCell">HorizontalScrollCell</a> - HorizontalScrollCell是一款使用方便的水平方向可滚动的单元格，适用于UICollectionView中实现水片方向滚动视图。 。</li>
<li><a href="https://github.com/shiyuan17/syTableView">SYJiugonggeTableView</a> - tableView封装的九宫格。</li>
<li><a href="https://github.com/ZhipingYang/UUChatTableView">UUChatTableView</a> - UUChatTableView 气泡聊天界面，支持文本、图片以及音频的气泡聊天界面。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/acani/Chats">Chats</a> - 聊天 UI 示例程序。此项目应该只为演示或学习之用，没有服务器 &ndash; swift。</li>
<li><a href="https://github.com/layerhq/Atlas-iOS">Atlas-iOS</a> - 快速在iOS里集成聊天功能，类似开源版本的环信。Layer家开源了一套聊天app界面的解决方案.看起来很赞，很多蛮复杂的东西直接都帮封好了。不得不说现在做app开发真是很简单，大部分时间搭积木就可以了。<a href="https://atlas.layer.com/">官方网站</a>。</li>
<li><a href="https://github.com/badoo/Chatto">Chatto.swift</a> - Chatto.swift:轻量级聊天应用框架及示例。文字及图片可扩展输入栏，汽泡效果等聊天核心特性，分页及自动布局完善。</li>
<li><a href="https://github.com/agdsdl/DLSlideView">DLSlideView</a> - DLSlideView对常见的顶部Tab页点击、滑动分页做了封装。它使用基于ViewController的container特性（而不是scrollview）来管理各个子页面，以支持无限分页，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/pozi119/VOVCManager">VOVCManager</a> - 页面管理器:1.跳转指定页面,只需要知道viewController的Class名,如果有storyboard,则需要指定storyboard名；2.无需添加基类；3.支持URLScheme跳转指定页面。</li>
<li><a href="https://github.com/Moblox/MBXPageViewController">MBXPageViewController</a> - 简洁快速的页面切换&ndash;MBXPageViewController，带有按钮控件的UIPageController，非常整洁、简单以及快速。该项目通过三种形式展示页面之间的切换，比如导航栏上的多个tab切换、页面左右两端箭头指示切换，以及使用分段控件。</li>
<li><a href="https://github.com/ming1016/PagerTab">PagerTab</a> - UIScrollView实现滑动转换页面，类似网易云音乐iOS版的页面滑动切换效果。</li>
<li><a href="https://github.com/guilhermearaujo/GUITabPagerViewController">GUITabPagerViewController</a> - 多个tab滑动切换。</li>
<li><a href="https://github.com/pozi119/VOMetroLayoutDemo">VOMetroLayoutDemo</a> - Metro风格的UICollectionView, 目前只支持横向布局,仅在iPad上应用。</li>
<li><a href="https://github.com/KittenYang/KYCellAnimation">KYCellAnimation</a> - 给UITableViewCell增加进入的动画。</li>
<li><a href="https://github.com/knutigro/COBezierTableView">COBezierTableView</a> - swift，通过编辑 Bezier 曲线四点位置设置 TableView 内 Cell 及对应按扭位置。实验效果很赞。</li>
<li><a href="https://github.com/robbdimitrov/RDVTabBarController">RDVTabBarController</a> - 一个TabBar组件，可以方便设置底部菜单的文字图片，点击效果，小红点提示等。</li>
<li><a href="https://github.com/DeveloperLx/LxTabBarController">LxTabBarController</a> - 改变了原生tabbar切换tab时的生硬效果，并加入滑动切换手势（有和界面上的其它手势发生冲突的风险，可根据具体项目予以关闭），<a href="https://github.com/DeveloperLx/LxTabBarController-swift">swift版本</a>。</li>
<li><a href="https://github.com/leichunfeng/WXTabBarController">WXTabBarController</a> - 在系统 UITabBarController 的基础上完美实现了安卓版微信 TabBar 的滑动切换功能，单手操作 iPhone 6 Plus 切换 TabBar 一直是一件很痛苦的事情，而滑动切换是一种不错的解决方案，支持屏幕旋转。</li>
<li><a href="https://github.com/KittenYang/GooeyTabbar">GooeyTabbar</a> - 皮筋式弹性缩放工具栏示例及演示。</li>
<li><a href="https://github.com/ChenYilong/CYLTabBarController">CYLTabBarController</a> - 低耦合集成TabBarController,最低只需传两个数组即可完成主流App框架搭建。</li>
<li><a href="http://d.cocoachina.com/code/detail/298409">横向展示文本内容的自定义cell</a> - 可以横向展示文本内容的自定义cell，根据文本无限滚动。</li>
<li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView-FDTemplateLayoutCell</a> - UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。</li>
<li><a href="https://github.com/jozsef-vesza/ExpandingStackCells">ExpandingStackCells</a> - 采用 UIStackView 实现表格单元格扩展内容显示示例及解决方案。</li>
<li><a href="https://github.com/forkingdog/FDStackView">FDStackView</a> - 可以将 UIStackView 的最低支持版本拉低到 iOS6，无需配置，没有代码侵染，扔到工程里后直接用系统 UIStackView 的 API 即可，同时兼容 Storyboard。</li>
<li><a href="https://github.com/nghialv/Sapporo">Sapporo</a> - swift 单元格模型驱动的集合视图管理器组件。又一个超实用的“轮子”。</li>
<li><a href="https://github.com/WeeTom/MDIHorizontalSectionTableViewController">MDIHorizontalSectionTableViewController</a> - 根据产品需求开源了一个交互项目，可以理解为横向Section的TableView，section和cell同时支持拖拽，后续安卓版本也会开源出来。</li>
<li><a href="https://github.com/JazysYu/JZNavigationExtension">JZNavigationExtension</a> - 多功能导航控制器，可以透明返回栏。</li>
<li><a href="https://github.com/itjhDev/NavTopImage">NavTopImage.swift</a> - NavigationController动态缩放titleView。</li>
<li><a href="https://github.com/okla/QuickRearrangeTableView">QuickRearrangeTableView</a> - 基于 UITableView 的快速重排功能扩展子类。通过长按选定单元格然后滚动移动到指定位置。</li>
<li><a href="https://github.com/nshintio/uicollectionview-reordering">uicollectionview-reordering</a> - UICollectionViews的拖拽(拖动、移动)效果,<a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/">实例教程</a>.</li>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a> - DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理。</li>
<li><a href="https://github.com/LvJianfeng/LLNoDataView">LLNoDataView</a> - 超简单的空数据提示通用View支持UIScrollView、UITableView、UICollectionView、UIWebView。</li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell">MGSwipeTableCell</a> - 另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。</li>
<li><a href="https://github.com/HebeTienCoder/XLPlainFlowLayout">XLPlainFlowLayout</a> - 可以让UICollectionView的header也支持悬停效果，类似于tableView的Plain风格。</li>
<li><a href="https://github.com/wangmchn/WMPageController">WMPageController</a> - 一个方便的 pageContrller 的控件，里面还包括滚动视图。</li>
<li><a href="https://github.com/steipete/PSTCollectionView">PSTCollectionView</a> - PSTCollectionView。</li>
<li><a href="https://github.com/lianleven/LLRiseTabBar-iOS">LLRiseTabBar-iOS</a> - 直接使用系统的特性实现的tabbar，比较简单。</li>
<li><a href="https://github.com/MartinRGB/MTMaterialDelete">MTMaterialDelete</a> - 非常有趣的Material Design动画，动画删除表里面的单元格。</li>
<li><a href="https://github.com/Ramotion/paper-onboarding">paper-onboarding.swift</a> - 漂亮的 material design 风格页面滑块。示例完整，易用。</li>
<li><a href="https://github.com/CosmicMind/Material">Material.swift</a> - 基于 Material Design 动画和图像框架库 （作者 Daniel Dahan）。</li>
<li><a href="https://github.com/gmertk/BusyNavigationBar">BusyNavigationBar</a> - 进度条式NavigationBar导航条。</li>
<li><a href="https://github.com/cemolcay/ReorderableGridView-Swift">ReorderableGridView-Swift</a> - 拖拽排序卡片。</li>
<li><a href="https://github.com/LiGoEX/LGSettingView">LGSettingView</a> - LGSettingView仅需三句代码即可快速集成设置界面，免去每次开发新应用都要重新布置设置界面的烦恼。</li>
<li><a href="http://code.cocoachina.com/view/129212">微博cell自动布局</a> - 使用autoLayout对微博的cell进行自动布局，自适应cell的高度。</li>
<li><a href="https://github.com/TyroneWing/TreeTableView">TreeTableView</a> - ZYTreeTableView：TreeView 模仿好友列表的实现方式。</li>
<li><a href="https://github.com/squarezw/ZWSlideViewController">ZWSlideViewController</a> - ZWSlideViewController多页滑动视图控制器（类似新闻类门户APP）,可以用最简单的继承方法使用，也可以不用继承，只用菜单或主视图页面，可实现丰富的定制，可以使用在多种不同形态的APP下，还可以将其做为多页或多图的滑动介绍。</li>
<li><a href="https://github.com/liuzhiyi1992/ZYThumbnailTableView">ZYThumbnailTableView.swift</a> - 可展开型预览TableView，开放接口，完全自由定制。<a href="http://zyden.vicp.cc/zythumbnailtableview/">实现教程</a></li>
<li><a href="https://github.com/wazrx/XWCatergoryView">XWCatergoryView</a> - 一个轻量级的顶部分类视图控件，只需要通过简单的设置，你就可以快速集成该控件， 控件目前暂时有底部横条移动，椭圆背景移动，文字缩放，文字颜色变化，和文字颜色渐变五种效果，五种效果可以叠加使用也可以单一使用。<a href="http://www.jianshu.com/p/274d19f97564">实现教程</a></li>
<li><a href="http://code.cocoachina.com/view/129675">jingDongFenLei</a> - 简单仿写京东分类中的多级分类页面。</li>
<li><a href="https://github.com/netyouli/WHC_CollectionViewFramework">WHC_CollectionViewFramework.swift</a> - 高仿支付宝可拖拽排序编辑动画效果cell的CollectionView集合视图。</li>
<li><a href="https://github.com/fortmarek/SwipeViewController">SwipeViewController.swift</a> - 一款好用的页面滑动和标签选项卡类库及示例。功能相当于 Objective-C 版 RKSwipeBetweenViewControllers。</li>
<li><a href="https://github.com/cwRichardKim/RKSwipeBetweenViewControllers">RKSwipeBetweenViewControllers</a> - 页面滑动和标签选项卡类库。</li>
<li><a href="http://www.cocoachina.com/ios/20160407/15870.html">FriendSearch</a> - 两种UI的搜索，搜索的算法可以满足中英文互搜，联想搜索等，其中还包含对一组数据自动进行按字母分组等功能。</li>
<li><a href="https://github.com/yixiangboy/YX_UITableView_IN_UITableView">YX_UITableView_IN_UITableView</a> - UITableview嵌套UITableView案例实践（仿淘宝商品详情页实现），<a href="http://blog.csdn.net/yixiangboy/article/details/51009010">项目讲解</a>。</li>
<li><a href="https://github.com/winslowdibona/TabDrawer">TabDrawer.swift</a> - 更适合单手操作的可定制 Tab Bar 组件库。P.S. 自动布局选择了 EasyPeasy。</li>
<li><a href="https://github.com/fdzsergio/SFFocusViewLayout">SFFocusViewLayout.swift</a> - UICollectionViewLayout实现的图片浏览器。</li>
<li><a href="https://github.com/12207480/TYPagerController">TYPagerController</a> - 简单，支持定制，页面控制器,可以滚动内容和标题栏,包含多种style。</li>
<li><a href="https://github.com/eggswift/ESTabBarController">ESTabBarController.swift</a> - 自定义TabBarController组件，继承自UITabBarControlle，可添加动画和自定义样式。<a href="http://www.jianshu.com/p/9e52630e7368">swift 高度自定义TabBarController，支持自定义TabBarItem样式或添加动画</a></li>
</ul>


<h5>隐藏与显示</h5>

<ul>
<li><a href="http://d.cocoachina.com/code/detail/286102">SlideTapBar</a> - 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。</li>
<li><a href="https://github.com/Yalantis/FoldingTabBar.iOS">FoldingTabBar.iOS</a> - 可折叠Tab Bar和Tab Bar Controller。</li>
<li><a href="https://github.com/ltebean/LTNavigationBar">LTNavigationBar</a> - LTNavigationBar为app导航栏添加动态着色效果，可自定义其背景色。Demo包含：1.变换背景色；2.滚动视图，导航栏和状态栏重叠。<a href="http://tech.glowing.com/cn/change-uinavigationbar-backgroundcolor-dynamically/">实现教程</a></li>
<li><a href="https://github.com/MoZhouqi/KMNavigationBarTransition">KMNavigationBarTransition</a> - LTNavigationBar在右滑返回的时候NavigationBar显示都不完美,KMNavigationBarTransition一个用来统一管理导航栏转场以及当 push 或者 pop 的时候使动画效果更加顺滑的通用库，并且同时支持竖屏和横屏。</li>
<li><a href="https://github.com/HelloYeah/HYNavBarHidden">HYNavBarHidden</a> - 导航条滚动透明，超简单好用的监听滚动,导航条渐隐的UI效果实现。</li>
<li><a href="https://github.com/bryankeller/BLKFlexibleHeightBar">BLKFlexibleHeightBar</a> - 固定Header的效果库，一个拥有非常灵活高度的标题栏，可以为使用软件的用户提供更多的阅读和滑动空间，现在已经被众多app所采用。</li>
<li><a href="https://github.com/kukumaluCN/JXT_iOS_Demos">JXT_iOS_Demos</a> - AboutNavigationBar:一些关于navigationBar的非常规的但是较为实用的操作，包括利用毛玻璃、动态透明、动态隐藏，以及头视图的动态缩放，并同时涉及了statusBar的动态设置（换色）。<a href="http://www.jianshu.com/p/b2585c37e14b">教程</a>。</li>
<li><a href="https://github.com/CoderJackyHuang/NavigationBarScaleViewDemo">NavigationBarScaleViewDemo</a> - iOS导航条自由缩放头像效果。<a href="http://www.henishuo.com/nav-photo-scale/">原理剖析</a>。</li>
</ul>


<h5>HUD与Toast</h5>

<ul>
<li><a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> - 最多人用的loading。</li>
<li><a href="https://github.com/LvJianfeng/EBuyCommon">EBuyCommon</a> - 1.基于MBProgressHUD实现得图形加载提示方式，及其它标题方式提醒。2.弹窗。</li>
<li><a href="https://github.com/SVProgressHUD/SVProgressHUD">SVProgressHUD</a> - SVProgressHUD的loading，如果你需要定制化的等待提示器，这个就是了（也许是最好的）。</li>
<li><a href="https://github.com/relatedcode/ProgressHUD">ProgressHUD</a> - ProgressHUD的loading，使用最简单。</li>
<li><a href="https://github.com/mutualmobile/MMProgressHUD">MMProgressHUD</a> - 设置HUD出现和消失的方式（包括上下、左右、淡入淡出、放大缩小等等），设置HUD的内容（可以在HUD中加入帧动画、动态图片等等），设置HUD出现时的底部覆盖层颜色，等等。总而言之，这是一份集大成的HUD代码。慢慢看视频吧，囊括了所有效果。</li>
<li><a href="https://github.com/devSC/WSProgressHUD">WSProgressHUD</a> - 一个小巧精致的HUD,支持添加到自定义View上, 还有更多小细节.。</li>
<li><a href="https://github.com/liuzhiyi1992/PreLoader">PreLoader</a> - 一个很有意思的HUD loading ，通过运动污点和固定污点之间的粘黏动画吸引用户的眼球跟踪，能有效分散等待注意力。<a href="http://www.cocoachina.com/ios/20160427/16029.html">PreLoader的实现讲解</a></li>
<li><a href="https://github.com/scalessec/Toast-Swift">Toast-Swift</a> - 高可定制易用的 Toast 弹出信息或通知用户界面组件类。</li>
</ul>


<h5>对话框</h5>

<ul>
<li><a href="https://github.com/m1entus/WCAlertView">WCAlertView</a> - 自定义的对话框。</li>
<li><a href="https://github.com/wimagguc/ios-custom-alertview">IOS7AlertView</a> - IOS7AlertView的对话框。</li>
<li><a href="https://github.com/mtonio91/AMSmoothAlert">AMSmoothAlert</a> - 动画效果不错，最多star，但不支持arm64。</li>
<li><a href="https://github.com/dinhquan/DQAlertView">DQAlertView</a> - 扁平化的样式不错。</li>
<li><a href="https://github.com/mrchenhao/HHAlertView">HHAlertView</a> - 一个简易的alertview  有三种样式，有成功，失败，和警告三种样式，支持Delegate和block两种回调。</li>
<li><a href="https://github.com/martinjuhasz/MJPopupViewController">MJPopupViewController</a> - 实现弹出视图的各种弹出和消失效果，包括淡入淡出（fade in，fade out），从屏幕上方飞进，下方飞出，从屏幕左方飞进，右方飞出等等效果，弹窗。</li>
<li><a href="https://github.com/adad184/MMPopupView">MMPopupView</a> - 弹出框的基类组件（弹窗）。</li>
<li><a href="https://github.com/fengchuanxiang/Menu">Menu</a> - 项目中可能会用到的常用菜单，以后有时间会继续补充，弹窗。</li>
<li><a href="https://github.com/teodorpatras/EasyTipView">EasyTipView</a> - 弹出提示框类及演示示例。同样地，API 简单、易用。好“轮子”，弹窗。</li>
<li><a href="https://github.com/kolyvan/kxmenu">kxmenu</a> - kxmenu弹出菜单，点击视图上任意位置的按钮，会弹出一个菜单，并且有个小箭头指向点击的按钮，类似气泡视图。弹出的菜单位置会根据按钮的位置来进行调整。</li>
<li><a href="https://github.com/questbeat/QBPopupMenu">QBPopupMenu</a> - QBPopupMenu弹出菜单，实现类似 UIMenuItem 的弹出菜单按钮。点击按钮，会弹出一个菜单，上面可以排列多个按钮。纯代码实现，不需要任何图片。</li>
<li><a href="https://github.com/zhenlintie/STModalDemo">STModalDemo</a> - 弹出视图（通知，提示，选择，窗口）。</li>
<li><a href="https://github.com/TaimurAyaz/TAOverlay">TAOverlay</a> - TAOverlay可通过叠加层展示有用的信息，可自定义文本和背景色，添加阴影和模糊效果，以及更改字体大小或者用自定义图片替换页面上的icon。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;模糊效果 里面已经收藏。</li>
<li><a href="http://code.cocoachina.com/detail/232178">ActionSheetPicker-3.0</a> - 该项目是此前热门项目ActionSheetPicker的新版本，快速复制了iOS 8上的下拉 UIPickerView/ActionSheet功能。</li>
<li><a href="https://github.com/mayuur/MJAlertView">MJAlertView</a> - 3D效果转场效果警示图&ndash;MJAlertView。</li>
<li><a href="https://github.com/morizotter/SwiftyDrop">SwiftyDrop</a> - 轻量、易用的小清新弹出列表及信息提示组件真心不错。</li>
<li><a href="https://github.com/steipete/PSTAlertController">PSTAlertController</a> - 兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，做到高低版本通用。</li>
<li><a href="https://github.com/hryk224/PCLBlurEffectAlert">PCLBlurEffectAlert.swfit</a> - 细节定制较丰富的弹出警报窗口组件。</li>
<li><a href="https://github.com/wxxsw/GSAlert">GSAlert.swfit</a> - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。</li>
<li><a href="https://github.com/codestergit/SweetAlert-iOS">SweetAlert-iOS</a> - SweetAlert-iOS 带动画效果弹窗对话框封装类。</li>
<li><a href="https://github.com/xiekw2010/DXPopover">DXPopover</a> - DXPopover微信右上角的+点击展示列表效果，弹窗菜单。</li>
<li><a href="https://github.com/maxmoo/CCActionSheet">CCActionSheet</a> - CCActionSheet：仿照微信朋友圈自定义actionsheet，一行代码即可使用。</li>
<li><a href="https://github.com/entotsu/TKSwarmAlert">TKSwarmAlert.swift</a> - TKSwarmAlert.swift:模仿 Swarm app 的 Alert 提醒框动画工具。</li>
<li><a href="https://github.com/maltsugar/CustomPopOverView">CustomPopOverView</a> - 自定义弹出视图，内容支持传一组菜单标题，也支持自定义view，或者自定义viewController，支持任意按钮触发，会显示在按钮底部，也支持切换按钮的对齐方式：左对齐、居中、右对齐。</li>
<li><a href="https://github.com/Codeido/PMAlertController">PMAlertController.Swift</a> - 可定制弹窗组件替代官版不可定制的 UIAlertController。</li>
<li><a href="https://github.com/yulingtianxia/TBActionSheet">TBActionSheet.swift</a> - 支持Carthage，可自定义度100%的 ActionSheet，支持微信样式。</li>
</ul>


<h5>其他UI</h5>

<ul>
<li><a href="https://github.com/levey/AwesomeMenu">AwesomeMenu</a> - 最多人用的Path菜单。</li>
<li><a href="https://github.com/Tangdixi/DCPathButton">DCPathButton</a> - Path，4.0的弹出菜单，呼出或者关闭菜单时，多个小图标会分别按照逆时针和顺时针的方向进行滚动。</li>
<li><a href="https://github.com/itouch2/SphereMenu">SphereMenu</a> - 利用UIDynamicAnimator的有趣的菜单，path类似。</li>
<li><a href="https://github.com/KittenYang/KYGooeyMenu">KYGooeyMenu</a> - KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件(卫星菜单、path)。</li>
<li><a href="https://github.com/yoavlt/LiquidFloatingActionButton">LiquidFloatingActionButton</a> - 卫星弹出菜单。</li>
<li><a href="https://github.com/JustinFincher/JZMultiChoicesCircleButton">JZMultiChoicesCircleButton</a> - 三维多选按钮。</li>
<li><a href="https://github.com/lianchengjiang/LCUIKit">LCUIKit</a> - 一个button上面既有icon又有文字。也许左icon右文字，或者上icon下文字。</li>
<li><a href="https://github.com/xhzengAIB/XHTwitterPaggingViewer">TwitterPaggingViewer</a>  - 多个Tableview，左右滑动。</li>
<li><a href="https://github.com/carantes/CircularProgressControl">CircularProgressControl</a> - Circular Progress Control using CAShapeLayer ，环形进度控制条。</li>
<li><a href="https://github.com/kentya6/KYCircularProgress">KYCircularProgress</a> - 简单、实用路径可定进程条。</li>
<li><a href="https://github.com/kaandedeoglu/KDCircularProgress">KDCircularProgress</a> -  KDCircularProgress是使用swift制作的色彩炫丽的进度条，可以加入多种颜色来控制进度条的渐变效果。</li>
<li><a href="https://github.com/cgwangding/TextProgress">TextProgress</a> - 自定义实现数字进度条：1、可以自定义数字（0-100），填充的比例为当前设置的数字，2、可以实现自定义填充颜色，上下部分都可以，3、可以自定义边界的颜色4、实现了水波动画，可以设置打开或关闭。</li>
<li><a href="https://github.com/gsdios/SDProgressView">SDProgressView</a> - 简便美观的进度指示器，此系列共有六种样式的进度指示器。</li>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView">NVActivityIndicatorView</a> -  loading 进度条动画，有20-30多种，是在此<a href="https://github.com/gontovnik/DGActivityIndicatorView">DGActivityIndicatorView</a> 基础上做得修改。</li>
<li><a href="https://github.com/saitjr/STLoopProgressView">LoopProgressDemo</a> - 环形渐变进度条，<a href="http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress/">环形渐变进度条实现</a>。</li>
<li><a href="https://github.com/xmartlabs/XLPagerTabStrip">XLPagerTabStrip</a> - 做的很棒的iOS下的PagerTabStrip。</li>
<li><a href="https://github.com/alskipp/ASProgressPopUpView">ASProgressPopUpView</a> - 弹出的进度条显示进度。</li>
<li><a href="https://github.com/onevcat/RandomColorSwift">RandomColorSwift</a> - 一个自动生成好看的颜色的 Swift 库，RandomColorSwift。</li>
<li><a href="https://github.com/hyperoslo/Hue">Hue.Swift</a> - Hue.Swift：颜色常规功能集于一身的定义、使用 Color 工具类库（含图片取色）。</li>
<li><a href="https://github.com/bestswifter/MySampleCode/tree/master/KtColor">KtColor.swift</a> - 利用 Swift 的语法特性简化创建 UIColor对象的过程。具体文章可以参考博客：<a href="http://www.jianshu.com/p/f2173235cde8">当UIColor遇上 Swift</a>。</li>
<li><a href="https://github.com/ChangweiZhang/HexColorService">HexColorService</a> - 将16进制颜色字符串转成UIColor。</li>
<li><a href="https://github.com/NorthernRealities/Rainbow">Rainbow</a> - 旨在提高代码可读性及易用性的 UIColor 扩展，它使原先有限的预定义颜色（方法）选择，扩展至超过 1200 种。</li>
<li><a href="https://github.com/zhxnlai/UIColor-ChineseTraditionalColors">UIColor-ChineseTraditionalColors</a> - 中国传统颜色引用 UIColor 扩展。“UIColor.桃红()，UIColor.竹青() &hellip;”，共158种。</li>
<li><a href="https://github.com/MakeBetterMe/YPDropMenuViewDemo">YPDropMenuViewDemo.swift</a> - 一款DropMenu,menuView,类似之前美团的下拉菜单，支持swift2.2，因为用到iOS8.的毛玻璃。所以想支持到iOS8.0,支持自定义，支持等宽排列，支持从左向右排列。</li>
<li><a href="http://code.cocoachina.com/detail/284158">类似美团的下拉菜单</a> - 类似美团的下拉菜单，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="http://code4app.com/ios/%E7%B1%BB%E4%BC%BC%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E9%80%89%E9%A1%B9/538606d4933bf06e0a8b496e">类似美团的下拉选项</a> -  类似于美团、大众点评的下拉菜单选项，code4app代码，评论代码有瑕疵。</li>
<li><a href="http://code.cocoachina.com/detail/284267">CRMediaPickerController</a> - 一个简单易用的图片/视频选择器。1.可同时选择照片和视频。 2.挑选范围有Camera、Camera Roll、Photo Library以及最近拍摄的照片和视频。3.可自定义UIImagePickerController属性（Camera Overlay、Camera Device、Camera View Transform以及allowsEditing）。4.支持横屏和竖屏5.原生的iOS UI。，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChoose</a> - MDCSwipeToChoose可简单地添加滑动手势来调用UIView，并使用该行为提供了一个组件以创建类似Tinder app的like或者dislike界面的轻扫。基于轻扫的方向，你可以决定执行什么样的行为，并且你可以自定义文本颜色和图片。该项目适用于教学用的抽认卡、图片查看器以及其他等。</li>
<li><a href="http://d.cocoachina.com/code/detail/285611">iOS Material Design库</a> - 该项目借鉴于谷歌的Material Design guideline，用户可自定义背景色。</li>
<li><a href="https://github.com/fpt-software/Material-Controls-For-iOS">Material-Controls-For-iOS</a> - Material Design风格的各种控件，非常完整全面。</li>
<li><a href="https://github.com/richzertuche/ZMaterialDesignUIButton">ZMaterialDesignUIButton</a> - Swift Material Design UIButton。</li>
<li><a href="https://github.com/pixyzehn/MediumScrollFullScreen">MediumScrollFullScreen</a> - Medium的可扩展滚动页面，上下滚动时，全屏显示内容，并自然消隐上下菜单。由此项目感知，作者是一位很注重细节的开发者，他的另外<a href="https://github.com/pixyzehn">几个菜单类项目</a>也都不错，值得参考，比如：PathMenu, MediumMenu 等。</li>
<li><a href="https://github.com/SatanWoo/WZFlashButton">WZFlashButton</a> - WZFlashButton，点击后button里面出现水波扩散效果。</li>
<li><a href="https://github.com/piemonte/Twinkle">Twinkle</a> - 为字体加上钻石版闪耀的效果。使用Swift编写。</li>
<li><a href="https://github.com/palmin/ios-multi-back-button">ios-multi-back-button</a> - 可替换内置的UInavigationController返回按钮，长按左上角的返回按钮，实现多层级的快速返回。</li>
<li><a href="http://code.cocoachina.com/detail/226543">ASDayPicker</a> - 适用于iOS (iPhone)的日期选择器(时间选择器)，类似于Calendar app的周视图。</li>
<li><a href="http://adad184.com/2014/10/29/2014-10-29-how-to-setup-today-extension-programmatically/">today extension</a> - 用纯代码构建一个Widget(today extension) 。</li>
<li><a href="https://github.com/WenchaoD/FSCalendar">FSCalendar</a> - 日历视图，带有微妙和平滑的滚动效果，可自定义外观&ndash;国人。</li>
<li><a href="https://github.com/Mozharovsky/CVCalendar">CVCalendar</a> - 是一个方便开发者集成自定义日历视图到自己 iOS 应用的项目, 支持 Storyboard 和手动配置, 使用 CocoaPods 进行安装, 提供了丰富的 API 供开发者使用。</li>
<li><a href="https://github.com/EmilYo/HSDatePickerViewController">HSDatePickerViewController</a> - 带有Dropbox Mailbox感觉的时间日期选择器(时间选择器)。启动是背景被模糊化。界面也是主流的扁平化风格。</li>
<li><a href="https://github.com/huzhiqin/HZQDatePickerView">HZQDatePickerView</a> - 自定义时间选择器(日期选择器)，包括开始日期和结束日期两种类型。</li>
<li><a href="https://github.com/CharlinFeng/CFCityPickerVC">CFCityPickerVC</a> - 城市选取控制器。</li>
<li><a href="https://github.com/jonathantribouharet/JTCalendar">JTCalendar</a> - iOS下优美的 Calendar 组件，做 GTD 类 App 必备。</li>
<li><a href="https://github.com/Yalantis/Persei">Persei</a> - 动画隐藏或显示顶部菜单支持库及示例项目。&ndash;swift</li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar">PDTSimpleCalendar</a> - 是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。</li>
<li><a href="https://github.com/MrMage/DateRangePicker">DateRangePicker.swift</a> - 可能是目前最好的 OS X 日期选择器,高扩展性，界面风格看起来很舒服，不过注意，是 OS X 开发专用。</li>
<li><a href="https://github.com/hyperoslo/Form">Form</a> - JSON 驱动的 Form表单系统，复杂的表单填写类 App 极其需要（比如淘宝呢！）。</li>
<li><a href="https://github.com/neoneye/SwiftyFORM">SwiftyFORM</a> - swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件。</li>
<li><a href="https://github.com/icanzilb/SwiftSpinner">SwiftSpinner</a> - SwiftSpinner是使用swift制作的一款精致带感的指示器，并且连带有字体信息显示，模糊背景，半透明，扁平化等IOS8的效果。</li>
<li><a href="https://github.com/Akkyie/AKPickerView-Swift">AKPickerView-Swift</a> - 一款小而美的 3D 效果选择器。</li>
<li><a href="https://github.com/larcus94/ImagePickerSheetController">ImagePickerSheetController</a> - 图片或视频选择器（可多选）组件及其示例项目。</li>
<li><a href="https://github.com/saiwu-bigkoo/iOS-RatingBar">iOS-RatingBar</a> - iOS-RatingBar swift版的评分控件,跟Android的RatingBar一样有两种模式，评分模式和只读模式'支持视图编辑，自定义星星数量，评分等级,另外还能支持非整数星，0.5颗星，0.1颗星,可以开启动画效果。</li>
<li><a href="https://github.com/cwRichardKim/RKNotificationHub">RKNotificationHub</a> - 快速给 UIView 添加上炫酷的通知图标（Badge、红点、提示）。  * <a href="https://github.com/weng1250/WZLBadge">WZLBadge</a> - Badge，支持横竖屏支持iOS5~iOS8允许高度定制化，包括“红点”的背景颜色，文字(字体大小、颜色)，位置等。<a href="http://code.cocoachina.com/detail/316890/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A8%E9%80%81%E5%B0%8F%E7%BA%A2%E7%82%B9/">说明</a>.</li>
<li><a href="https://github.com/andreamazz/BubbleTransition">BubbleTransition</a> - 以气泡膨胀和缩小的动画效果来显示和移除 controller，Uber的就是这种取消操作的方式。</li>
<li><a href="https://github.com/KittenYang/KYFloatingBubble">KYFloatingBubble</a> - 类似iOS7中Game Center浮动气泡的效果。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - DKNightVersion 是一个支持夜间模式切换的框架。</li>
<li><a href="https://github.com/sx1989827/EasyUIControl">EasyUIControl</a> - 一个可以简化界面ui的控件框架。</li>
<li><a href="https://github.com/DeveloperLx/LxGridView">LxGridView-oc</a> <a href="https://github.com/DeveloperLx/LxGridView-swift">LxGridView-swift</a> - 利用UICollectionView模仿iOS系统桌面图标的交互，作用如动图。</li>
<li><a href="https://github.com/ZhongTaoTian/QQBtn">QQBtn</a> - 仿QQ未读消息弹性按钮动画，达到和手机QQ未读信息一样的动画效果，效果基本实现。</li>
<li><a href="https://github.com/gmertk/GMStepper">GMStepper</a> - swift 带动画效果、支持手势滑动操作的步进标签。</li>
<li><a href="https://github.com/tomvanzummeren/TZStackView">TZStackView</a> - OS 9 UIStackView 功能模拟实现于 iOS 7/ iOS 8 内。</li>
<li><a href="https://github.com/yushuyi/LayoutTrait">LayoutTrait</a> - swift 一个小类库。 做iPad 多任务分屏 适配的同学可以看一下。</li>
<li><a href="https://github.com/HAHAKea/HACursor">HACursor</a> - HACursor，是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能。</li>
<li><a href="https://github.com/wuzhentao/ZTPageController">ZTPageController</a> - 模仿网易新闻和其他新闻样式做的一个菜单栏，栏中有各自的控制器，其中有4中展示样式’网易style' ’搜狐style' ’腾讯style1' ’网易style2' 。</li>
<li><a href="https://github.com/nixzhu/Ruler">Ruler</a> - 尺子。</li>
<li><a href="https://github.com/justhum/HUMSlider">HUMSlider</a> - HUMSlider是一款能够自动显示刻度记号的滑竿，滑动到某处，该处的刻度会自动上升，两边还能配置图像。支持代码或storyboard中实现。</li>
<li><a href="https://github.com/zhangli4659507/JDSelectedDemo">JDSelectedDemo</a> - 仿京东筛选菜单实现。</li>
<li><a href="https://github.com/PhamBaTho/BTNavigationDropdownMenu">BTNavigationDropdownMenu</a> -  下拉列表暨导航标题组件。简单、直接、易用 -swift。</li>
<li><a href="https://github.com/luzefeng/3DTouchDemo">3DTouchDemo</a> - 详细介绍了每个参数的含义和3Dtouch的入口，保证包学包会。</li>
<li><a href="https://github.com/RichardLeung/3DTouchSample">3DTouchSample</a> - 3D-Touch的功能分为两个部分：Shortcut和Preview。</li>
<li><a href="https://github.com/DeskConnect/SBShortcutMenuSimulator">SBShortcutMenuSimulator</a> - 教你如何在模拟器上测试 3D Touch 功能!</li>
<li><a href="https://github.com/richzertuche/InceptionTouch">InceptionTouch.swift</a> - 让没有 3D Touch 设备也有类似交互体验的 InceptionTouch 类（基于 UITextView 实现，支持日期，链接，电话号码，地址触摸响应）。</li>
<li><a href="http://code.cocoachina.com/view/128287">仿LOL滚动视图</a> - 仿LOL滚动视图。</li>
<li><a href="http://code.cocoachina.com/view/128281">答题选择切换页</a> - 将scrollview和tableview封装在一起，在初始化的时候简单的将数据带上，就可以一页一页的左右来回滑动。</li>
<li><a href="https://github.com/SergioChan/SCTrelloNavigation">SCTrelloNavigation</a> - 类似trello的导航动效控件实现。</li>
<li><a href="https://github.com/Akateason/XTPaster">XTPaster</a> - 贴纸功能出现在很多图片社交中, 就是图片上面贴图片, 对贴纸而言就是需要控制贴纸的位置,旋转,大小,<a href="http://www.jianshu.com/p/d873d348bbfb">如何使用</a>。</li>
<li><a href="https://github.com/refinemobi/RGCategoryView">RGCategoryView</a> - 仿了个苏宁易购的分类页面。</li>
<li><a href="https://github.com/txaidw/TWControls">TWControls.swift</a> - 简单的开关和按钮控制器,使用闭包来执行由控件触发的操作。</li>
<li><a href="https://github.com/ephread/Instructions">Instructions.swift</a> - 可定制嵌入式操作指引框架及演示。</li>
<li><a href="https://github.com/Lves/LLPieCharts">LLPieCharts</a> - LLPieCharts iOS 绘制饼图，<a href="http://www.lvesli.com/?p=339">教程</a>。</li>
<li><a href="https://github.com/Boris-Em/BEMCheckBox">BEMCheckBox</a> - BEMCheckBox 是一个用于 iOS 应用上构建漂亮, 高度可定制化动画效果的复选框类库, 最低支持到 iOS 7 系统, 有多种不同风格的动画效果可供选择。</li>
<li><a href="https://github.com/kevin0571/STPopup">STPopup</a> - 提供了一个可在 iPhone 和 iPad 上使用的具有 UINavigationController 弹出效果的 STPopupController 类, 并能在 Storyboard 上很好的工。</li>
<li><a href="https://github.com/victorBaro/VBFPopFlatButton">VBFPopFlatButton</a> - 通过几条线段实现的非常Q萌的动画按钮效果。</li>
<li><a href="https://github.com/richzertuche/ZSeatSelector">ZSeatSelector</a> - 电影院位置排座位。</li>
<li><a href="https://github.com/zangqilong198812/CustomSearchBar">CustomSearchBar</a> - 自定义searchbar,类似于instagram的搜索框效果。</li>
<li><a href="https://github.com/LeoNatan/LNPopupController">LNPopupController</a> - AppleMusic式pop up，弹出是页面，可以上下拉动。</li>
<li><a href="https://github.com/gontovnik/DGRunkeeperSwitch/">DGRunkeeperSwitch</a> - 动画segment，节选器。</li>
<li><a href="https://github.com/KittenYang/DynamicMaskSegmentSwitch">DynamicMaskSegmentSwitch</a> - 一个简单有趣的 SegmentedControl 节选器。</li>
<li><a href="https://github.com/sima-11/SMSegmentView">SMSegmentView.swift</a> - 高可定制化，既支持横向，也支持纵向布局的图文 Segment Control 组件，节选器。</li>
<li><a href="https://github.com/yixiangboy/YXFilmSelectView">YXFilmSelectView</a> - 仿造时光网选择电影票的UI而开发的一个自定义View。</li>
<li><a href="http://code.cocoachina.com/view/129152">FJTagCollectionView</a> - 标签（适配宽度）。</li>
<li><a href="https://github.com/yukiasai/Gecco">Gecco.Swift</a> - Gecco.Swift 是一款支持对视图进行局部高亮的 Swift 库, 帮助 iOS 开发者快速创建产品的新手指导界面。</li>
<li><a href="https://github.com/anyunzhong/DFTimelineView">DFTimelineView</a> - DFTimelineView仿微信朋友圈 时间轴。</li>
<li><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit.swift</a> - AsyncDisplayKit.swift是 facebook的提供异步的界面高流畅性切换及更灵敏的响应框架。</li>
<li><a href="https://github.com/andreamazz/SubtleVolume">SubtleVolume.swift</a> - 更隐蔽的系统音量替代指示器。</li>
<li><a href="https://github.com/shaps80/InkKit">InkKit.swift</a> - 该类库帮助开发者绘制简单图形更容易。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBImageCliped">HYBImageCliped</a> - 可给任意继承UIView的控件添加任意多个圆角、可根据颜色生成图片且可带任意个圆角、给UIButton设置不同状态下的图片且可带任意圆角、给UIImageView设置任意图片，支持带圆角或者直接生成圆形。</li>
<li><a href="https://github.com/mchoe/SwiftSVG">SwiftSVG</a> - 支持多种接口（String, NS/UIBezierPath, CAShapeLayer, and NS/UIView）绘制 SVG 类库。</li>
<li><a href="https://github.com/wangshengjia/LeeGo">LeeGo.swift</a> - 带来更 声明式的，可配置的和易复用的UI开发方式，让UI开发变得像玩乐高积木一样简单直观，某种程度上取代ComponentKit。<a href="http://allblue.me/swift/2016/05/26/LeeGo-chinese-version/">用 struct 和 enum 来构建你的整套 UI</a></li>
<li><a href="https://github.com/prolificinteractive/Caishen">Caishen.swift</a> - 简易、实用的付款输入及校验 UI 组件。</li>
<li><a href="https://github.com/Khan/SwiftTweaks">SwiftTweaks</a> - 不用重新编译即可调整 UI 配置（按钮颜色、背景、动画延迟，简单布局等）的解决方案库。实现了发布生产版本前 UI 的简单配置，省却反复调试代码的麻烦。类似 OC 版 Facebook Tweats。</li>
<li><a href="https://github.com/seedco/StackViewController">StackViewController</a> - 方便 iOS 开发者使用 UIStackView 构建表单或其它静态内容视图。</li>
<li><a href="https://github.com/lilei644/LLBootstrapButton">LLBootstrapButton</a> - Bootstrap 3.0扁平化风格按钮，自带图标，一句代码直接调用！</li>
<li><a href="https://github.com/raozhizhen/JMRoundedCorner">JMRoundedCorner</a> - UIView设置不触发离屏渲染的圆角！</li>
<li><a href="https://github.com/raozhizhen/JMRoundedCornerSwift">JMRoundedCornerSwift</a> - swift版本：UIView设置不触发离屏渲染的圆角！</li>
</ul>


<hr />

<h4>动画</h4>

<ul>
<li><a href="http://www.starming.com/index.php?v=index&amp;view=62">Core Animation笔记，基本的使用方法</a> - Core Animation笔记，基本的使用方法：1.基本动画，2.多步动画，3.沿路径的动画，4.时间函数，5.动画组。</li>
<li><a href="https://github.com/sxyx2008/awesome-ios-animation">awesome-ios-animation</a> - <a href="https://github.com/sxyx2008/DevArticles/issues/91">iOS Animation 主流炫酷动画框架(特效)收集整理</a> 收集整理了下iOS平台下比较主流炫酷的几款动画框架。</li>
<li><a href="https://github.com/Animatious/awesome-animation">awesome-animation</a> -  在内的十多位童鞋们一起发起的一起动画开源组正式成立啦~Github组织名称：Animatious，这是我们第一期成员先前开源的一些动效库，我们的第一个合作开源项目正在紧锣密鼓的准备~请大家期待设计和代码的碰撞吧。</li>
</ul>


<h5>侧滑与右滑返回手势</h5>

<ul>
<li><a href="https://github.com/fastred/SloppySwiper">SloppySwiper</a> - iOS系统自带的UINavigationController要7.0才支持，但不过该手势只能从屏幕左侧边缘识别，如果要扩大到整个屏幕范围怎么办？配合一个SloppySwiper无需代码就可以轻松实现。此库支持iOS5.0以上版本（另外：Nav的title滑动不明显，本人写了2个类似的控件），<a href="https://github.com/Tim9Liu9/SloppySwiper-Example">SloppySwiper-demo</a> ：代码方式与storyboard方式。</li>
<li><a href="https://github.com/singro/SCNavigation">SCNavigation</a> - UINavigation可以右滑返回，隐藏UINavigationBar。</li>
<li><a href="https://github.com/YueRuo/UINavigationController-YRBackGesture">UINavigationController-YRBackGesture</a> - 支持右滑返回手势，标题栏不动。</li>
<li><a href="https://github.com/gresrun/GHSidebarNav">GHSidebarNav</a> - 现在比较流行使用侧开(侧滑)菜单设计。试了不少控件，感觉GHSidebarNav最成熟，尤其对纯代码创建的界面兼容性最好。<a href="http://www.cnblogs.com/zyl910/archive/2013/06/14/ios_storyboard_sidemenu.html">在Storyboard中使用GHSidebarNav侧开菜单控件</a>。</li>
<li><a href="https://github.com/aryaxt/iOS-Slide-Menu">iOS-Slide-Menu</a> - 能够类似Facebook和Path那样弹出左右边栏侧滑菜单,还支持手势。多种可以自定义的属性 (非常不错)。</li>
<li><a href="https://github.com/ECSlidingViewController/ECSlidingViewController">ECSlidingViewController</a> - 侧滑菜单。</li>
<li><a href="https://github.com/gotosleep/JASidePanels">JASidePanels</a> - 侧滑菜单,有左右菜单，有pop功能，支持手势侧滑,本人使用中：简单。</li>
<li><a href="https://github.com/Ramotion/animated-tab-bar">animated-tab-bar</a> - 让 Tabbar items能显示萌萌的动画。</li>
<li><a href="http://code.cocoachina.com/detail/284346">tabbar图标动画</a> - tabbar上图标的动画实现，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/Yalantis/Side-Menu.iOS/tree/master/SideMenu">SideMenu</a> - swift实现，一款带动画效果可定制 Slide Menu，可以学习其动画实现思路。P.S. 对于Hamburger式菜单，虽然很常用，不过，苹果并不鼓励使用，甚至有开发小组对其弊病用自家上线应用前后数据对比进行了抨击。</li>
<li><a href="https://github.com/romaonthego/RESideMenu">RESideMenu</a> - 侧开菜单，qq类似。</li>
<li><a href="https://github.com/Jiahai/JHMenuTableViewDemo">JHMenuTableViewDemo</a> - 仿网易邮箱列表侧滑菜单。</li>
<li><a href="https://github.com/xudafeng/SlideMenuView">SlideMenuView</a> - 炫酷侧滑菜单布局框架，<a href="Android%20%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E8%87%B4%E5%AE%9E%E7%8E%B0%E8%AF%B7%E8%A7%81%EF%BC%9Ahttps://github.com/xudafeng/SlidingMenu">Android版本的一致实现</a>。</li>
<li><a href="https://github.com/shinept/QQConfiguration">QQConfiguration</a> - swift，QQ-iPhone端框架，左侧菜单栏拖动手势。</li>
<li><a href="https://github.com/KyleGoddard/KGFloatingDrawer">KGFloatingDrawer</a> - 侧滑菜单，qq类似，KyleGoddard/KGFloatingDrawer：一款适合于大屏手机或平板的浮动抽屉式导航界面组件。效果很赞- 侧开菜单，qq类似（与RESideMenu类似）。</li>
<li><a href="https://github.com/cocoatoucher/AIFlatSwitch">AIFlatSwitch</a> - 一款带平滑过渡动画的 Switch 组件类，类相同风格的 Menu/Back<a href="https://github.com/fastred/HamburgerButton">HamburgerButton</a>,类似相同风格的 Menu/Close<a href="https://github.com/robb/hamburger-button">hamburger-button</a>.</li>
<li><a href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a> - 在应用中采用链式写出酷炫的动画效果, 使代码更加清晰易读，利用block实现的链式编程。</li>
<li><a href="https://github.com/WXGBridgeQ/WXGSlideMenuDemo">WXGSlideMenuDemo</a> - 个简单实现侧拉（侧滑）菜单的小demo，供初学者共同学习、练习使用。</li>
<li><a href="https://github.com/pkluz/PKRevealController">PKRevealController</a> - PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷），这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。</li>
<li><a href="https://github.com/GabrielAlva/SwiftPages">SwiftPages</a> - 高可定制类似 Instagram 视图滑动切换功能类库。API 简单、易用。</li>
<li><a href="https://github.com/michaelhenry/FlipBoardNavigationController">FlipBoardNavigationController</a> - FlipBoardNavigationController。</li>
<li><a href="https://github.com/mutualmobile/MMDrawerController">MMDrawerController</a> - 最多人用的一个有关侧边“抽屉”导航框架，里面还有很多你意想不到的交互效果，侧滑。</li>
<li><a href="http://code.cocoachina.com/detail/316925/UIWebView%E7%BF%BB%E9%A1%B5%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C%EF%BC%88%E5%8F%98%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%89/">UIWebView翻页返回效果</a> - UIWebView翻页返回效果（变通方法）。</li>
<li><a href="https://github.com/lilei644/LLSlideMenu">LLSlideMenu</a> - 一个弹性侧滑菜单,弹性动画原理借鉴该项目中阻尼函数实现。</li>
<li><a href="https://github.com/yannickl/FlowingMenu">FlowingMenu.swift</a> - 菜单如此出场方式（橡皮筋弹跳式动画）好玩又有趣。</li>
</ul>


<h5>gif动画</h5>

<ul>
<li><a href="https://github.com/yfme/UIImageView-PlayGIF">UIImageView-PlayGIF</a> - UIImageView-PlayGIF。</li>
<li><a href="https://github.com/liyong03/YLGIFImage">YLGIFImage</a> - YLGIFImage。</li>
<li><a href="https://github.com/liyong03/YLGIFImage-Swift">YLGIFImage-Swift</a> - YLGIFImage-Swift。</li>
<li><a href="https://github.com/kaishin/gifu">gifu.Swift</a> - gifu.Swift高性能GIF显示类库。</li>
<li><a href="https://github.com/mortenjust/droptogif">droptogif</a> -  droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。</li>
<li><a href="https://github.com/wangjwchn/JWAnimatedImage">JWAnimatedImage.swift</a> - JWAnimatedImage.swift集中了目前主流的 GIF 显示库(如 FLAnimatedImage,Gifu 等)的优点，进行重构，代码短小精悍。而且使用了新的 frame 提取算法。</li>
<li><a href="https://github.com/kirualex/SwiftyGif">SwiftyGif</a> - 高性能 Gif 播放引擎。</li>
<li><a href="https://github.com/producthunt/PHImageKit">PHImageKit.swift</a> - 出自 Product Hunter 开发小组的带下载、缓存的 GIF 播放组件库。使用简单又方便。</li>
</ul>


<h5>其他动画</h5>

<ul>
<li><a href="https://github.com/schneiderandre/popping">popping</a> - popping是一个POP 使用实例工程</li>
<li><a href="https://github.com/xhzengAIB/PopMenu">PopMenu</a> - 用POP动画引擎写的Sina微博的Menu菜单。</li>
<li><a href="https://github.com/adad184/MMTweenAnimation">MMTweenAnimation</a> - facebook POP的自定义动画扩展(基于POPCustomAnimation) 提供10种函数式动画。</li>
<li><a href="https://github.com/zangqilong198812/ZQLRotateMenu">ZQLRotateMenu</a> - 这是一个旋转视图的选择器。</li>
<li><a href="https://github.com/zangqilong198812/CoolLoadAniamtion">CoolLoadAniamtion</a> - 一个简单但是效果不错的loading动画。</li>
<li><a href="https://github.com/zangqilong198812/SequenRotateAnimation">SequenRotateAnimation</a> - 一个简单的loading次序动画。</li>
<li><a href="https://github.com/yushuyi/SYAppStart">SYAppStart</a> - App启动插画的自定义过度。</li>
<li><a href="https://github.com/victorjiang/UIImage-VJDeviceSpecificMedia/">VJDeviceSpecificMedia</a> - <a href="http://www.imooc.com/wenda/detail/249271">如何根据设备选择不同尺寸的图片</a> 可以通过设置不同尺寸设备的LaunchImage，来使得App适配这些设备，要是在不同不同尺寸设备上使用不同大小的图片，则需要在代码中一一判断，然后加载。</li>
<li><a href="https://github.com/michaelbabiy/RMParallax">RMParallax</a> - RMParallax是一个app启动页引导开源项目，除了细微的翻页视差效果，描述文本的过渡也非常美观（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/Nododo/ADo_GuideView">ADo_GuideView</a> - 转动的用户引导页(模仿网易bobo) 因为没有从app包里抓到@3x的图片,建议在iPhone5模拟器运行,保证效果~ （版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/CharlinFeng/CoreNewFeatureVC">CoreNewFeatureVC</a> - 版本新特性（引导页），1.封装并简化了版本新特性启动视图！2.添加了版本的本地缓存功能，3.集成简单，使用方便，没有耦合度，4.支持block回调（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MachelleZhang/MZGuidePages">MZGuidePages</a> - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/ijoshsmith/Wizardry">Wizardry.swift</a> - 可重用的方法和框架实现向导式用户界面管理。（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/AdamBCo/ABCIntroView">ABCIntroView</a> - ABCIntroView是一个易于使用的入门类，让你到达主屏幕之前介绍你的应用程序（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MengTo/Spring">Spring</a> - Spring是一个Swift编写的开源库，可简化Swift编写的iOS动画。支持shake、pop、morph、squeeze、wobble、swing、flipX、flipY、fall、squeezeLeft、squeezeRight以及squeezeDown等多种动画形式，用 IBDesignable 让使用者可以在 Xcode 中快速设置动画效果。</li>
<li><a href="https://github.com/KittenYang/KYBezierBounceView">KYBezierBounceView</a> - 手势控制贝塞尔曲线，取消手势贝塞尔曲线会有反弹效果。</li>
<li><a href="http://kittenyang.com/cadisplaylinkanduibezierpath/">cadisplaylinkanduibezierpath</a> - CADisplayLink结合UIBezierPath的神奇妙用。</li>
<li><a href="https://github.com/KittenYang/KYCuteView">KYCuteView</a> - 实现类似QQ消息拖拽消失的交互+GameCenter的浮动小球效果，<a href="http://kittenyang.com/drawablebubble/">分析</a>。</li>
<li><a href="https://github.com/KittenYang/KYWaterWaveView">KYWaterWaveView</a> - 一个内置波浪动画的UIView，里面有鱼跳跃水溅起来的效果。</li>
<li><a href="https://github.com/liuzhiyi1992/WaveLoadingView">WaveLoadingView</a> - iOS 唯一完美的波浪进度加载指示器，<a href="http://zyden.vicp.cc/waveloadingindicator/">实现说明</a>。</li>
<li><a href="https://github.com/KittenYang/KYPingTransition">KYPingTransition</a> - 实现圆圈放大放小的转场动画，可以根据自己的需要使用Paper中的弹性效果，有Material风格。</li>
<li><a href="https://github.com/KittenYang/KYNewtonCradleAnimiation">KYNewtonCradleAnimiation</a> - 牛顿摆动画。</li>
<li><a href="https://github.com/scotteg/LayerPlayer">LayerPlayer</a> - 一款全面展示核心动画 API 示例项目（上架应用）。包括 CALayer, CAScrollLayer, CATextLayer, AVPlayerLayer, CAGradientLayer, CAReplicatorLayer, CATiledLayer, CAShapeLayer, CAEAGLLayer, CATransformLayer, CAEmitterLayer 等使用的互动演示。</li>
<li><a href="https://github.com/JayGajjar/JGTransitionCollectionView">JGTransitionCollectionView</a> - swift，基于集合视图扩展实现完成自动布局及单元项 Flip式动画效果（效果很赞）。组件使用方便、自然（只需设置集合视图数据源的标准方式即可）。</li>
<li><a href="https://github.com/KittenYang/KYShareMenu">KYShareMenu</a> - 带弹性动画的分享菜单。</li>
<li><a href="https://github.com/Yalantis/Context-Menu.iOS">Context-Menu.iOS</a> - 可以为app的菜单添加漂亮的动画内容，可自定义icon，并可根据自己的喜好设计单元格和布局。</li>
<li><a href="https://github.com/LuciusLu/DeformationButton">DeformationButton</a> - 一个简单的变换形状动画按钮。</li>
<li><a href="https://github.com/heroims/UnReadBubbleView">UnReadBubbleView</a> - UnReadBubbleView是一个能够拖拽并拉长的气泡视图。拖拽到一定的长度会消失，可以通过系数设置来控制拖拽的长度。气泡也支持多种属性设置。</li>
<li><a href="https://github.com/smallmuou/PPDragDropBadgeView">PPDragDropBadgeView</a> - 实现了类似于QQ 5.0 水滴拖拽效果. 支持iOS 5.0+ ARC，气泡能够带有数字标识，同时支持消失block方法。消失时还带有消失效果动画。</li>
<li><a href="https://github.com/MartinRGB/GiftCard-iOS">GiftCard-iOS</a> - 礼品卡购买的炫酷动画。</li>
<li><a href="https://github.com/gsdios/SDCycleScrollView">SDCycleScrollView</a> - 无限循环自动图片轮播器(一步设置即可使用)。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBLoopScrollView">HYBLoopScrollView</a> - HYBLoopScrollView实现自动循环滚动，一般用于展示广告页。微信在贴纸宣传处就使用了轮播。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/BuildAnInfiniteCarousel">BuildAnInfiniteCarousel</a> - 自己动手造无限循环图片轮播，<a href="https://autolayout.club/2015/10/29/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%80%A0%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD/">教程</a>。</li>
<li><a href="https://github.com/nicklockwood/iCarousel">iCarousel</a> - iCarousel是一个类，它继承于UIView。用于简化实现各种类型的旋转木马(分页滚动视图），无限轮播 ，<a href="http://www.cocoachina.com/ios/20150828/13198.html">iOS开发之多图片无缝滚动组件封装与使用</a>。</li>
<li><a href="https://github.com/smartwalle/KIPageView">KIPageView</a> - 无限循环PageView，横向TableView，无限轮播。</li>
<li><a href="http://code.cocoachina.com/view/128288">简单实用的无限循环轮播图</a> - 简单实用的无限循环轮播图 。</li>
<li><a href="https://github.com/crespoxiao/CPInfiniteBanner">CPInfiniteBanner</a> - 是一个循环播放的组件，可以左右无缝滑动,3个imageview实现。<a href="http://ios.jobbole.com/84711/">高效图片轮播，两个ImageView实现</a>。</li>
<li><a href="https://github.com/Akateason/XTLoopScroll">XTLoopScroll</a> - 用两个 timer 三个重用的 view 实现无限循环 scrollView，1自动轮播 2点击监听回调当前图片 3手动滑动后重新计算轮播的开始时间, 良好的用户体验。</li>
<li><a href="https://github.com/zangqilong198812/HotGirls">HotGirls</a> - 卡片动画。</li>
<li><a href="https://github.com/tispr/tispr-card-stack">tispr-card-stack</a> - swift 卡片风格动画切换组件及完整交互示例。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - swift 卡片堆叠效果的实现（ZLSwipeableView)】可实现类似Tinder和Potluck应用程序的卡片堆叠效果，该项目基于<a href="https://github.com/zhxnlai/ZLSwipeableView/">ZLSwipeableView objective-c</a>实现。1.自定义动画。2.自定义滑动切换。3.自定义方向。4.撤销。</li>
<li><a href="https://github.com/Yalantis/Koloda">Koloda</a> - 基于卡片的 Tinder-style 动画效果示例。精细绝人。更赞的是额外附了详细开发教程 How We Built Tinder-Like Koloda Animation in Swift <a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/">网页链接</a> 。Yalantis 出品动画程序款款精品。</li>
<li><a href="https://github.com/zangqilong198812/QQPersonalInfoTransition">QQPersonalInfoTransition</a> - 仿照QQ的转场。</li>
<li><a href="https://github.com/KittenYang/KYAnimatedPageControl">KYAnimatedPageControl</a> - 除了滚动视图时PageControl会以动画的形式一起移动，点击目标页还可快速定位。支持两种样式：粘性小球和旋转方块。</li>
<li><a href="https://github.com/likedan/KDIntroView">KDIntroView</a> - swift 动态介绍视图框架及演示。另外两个相似的类库是 RazzleDazzle和 Presentation，择需使用。</li>
<li><a href="https://github.com/IFTTT/RazzleDazzle">RazzleDazzle</a> - 【IFTTT开源Swift编写的帧动画框架&ndash;RazzleDazzle】RazzleDazzle 是IFTTT开源的一个iOS帧动画框架，非常适用于APP初次使用时的介绍和引导信息。JazzHands是UIKit一个简单的关键帧基础动画框架，可通过手势、scrollview、KVO等控制动画，被IFTTT应用在IFTTT for iPhone上。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 一个类似RazzleDazzle的框架。</li>
<li><a href="https://github.com/poolqf/FillableLoaders">FillableLoaders</a> - 基于 CGPaths 可定制个性化填空式装载类库。附水波上涨式示例。</li>
<li><a href="https://github.com/dsxNiubility/SXWaveAnimate">SXWaveAnimate</a> - 实现非常美观的灌水动画。</li>
<li><a href="https://github.com/liusen001/LSPaomaView">LSPaomaView</a> - 可循环滚动的较长文字，跑马灯，效果很好，一句话集成。</li>
<li><a href="https://github.com/ProudOfZiggy/SIFloatingCollection_Swift">SIFloatingCollection_Swift</a> - 可定制的 Apple Music 风格浮动形状动画组件及演示。</li>
<li><a href="https://github.com/suguru/Cheetah">Cheetah</a> - 易用、高可读链式动画类库。另一个类似类库是 <a href="https://github.com/Draveness/DKChainableAnimationKit">DKChainableAnimationKit</a>。</li>
<li><a href="https://github.com/CezaryKopacz/CKWaveCollectionViewTransition">CKWaveCollectionViewTransition</a> - swift， UICollectionViewController之间切换的动画。</li>
<li><a href="https://github.com/entotsu/TKSubmitTransition">TKSubmitTransition</a> - 基于 UIButton 的登录加载、返回按钮转场动画组件及示例。</li>
<li><a href="https://github.com/AugustRush/ARAnimation">ARAnimation</a> - ARAnimation 对 Core Animation 进行了封装, 帮助 iOS 开发者能更加便捷的在项目中使用动画。</li>
<li><a href="https://github.com/adow/CardsAnimationDemo">CardsAnimationDemo</a> - swift， <a href="http://swiftcn.io/topics/64?f=w">《使用 UICollectionView 实现的一个卡片动画》</a>不是直接操作所有 UIView 和 CALayer 的 transform3D 属性来实现整个效果的，而是使用 UICollectionView 来完成所有的视图管理和实现。</li>
<li><a href="https://github.com/TBXark/TKRubberIndicator">TKRubberIndicator.swift</a> - 一个很不错的 page control。</li>
<li><a href="http://code.cocoachina.com/view/127174">渐变特效文字</a> - 做了一个仿iPhone的移动滑块来解锁的渐变特效文字,还有一个类似ktv歌词显示的文字特效。</li>
<li><a href="https://github.com/zekunyan/TTGEmojiRate">TTGEmojiRate.swift</a> - TTGEmojiRate.swift以Emoji表情为基础绘图，<a href="http://tutuge.me/2015/10/25/ttgemojirate-lib/">Swift开源项目: TTGEmojiRate的实现</a>。</li>
<li><a href="https://github.com/nathanwhy/HYAwesomeTransition">HYAwesomeTransition</a> - 模仿格瓦拉的转场效果。</li>
<li><a href="https://github.com/seedante/CardAnimation">CardAnimation.swift</a> - CardAnimation 是国人开发的一个用 Swift 实现卡片垂直翻转动画的 Demo, <a href="http://www.jianshu.com/p/286222d4edf8">实现思路</a>。</li>
<li><a href="https://github.com/Glow-Inc/TaskSwitcherDemon">TaskSwitcherDemon</a> -  是仿造iOS9的Task Switcher做出来的动画效果, 具体的实现思路可参照<a href="http://tech.glowing.com/cn/implement-ios9-task-switcher-animation/">这篇文章</a>。</li>
<li><a href="https://github.com/lzwjava/CoreAnimationCode">CoreAnimationCode.swift</a> - 提供了 &ldquo;iOS Core Animation Advanced Techniques&rdquo; 书籍中的代码实例, 方便开发者们进行参考学习。</li>
<li><a href="https://github.com/xxycode/UIViewXXYBoom">UIViewXXYBoom.swift</a> - 一个炫酷好玩的爆炸效果，<a href="http://xxycode.com/ru-he-zhi-zuo-ge-xuan-ku-hao-wan-de-bao-zha-xiao-guo-2/">如何实现这个效果</a>。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - <a href="https://github.com/zhxnlai/ZLSwipeableView">ZLSwipeableView</a> - ZLSwipeableViewSwift在Tinder and Potluck中的动画效果实现思路（连续卡片翻页效果），最贴心的是作者提供了OC和Swift两个版本来供开发者使用，非常丝滑顺畅的效果。</li>
<li><a href="https://github.com/Resory/RYCuteView">RYCuteView</a> - 用UIBezierPath实现果冻效果。 <a href="http://www.jianshu.com/p/21db20189c40">教程</a></li>
<li><a href="https://github.com/JakeLin/IBAnimatable">IBAnimatable.swift</a> - 第三方开源库IBAnimatable可以帮助我们在Interface Builder和Swift Playground里面设计UI, 交互, 导航模式, 换场和动画。整个App 都是通过 IBAnimatable 在Interface Builder 设计完成，没有任何一行代码。</li>
<li><a href="https://github.com/poetmountain/MotionMachine">MotionMachine.swift</a> - 功能强大、优雅、模块化动画库。</li>
<li><a href="https://github.com/Ramotion/circle-menu">circle-menu.swift</a> - 动画效率很赞的圆形缩放菜单演示及类库。</li>
<li><a href="https://github.com/ariok/BWWalkthrough">BWWalkthrough.swift</a> - BWWalkthrough.swift界面切换中加入灵动的动画效果。</li>
<li><a href="https://github.com/robb/hamburger-button">hamburger-button.swift</a> - hamburger-button.swift一个汉堡包动画关闭按钮。</li>
<li><a href="https://github.com/fastred/HamburgerButton">HamburgerButton.swift</a> - HamburgerButton.swift一个汉堡包动画返回按钮。</li>
<li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChooseView</a> - MDCSwipeToChooseView翻牌子效果。</li>
<li><a href="https://github.com/StoneLeon/STLBGVideo">STLBGVideo</a> - STLBGVideo让您的视图控制器的自定义backgroundvideo,<a href="http://www.jianshu.com/p/c4704c086b67">实现说明1</a>、<a href="http://www.jianshu.com/p/3dcebf0493d1">实现说明2</a>。</li>
<li><a href="https://github.com/storehouse/Advance">Advance.swift</a> - 简单易用、功能强大的动画框架库。在手势交互、帧动画、自定义动画及仿真类型将是不错的选择。</li>
<li><a href="https://github.com/zangqilong198812/PanelDemo">PanelDemo</a> - 仪表盘,模拟汽车的车速仪表盘,<a href="http://reviewcode.cn/article.html?reviewId=16">一些简单的数学知识</a>。</li>
<li><a href="https://github.com/Loveway/HWAnimationTransition_Swift">HWAnimationTransition_Swift</a> 、<a href="https://github.com/Loveway/HWAnimationTransition_OC">HWAnimationTransition_OC</a> - 类似于格瓦拉启动页中的放大转场动画（objective-C &amp;&amp; Swift）。<a href="http://www.jianshu.com/p/8c29fce5a994">教程</a></li>
<li><a href="https://github.com/MatthewYork/MYBlurIntroductionView">MYBlurIntroductionView</a> - 方便好用的引导类库，在App注册登录页面可以用到。</li>
<li><a href="https://github.com/WZF-Fei/ZFCityGuides">ZFCityGuides</a> - 实现City Guides的动画效果，数字动态变化的动画效果。</li>
<li><a href="https://github.com/me-abhinav/NumberMorphView">NumberMorphView.swift</a> - 可爱的数字补间（变身）动画类库。</li>
<li><a href="https://github.com/Yalantis/DisplaySwitcher">DisplaySwitcher.swift</a> - 两个集合视图在不同布局（平铺和列表）间平滑切换。Yalantis 出品。</li>
<li><a href="https://github.com/yannickl/DynamicButton">DynamicButton.swift</a> - 一套完整、且带动画过渡的图标按钮库。</li>
<li><a href="https://github.com/TBXark/TKDotSegment">TKDotSegment.swift</a> - 是一个带有圆点动画的 segment。</li>
<li><a href="https://github.com/yoavlt/LiquidLoader">LiquidLoader.swift</a> - 液态加载动画的轻量级 UI 组件。</li>
<li><a href="https://github.com/larrynatalicio/15DaysofAnimationsinSwift">15DaysofAnimationsinSwift</a> - 15DaysofAnimationsinSwift动画。</li>
<li><a href="https://github.com/marmelroy/Interpolate">Interpolate.swift</a> - 手势驱动交互式转场动画框架库。这个很专业，且非常有意思。</li>
<li><a href="https://github.com/indragiek/INPopoverController">INPopoverController</a> - OS X可自由定制的  Popover 视图。</li>
<li><a href="https://github.com/Wzxhaha/WZXJianShuPopDemo">WZXJianShuPopDemo</a> - 仿简书、淘宝等等的View弹出效果，已封装好，使用简单。<a href="http://www.jianshu.com/p/a697d2a38b3c">实现原理</a></li>
<li><a href="https://github.com/marmelroy/PeekPop">PeekPop.swift</a> - 3DTouch动画组件。</li>
<li><a href="https://github.com/onmyway133/fantastic-ios-animation">fantastic-ios-animation.swift</a> - 基于 UI 组件类别分类，且带精彩动画效果的 iOS 组件库集合。</li>
<li><a href="https://github.com/facebook/pop">pop</a> - facebook出品的非常赞的动画引擎。</li>
</ul>


<hr />

<h4>网络相关</h4>

<h5>网络连接</h5>

<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> - ASI不升级以后，最多人用的网络连接开源库，<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a>,<a href="http://www.superqq.com/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan/">iOS开发下载文件速度计算</a> , <a href="http://www.cocoachina.com/ios/20151022/13831.html">AFNetworking 3.0迁移指南</a> , <a href="http://www.cocoachina.com/ios/20140829/9480.html">AFNetworking2.0源码解析&lt;一></a> 、<a href="http://www.cocoachina.com/ios/20140904/9523.html">AFNetworking2.0源码解析&lt;二></a>、<a href="http://www.cocoachina.com/ios/20140916/9632.html">AFNetworking源码解析&lt;三></a>、<a href="http://www.cocoachina.com/ios/20141120/10265.html">AFNetworking源码解析&lt;四></a>。</li>
<li><a href="https://github.com/Alamofire/Alamofire">Alamofire.swift</a> - Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。<a href="https://github.com/ipader/SwiftGuide/wiki/Alamofire%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">Alamofire 最佳实践</a></li>
<li><a href="https://github.com/tristanhimmelman/AlamofireObjectMapper">AlamofireObjectMapper.swift</a> - 将Alamofire JSON响应数据 转为swift对象。</li>
<li><a href="https://github.com/RxSwiftCommunity/RxAlamofire">RxAlamofire.swift</a> - 为Alamofire提供函数响应式（FRP）调用接口,以优雅的方式使用Alamofire进行网络请求。</li>
<li><a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a> - 是基于 AFNetworking 封装的 iOS网络库，提供了更高层次的网络访问抽象。相比AFNetworking，YTKNetwork提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBNetworking">HYBNetworking</a> - 基于AFN封装的网络库，可以通用。<a href="http://www.henishuo.com/base-on-afnetworking-wrapper/">基于AFNetworking封装网络库说明</a>目前已经提供了通用的GET/POST、上传、下载API等。</li>
<li><a href="https://github.com/DeveloperLx/LxFTPRequest">LxFTPRequest</a> - 支持获取FTP服务器资源列表，下载/上传文件，创建/销毁ftp服务器文件/目录，以及下载断点续传，下载/上传进度，自动判断地址格式合法性跟踪等功能！国人开发，QQ：349124555。</li>
<li><a href="https://github.com/HHuiHao/HSDownloadManager">HSDownloadManager</a> - HSDownloadManager，下载音乐、视频、图片各种资源，支持多任务、断点下载。</li>
<li><a href="https://github.com/HHuiHao/MutableUploadDemo">MutableUploadDemo</a> - 模拟需求：图文混编，要求用户选择图片后就上传，可选择多图，并行上传，用户确定提交后后台执行，必须全部图片上传完才能提交文字。</li>
<li><a href="https://github.com/swtlovewtt/WTRequestCenter">WTRequestCenter</a> - 方便缓存的请求库，提供了方便的HTTP请求方法，传入请求url和参数，返回成功和失败的回调。 UIKit扩展提供了许多不错的方法，快速缓存图片，图片查看，缩放功能， 颜色创建，设备UUID，网页缓存，数据缓存等功能。 无需任何import和配置，目前实现了基础需求。</li>
<li><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole</a> - Message passing between iOS apps and extensions 2个iOS设备之间通信。</li>
<li><a href="https://github.com/socketio/socket.io-client-swift">socket.io-client-swift</a> - WebSockect 客户端类库。开放的通讯协议，有利于构建强大地跨平台应用。</li>
<li><a href="https://github.com/nghialv/Transporter">Transporter</a> - swift， 短小、精悍、易用的多文件（并发或顺序）上传和下载传输库。还支持后台运行、传输进程跟踪、暂停/续传/取消/重试控制等功能。</li>
<li><a href="https://github.com/kevin0571/STNetTaskQueue">STNetTaskQueue</a> - STNetTaskQueue Objective-C 可扩展网络请求管理库。</li>
<li><a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> - 在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大，<a href="http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/">使用教程</a>。</li>
<li><a href="https://github.com/roustem/AsyncSocket">AsyncSocket</a> - AsyncSocket。</li>
<li><a href="http://code.cocoachina.com/view/128711">Socket通信</a> - 通过AsyncSocket封装的Socket通讯方法，简单实用，通俗易懂，初学者不能错过 。</li>
<li><a href="https://github.com/eugenehp/GCDAsyncSocket">GCDAsyncSocket</a> - GCDAsyncSocket ， <a href="https://github.com/smalltask/TestTcpConnection">不错的Demo</a>。</li>
<li><a href="https://github.com/JustHTTP/Just">Just</a> - 小而美的 HTTP 类。功能简单、直接、完整且健壮性高&ndash; swift。</li>
<li><a href="https://github.com/nghialv/Future">Future</a> - 基于微框架设计思想的异步执行及结果响应类，代码即简单又干净&ndash; swift。</li>
<li><a href="https://github.com/mzeeshanid/MZDownloadManager">MZDownloadManager</a> - 下载管理。</li>
<li><a href="https://github.com/venmo/DVR">DVR</a> - 针对网络请求的测试框架，超实用的工具。且支持 iOS, OSX, watchOS 全平台。</li>
<li><a href="https://github.com/hongfenglt/HFDownLoad">HFDownLoad</a> - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 <a href="http://blog.csdn.net/hongfengkt/article/details/48290561">下载方式具体的思路、区别见Blog</a> 。</li>
<li><a href="https://github.com/johnlui/Pitaya">Pitaya.swift</a> - Pitaya 是纯 Swift 写的 iOS 网络库，支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持，开箱即用。 <a href="https://github.com/johnlui/Pitaya/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3">中文文档</a></li>
<li><a href="https://github.com/daltoniam/starscream">starscream.swift</a> - starscream.swift:WebSocket客户端类库。</li>
<li><a href="https://github.com/FengDeng/SwiftNet">SwiftNet.swift</a> - 基于 RxSwift 和 Alamofire 的网络请求简易封装库。</li>
<li><a href="https://github.com/3lvis/Networking">Networking.Swift</a> - 使用简单、功能惊喜，基于 NSURLSession 的网络封装。</li>
</ul>


<h5>图像获取</h5>

<ul>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage</a> - SDWebImage 网络图片获取及缓存处理。</li>
<li><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a> - 纯 Swift 实现的类 SDWebImage 库，实现了异步下载和缓存图片。</li>
<li><a href="https://github.com/kiavashfaisali/KFSwiftImageLoader">KFSwiftImageLoader</a> - Swift，一个图像缓存加载库。</li>
<li><a href="https://github.com/path/FastImageCache">FastImageCache</a> - FastImageCache 网络图片获取及缓存处理，<a href="http://www.imooc.com/wenda/detail/247239">iOS图片加载速度极限优化—FastImageCache解析</a>。</li>
<li><a href="https://github.com/enormego/EGOCache">EGOCache</a> - 十分知名的第三方缓存类库，可以缓存NSString、UIImage、NSImage以及NSData。除此，如果还可以缓存任何一个实现了<NSCoding>接口的对象。所有缓存的数据都可以自定义过期的时间，默认是1天。EGOCache 支持多线程（thread-safe），<a href="http://www.superqq.com/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti/">UITableView加载多张照片导致内存上涨的问题</a>。</li>
<li><a href="https://github.com/ibireme/YYWebImage/">YYWebImage</a> - 一个图片加载库 YYWebImage，支持 APNG、WebP、GIF 播放，支持渐进式图片加载，更高性能的缓存，更多图像处理方法，可以替代 SDWebImage 等开源库，<a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">相关文章</a>。</li>
</ul>


<h5>网络聊天</h5>

<ul>
<li><a href="https://github.com/robbiehanson/XMPPFramework">XMPPFramework</a> - XMPPFramework openfire聊天。</li>
<li><a href="https://github.com/dsxNiubility/SXTheQQ">SXTheQQ</a> - 用xmppFramework框架编写QQ程序，主要为了练习通讯的一些原理，界面比较渣 必须要先在本地配置好环境才可以运行。</li>
<li><a href="http://www.easemob.com/">环信</a> - 给开发者更稳定IM云功能。8200万用户考验，好用！（暂无及时语音、视频通话）</li>
<li><a href="http://www.rongcloud.cn/">融云</a> - 即时通讯云服务提供商。（暂无及时语音、视频通话）</li>
<li><a href="http://www.yuntongxun.com">容联云通讯</a> - 提供基于互联网通话,视频会议,呼叫中心/IVR,IM等通讯服务。</li>
<li><a href="https://github.com/ChatSecure/ChatSecure-iOS">ChatSecure-iOS</a> - 基于XMPP的iphone、android加密式聊天软件， <a href="https://chatsecure.org/">chatsecure官网</a> 。 <a href="https://github.com/ChatSecure/ChatSecure-iOS">iOS代码1</a>，<a href="https://github.com/ChatSecure/ChatSecure-iOS">iOS代码2</a>， <a href="http://www.cocoachina.com/bbs/read.php?tid=153156">iOS中文版</a>。</li>
<li><a href="https://github.com/xhzengAIB/MessageDisplayKit">MessageDisplayKit</a> - 仿微信聊天，参考JSQMessagesViewController。（国人写）</li>
<li><a href="https://github.com/jessesquires/JSQMessagesViewController">JSQMessagesViewController</a> - 聊天 。</li>
<li><a href="https://github.com/MessageKit/MessageKit">MessageKit.swift</a> - 消息 UI 库 JSQMessagesViewController 的 Swift 版。</li>
<li><a href="https://github.com/HanYaZhou1990/-SunFlower">SunFlower</a> - 环信聊天demo，比较多功能 。</li>
<li><a href="http://code4app.com/ios/BlueTalk%E8%93%9D%E7%89%99%E8%81%8A%E5%A4%A9-%E6%89%8B%E6%9C%BA%E4%B9%8B%E9%97%B4/552b8190933bf0291e8b4748">BlueTalk蓝牙聊天</a> - 以MultipeerConnectivity为基础， 实现了简单的蓝牙聊天。</li>
<li><a href="https://github.com/jpush/jchat-swift">jchat-swift</a> - 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。</li>
</ul>


<h5>网络测试</h5>

<ul>
<li><a href="https://github.com/tonymillion/Reachability">Reachability</a> - 苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。<a href="http://www.jianshu.com/p/efcfa3c87306">iOS网络监测如何区分2、3、4G</a></li>
<li><a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> - 用于替换苹果的 Reachability 类，可以方便地检测当前是否联网以及具体的联网状态。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrier">SimpleCarrier</a> - 简单的运营商信息获取!。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrie">NetReachability</a> - swift2.0 简单的方法检查网络连接的连通性，提供通知中心集成接口。</li>
<li><a href="https://github.com/coderyi/NetworkEye">NetworkEye</a> - 一个网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。</li>
<li><a href="https://github.com/bin1991/SimpleBS">SimpleBS.swift</a> - 网络测试小工具。</li>
<li><a href="https://github.com/dustturtle/RealReachability">RealReachability</a> - <a href="http://www.cocoachina.com/ios/20160224/15407.html">iOS下的实际网络连接状态检测</a>，解决“如何判断设备是否真正连上互联网？而不是只有网络连接”的问题。</li>
</ul>


<hr />

<h5>网页框架</h5>

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect.swift</a> - Perfect 致力于 Swift 服务端应用，从打造专业应用服务器开始。<a href="http://blog.csdn.net/kinfey/article/details/50644752">Swift服务端编程：Perfect项目上手指南</a></li>
<li><a href="https://github.com/huytd/swift-http">swift-http</a> - Swift HTTP Server，又一个 Swift 服务器，最大的亮点是支持 Docker 部署。</li>
<li><a href="https://github.com/necolt/Swifton">Swifton</a> - Swifton是一个优秀的Swift on Rails 的Web Framework。</li>
<li><a href="https://github.com/izqui/Taylor">Taylor.swift</a> - Taylor一个swift的轻量级的http服务器的库。</li>
<li><a href="https://github.com/colemancda/NetworkObjects">NetworkObjects.swift</a> - NetworkObjects.swift轻量版HttpServer框架，跨平台解决方案。</li>
<li><a href="https://github.com/qutheory/vapor">vapor.swift</a> - vapor.swift：swift的服务器库 vapor。</li>
<li><a href="https://github.com/IBM-Swift/Kitura">Kitura.swift</a> - Kitura.swift：安装、使用步骤及文档最为清晰地来自 IBM Swift 开发组的开源 Web 服务器。此外，IBM 云服务 Bluemix 也为 Swift 打开通路。</li>
</ul>


<hr />

<h5>WebView与WKWebView</h5>

<ul>
<li><a href="https://github.com/mattgemmell/MGTemplateEngine">MGTemplateEngine</a> - MGTemplateEngine比较象 PHP 中的 Smarty、FreeMarker 和 Django的模版引擎，是一个轻量级的引擎，简单好用。只要设置很多不同的HMTL模版，就能轻松的实现一个View多种内容格式的显示，对于不熟悉HTML或者减轻 工作量而言，把这些工作让设计分担一下还是很好的，也比较容易实现设计想要的效果。</li>
<li><a href="https://github.com/ninjinkun/NJKWebViewProgress">NJKWebViewProgress</a> - 一个 UIWebView 的进度条接口库,UIWebView 本身是不提供进度条的。</li>
<li><a href="https://github.com/siriusdely/GTMNSString-HTML">GTMNSString-HTML</a> - 谷歌开源的用于过滤HTML标签。</li>
<li><a href="https://github.com/WangXiaoxi/IOSLearing/">js-in-ios</a> - webView与js的交互。</li>
<li><a href="https://github.com/mozhenhau/D3Generator/">D3Generator</a> - D3Generator根据dict字典生成对象。 适用webview和push推送时，根据后台传回字典实现动态跳转。<a href="http://mozhenhau.com/2016/02/07/D3Generator%E5%AE%9E%E7%8E%B0%E4%B8%87%E8%83%BD%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%EF%BC%8CUIWebview%E4%B8%8Ejs%E9%9A%8F%E6%84%8F%E4%BA%A4%E4%BA%92/">实现说明</a></li>
<li><a href="https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS">IOSCallJsOrJsCallIOS</a> - IOSCallJsOrJsCallIOS：利用iOS7.0后出来的JavaScriptCore framework，webview与Js交互是常见的需求。OC版本与swift版本。<a href="http://www.henishuo.com/oc-js/">《OC JavaScriptCore与js交互》</a>,<a href="http://www.henishuo.com/swift-js/">《Swift JavaScriptCore与js交互》</a>。</li>
<li><a href="https://github.com/CoderJackyHuang/WKWebViewTestDemo">WKWebViewTestDemo.swift</a> - WKWebViewTestDemo：WKWebView新特性及JS交互,<a href="http://www.henishuo.com/wkwebview-js/">文章讲解</a>。</li>
<li><a href="https://github.com/alexdrone/Render">React.swift</a> - 启发自 React 的纯 Swift 函数版基于 UIKit 封装类库。这种结构是否似曾相识。</li>
</ul>


<hr />

<h4>Model</h4>

<ul>
<li><a href="https://github.com/johnezang/JSONKit">JSONKit</a> - JSONKit库是非常简单易用而且效率又比较高的，重要的JSONKit适用于ios 5.0以下的版本,使用JSONKit库来解析json文件，只需要下载JSONKit.h 和JSONKit.m添加到工程中；然后加入libz.dylib即可。</li>
<li><a href="https://github.com/icanzilb/JSONModel">JSONModel</a> - 解析服务器返回的Json数据的库,<a href="http://www.jianshu.com/p/3d795ea37835">JSONModel源码解析一</a>。</li>
<li><a href="https://github.com/Mantle/Mantle">Mantle</a> - Mantle主要用来将JSON数据模型化为OC对象, 大系统中使用。<a href="http://www.iwangke.me/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么选择Mantle</a>。</li>
<li><a href="https://github.com/refusebt/RFJModel">RFJModel</a> - RFJModel是一个IOS类库，可以将JSON字典自动装填到OBJC对象。相比JSONModel有一些非常好的特性，使用上也比较简单。</li>
<li><a href="https://github.com/nicklockwood/XMLDictionary">XMLDictionary</a> - ios与mac os平台下xml与NSDictionary相互转化开源类库。</li>
<li><a href="https://github.com/tadija/AEXML">AEXML.swift</a> - AEXML.swift简单又易于的XML解析类及示例。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a> - 用于json转model进行使用，转换效率很高，使用也比较简单，只要前后台约定好，json直接就转成了model。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">CFRuntime</a> - “Swift 版的 MJExtension，运行时、反射与一键字典模型互转”。</li>
<li><a href="https://github.com/openboy2012/DDModel">DDModel</a> - 快速搭建项目Model层，支持ORM映射关系，能从JSON/XML直接实例一个Model对象。支持SQLite本地数据持久化，封装了HTTP， 减少HTTP代码与UIViewController的代码耦合，支持Cache；类似RESTKit、Mantle的功能；使用该类库以后简化了网络层的开发工作，把更多的精力放在UI上面；目前只支持GET/POST方法的请求。使用到的第三方库有：1.SQLitePersistentObject; 2.JTObjectMapping; 3.AFNetworking; 4.XMLDictionary;</li>
<li><a href="https://github.com/alexeyxo/protobuf-swift">protobuf-swift</a> - Protocol Buffers 的 Swift 语言实现库。P.S. Protocol Buffers 是 Google 开源项目，主要功能是实现直接序列化结构化的对象数据，方便跨平台快速传递，开发者也可以直接修改 protobuf 中的数据。相比 XML 和 JSON，protobuf 解析更快，存储更小。</li>
<li><a href="https://github.com/matthewcheok/JSONCodable">JSONCodable</a> - 基于 Swift 2.0 新特性（Protocol Extensions and Error Handling）的JSON 解析类。</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a> - 使Swift的JSON解析变得简单。</li>
<li><a href="https://github.com/johnlui/JSONNeverDie">JSONNeverDie.swift</a> - JSON 到 Model 类的自动映射工具。</li>
<li><a href="https://github.com/cezheng/Fuzi">Fuzi.swift</a> - Swift实现的轻量快速的 XML/HTML 解析器。</li>
<li><a href="https://github.com/drmohundro/SWXMLHash">SWXMLHash.swift</a> - 易用的 XML 解析类库。非常实用的“轮子”。</li>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> - 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/benloong/TidyJSON">TidyJSON.swift</a> - TidyJSON.swift一款简单、易用、明了的 JSON 解析小类库。</li>
<li><a href="https://github.com/postmates/PMJSON">PMJSON.swift</a> - PMJSON.swift简单、实用、高效的 JSON 解析类库。</li>
<li><a href="https://github.com/JohnSundell/Unbox">Unbox.swift</a> - 极为易用、轻量，更少辅助代码的 JSON 解析类。</li>
<li><a href="https://github.com/JohnSundell/Wrap">Wrap.swift</a> - 方便、易用的对象转 JSON 类库。</li>
</ul>


<hr />

<h4>通讯录</h4>

<ul>
<li><a href="http://code.cocoachina.com/view/128245">快速查找联系人</a> - 类似微信联系人搜索的界面,快速查找联系人,并支持点击查询结果 。</li>
</ul>


<hr />

<h4>其他库</h4>

<ul>
<li><a href="https://github.com/exsortis/DateTimeKit">DateTimeKit</a> - 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a> - 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers">iOS私有API</a> - 私有API，绿色 == public，红色 == private，蓝色 == dylib。</li>
<li><a href="http://opensource.apple.com/source/CF/">iOS源代码</a> - iOS源代码。</li>
<li><a href="https://github.com/ShiqiYu/libfacedetection">libfacedetection</a> - C++ 人脸识别 包含正面和多视角人脸检测两个算法.优点:速度快(OpenCV haar+adaboost的2-3倍), 准确度高 (FDDB非公开类评测排名第二），能估计人脸角度。</li>
<li><a href="https://github.com/Brimizer/Slidden">Slidden</a> - 一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。</li>
<li><a href="https://github.com/michaeltyson/TPKeyboardAvoiding">TPKeyboardAvoiding</a> - 用户键盘弹出自动计算高度，进行屏幕滚动操作。</li>
<li><a href="http://d.cocoachina.com/code/detail/298267">CDPMonitorKeyboard</a> - CDPMonitorKeyboard封装,可以解决输入视图(例如textField,textView等)被键盘覆盖问题，并可设置高于键盘多少。</li>
<li><a href="http://code.cocoachina.com/detail/297973/%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E9%AB%98%E5%BA%A6/">自动监听键盘高度</a> - 自动监听键盘高度，初始界面，输入框在屏幕最下方，当键盘出现时，输入框随即移动到键盘上方。</li>
<li><a href="https://github.com/liuzhiyi1992/ZYKeyboardUtil">ZYKeyboardUtil</a> - 全自动处理键盘遮挡事件，只需要一个Block，全自动处理任何多层嵌套复杂界面 因键盘升降 造成的输入控件遮挡问题。
第三方键盘分次弹出问题 ,<a href="http://ios.jobbole.com/85135/">说明</a>。</li>
<li><a href="https://github.com/Jiar/KeyboardToolBar/">KeyboardToolBar</a> - 从此不再担心键盘遮住输入框，<a href="http://www.jianshu.com/p/48993ff982c1">文档</a>。</li>
<li><a href="https://github.com/yushuyi/SYKeyboardTextField">SYKeyboardTextField</a> - SYKeyboardTextField 是一个轻巧,简单,非侵入式的键盘附随输入框! 采用Swift编写。</li>
<li><a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a> - 处理键盘事件强大的库，有OC和Swift版本，纯代码、Storyboard和Xib都适用。</li>
<li><a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a> - block框架，为 OC 常用类提供了强大的 Block 语法支持，使得编写 OC 代码变得舒适、快速、优雅。</li>
<li><a href="https://github.com/facebook/KVOController">KVOController</a> - 在项目中有使用 KVO ，那么 KVOController 绝对是个好选择。它是 facebook 开源的一个 KVO 增强框架。</li>
<li><a href="https://github.com/arashpayan/appirater">appirater</a> - 用于提醒用户给你的 APP 打分的工具。</li>
<li><a href="https://github.com/MHaroonBaig/MotionKitr">MotionKitr</a> - 为核心运动框架（The Core Motion framework）提供友好的类库封装，以更方便使用三轴陀螺仪和加速感应器特性。</li>
<li><a href="https://launchkit.io/reviews/">Review Monitor</a> -  第一时间自动推送 Apple Store 的用户评论到你的邮件箱或者 Slack，第一时间跟进用户反馈，打造优秀 App 必备工具！类似的有：App annie 的类似功能。</li>
<li><a href="https://github.com/Naituw/WBWebViewConsole">WBWebViewConsole</a> - 类似微博iPhone客户端的 “调试选项” 吗？把其中的 “内置浏览器网页调试” 开源在 Github 上了。</li>
<li><a href="https://github.com/futurice/ios-good-practices">ios-good-practices</a> - ios-good-practices iOS 开发最佳实践。</li>
<li><a href="http://ios.jobbole.com/81830/">iOS开发最佳实践</a> - iOS 开发最佳实践 &ndash; 中文。</li>
<li><a href="http://code.cocoachina.com/detail/232160">TodayExtensionSharingDefaults</a> - TodayExtensionSharingDefaults是一个iOS 8 Today扩展示例，可以使用NSUserDefaults与其containing app分享数据。</li>
<li><a href="http://code.cocoachina.com/view/129108">原生实现扫描二维码条码</a> - iOS原生实现扫描二维码条码.</li>
<li><a href="https://github.com/Zirkfied/ZFScan">ZFScan</a> - 仿微信 二维码/条形码 扫描。</li>
<li><a href="https://github.com/yannickl/QRCodeReader.swift">QRCodeReader.swift</a> - QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。</li>
<li><a href="https://github.com/MxABC/swiftScan">swiftScan</a> - 具有丰富功能的二维码扫描组件及类库。<a href="https://github.com/MxABC/LBXScan">对应OC版本LBXScan</a>。</li>
<li><a href="https://github.com/appcoda/QR-Code-Generator">QR-Code-Generator.swift</a> - 生成二维码。</li>
<li><a href="https://github.com/100mango/QRCatcher">QRCatcher</a> - 一个简洁美观的二维码扫描应用， <a href="https://github.com/100mango/zen/blob/master/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%20.md">iOS学习：AVFoundation 视频流处理&ndash;二维码扫描</a>。</li>
<li><a href="https://github.com/zhengjinghua/MQRCodeReaderViewController">MQRCodeReaderViewController</a> - 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用。</li>
<li><a href="https://github.com/ayanonagon/Parsimmon">Parsimmon</a> - swift，小而美的语言学类库封装工具包。提供分词、标记词性、词形归并、朴素贝页斯分类、决策树等自然语言分析小工具。P.S. 英语分词效果好于中文，感兴趣的同学可以针对中文做一些优化开发。参考译文 NSHipster - <a href="http://nshipster.cn/nslinguistictagger/">NSLinguistic​Tagger</a>。</li>
<li><a href="https://github.com/liuchunlao/Password-keyboard">Password-keyboard</a> - 随机变换数字位置的密码键盘。 模仿银行类应用在付款时输入的随机密码键盘。</li>
<li><a href="https://github.com/SemperIdem/MKMapView-Extension">MKMapView-Extension</a> - 这是关于 MKMapView 写的一个基于swift的扩展，可以扩展 MKMapView 的相关功能，减少复用代码量。</li>
<li><a href="https://github.com/nomothetis/SemverKit">SemverKit</a> - 针对符合『语义化版本规范 2.0.0』版本号的解析、比较运算类库。不仅支持 Major, Minor, Patch，还支持 Alpha 和 Beta 预发布版本，以及相应地递增运算扩展。</li>
<li><a href="https://github.com/jpotts18/SwiftValidator">SwiftValidator</a> - 基于规则的输入验证类库。项目良好的面向对象设计思想，使规则的扩展及自定义非常方便。更专业的规则引擎（甚至是基于自然语言的规则配置）解决方案，比如：开源的 Drools，商用的 ILOG 等。</li>
<li><a href="https://github.com/Ben-G/Validated">Validated.swift</a> - Validated.swift通过值验证或限定，快速定义新类型的微类库（约50行代码）。</li>
<li><a href="https://github.com/gali8/Tesseract-OCR-iOS">Tesseract-OCR-iOS</a> - 有关OCR文字识别项目。</li>
<li><a href="https://github.com/osnr/Screenotate">Screenotate</a> - 支持 OCR 文字识别的载屏笔记 Mac 完整应用。</li>
<li><a href="https://github.com/garnele007/SwiftOCR">SwiftOCR</a> - 识别字母和数字相较于 Tesseract 有压倒性优势（附图）的 OCR 类库。</li>
<li><a href="http://cocoacats.com/">cocoacats</a> - 【分类汇总】里面收集了 iOS 中常用的分类文件，一直在更新。</li>
<li><a href="https://github.com/nonstriater/Olla4iOS">Olla4iOS</a> - 过去积累的一些方便复用的类和方法，还在整理中。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - 用最快的方式给你的应用加上夜间和白天的切换效果。</li>
<li><a href="https://github.com/morizotter/TouchVisualizer">TouchVisualizer</a> - 实用的多点触摸可视化组件。扩展并作用于 UIWindows，结构上提供了简单地针对触摸显示定制，比如触摸点的颜色。</li>
<li><a href="https://github.com/wezm/RegexKitLite">RegexKitLite</a> - 用来处理正则表达式。</li>
<li><a href="https://github.com/sharplet/Regex">Regex.swift</a> - 实用的正则表达式微框架类库。</li>
<li><a href="https://github.com/cezheng/PySwiftyRegex">PySwiftyRegex.swift</a> - 像Python一样简洁高效地作正则处理。</li>
<li><a href="https://github.com/marmelroy/PhoneNumberKit">PhoneNumberKit.swift</a> -  解析、格式化及验证国际电话号码工具库（相当于 Google 的 libphonenumber 库的 Swift 版本）。</li>
<li><a href="https://github.com/czechboy0/XcodeServerSDK">XcodeServerSDK</a> - 非官方 Xcode Server SDK 封装库。 P.S. 该 SDK 分离自之前推荐的由该作者开发的自动测试框架 <a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a>。</li>
<li><a href="https://github.com/FabrizioBrancati/BFKit-Swift">BFKit-Swift</a> - BFKit-Swift 这套工具库可以提高应用开发效率。</li>
<li><a href="https://github.com/nofelmahmood/Seam">Seam</a> - 基于 CloudKit 服务器实现多终端数据同步。</li>
<li><a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a> - 简洁、灵活、多变的操作 SequenceType 的类库（基于微框架（μframework）设计思想）。</li>
<li><a href="https://github.com/photondragon/IDNFeedParser">IDNFeedParser</a> - 一个简单易用的Rss解析库。</li>
<li><a href="https://github.com/CharlinFeng/CoreUmeng">CoreUmeng</a> - 简单：友盟分享封装。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。</li>
<li><a href="https://github.com/tomkowz/Swifternalization">Swifternalization</a> - 一套实用的本地化工具库。使用教程及 API 文档完整。值得收入项目的“轮子”。</li>
<li><a href="https://github.com/marmelroy/Localize-Swift">Localize-Swift</a> - Localize-Swift一款开发者不可或缺的国际化及本地化字符串框架支持类库。同样地，使用简单、直观又方便。</li>
<li><a href="https://github.com/owensd/apous">apous</a> - 一款有趣的 Swift 应用 － 让 Swift 成为脚本语言。</li>
<li><a href="https://github.com/kostiakoval/Mirror">Mirror</a> - 通过反射（Refection）实现镜像对象封装库。从而可以更轻松获取（或输出）对象属性名、类型及值变量。</li>
<li><a href="https://github.com/nixzhu/Proposer">Proposer</a> - Proposer 用单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。</li>
<li><a href="https://github.com/nickoneill/PermissionScope">PermissionScope</a> - 用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高。</li>
<li><a href="https://github.com/intuit/LocationManager">LocationManager</a> - 地理位置管理封装库， CoreLocation使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单！<a href="http://www.cocoachina.com/ios/20150721/12611.html">iOS-CoreLocation：无论你在哪里，我都要找到你！</a> 。</li>
<li><a href="https://github.com/Cee/pangu.objective-c">pangu.objective-c</a> - 有多种语言实现版本～ Pangu.Objective-C：格式化中英文之间的空格（OC）。</li>
<li><a href="https://github.com/atomicobject/objection">objection</a> - 一个轻量级的依赖注入框架Objection。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/ControlOrientation/ControlOrientation">ControlOrientation</a> - 如何用代码控制以不同屏幕方向打开新页面【iOS】， <a href="https://lvwenhan.com/ios/458.html">使用说明</a>。</li>
<li><a href="https://github.com/nicklockwood/iRate">iRate</a> - 问卷调查。</li>
<li><a href="https://github.com/nihalahmed/GameCenterManager">GameCenterManager</a> - 在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。</li>
<li><a href="https://github.com/slackhq/SlackTextViewController">SlackTextViewController</a> - 用作极佳、定制的文本输入控制时，自适应文本区域，手势识别、自动填充、多媒体合并，快速drop-in解决方案。</li>
<li><a href="https://github.com/saturngod/IAPHelper">IAPHelper</a> - 应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。</li>
<li><a href="https://github.com/WildDylan/IAPDemo">IAPDemo</a> - 应用内支付IAP全部流程, <a href="http://www.jianshu.com/p/e9ae4cece800">教程</a>。</li>
<li><a href="https://github.com/bizz84/SwiftyStoreKit">SwiftyStoreKit</a> - 一款轻量级的 iOS 应用内购买框架。</li>
<li><a href="https://github.com/JanC/TAPromotee">TAPromotee</a> - 交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。</li>
<li><a href="https://github.com/cgwangding/DownloadFontOnline">DownloadFontOnline</a> - 实现了在线下载一些字体的功能，不用在工程中导入字体库，下载的字体也不会保存在你的应用中，所以可以放心使用。修复了一下崩溃的bug。</li>
<li><a href="https://github.com/zhenlintie/STClock">STClock</a> - 仿锤子时钟。</li>
<li><a href="https://github.com/git-up/GitUp">GitUp</a> - GitUp是一个可视化的Git客户端，能够实时的进行编辑、合并、回滚等多种操作，更多功能，请下载体验。</li>
<li><a href="http://code.cocoachina.com/detail/320392/">获取联系人信息，通讯录</a> - 获取联系人信息，通讯录。</li>
<li><a href="https://github.com/HHuiHao/Universal-Jump-ViewController">Universal-Jump-ViewController</a> - 根据规则跳转到指定的界面(runtime实用篇一)。</li>
<li><a href="https://github.com/Ekhoo/Device">Device-swift</a> - 可以非常方便的获取设备型号和屏幕尺寸，实现起来难度不大，大家可以学习一下源码。</li>
<li><a href="https://github.com/khoiln/RunKit">RunKit.swift</a> - 针对 GCD 框架的一个友好访问封装库（支持方法链式调用）。</li>
<li><a href="https://github.com/FlexMonkey/Plum-O-Meter">Plum-O-Meter</a> - swift 称重应用， (3D Touch之我见)[<a href="http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/">http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/</a>]。</li>
<li><a href="http://code.cocoachina.com/view/128249">打开自带地图、百度地图、腾讯地图</a> - 打开自带地图、百度地图、腾讯地图。</li>
<li><a href="https://github.com/varshylmobile/MapManager">MapManager.swift</a> - MapManager.swift地图及路径管理封装库。</li>
<li><a href="https://github.com/googollee/eviltransform">eviltransform.swift</a> - eviltransform.swift解决国内GPS地图坐标偏移问题,它将政府加密过的GCJ-02坐标，转成世界通用的WGS-84坐标。</li>
<li><a href="https://github.com/colin1994/batteryLevelTest">batteryLevelTest</a> - runtime精准获取电池电量，<a href="http://www.jianshu.com/p/11c1afdf5415">文档</a>。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。</li>
<li><a href="https://github.com/MatthewYork/DateTools">DateTools</a> - 用于提高Objective-C中日期和时间相关操作的效率。灵感来源于 DateTime和Time Period Library。</li>
<li><a href="https://github.com/deepdevelop/DDSlackFeedback">DDSlackFeedback</a> - 用这个接口实现的摇一摇上传文字或者截屏反馈到你的 Slack channel，特别适合测试 app 的时候用，集成也很简单。</li>
<li><a href="https://github.com/coolnameismy/BabyBluetooth">BabyBluetooth</a> - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。<a href="http://www.cocoachina.com/ios/20160219/15301.html">iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍</a></li>
<li><a href="https://github.com/Polidea/RxBluetoothKit">RxBluetoothKit.swift</a> - 基于 RxSwift 的蓝牙通讯库。</li>
<li><a href="https://github.com/rasmusth/BluetoothKit">BluetoothKit.swift</a> - 基于 CoreBluetooth API 实现iOS/OS X 设备间蓝牙通讯封装类库。功能强大、传输稳定，示例完整，很酷。</li>
<li><a href="https://github.com/bignerdranch/CoreDataStack">CoreDataStack.swift</a> - 存储栈。</li>
<li><a href="https://github.com/THREDOpenSource/SYNQueue">SYNQueue.swift</a> - 执行队列类库。</li>
<li><a href="https://github.com/davedelong/DDMathParser">DDMathParser.swift</a> - 相比 NSExpression 和 GCMathPaser，功能更强大的数学表达式解析器。</li>
<li><a href="https://github.com/soffes/RateLimit">RateLimit.swift</a> - 简单、实用定时执行任务工具类库。</li>
<li><a href="https://github.com/shaojiankui/IOS-Categories">iOS-Categories</a> - 收集了许多有助于开发的iOS扩展,各种category分类。</li>
<li><a href="https://github.com/ibireme/YYCategories">YYCategories</a> - 功能丰富的 Category 类型工具库。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayers">YYAsyncLayers</a> -  iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a> -  iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYKeyboardManager">YYKeyboardManager</a> -   iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/6ag/shoppingCart">shoppingCart.swift</a> - swift的购物车demo，采用纯代码UI，autolayout自动布局，core animation动画效果。</li>
<li><a href="https://github.com/gbaldera/ShoppingCartExample">ShoppingCartExample</a> - 购物车最多star demo。</li>
<li><a href="https://github.com/yhangeline/shoppingCart">shoppingCart1</a> - 仿美团购物车效果。</li>
<li><a href="https://github.com/WZF-Fei/ZFShoppingCart">ZFShoppingCart</a> - 仿照美团外卖加入购物车的动态效果。</li>
<li><a href="https://github.com/spxvszero/ShoppingCart">shoppingCart2</a> - 一个购物车demo，包含购物车动画效果、购物车多选、删除、编辑等功能。</li>
<li><a href="https://github.com/DrYrw/shoppingCart-demo">shoppingCart-demo</a> - 一个简单的购物车功能实现demo。</li>
<li><a href="https://github.com/ZyZwei/iOS_oShoppingCart_Demo">iOS_oShoppingCart_Demo</a> - 简单实现购物车常见的筛选功能。</li>
<li><a href="https://github.com/342261733/XNQShoppingTrolley">XNQShoppingTrolley</a> - 购物车功能 基本功能仿照淘宝的购物车。</li>
<li><a href="https://github.com/Zhangjingwang1993/ShoppingDemo">ShoppingDemo</a> - iOS仿美团外卖饿了吗App点餐动画,购物车。</li>
<li><a href="http://code.cocoachina.com/view/129430">shopCarDemobyCX</a> - shopCarDemobyCX一个简易购物车效果，最重要的是可以分单结算，分单个商品结算，代理是主要技术。</li>
<li><a href="http://code.cocoachina.com/view/128713">MVVM KVO购物车</a> - MVVM KVO 购物车(一处计算总价钱)。</li>
<li><a href="https://github.com/bb-coder/BHBDrawBoarderDemo">BHBDrawBoarderDemo车</a> - 仿写猿题库练题画板功能，没有用drawRect，而是用CAShapeLayer来做画板绘画，特别省内存，赞1个，<a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/">实现分析</a>。</li>
<li><a href="https://github.com/uraimo/SwiftyGPIO">SwiftyGPIO</a> - 通过 Swift 语言去控制基于 Linux 主板（比如：C.H.I.P. 和 树莓派） 的 GPIO（General Purpose Input Output ），去完成简单的工控功能（比如 LED 灯的显示）。</li>
<li><a href="https://github.com/onmyway133/Scale">Scale.swifty</a> - 简单直观的单位计算及换算类库（支持常用计量类型）。代码简洁性、直观性杠杠的。</li>
<li><a href="https://github.com/dankogai/swift-pons">swift-pons</a> - 面向协议的不受长度限制数字类型及数学计算扩充类库。用它做一款最牛科学计算器妥妥地。</li>
<li><a href="https://github.com/amayne/SwiftString">SwiftString</a> - SwiftString:String 扩展功能很丰富（无论格式化杂乱字符串，还是子串查找，亦或是格式转换都很强大）。</li>
<li><a href="https://github.com/rentzsch/jrswizzle">jrswizzle</a> - runtime实现的Method Swizzling第三方框架。</li>
<li><a href="https://github.com/marmelroy/FileBrowser">FileBrowser.swift</a> - FileBrowser.swift 一款开源的 iOS 文件浏览器, 支持文件搜索, 文件预览和 3D touch 功能。</li>
<li><a href="https://github.com/marmelroy/FileBrowser">AFBrushBoard.swift</a> -  AFBrushBoard.swift基于swift的毛笔画板Demo。包含多阶贝塞尔曲线的抽取、模拟画笔速度等算法。</li>
<li><a href="https://github.com/ortuman/SwiftForms">SwiftForms</a> - SwiftForms表单递交库，快速开发利器。</li>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a> - Design-Patterns-In-Swift如何使用常用设计模式及示例。</li>
<li><a href="https://github.com/ankurp/Dollar">Dollar.swift</a> - Dollar.swift是一个Swift库，无需扩展任何内置对象就为Swift语言提供有效的函数式编程辅助方法，类似于Lo-Dash或JavaScript中的Underscore。而Cent则是通过扩展功能来扩展Swift中的特定对象类型。</li>
<li><a href="https://github.com/JakeLin/Underscore">Underscore.swift</a> - 函数式编程辅助方法，可靠性上压倒目标对手是 Dollar。</li>
<li><a href="https://github.com/kylef/PathKit">PathKit.swift</a> - PathKit.swift小而美的路径管理类。</li>
<li><a href="https://github.com/mattt/Surge">Surge.swift</a> - Surge.swift基于苹果Accelerate高性能计算数学框架封装库。</li>
<li><a href="https://github.com/duemunk/Async">Async.swift</a> - Async.swift简洁的后台执行代码的异步封装库。</li>
<li><a href="https://github.com/Alecrim/AlecrimAsyncKit">AlecrimAsyncKit.swift</a> - 一款很优雅的异步执行框架库。</li>
<li><a href="https://github.com/Thomvis/BrightFutures">BrightFutures.swift</a> - BrightFutures.swift漫长或复杂计算由独立线程异步来完成。</li>
<li><a href="https://github.com/mattt/Euler">Euler.swift</a> - Euler.swift直观、简洁的数学表达式∛27÷3+∑[3,1,2]。</li>
<li><a href="https://github.com/ArtSabintsev/Siren">Siren.swift</a> - Siren.swift当应用更新时，通知用户并提供App Store链接。</li>
<li><a href="https://github.com/nutletor/Demo_ProductDetailScroll">Demo_ProductDetailScroll</a> - Demo_ProductDetailScroll ：仿京东商品详情滚动翻页。</li>
<li><a href="https://github.com/huangzhibiao/-">BGTaobao</a> - ios 高仿淘宝/京东详情页 - 集合各种测试框架。</li>
<li><a href="https://github.com/LQQZYY/CartDemo">CartDemo</a> - CartDemo比较完整的购物车界面及逻辑,商品展示,多选,单选,全选及滑动删除,价格计算。</li>
<li><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a> - JLRoutes好用的URL map库，它的作用是让按钮的点击像网页里的链接一样，只是触发了某个URL，而没有像pushViewController这样的行为，实现解耦。</li>
<li><a href="https://github.com/lorentey/BTree">BTree.swift</a> - BTree.swift:相对于标准集合类型具有更优执行性能的基于B-Tree的优化集合类型实现类库。</li>
<li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> - 同时支持 Swift 及 Objective-C 的 Promise 类库，异步编程类库 提供了很多实用的异步函数 让异步编程更简单。</li>
<li><a href="https://github.com/ZipArchive/ZipArchive">ZipArchive</a> - 适用iOS和OS X的解压库。</li>
<li><a href="https://github.com/SwiftStudies/Duration">Duration.swift</a> - 测量代码片段执行时间工具类库（Swift）。</li>
<li><a href="https://github.com/BoltsFramework/Bolts-Swift">Bolts-Swift</a> - 全平台（所有支持 Swift 的设备）任务管理 futures/promises 异步实现类库。</li>
<li><a href="https://github.com/boycechang/BCColor">BCColor.swift</a> - 轻量而强大的颜色处理库，纯 Swift 版。 支持从图片拾取一套主题色，类似AppleMusic；支持图片黑白化、对颜色的加深和变浅、生成渐变颜色等。</li>
<li><a href="https://github.com/KevinCoble/AIToolbox">AIToolbox.swift</a> - AI 主流模块集工具箱库。其中涉及 AI 知识实在广阔又高端。</li>
<li><a href="https://github.com/Loveway/HWChangeFont">HWChangeFont</a> - 利用runtime一键改变字体。<a href="http://www.jianshu.com/p/b9fdd17c525e">教程</a>。</li>
<li><a href="https://github.com/Tuccuay/RuntimeSummary">RuntimeSummary</a> - 一个集合了常用 Objective-C Runtime 使用方法的 Playground。</li>
<li><a href="https://github.com/goktugyil/EZSwiftExtensions">EZSwiftExtensions</a> - 对Swift标准库， Foundation， UIKit 提供了很多高级扩展函数。</li>
<li><a href="https://github.com/jscalo/TempiBeatDetection">TempiBeatDetection.swift</a> - Swift 语言写的音乐节奏节拍检测库。</li>
<li><a href="https://github.com/VeniceX/Venice">Venice.swift</a> - 让 Swift 3 提前支持协程（Coroutine）。P.S.  Chris  曾答疑过，Coroutine 不在 Swift 3 支持范围中，将在更晚时候讨论语言级支持。</li>
<li><a href="https://github.com/mzaks/FlatBuffersSwift">FlatBuffersSwift</a> - Swift 版 FlatBuffers 实现类库。P.S. FlatBuffers 是跨平台、高效，提供了 C++/Java 接口的序列化开源工具库。</li>
<li><a href="https://github.com/genadyo/Lyft">Lyft.swift</a> - 一套面向 Lyft 开发者的 Swift API 类库。</li>
<li><a href="https://github.com/gjiazhe/Up-Down">Up-Down.swift</a> - Up-Down.swift:在 OS X 菜单栏上实时显示网络上传和下载速度小工具。</li>
<li><a href="https://github.com/genadyo/Lyft">Algorithm.swift</a> - 算法和概率模型工具集。（作者 Daniel Dahan）</li>
<li><a href="https://github.com/cyanzhong/GCDThrottle">GCDThrottle</a> - 限制频率过高的调用GCD多线程。</li>
<li><a href="https://github.com/hyperoslo/Spots">Spots.swift</a> - 一套为了加速开发效率、将 view models 采用 JSON 格式存储于云端 view controller 框架库。</li>
<li><a href="https://github.com/Lickability/PinpointKit">PinpointKit.swift</a> - 简单的手势动作快速触发反馈组件。主要功能包含自动截屏、附加说明和日志。支持添加可定制箭头、着重框、文本、模糊打码等常用快照编辑功能。它非常适合开发过程中测试人员反馈缺陷。</li>
<li><a href="https://github.com/X140Yu/Switcher">Switcher.swift</a> - 一个 OS X 小 App，可以很轻松地切换 App Store 和 iTunes 的账号，对于同时使用多个 Apple ID 的人来说非常地方便。</li>
</ul>


<hr />

<h4>数据库</h4>

<ul>
<li><a href="https://github.com/ccgus/fmdb">FMDB</a> - sqlite的工具， <a href="https://github.com/tangqiaoboy/FmdbSample">多线程FMDatabaseQueue实例</a>，<a href="https://github.com/liuchunlao/LVDatabaseDemo">FMDB数据库的使用演示和封装工具类</a>，<a href="http://code.cocoachina.com/view/128312">基于fmdb 的基本操作</a> 通过 fmdb 进行的数据库的 基本操作(增删改查 )查找是使用 UISearchBar 和UISearchDisplayController 进行混合使用。</li>
<li><a href="https://github.com/Gerry1218/GXDatabaseUtils">GXDatabaseUtils</a> - 在FMDB基础上的工具。</li>
<li><a href="https://github.com/realm/realm-cocoa">realm-cocoa</a> - Realm是一个真正为移动设备打造的数据库，同时支持Objective-C和Swfit。Realm宣称其相比Sqlite，在移动设备上有着更好的性能表现,<a href="https://realm.io/cn/">官方中文</a> ，<a href="http://swift.gg/2015/12/08/ios-realm-instead-of-coredata/">iOS：选择 Realm 而不是 CoreData</a>, <a href="http://swift.gg/2015/12/08/building-a-todo-app-using-realm-and-swift/">使用 Realm 和 Swift 创建 ToDo 应用</a>。</li>
<li><a href="https://github.com/eure/RealmIncrementalStore">RealmIncrementalStore.swift</a> - RealmIncrementalStore.swift:集 Realm 数据库和 CoreData 对象模型两者优势的 Realm 数据库访问类库。</li>
<li><a href="https://github.com/andrelind/Breeze">Breeze</a> - 用Swift写的一个轻量级的CoreData管理工具，并且还支持iCloud 。</li>
<li><a href="https://github.com/Alecrim/AlecrimCoreData">AlecrimCoreData</a> - Swift，更容易地访问 CoreData 对象封装类库。除了 CRUD，还提供指针定位，强大的排序、筛选，异步数据获取，以及独立线程后台存取数据。</li>
<li><a href="https://github.com/AfryMask/AFBrushBoard">CoreStore</a> -  Core Data 管理类库。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a> - CoreData第一库，MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="http://rentzsch.github.io/mogenerator/">mogenerator</a> - mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 重量级好项目 Presentation，它可以方便你制作定制的动画式教程、Release Notes、个性化演讲稿等。</li>
<li><a href="https://github.com/terhechte/CoreValue">CoreValue</a> - Swift 2 版 Core Data 封装库。相比另外两个 <a href="https://github.com/arkverse/SwiftRecord">SwiftRecord</a>和 <a href="https://github.com/JohnEstropia/CoreStore">CoreStore</a>更轻量。</li>
<li><a href="https://github.com/sqlcipher/sqlcipher">SQLCipher</a> - SQLCipher使用256-bit AES加密，SQLCipher分为收费版本和免费版本。<a href="https://www.zetetic.net/sqlcipher/ios-tutorial/">官方教程</a>， <a href="http://foggry.com/blog/2014/05/19/jia-mi-ni-de-sqlite/">加密你的SQLite</a> - 各种sqlite数据库加密介绍。 <a href="http://download.csdn.net/detail/wzzvictory_tjsd/7379055">SQLCipherDemo下载</a> 。</li>
<li><a href="https://github.com/stephencelis/SQLite.swift">SQLite.swift</a> - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。</li>
<li><a href="https://github.com/qutheory/fluent">fluent.swift</a> - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。</li>
<li><a href="http://www.appcoda.com/swiftydb/">swiftydb</a> - 是一个第三方 SQLite 工具，能够大大简化数据库操作。如果你不放心 Realm，那就用 SwiftyDB 吧。<a href="http://swift.gg/2016/05/17/swiftydb/">使用教程</a>、<a href="https://github.com/appcoda/SwiftyDB-Demo">demo</a></li>
<li><a href="https://github.com/CosmicMind/Graph">Graph.swift</a> - 设计新颖、使用简单基于 Core Data 的数据驱动框架库 （作者Daniel Dahan）。</li>
</ul>


<hr />

<h4>缓存处理</h4>

<ul>
<li><a href="https://github.com/yuantiku/YTKKeyValueStore">YTKKeyValueStore</a> - Key-Value存储工具类，<a href="http://tangqiaoboy.gitcafe.io/blog/2014/10/03/opensouce-a-key-value-storage-tool/">说明</a>。</li>
<li><a href="https://github.com/tumblr/TMCache">TMCache</a> - TMCache 是 Tumblr 开源的一个基于 key/value 的数据缓存类库,可以用于缓存一些临时数据或者需要频繁加载的数据,比如某些下载的数据或者一些临时处理结果。</li>
<li><a href="https://github.com/jl322137/JLKeychain">JLKeychain</a> - 快捷使用keychain存储数据的类，使keychain像NSUserDefaults一样工作。</li>
<li><a href="https://github.com/soffes/sskeychain">sskeychain</a> - SSKeyChains对苹果安全框架API进行了简单封装,支持对存储在钥匙串中密码、账户进行访问,包括读取、删除和设置。</li>
<li><a href="https://github.com/kishikawakatsumi/KeychainAccess">KeychainAccess</a> - 管理Keychain接入的小助手。</li>
<li><a href="https://github.com/ibireme/YYCache">YYCache</a> - 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/CoderJackyHuang/RuntimeDemo">RuntimeDemo</a> - runtime自动归档/解档,<a href="http://www.henishuo.com/runtime-archive-unarchive-automaticly/">源码分析</a>。</li>
<li><a href="https://github.com/soffes/Cache">Cache.swift</a> - 一款简单、易用的缓存库。支持 MemoryCache, DiskCache 以及前两项组合的 MultiCache。</li>
<li><a href="https://github.com/hyperoslo/Cache">Cache.swift</a> - Nothing but Cache。</li>
<li><a href="https://github.com/aschuch/AwesomeCache">AwesomeCache.swift</a> - Delightful on-disk cache (written in Swift)。</li>
<li><a href="https://github.com/maquannene/Track">Track.swift</a> - 基于文件系统和链表的 Cache。分为 Disk 和 Memory，线程安全，支持 LRU 淘汰，性能尚可。</li>
</ul>


<hr />

<h4>PDF</h4>

<ul>
<li><a href="https://github.com/vfr/Reader">Reader</a> - Reader可提供类似iBooks的文档导航，支持屏幕旋转和所有方向，并通过密码保护加密PDF文件，支持PDF链接和旋转页面。</li>
</ul>


<hr />

<h4>图像浏览及处理</h4>

<ul>
<li><a href="https://github.com/liric28/FLAnimatedImage">FLAnimatedImage</a> - gif播放处理的工具。</li>
<li><a href="https://github.com/yackle/CLImageEditor">CLImageEditor</a> - 超强的图片编辑库，快速帮你实现旋转，防缩，滤镜等等一系列麻烦的事情。</li>
<li><a href="https://github.com/esilverberg/ios-image-filters">ios-image-filters</a> - 图像滤镜，库比较旧了，很容易崩溃。</li>
<li><a href="https://github.com/xissburg/XBImageFilters">XBImageFilters</a> - 图像滤镜。</li>
<li><a href="https://github.com/mwaterfall/MWPhotoBrowser">MWPhotoBrowser</a> - 一个非常不错的照片浏览器，在github的star接近3000个，<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。</li>
<li><a href="https://github.com/objcio/issue-21-core-image-explorer">core-image-explorer</a> -  Core Image 滤镜处理图片&ndash; swift ，<a href="http://objccn.io/issue-21-6/">Core Image 介绍</a>。</li>
<li><a href="https://github.com/rFlex/CoreImageShop">CoreImageShop</a> - CoreImageShop图片滤镜处理&ndash; Mac app that let you create a complete Core Image Filter usable on iOS using SCRecorder。</li>
<li><a href="https://github.com/BradLarson/GPUImage">GPUImage</a> - 处理图片效果。</li>
<li><a href="https://github.com/BradLarson/GPUImage2">GPUImage2.swift</a> - Swift 版基于 GPU 图像和视频处理框架库。</li>
<li><a href="https://github.com/ruslanskorb/RSKImageCropper">RSKImageCropper</a> - 适用于iOS的图片裁剪器，类似Contacts app，可上下左右移动图片选取最合适的区域。</li>
<li><a href="http://code.cocoachina.com/detail/232156">WZRecyclePhotoStackView</a> - 删除照片交互&ndash;WZRecyclePhotoStackView，就是模拟生活中是删除或保留犹豫不决的情形而产生的。 在上滑，下滑的部分，借鉴了<a href="https://github.com/cwRichardKim/TinderSimpleSwipeCards">TinderSimpleSwipeCards</a>。</li>
<li><a href="https://github.com/schwa/TimingFunctionEditor">TimingFunctionEditor</a> - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器。 <a href="https://github.com/Carthage/Carthage">Carthage</a> ，而非常用的 CocoaPods。<a href="http://www.cocoachina.com/ios/20141204/10528.html">Carthage介绍中文</a>。</li>
<li><a href="https://github.com/aaronabentheuer/AAFaceDetection">AAFaceDetection</a> - AAFaceDetection&ndash;swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。</li>
<li><a href="https://github.com/itouch2/PhotoTweaks">PhotoTweaks</a> - 这个库挺赞的，正好是对图像操作的。</li>
<li><a href="https://github.com/contentful-labs/Concorde">Concorde</a> - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。</li>
<li><a href="https://github.com/tristanhimmelman/ZoomTransition">ZoomTransition</a> - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。</li>
<li><a href="https://github.com/melvitax/AFImageHelper">AFImageHelper</a> - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取。</li>
<li><a href="https://github.com/demonnico/PinterestSwift">PinterestSwift</a> - swift,Pinterest 风格图片缩放、切换示例。</li>
<li><a href="https://github.com/KittenYang/KYElegantPhotoGallery">KYElegantPhotoGallery</a> - 一个优雅的图片浏览库。</li>
<li><a href="https://github.com/gsdios/SDPhotoBrowser">SDPhotoBrowser</a> - 仿新浪动感图片浏览器,非常简单易用的图片浏览器，模仿微博图片浏览器动感效果，综合了图片展示和存储等多项功能。</li>
<li><a href="https://github.com/chennyhuang/HZPhotoBrowser">HZPhotoBrowser</a> - 一个类似于新浪微博图片浏览器的框架（支持显示和隐藏动画；支持双击缩放，手势放大缩小；支持图片存储；支持网络加载gif图片，长图滚动浏览；支持横竖屏显示）。</li>
<li><a href="https://github.com/ijoyc/PhotoStackView-Swift">PhotoStackView-Swift</a> - PhotoStackView——照片叠放视图，<a href="http://blog.csdn.net/u013604612/article/details/46336657">使用说明</a>。</li>
<li><a href="https://github.com/FlexMonkey/MarkingMenu">MarkingMenu</a> - 基于手势、类似 Autodesk Maya 风格标记菜单及图片渲染。</li>
<li><a href="https://github.com/dsxNiubility/SXPhotoShow">SXPhotoShow</a> - UICollectionViewFlowLayout流水布局 是当下collectionView中常用且普通的布局方式。本代码也写了三种好看的布局，其中LineLayout和流水布局有很大的相同点就直接继承UICollectionViewFlowLayout，然后StackLayout，CircleLayout这两种都是直接继承自最原始的UICollectionViewLayout 布局方案。</li>
<li><a href="https://github.com/cgwangding/PictureWatermark">PictureWatermark</a> - 主要实现了给图片加文字以及图片水印的功能，已封装成了UIImage的类别，方便使用。</li>
<li><a href="http://code.cocoachina.com/detail/320603/">自定义宽高比的相册框 拍照</a> - 取出照片时 弹出自定义view。在这个自定义view上创建一个需要的相框大小的view层 把取出的图片赋值给UIImageView按缩放添加到这个层上。对uiimageView添加捏合、移动 手势。添加按钮 选取，最后根据位移和缩放比例 裁剪image。</li>
<li><a href="https://github.com/gang544043963/LGPhotoBrowser">LGPhotoBrowser</a> - LGPhotoBrowser:相册选择/浏览器/照相机（仿微信）,包含三个模块：照片浏览器，相册选择器，照相机。</li>
<li><a href="https://github.com/oscarWyz/PhotoBrowser">PhotoBrowser</a> - 一个简单的好用的的图片浏览器。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">BeautyHour</a> - 完整应用，功能与“美图秀秀”雷同。</li>
<li><a href="https://github.com/DroidsOnRoids/MPParallaxView">MPParallaxView</a> - 是用 Swift 写的类似 Apple TV Parallax 效果的视图。</li>
<li><a href="https://github.com/zhengjinghua/StitchingImage">StitchingImage</a> - 仿微信群组封面拼接控件, 直接拖进项目就可使用，<a href="http://gold.xitu.io/entry/56395f5360b20b143a9178f6">教程</a>。</li>
<li><a href="https://github.com/seedante/SDECollectionViewAlbumTransition">SDECollectionViewAlbumTransition</a> - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">SKPhotoBrowser.swift</a> - swift中规中矩、实用的图片浏览类库。示例也很完整。</li>
<li><a href="https://github.com/kean/Nuke">Nuke.swift</a> - 完整、强大、实用的图片管理类库。主要功能包括可定制装载，缓存，滤镜及尺寸变换。</li>
<li><a href="https://github.com/AwesomeDennis/DNImagePicker">DNImagePicker</a> - 类似wechat的图片选择。</li>
<li><a href="https://github.com/lioonline/CocoaPicker">CocoaPicker</a> - 仿QQ图片选择器（OC）。</li>
<li><a href="https://github.com/johnil/JFImagePickerController">JFImagePickerController</a> - vvebo作者：多选照片、预览已选照片、针对超大图片优化。</li>
<li><a href="https://github.com/vitoziv/VIPhotoView">VIPhotoView</a> - 图片浏览，用于展示图片的工具类，因为是个 View，所以你可以放在任何地方显示。支持旋转，双击指定位置放大等。</li>
<li><a href="https://github.com/SpringOx/AGImagePickerController">AGImagePickerController</a> - 是一个图片选择器，支持图片多选，支持大图横滑预览，支持放大预览，支持横竖屏，支持所有的iOS设备。</li>
<li><a href="https://github.com/ibireme/YYImage">YYImage</a> - 功能强大的 iOS 图像框架，支持大部分动画图像、静态图像的播放/编码/解码。</li>
<li><a href="https://github.com/KyoheiG3/PagingView">PagingView.swift</a> - 注重细节的自动布局分页视图组件。</li>
<li><a href="https://github.com/banchichen/TZImagePickerController">TZImagePickerController</a> - 一个支持多选、选原图和视频的图片选择器，同时有预览功能，适配了iOS6789系统。<a href="http://www.cocoachina.com/ios/20160112/14942.html">教程</a>.</li>
<li><a href="http://code.cocoachina.com/view/129134">更换头像</a> - 用户选取从相机或者相册获取图片，并且显示在View上。</li>
<li><a href="https://github.com/luzefeng/DouBanMeinv">DouBanMeinv.swift</a> - 抓取豆瓣美女图片，瀑布流显示。</li>
<li><a href="https://github.com/ACEYL/ZZPhotoKit">ZZPhotoKit</a> - 基于Photos和AVFoundation框架开源，相册多选与相机连拍。</li>
<li><a href="https://github.com/startry/SwViewCapture">SwViewCapture.swift</a> - SwViewCapture.swift一个用起来还不错的iOS截图库.(支持截取所有内容, 适用于所有ScrollView组成的视图, 包括WebView)。</li>
<li><a href="https://github.com/Guikunzhi/BeautifyFaceDemo">BeautifyFaceDemo</a> - 一个基于 GPUImage 的实时直播磨皮滤镜的开源实现,主要功能脸部去斑磨皮！</li>
<li><a href="https://github.com/YuAo/YUCIHighPassSkinSmoothing">YUCIHighPassSkinSmoothing</a> - 磨皮滤镜！</li>
<li><a href="https://github.com/FlexMonkey/Filterpedia">Filterpedia.swift</a> - 强大的图片滤镜库演示。</li>
<li><a href="https://github.com/YuAo/YUGPUImageHighPassSkinSmoothing">YUGPUImageHighPassSkinSmoothing</a> - 一个基于 GPUImage 的磨皮滤镜！</li>
<li><a href="https://github.com/Ramotion/preview-transition">preview-transition.swift</a> - 通过向导式代码实现步骤，实现完整、自然流畅的图片预览及转场功能。</li>
<li><a href="https://github.com/FlexMonkey/CartoonEyes">CartoonEyes.swift</a> - 前置摄像头捕获图像后，采用 Core Image 脸部识别 CIDetector 和漫画效果滤镜复合出卡通效果眼睛。</li>
<li><a href="https://github.com/Guikunzhi/YLFaceuDemo">YLFaceuDemo</a> - 在直播应用中添加Faceu贴纸效果。Faceu贴纸效果其实就是在人脸上贴一些图片，同时这些图片是跟随着人脸的位置改变的。<a href="http://www.jianshu.com/p/ba1f79f8f6fa">说明</a></li>
</ul>


<hr />

<h4>摄像照相视频音频处理</h4>

<ul>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - SCRecorder 短视频录制。</li>
<li><a href="https://github.com/zangqilong198812/VideoPushDemo">VideoPushDemo</a> - 视频剪辑 <a href="http://www.jianshu.com/p/3006502912aa">视频特效制作1</a> <a href="http://www.jianshu.com/p/6313025349a9">视频特效制作2</a>。</li>
<li><a href="https://github.com/omergul123/LLSimpleCamera">LLSimpleCamera</a> - A simple, customizable camera control for iOS， 摄像头。</li>
<li><a href="https://github.com/syedhali/EZAudio">EZAudio</a> - EZAudio 是一个 iOS 和 OSX 上简单易用的音频框架，根据音量实时显示波形图，基于Core Audio，适合实时低延迟音频处理，非常直观。<a href="https://segmentfault.com/blog/news/1190000000370957">中文介绍</a>,<a href="http://www.syedharisali.com/about">官网</a>。</li>
<li><a href="http://ffmpeg.org/">ffmpeg</a> - ffmpeg官网，<a href="http://www.cocoachina.com/ios/20150514/11827.html">FFmpeg在iOS上完美编译</a>。</li>
<li><a href="http://www.videolan.org/">VLC</a> - VCL官网,<a href="https://www.videolan.org/vlc/download-ios.html">VLC for iOS 2.7.2 source code</a>。</li>
<li><a href="https://github.com/kolyvan/kxmovie">kxmovie</a> - 使用ffmpeg的影片播放器，<a href="http://www.cocoachina.com/bbs/read.php?tid=145575">修改说明</a>， <a href="https://github.com/kinglonghuang">修改代码</a>，<a href="https://github.com/namebryant/FFmpeg-Compilation">基于FFmpeg的kxMoive艰难的编译运行</a>。</li>
<li><a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a> - B站开源的视频播放器，支持Android和iOS。 <a href="http://www.jianshu.com/p/1f06b27b3ac0">iOS中集成ijkplayer视频直播框架</a>。</li>
<li><a href="https://github.com/tumtumtum/StreamingKit">StreamingKit</a> - StreamingKit流媒体音乐播放器。</li>
<li><a href="https://github.com/muhku/FreeStreamer">FreeStreamer</a> - FreeStreamer流媒体音乐播放器，cpu占用非常小。</li>
<li><a href="https://github.com/douban/DOUAudioStreamer">DOUAudioStreamer</a> - DOUAudioStreamer豆瓣的音乐流媒体播放器。</li>
<li><a href="https://github.com/fmpro/fmpro">fmpro</a> - 电台播放器，支持锁屏歌词，支持基本播放流程，歌词展示，后台锁屏播放和控制以及锁屏后封面+歌词，<a href="https://github.com/jovisayhehe/fmpro_R">fmpro_R</a> 。</li>
<li><a href="https://github.com/mmackh/IPDFCameraViewController">IPDFCameraViewController</a> - 支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。</li>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - 酷似 Instagram/Vine 的音频/视频摄像记录器，以 Objective-C 为基础的过滤器框架。 你可以做很多如下的操作：记录多个视频录像片段。删除任何你不想要的记录段。可以使用任何视频播放器播放片段。保存的记录可以在序列化的 NSDictionary 中使用。（在 NSUserDefaults 的中操作）添加使用 Core Image 的视频滤波器。可自由选择你需要的 parameters 合并和导出视频。</li>
<li><a href="https://github.com/GabrielAlva/Cool-iOS-Camera">Cool-iOS-Camera</a> - Cool-iOS-Camera。</li>
<li><a href="https://github.com/IFTTT/FastttCamera">FastttCamera</a> - FastttCamera 快速照相。</li>
<li><a href="https://github.com/itsmeichigo/ICGVideoTrimmer">ICGVideoTrimmer</a> - ICGVideoTrimmer提供提供视频剪切的视图（类似系统相册中浏览视频时顶部那个条状视图）。左右两个边界选择器还能够自定义。</li>
<li><a href="http://d.cocoachina.com/code/detail/285717">IOS录音和播放功能demo</a> - 比较完整的ios录音和播放功能的实现。</li>
<li><a href="https://github.com/imaginary-cloud/CameraManager">CameraManager</a> - 相机管理封装类库。看着极好用的样子&mdash;-swift。</li>
<li><a href="https://github.com/msching/MCAudioInputQueue">MCAudioInputQueue</a> - 简易录音类，基于AudioQueue的。</li>
<li><a href="https://github.com/vizllx/DraggableYoutubeFloatingVideo">DraggableYoutubeFloatingVideo</a> - 展示像类似Youtube移动应用的那种浏览视频的效果，当点击某视频时能够从右下方弹出一个界面，并且该界面能够通过手势，再次收缩在右下方并继续播放。这是通过AutoLayout设计实现。</li>
<li><a href="http://www.penguin.cz/~utx/amr">amr</a> - 做即时通讯的音频处理，录音文件是m4a，便于web端的音频播放。</li>
<li><a href="http://code4app.com/ios/%E8%BE%B9%E5%BD%95%E9%9F%B3%E8%BE%B9%E8%BD%AC%E7%A0%81/521c65d56803fab864000001">边录音边转码</a> - 一边录音，一边将录制成的 wav 格式音频文件转码成 amr 音频格式。只支持真机运行调试。</li>
<li><a href="https://github.com/f33chobits/FSVoiceBubble">FSVoiceBubble</a> - 一个轻量级播放录音音频的气泡：1.支持短时间的音频播放（支持网络音频）；2.播放时的声波动画；3.自定义包括声波的颜色，气泡的背景等。</li>
<li><a href="https://github.com/36Kr-Mobile/KRVideoPlayer">KRVideoPlayer</a> - 类似Weico的播放器，支持竖屏模式下全屏播放。</li>
<li><a href="http://code.cocoachina.com/view/128253">自定义视频播放器AVPlayer</a> - 利用系统类AVPlayer实现完全自定义视频播放器，显示播放时间，缓存等功能。代码清晰，注释详细。</li>
<li><a href="https://github.com/xujingzhou/VideoBeautify">VideoBeautify</a> - 功能酷似美拍,秒拍等应用的源码：对视频进行各种美化处理，采用主题形式进行分类，内含各种滤镜，动画特效和音效等。</li>
<li><a href="https://github.com/hanton/HTY360Player">HTY360Player</a> - 是一款提供在 iOS 中使用 360 度无死角拖拽视频进行不同角度播放的视频播放器。</li>
<li><a href="https://github.com/AlexLittlejohn/ALCameraViewController">ALCameraViewController</a> - ALCameraViewController 摄像头视图控制器（含可定制照片选择器，图片简单裁切功能）及演示。</li>
<li><a href="https://github.com/lfb-cd/recordDemo">recordDemo.swift</a> - 一个Swift语言实现直接可以用的录音Demo，<a href="http://www.jianshu.com/p/f0b88355d7cb">实现说明</a>。</li>
<li><a href="https://github.com/swiftcodex/Swift-Radio-Pro">Swift-Radio-Pro</a> - 集成 LastFM 的专业电台应用（基于 Swift 2.0）。</li>
<li><a href="https://github.com/coderyi/Eleven">Eleven</a> - Eleven Player - 一个使用 FFmpeg 实现的简单强大的 iOS 开源播放器。</li>
<li><a href="https://github.com/mobileplayer/mobileplayer-ios">mobileplayer-ios.swift</a> - 很不错的高度可定制播放器项目。</li>
<li><a href="https://github.com/lajos/iFrameExtractor">iFrameExtractor</a> - 开源视频播放器， ffmpeg在iOS的使用-iFrameExtractor源码解析，<a href="http://ios.jobbole.com/82408/">文章</a>。</li>
<li><a href="https://github.com/gontovnik/Periscope-VideoViewController">Periscope-VideoViewController.swift</a> - 简洁实用的视频快进、倒带控制视图类库。</li>
<li><a href="https://github.com/audiokit/AudioKit">AudioKit.swift</a> - 音频合成、加工及分析平台（支持 iOS、OS X、tvOS）框架库。无论其易用性，还是功能性及专业性。</li>
<li><a href="https://github.com/menxu/MusicPlayert">MusicPlayert</a> - MusicPlayert本地音乐播放+音乐信息显示+在线歌词搜索显示（千千静听服务器）。</li>
<li><a href="https://github.com/liuFangQiang/MusicPlayer">MusicPlayert</a> - MusicPlayert音乐播放器，用reveal可以查看层次关系，主要实现了歌词的同步显示。</li>
<li><a href="http://code.cocoachina.com/view/129435">音乐播放器</a> - 音乐播放器：显示歌词。</li>
<li><a href="https://github.com/suifengqjn/TBPlayer">TBPlayer</a> - 视频变下变播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer。<a href="http://www.jianshu.com/p/990ee3db0563">实现说明</a></li>
<li><a href="https://github.com/zhengwenming/WMPlayer">WMPlayer</a> - WMPlayer视频播放器，AVPlayer的封装，继承UIView，想怎么玩就怎么玩。支持播放mp4、m3u8、3gp、mov，网络和本地视频同时支持。全屏和小屏播放同时支持。 cell中播放视频，全屏小屏切换自如。</li>
<li><a href="https://github.com/280772270/IWatch">IWatch</a> - 一个视频日报类的app 播放器用到了AVFoudation。</li>
<li><a href="https://github.com/wubianxiaoxian/SkfSwiftCammer">SkfSwiftCammer</a> - 一个相机demo，在oc里面调用了swift。</li>
<li><a href="https://github.com/renzifeng/ZFPlayer">ZFPlayer</a> - 基于AVPlayer，支持横屏、竖屏（全屏播放还可锁定屏幕方向），上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。</li>
<li><a href="https://github.com/BrikerMan/BMPlayer">BMPlayer.swift</a> - 基于 AVPlayer 使用 Swift 封装的视频播放器，方便快速集成,支持横屏、竖屏，上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。</li>
</ul>


<hr />

<h4>响应式框架</h4>

<ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> - ReactiveCocoa 受函数响应式编程激发。不同于使用可变的变量替换和就地修改，RAC提供Signals来捕获当前值和将来值（ <a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/">使用介绍</a> ），<a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">不错的例子</a>,入门好教程：<a href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分 </a>。<a href="http://ios.jobbole.com/82232/">Reactive Cocoa 3.0 在 MVVM 中的应用</a> ,<a href="http://www.jianshu.com/p/87ef6720a096">小码哥：快速让你上手ReactiveCocoa之基础篇</a>。</li>
<li><a href="https://github.com/CrazySurfBoy/LoginWithReactiveCocoa">LoginWithReactiveCocoa</a> - ReactiveCocoa - 登录交互效果的实现。</li>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> - RxSwift:函数响应式编程框架。</li>
<li><a href="https://github.com/sunshinejr/RxPermission">RxPermission.swift</a> - 通过绑定 RxSwift 实现的 RxPermission。</li>
<li><a href="https://github.com/delba/Permission">Permission.swift</a> - 统一的 API 请求 iOS 本地设备及资源权限类库。</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveAnimation">ReactiveAnimation</a> - ReactiveCocoa 推出了一个叫 ReactiveAnimation 的子项目，直接用完全用 Swift 来实现了。</li>
<li><a href="https://github.com/gavinkwoe/BeeFramework">BeeFramework</a> -  与ReactiveCocoa类似，<a href="http://www.lanrenios.com/tutorials/all/2012/1220/641.html">BeeFramework用户指南 v1.0</a>。</li>
<li><a href="https://github.com/Tricertops/Objective-Chain">Objective-Chain</a> - Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。</li>
<li><a href="https://github.com/bppr/Swiftest">Swiftest</a> - BDD 全称 Behavior Driven Development，行为驱动开发。各种 DD 数不胜数，孰优孰劣争论不休，其实归根结底还是要根据使用场景进行选择。</li>
<li><a href="https://github.com/lovemo/MVVMFramework">MVVMFramework</a> - (OC版)总结整理下一个快速开发框架，分离控制器中创建tableView和collectionView的代码，已加入cell自适应高度，降低代码耦合，提高开发效率。<a href="https://github.com/lovemo/MVVMFramework-Swift">MVVMFramework-Swift</a> - swift版本。</li>
</ul>


<hr />

<h4>消息相关</h4>

<h5>消息推送客户端</h5>

<ul>
<li><a href="https://github.com/sagiwei/SGPush/tree/master/SGPushDemo">SGPushDemo</a> - 消息推送客户端</li>
<li><a href="https://github.com/mattt/Orbiter">Orbiter</a> - 消息推送客户端:Push Notification Registration for iOS.</li>
<li><a href="https://github.com/ios44first/PushDemo">PushDemo</a> - 客户端消息接收消息代码，<a href="http://blog.sina.com.cn/s/blog_71715bf80102uy2k.html">IOS开发之 &mdash;- IOS8推送消息注册</a> ， <a href="http://my.oschina.net/u/2340880/blog/413584">分分钟搞定IOS远程消息推送</a>。</li>
</ul>


<h5>消息推送服务端</h5>

<ul>
<li><a href="https://code.google.com/p/archive/downloads/list">javapns源代码</a> - 消息推送的java服务端代码，注意：DeviceToken中间不能有空格。</li>
<li><a href="https://github.com/stefanhafeneger/PushMeBaby">pushMeBaby</a> - Mac端消息推送端代码，注意：DeviceToken中间要有空格。</li>
</ul>


<h5>通知相关</h5>

<ul>
<li><a href="https://github.com/jessesquires/JSQNotificationObserverKit">JSQNotificationObserverKit</a> - 一款轻量、易用的通知发送及响应框架类库。作者是知名开源项目 JSQMessagesViewController（Objective-C 版即时聊天）的作者 Jesse Squires.</li>
<li><a href="https://github.com/Glow-Inc/GLPubSub">GLPubSub</a> - 一个简短实用的 NSNotificationCenter 的封装。</li>
<li><a href="https://github.com/lizyyy/Homeoff">Homeoff</a> - 用swift写了一个模仿Launcher通知中心快捷方式的应用。支持20个应用，并增加了一个返回到桌面来解放Home键的功能。</li>
<li><a href="https://github.com/jaydee3/JDStatusBarNotification">JDStatusBarNotification</a> - 在状态栏顶部显示通知。可以自定义颜色字体以及动画。支持进度显示以及显示状态指示器。</li>
<li><a href="https://github.com/100mango/SwiftNotificationCenter">SwiftNotificationCenter</a> - 一个面向协议的类型安全、线程安全、内存安全的通知中心。</li>
</ul>


<hr />

<h4>版本新API的Demo</h4>

<ul>
<li><a href="https://github.com/WildDylan/appleSample">appleSample</a> - iOS 苹果官方Demo合集， <a href="https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&amp;topic=Sample%20Code">官方demo</a>.</li>
<li><a href="https://github.com/shu223/iOS7-Sampler">iOS7-Sampler</a> - 整合了iOS7.0的一些十分有用的特性，比如：Dynamic Behaviors、碰撞检测、语音合成、视图切换、图像滤镜、三维地图、Sprite Kit（动画精灵）、Motion Effect（Parallax）、附近蓝牙或者wifi搜索连接、AirDrop、运动物体追踪（iPhone 5S以上，需要M7处理器）等等。对于日常的应用开发十分实用。</li>
<li><a href="https://github.com/shu223/iOS8-Sampler">iOS8-Sampler</a> - 日本的shuさん制作的 iOS8 参考代码集。01.Audio Effects ；02.New Image Filters；03.Custom Filters；04.Metal Basic；05.Metal Uniform Streaming；06.SceneKit；07.HealthKit；08.TouchID；09.Visual Effects；10.WebKit；11.UIAlertController；12.User Notification；13.Pedometer；14.AVKit；15.Histogram；16.Code Generator；17.New Fonts；18.Popover；19.Accordion Fold Transition</li>
<li><a href="https://github.com/shu223/iOS-9-Sampler">iOS-9-Sampler</a> - 通过实例介绍了iOS 9 SDK中重要新特性的使用。</li>
<li><a href="https://github.com/MartinRGB/MTSwift-Learning">MTSwift-Learning</a> - 通过一些简单项目实战演练开始学习 Swift 。</li>
<li><a href="https://github.com/shinobicontrols/iOS8-day-by-day">iOS8-day-by-day</a> - swift。</li>
<li><a href="https://github.com/shinobicontrols/iOS9-day-by-day">iOS9-day-by-day</a> - swfit <a href="http://www.jianshu.com/p/039f8de6ee4d">iOS9 Day-by-Day :: Day 2 :: UI Testing</a>。</li>
<li><a href="http://www.cocoachina.com/ios/20150714/12557.html">iOS 9 分屏多任务</a> - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。</li>
<li><a href="https://github.com/uraimo/uistackview-sample">uistackview-sample.swift</a> - iOS 9 引进了 UIStackViews，提供 auto-layout 特性。如果你开发过 Android 应用，会发现它和 LinearLayouts 概念上很类似，它是增强版。你可以手动创建，也可以使用 IB 自动创建，本文用的是代码实现。</li>
<li><a href="https://github.com/fish-yan/Search-APIs">Search-APIs</a> - iOS 9 学习系列: SearchAPIs。<a href="http://blog.csdn.net/fish_yan_/article/details/50635433">教程</a></li>
</ul>


<hr />

<h4>代码安全与密码</h4>

<ul>
<li><a href="https://github.com/Polidea/ios-class-guard">ios-class-guard</a> - 一个用于混淆iOS的类名、方法名以及变量名的开源库&ndash;有人反映编译出来的app运行不了。</li>
<li><a href="https://www.polidea.com/#!heartbeat/blog/Protecting_iOS_Applications">《Protecting iOS Applications》</a>：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。</li>
<li><a href="https://github.com/facebook/fishhook">fishhook</a> - fishhook是Facebook开源的一个可以hook系统方法的工具。</li>
<li><a href="https://github.com/smilingxinyi/GesturePassword">GesturePassword</a> - 一个iOS手势密码功能实现，iPad/iPhone 都可以用，没有使用图片，里面可以通过view自己添加。keychain做的数据持久化，利用苹果官方KeychainItemWrapper类。操作部分都在controller了。删除直接用一下clear。</li>
<li><a href="https://github.com/Juuman/JMPasswordView">JMPasswordView</a> - 简单实用的手势密码，效果可自行调控。</li>
<li><a href="http://code.cocoachina.com/detail/298556/%E4%BB%BF%E5%AF%86%E7%A0%81%E9%94%81-%E4%B9%9D%E5%AE%AB%E6%A0%BC/">仿密码锁-九宫格</a> - 仿密码锁-九宫格，主要是使用UIButton 手势事件  UIBezierPath画图，解锁失败弹出“密码错误”。</li>
<li><a href="https://github.com/CharlinFeng/CoreLock">CoreLock</a> - 本框架是高仿支付宝，并集成了所有功能，并非一个简单的解锁界面展示。个人制作用时1周多，打造解锁终结者框架。</li>
<li><a href="https://github.com/crazypoo/LikeAlipayLockCodeView">LikeAlipayLockCodeView</a> - 高仿支付宝手势解锁（超级版）。</li>
<li><a href="https://github.com/liu044100/Smile-Lock">Smile-Lock.swfit</a> - 一个类似于iOS的解锁界面。</li>
<li><a href="https://github.com/iosdeveloperpanc/PCGestureUnlock">PCGestureUnlock</a> - 目前最全面最高仿支付宝的手势解锁，而且提供方法进行参数修改，能解决项目开发中所有手势解锁的开发。</li>
<li><a href="https://github.com/icoder20150719/ICPayPassWordDemo">ICPayPassWordDemo</a> - CPayPassWordDemo，一个模仿支付宝支付密码输入对话框小demo。</li>
<li><a href="https://github.com/bigsan/RSAESCryptor">RSAESCryptor</a> - 加密 RSA+AES Encryption/Decryption library for iOS. This library uses 2048-bit RSA and 256-bit key with 128-bit block size AES for encryption/decryption。</li>
<li><a href="https://github.com/bringbird/TouchID">TouchID</a> - 用法简单的TouchID验证框架：两行代码搞定。</li>
<li><a href="https://github.com/OAuthSwift/OAuthSwift">OAuthSwift</a> - OAuthSwift国外主流网站OAuth授权类库。</li>
<li><a href="https://github.com/krzyzanowskim/CryptoSwift">CryptoSwift</a> - swift加密库, 支持md5,sha1,sha224,sha256&hellip;。</li>
</ul>


<hr />

<h4>测试及调试</h4>

<ul>
<li><a href="https://github.com/tapwork/HeapInspector-for-iOS">HeapInspector</a> - HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。</li>
<li><a href="http://try.crashlytics.com/">Crashlytics</a> - Crashlytics 崩溃报告 崩溃日志   <a href="http://www.infoq.com/cn/articles/crashlytics-crash-statistics-tools">使用说明</a> 。</li>
<li><a href="https://github.com/RuiAAPeres/UIViewController-Swizzled">UIViewController-Swizzled</a> - 把你进入的每一个controller的类名打出来,如果看一些特别复杂的项目的时候直接运行demo就可以知道执行次序了。</li>
<li><a href="https://code.google.com/archive/p/snoop-it/">snoop-it</a> - snoop-it比UIViewController-Swizzled好用，代码托管在google上。</li>
<li><a href="https://github.com/zenangst/Versions">Versions</a> - 版本比较小工具。</li>
<li><a href="http://code4app.com/ios/MobileWebPerformanceTest/5465d3e9933bf00c658b4f43">MobileWebPageTest</a> - MobileWebPageTest是用来测试移动网页性能的软件，它可以对页面的加载和渲染过程进行截屏，协助开发者分析出页面性能瓶颈。</li>
<li><a href="https://github.com/Coneboy-k/KKLog">KKLog</a> - 一个日志管理系统。</li>
<li><a href="https://github.com/emaloney/CleanroomLogger">CleanroomLogger</a> - 相当于 CocoaLumberjack 或 Log4j 的 Swift 版本，功能上甚至更强大。另外，源代码中已经内含了完整的 API 文档，使用非常方便。</li>
<li><a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a> - 自动测试框架 Buildasaur。</li>
<li><a href="http://www.devtf.cn/?p=739">使用Quick框架和Nimble来测试ViewControler</a> - Quick是一个用于创建BDD测试的框架。配合Nimbl，可以为你创建更符合预期目标的测试。</li>
<li><a href="https://github.com/fastlane/fastlane">fastlane</a> - 一套iOS开发和持续集成的命令行工具fastlane，可以用来快速搭建CI甚至自动提交的开发环境。这套工具中包括了上传ipa文件，自动截取多语言截屏，生成推送证书，管理产品证书等一系列实用工具。</li>
<li><a href="https://github.com/kif-framework/KIF">KIF</a> - 是一个开源的用户界面UI测试框架. 使用 KIF, 并利用 iOS中的辅助功能 API, 你将能够编写模拟用户输入，诸如点击，触摸和文本输入，自动化的UI测试.</li>
<li><a href="https://github.com/Quick/Quick">Quick</a> - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。</li>
<li><a href="https://github.com/railsware/Sleipnir">Sleipnir</a> - Swift的测试框架。</li>
<li><a href="https://github.com/kiwi-bdd/Kiwi/wiki">kiwi-bdd</a> - TDD或BDD，objective-c语言的测试框架，最流行的BDD测试框架了，Kiwi最受欢迎（根据github上的star数来推断，行为描述和期望写起来也比较易懂，至少我是这么认为的） <a href="http://www.jianshu.com/p/7e3f197504c1#">iOS开发中的测试框架</a>。</li>
<li><a href="https://github.com/specta/specta">specta</a> -  TDD或BDD，objective-c语言的测试框架，用的人多。</li>
<li><a href="https://github.com/pivotal/cedar">cedar</a> -  TDD或BDD，objective-c语言的测试框架，用的人少。</li>
<li><a href="https://github.com/daisuke0131/ViewMonitor">ViewMonitor</a> - 能够帮助 iOS 开发者们精确的测量视图, 可直接在调试应用中查看具体某个视图的坐标, 宽高等参数。</li>
<li><a href="https://github.com/adad184/MMPlaceHolder">MMPlaceHolder</a> - 一行代码显示UIView的位置及相关参数。</li>
<li><a href="https://github.com/adad184/XXPlaceHolder">XXPlaceHolder.swift</a> - MMPlaceHolder的swift版本。</li>
<li><a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a> - KMCGeigerCounter通过复杂和简单的视图演示了类似盖革计数器的帧速计算功能。掉帧通常是可见的，但是很难区分55fps和60fps之间的不同，而KMCGeigerCounter可以让你观测到掉落5帧的情况。</li>
<li><a href="https://github.com/SwiftyBeaver/SwiftyBeaver">SwiftyBeaver</a> - 一个完善的日志工具，支持彩色输出、输出内容到文件、重要性分级、多输出目标。工具执行在后台，不影响性能，可以极大提高开发效率。</li>
<li><a href="https://github.com/iachievedit/swiftlog">swiftlog</a> - 为Swift 应用提供快捷添加日志信息的方法，Swift 包管理支持（SPM）、 使用惊艳的 Rainbow 包输出彩色日志、支持写入文件。<a href="https://segmentfault.com/a/1190000004512773">使用 swiftlog</a></li>
<li><a href="https://github.com/delba/Log">Log.swift</a> - 灵活、易用、可定制输出格式和主题风格的日志类（Swift）,支持控制台彩色输出。</li>
<li><a href="https://github.com/SwiftKit/Cuckoo">Cuckoo.swift</a> - Cuckoo.swift一款用法更接近于传统单元测试 Mock 框架库（区别之处在于需要用脚本预先生成 Mock 类）。</li>
<li><a href="https://github.com/DaveWoodCom/XCGLogger">XCGLogger.swift</a> - XCGLogger.swift功能完整的日志管理类库。</li>
<li><a href="https://github.com/mindsnacks/MSLeakHunter">MSLeakHunter</a> - 自动检测 UIViewController 和 UIView 对象的内存泄露。<a href="https://github.com/Zepo/MLeaksFinder">MLeaksFinder 的使用参照</a></li>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a> - 是一个快速、简单，但很强大的日志框架。</li>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a> - 是一个快速、简单，但很强大的日志框架。</li>
<li><a href="https://github.com/hades0918/ipapy">ipapy</a> - iOS项目自动打包脚本，并且上传到fir.im，然后发送邮件给测试人员。</li>
<li><a href="https://github.com/facebook/fbretaincycledetector">fbretaincycledetector</a> - Facebook出品,通过Runtime监测循环引用。</li>
<li><a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a> - Facebook出品,内存检测库。<a href="http://ifujun.com/fbmemoryprofiler-shi-yong-ji-chu-jiao-cheng/">FBMemoryProfiler 基础教程</a>。</li>
<li><a href="https://github.com/facebook/FBAllocationTracker">FBAllocationTracker</a> - Facebook出品,跟踪oc对象的分配情况。</li>
<li><a href="https://github.com/facebook/xctool">xctool</a> - Facebook出的自动化打包工具，它规范了输出的log日志，而且一些错误信息也更为清晰一些。</li>
<li><a href="https://github.com/shaps80/Peek">Peek.swift</a> - 更友好、手势方式检查界面内组件布局信息（相当于浏览器元素检查功能），界面调试利器。</li>
</ul>


<hr />

<h4>动态更新</h4>

<ul>
<li><a href="https://github.com/mmin18/WaxPatch">waxPatch</a> - 大众点评的屠毅敏同学在基于<a href="https://github.com/probablycorey/wax">wax</a>的基础上写了waxPatch，这个工具的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。</li>
<li><a href="https://github.com/bang590/JSPatch">JSPatch</a> - JSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。<a href="https://github.com/bang590/JSPatch">官网</a>。(JSPatchX)[<a href="https://github.com/bang590/JSPatchX">https://github.com/bang590/JSPatchX</a>] JSPatch的XCode 代码补全插件。</li>
<li><a href="https://github.com/casatwy/CTJSBridge">CTJSBridge</a> - JCTJSBridge：a javascript bridge for iOS app to interact with h5 web view。</li>
</ul>


<hr />

<h4>AppleWatch</h4>

<ul>
<li><a href="https://github.com/eleks/rnd-apple-watch-tesla">Tesla汽车AppleWatch app demo演示</a> - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/kostiakoval/WatchKit-Apps">WatchKit-Apps</a> - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。</li>
<li><a href="https://github.com/KittenYang/KYVoiceCurve">KYVoiceCurve</a> - 类似Apple Watch中语音的声音曲线动画。</li>
<li><a href="https://github.com/facebookarchive/IGInterfaceDataTable">IGInterfaceDataTable</a> - IGInterfaceDataTable是WKInterfaceTable对象的一个类别，可以让开发者更简单地配置多维数据。该项目使用类似UITableViewDataSource的数据源模式配置Apple Watch表格，而不是将数据结构扁平化成为数组。</li>
<li><a href="http://www.swiftkiller.com/?p=613">Apple Watch开发教程资料汇总</a> - Apple Watch开发教程资料汇总。</li>
<li><a href="https://github.com/contentful-labs/Stargate">Stargate</a> - 通过 iPhone 桥接实现 Mac 与 Watch 的即时通讯。Stargate 通过封装两个优秀的基础类库 MMWormhole 和 PeerKit 实现高效的通讯应用。&ndash;swift</li>
<li><a href="https://github.com/sandofsky/soon">soon</a> - 一款倒计时 WatchKit 示例应用。作者从架构的角度，思考如何设计一款完整、通讯高效且性能又好的 WatchKit 扩展应用。该示例学习性非常强。&ndash;swift</li>
<li><a href="https://github.com/shu223/watchOS-2-Sampler">watchOS-2-Sampler</a> - 基于 watchOS 2 若干新特性，写了相应的示例代码供大家学习、参考。</li>
<li><a href="https://github.com/KhaosT/HMWatch">HMWatch</a> - HMWatch是个有待完善的watchOS 2.0 HomeKit 应用示例。</li>
<li><a href="https://github.com/manavgabhawala/CocoaMultipeer">CocoaMultipeer</a> - CocoaMultipeer这个开源框架支持OS X, iOS和watchOS设备间的点对点通信，解决watchOS和Mac之间通信的方案还是很有用的。</li>
<li><a href="https://github.com/GetHighstreet/HighstreetWatchApp">HighstreetWatchApp</a> - 是电商平台Highstreet针对App Watch的一款应用，该demo中加载的是虚拟数据。</li>
<li><a href="https://github.com/NilStack/NKWatchChart">NKWatchChart</a> - NKWatchChart是一个基于PNChart专门为Apple Watch 开发的图表库,目前支持 line, bar, pie, circle 和 radar 等 图表形式。</li>
<li><a href="https://github.com/diwu/BeijingAirWatch">BeijingAirWatch</a> - 国人的开源项目代码 ！WatchOS 2.0 Complication of Real-time Air Quality for Major Chinese Cities 苹果表盘实时刷新北上广沈蓉空气质量。</li>
<li><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole.swift</a> - MMWormhole.swift:iOS或OS X扩展与宿主应用的通讯框架。</li>
</ul>


<hr />

<h4>VPN</h4>

<ul>
<li><a href="https://github.com/lexrus/vpnon/">vpnon</a> - swift的VPN On 的源码和本地化内容都是开放的: <a href="https://crowdin.com/project/vpnon">官方网站</a>。</li>
<li><a href="https://github.com/CatchChat/Hydro.network">Hydro.network</a> - <a href="http://blog.zhowkev.in/2015/03/09/hydro-network-de-kai-fa-lu-cheng/">Hydro.network 的开发旅程</a>, <a href="https://gitcafe.com/Catch/Hydro.network">gitcafe</a>。</li>
</ul>


<hr />

<h4>完整项目</h4>

<ul>
<li><a href="https://github.com/gsdios/GSD_WeiXin">GSD_WeiXin</a> 高仿微信</li>
<li><a href="https://github.com/singro/v2ex">v2ex</a> - v2ex 的客户端，新闻、论坛。</li>
<li><a href="https://github.com/Finb/V2ex-Swift">V2ex-Swift</a> - 用 Swift 写的 V2EX 客户端。</li>
<li><a href="https://github.com/iAugux/iBBS-Swift">iBBS-Swift</a> - “新手开源一个用Swift（2.0）写的论坛客户端”。<a href="http://obbs.sinaapp.com/">BBS 服务端</a>。</li>
<li><a href="https://github.com/wikimedia/wikipedia-ios">wikipedia-ios</a> - wikipedia-ios 客户端。</li>
<li><a href="https://github.com/uber/jetstream-ios">jetstream-ios</a> - 一款 Uber 的 MVC 框架。它同时提供了多用户实时通讯支持，一旦启动 JetStream 后端服务，通过 WebSocket 协议可以分分钟建立多用户实时通讯应用。</li>
<li><a href="https://github.com/jpsim/DeckRocket">DeckRocket</a> - 在相同 WiFi 网络环境内，通过iPhone 控制并播放 Mac 中的 PDF 文档。</li>
<li><a href="https://github.com/JayFang1993/ScanBook">ScanBook</a> - 扫扫图书:可以扫描条形码查询图书，也可以关键字搜索，遇到合乎你口味的书，还可以看看别人的读书笔记，不同角度去体会。</li>
<li><a href="https://github.com/MengTo/DesignerNewsApp">DesignerNewsApp</a> - Swift 开发的 DesignerNews 客户端，看着美美的！</li>
<li><a href="https://github.com/KittenYang/KYWeibo">KYWeibo</a> - 调用新浪API自己写的第三方微博客户端。</li>
<li><a href="https://github.com/li6185377/DouQu_IOS">DouQu_IOS</a> - 逗趣IOS手机端（一款笑话软件）,拥有完整的功能的手机应用app 。</li>
<li><a href="https://github.com/itjhDev/itjh">IT江湖iOS客户端</a> - IT江湖iOS客户端。</li>
<li><a href="https://github.com/artsy/eidolon">Eidolon</a> - 艺术品拍卖的投标亭平台，用swift与反应式编程框架 ReactiveCocoa。</li>
<li><a href="https://github.com/nonstriater/CrazyPuzzle">CrazyPuzzle</a> - 模仿“看图猜成语”App，功能齐全，配有音效，效果很不错。游戏使用cocoa框架完成，没有使用cocos2d的框架。</li>
<li><a href="https://github.com/Tim9Liu9/WhoCall">WhoCall</a> - 谁CALL我，iOS来电信息语音提醒，无需越狱。（需要iOS 7.0及以上版本。)骚扰电话预警、来电归属地提醒、联系人姓名播报，这些有中国特色人性化的电话功能，iOS上也应该有。电话提醒、私有API。</li>
<li><a href="http://www.devtf.cn/?p=562">仿iOS猎豹垃圾清理(实现原理+源码)</a> -  仿iOS猎豹垃圾清理(实现原理+源码),用到私有API。</li>
<li><a href="https://github.com/sam408130/DSLolita">DSLolita</a> - 模仿新浪微博做的一款app，有发送博文，评论，点赞，私聊功能。</li>
<li><a href="https://github.com/STShenZhaoliang/STPhotoBrowser">STPhotoBrowser</a> - 高仿新浪微博的图片浏览器，极佳的编写方式，易扩展，低耦合。</li>
<li><a href="https://github.com/gsdios/GSD_ZHIFUBAO">GSD_ZHIFUBAO</a> - 支付宝高仿版。</li>
<li><a href="https://github.com/thoughtbot/Tropos">Tropos</a> - Tropos, 由 thoughtbot 推出的一款用 Objective-C 写的开源天气类应用, 截至今天, thoughtbot 已在 GitHub 上贡献了 174 个开源项目, 实在令人敬佩。</li>
<li><a href="https://github.com/liu044100/SmileWeather">SmileWeather</a> -开源天气类应用,天气图标很完整。</li>
<li><a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> - GitBucket 2.0 通过审核啦，她是我在公司实践了一年多 MVVM 和 RAC 的基础上，利用业余时间开发的第三方 GitHub 客户端，旨在能够对想实践 MVVM 和 RAC 的 iOS 开发者有所帮助。<a href="https://itunes.apple.com/cn/app/id961330940?mt=8">AppStore地址</a>，欢迎下载使用GitBucket和收藏MVVMReactiveCocoa。</li>
<li><a href="https://github.com/dasdom/Tomate">Tomate</a> - 这个圆盘式计时器让你更专注于工作或学习。P.S. App Store 上架收费应用（0.99 欧）。</li>
<li><a href="https://github.com/joeshang/StoveFireiOSMenu">StoveFireiOSMenu</a> - 炉火餐饮系统iPad点餐端。</li>
<li><a href="https://github.com/belm/BaiduFM-Swift">BaiduFM-Swift</a> - 百度FM, swift语言实现，基于最新xcode6.3+swift1.2,初步只是为了实现功能，代码比较粗燥，后面有时间会整理，支持Apple Watch。</li>
<li><a href="https://github.com/ZhongTaoTian/WNXHuntForCity">WNXHuntForCity</a> - iOS高仿城觅项目（开发思路和代码）。</li>
<li><a href="https://github.com/zyprosoft/ZYChat">ZYChat</a> - 关于聊天界面的可消息类型扩展，响应绑定设计。</li>
<li><a href="https://github.com/lookingstars/meituan">meituan</a> - 美团5.7iOS版（高仿），功能包括，团购首页，高德地图搜索附近美食并显示在地图上，上门服务，商家，友盟分享。</li>
<li><a href="https://github.com/zangqilong198812/MeituanDemo">MeituanDemo</a> - 造美团应用界面构建的 iOS 应用, 第一个是 @叶孤城___ 的 MeituanDemo。</li>
<li><a href="https://github.com/tubie/JFMeiTuan">JFMeiTuan</a> - 造美团应用界面构建的 iOS 应用, 第二个是 @tubiebutu 的 JFMeiTuan。</li>
<li><a href="https://github.com/lookingstars/chuanke">chuanke</a> - 高仿百度传课iOS版。</li>
<li><a href="https://github.com/aiqiuqiu/Tuan">Tuan</a> - 模仿MJ老师iPad版美团（swift版），偶有bug 见谅。</li>
<li><a href="https://github.com/dsxNiubility/SXNews">SXNews</a> - 模仿网易新闻做的新闻软件，完成了主导航页，新闻详情页，图片浏览页，评论页。效果不错，比网上流传的各种和网易新闻UI架构有关的代码都要完整，都要好。</li>
<li><a href="https://github.com/coderyi/Monkey">Monkey</a> - Monkey for GitHub是一个GitHub开发者和仓库排名的开源App。这次主要增加了登录GitHub的功能，随手follow和star，并且增加发现模块，包括GitHub的trending，动态，showcases等。</li>
<li><a href="https://github.com/callmewhy/Uther">Uther</a> -  跟蠢萌的外星人聊天，还能帮你记事”。<a href="https://itunes.apple.com/cn/app/uther/id1024104920">itunes下载</a> 。</li>
<li><a href="https://github.com/zixun/CocoaChinaPlus">CocoaChinaPlus</a> - CocoaChina+是一款开源的第三方CocoaChina移动端。整个App都用Swift2.0编写(除部分第三方OC代码外，比如JPush和友盟)。</li>
<li><a href="http://code.cocoachina.com/view/128246">高仿斗鱼TV</a> - 高仿斗鱼TV，点击头部滚动视图可以播放视频。</li>
<li><a href="https://github.com/LonelyTown/LXZEALER">LXZEALER</a> - 模仿着做了zealer客户端,App里几乎所有请求都是Post,所以内容都是固定的URL加载的,登录功能只做了微博的第三方登录。</li>
<li><a href="https://github.com/pengleelove/ShiXiSeng_ios">ShiXiSeng_ios</a> - 完整app的UI框架。</li>
<li><a href="https://github.com/Coding/Coding-iPad">Coding-iPad</a> - Coding-iPad 是@Coding的官方 iPad 客户端, 又是一个完整的开源应用。</li>
<li><a href="https://github.com/likumb/SimpleMemo">SimpleMemo</a> - 易便签已经转到Swift2.0，全面适配iOS9和Watch OS2，并支持iPhone6s和iPhone6sPlus的3D Touch功能，包括图标快捷键和内容预览。</li>
<li><a href="https://github.com/xxycode/XXYAudioEngine">XXYAudioEngine.swift</a> - 基于NSURLSession 和 AVAudoPlayer的在线音乐的工具，可以把音乐保存在本地，也可以支持后台播放，后台下载，最低支持iOS7，swift版本1.2。</li>
<li><a href="https://github.com/twitterdev/furni-ios">furni-ios.swift</a> - furni-ios.swift是由 Twitter 开发团队出品的一款用 Swift 写的 iOS 家居商城应用, 其主要目的在于让开发者从这款 Demo 应用中看出 Fabric 的强大。</li>
<li><a href="https://github.com/sheepy1/SelectionOfZhihu">SelectionOfZhihu.swift</a> - 『看知乎』iOS 客户端, <a href="http://www.jianshu.com/p/2c3a0f109788">项目说明</a>。</li>
<li><a href="https://github.com/TigerWf/WFZhiHu">WFZhiHu</a> - WFZhiHu仿知乎日报客户端app。</li>
<li><a href="https://github.com/zpz1237/NirZhihuDaily2.0">NirZhihuDaily2.0_swift</a> - 精仿了知乎日报iOS端练手，Swift2.0，注释相当详细。</li>
<li><a href="https://github.com/CatchChat/Yep">Yep.swift</a> - Yep 一个由天才开发给天才们使用的社交软件。</li>
<li><a href="https://github.com/ZhongTaoTian/LoveFreshBeen">LoveFreshBeen.swift</a> - 高仿爱鲜蜂 - Swift2.0</li>
<li><a href="https://github.com/ZhongTaoTian/LoveFreshBeen">trySwiftApp.swift</a> - trySwiftApp一款较为完整的会议原型应用。有需求的同学可以做为开发参考。</li>
<li><a href="https://github.com/gaowanli/PinGo">PinGo.swift</a> - PinGo.swift：纯Swift编写的仿“随遇”App。</li>
<li><a href="https://github.com/ZeroJian/UmbrellaWeather">UmbrellaWeather.swift</a> - UmbrellaWeather.swift使用 Swift 编写的一款天气应用,现已上架 AppStore。</li>
<li><a href="https://github.com/JakeLin/SwiftWeather">SwiftWeather</a> - SwiftWeather清新淡雅持续改进天气预报项目。</li>
<li><a href="https://github.com/iAugux/Phonetic">Phonetic.swift</a> - Phonetic一个 iOS 版的 Phonetic Contacts，功能很多，其中昵称功能非常实用，已在 GitHub 开源并上架 App Store。</li>
<li><a href="https://github.com/tnantoka/edhita">edhita.swift</a> - edhita.swift支持Markdown, HTML预览的文本编辑器。</li>
<li><a href="https://github.com/cornerAnt/PilesSugar">PilesSugar.swift</a> - PilesSugar.swift:Swift高仿项目,堆糖。</li>
<li><a href="https://github.com/xiekw2010/react-native-gitfeed">react-native-gitfeed</a> - 目前最实用简洁的github客户端了。</li>
<li><a href="https://github.com/Aufree/phphub-ios">phphub-ios</a> - PHPHub的iOS客户端，同时兼容iPhone和iPad。</li>
<li><a href="https://github.com/pepibumur/SoundCloudSwift">SoundCloudSwift</a> - SoundCloud的Swift版本，采用Swift2.0，Reactive API with ReactiveCocoa 4.0。</li>
<li><a href="https://github.com/HarrisHan/LeagueofLegends">LeagueofLegends</a> - 一个关于英雄联盟的完整iOS开源项目，接口均来自多玩，腾讯各大游戏平台。</li>
<li><a href="https://github.com/wenghengcong/Coderpursue">Coderpursue.swift</a> - 一款 Github 第三方客户端，使用最新 Swift 语言编写。</li>
<li><a href="https://github.com/Ryan0520/BTApp">BTApp</a> - BTApp 仿半糖 iOS App 的 Demo 应用。</li>
<li><a href="http://www.henishuo.com/ios-app-fully-code/">iOS完整App资源收集</a> - iOS开发学习者都希望得到实战训练，但是很多资料都是只有一小部分代码，并不能形成完成的App，笔者在此处收集了很多开源的完整的App，都有源代码哦！&ndash;标哥的技术博客</li>
<li><a href="https://github.com/callmejoejoe/XCFApp">XCFApp-1</a> - 高仿下厨房App，Objective-C，Xcode7.2，数据通过Charles抓的，有接口也有本地数据。说明：关于代码被清空，会用git的你肯定明白，<a href="http://www.jianshu.com/p/a8f619a2c622/">教程</a></li>
<li><a href="https://github.com/STShenZhaoliang/XCFAPP">XCFApp-2</a> - 高仿下厨房APP。</li>
<li><a href="https://github.com/YouXianMing/YoCelsius">YoCelsius</a> - 已经上线的一款天气预报的应用,几乎所有的交互动画效果，想学习动画的开发人员可以作为参考。</li>
<li><a href="https://github.com/HansRove/XiMaLaYa-by-HansRove-">XiMaLaYa-by-HansRove-</a> - 仿喜马拉雅FM, 对AVFoundation框架的一次尝试，采用MVVM模式，<a href="http://ios.jobbole.com/85275/">教程</a>。</li>
</ul>


<hr />

<h4>好的文章</h4>

<ul>
<li><a href="http://www.jianshu.com/p/38cd35968864">自定义转场动画</a> - 3 种方法～ 关于自定义转场动画。</li>
<li><a href="https://github.com/icepy/_posts/blob/master/iOS%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7.md">iOS提高效率的方法和工具</a> - iOS提高效率的方法和工具。</li>
<li><a href="http://jsonapi.org.cn/">用 JSON 构建 API 的标准指南</a> - 用 JSON 构建 API 的标准指南。</li>
<li><a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/">RxSwift入坑手册</a> - RxSwift入坑手册。</li>
<li><a href="http://miketech.it/ios-transparent-viewcontroller/">iOS创建半透明ViewController</a> - iOS创建半透明ViewController。</li>
<li><a href="http://www.jianshu.com/p/cda4b0fe07e0">Xcode使用技巧</a> - SwiftGG 交流分享：Xcode使用技巧。</li>
<li><a href="http://www.cocoachina.com/ios/20160219/15301.html">iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍</a> - <a href="http://www.cocoachina.com/ios/20150915/13454.html">iOS蓝牙开发（一）蓝牙相关基础知识</a>,<a href="http://www.cocoachina.com/ios/20160217/15294.html">iOS蓝牙开发（二）：iOS连接外设的代码实现</a>,<a href="http://www.cocoachina.com/ios/20160218/15299.html">iOS蓝牙开发（三）：App作为外设被连接的实现</a>。</li>
<li><a href="http://blog.adorkabledean.cn/blog/20151027/tong-ji-xiang-mu-zhong-tu-pian-shi-yong-qing-kuang/">统计项目中图片使用情况</a> - 统计项目中图片使用情况;工具：<a href="http://jeffhodnett.github.io/Unused/">Unused</a>:找出项目中未使用的图片, Unused 的基础上改了一下的<a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a>;工具：<a href="https://imageoptim.com/">ImageOptim</a> 图片保真压缩。【iOS图片压缩工具】效率最高的是<a href="http://www.alfredforum.com/topic/1520-tiny-png-workflow-updated-to-v12/">tiny-png</a>:在线压缩，前500张免费。</li>
<li><a href="http://ios.jobbole.com/83952/">iOS推送之远程推送</a> 、<a href="http://ios.jobbole.com/83949/">iOS推送之本地推送</a>。</li>
<li><a href="http://www.cocoachina.com/ios/20151019/13761.html">动态部署方案</a> - iOS应用架构谈动态部署方案。</li>
<li><a href="https://github.com/AntBranch/awesome-github">awesome-github</a> - awesome-github:收集这个列表，只是为了更好地使用亲爱的GitHub。</li>
<li><a href="http://www.jianshu.com/p/fccba7be1ca1">ReactiveCocoa 4 文档翻译目录</a> - ReactiveCocoa 4 文档翻译目录。</li>
<li><a href="http://geek.csdn.net/news/detail/58593">Swift编程的15个技巧</a> - Swift编程的15个技巧。</li>
<li><a href="http://www.cocoachina.com/ios/20160304/15558.html">每个Xcode开发者应该知道的七个使用技巧</a> - 每个Xcode开发者应该知道的七个使用技巧。</li>
<li><a href="http://blog.jobbole.com/94261/">腾讯力作！超实用的iOS 9人机界面指南</a> - 腾讯力作！超实用的iOS 9人机界面指南。</li>
<li><a href="http://ios.jobbole.com/84956/">iOS开发-超链接富文本案</a> - iOS开发-超链接富文本。</li>
<li><a href="https://segmentfault.com/a/1190000005112043">UIView+RedPoint实现底部UITabBarItem和控件的右上角显示和隐藏红点/数字的需求</a> -</li>
<li><a href="www.jianshu.com/p/54bbacfcc31b">使用GCD实现和封装分组并发网络请求</a> - 使用GCD实现和封装分组并发网络请求。</li>
<li><a href="http://www.jianshu.com/p/1d354feacf3c">微信语音连播的实现思路</a> - 微信语音连播的实现思路。</li>
<li><a href="http://www.jianshu.com/p/b422d92738ac">UITableView 手势延迟导致subview无法完成两次绘制</a> - UITableView 手势延迟导致subview无法完成两次绘制。</li>
</ul>


<hr />

<h4>Xcode插件</h4>

<ul>
<li><a href="http://www.cocoachina.com/special/xcode/">iOS开发进阶，从Xcode开始</a> - 学习使用Xcode构建出色的应用程序！</li>
<li>在Xcode启动的时候，Xcode将会寻找位于~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中的后缀名为.xcplugin的bundle作为插件进行加载（运行其中的可执行文件）。<a href="http://studentdeng.github.io/blog/2014/02/21/xcode-plugin-fun/">Xcode5 Plugins 开发简介</a>  <a href="http://joeyio.com/ios/2013/07/25/write_xcode4_plugin_of_your_own/">写个自己的Xcode4插件</a></li>
<li><a href="https://www.onevcat.com/2013/02/xcode-plugin/">Xcode 4 插件制作入门</a> - Xcode 4 插件制作入门:Xcode所使用的所有库都包含在Xcode.app/Contents/的Frameworks，SharedFrameworks和OtherFrameworks三个文件夹下。其中和Xcode关系最为直接以及最为重要的是Frameworks中的IDEKit和IDEFoundation，以及SharedFrameworks中的DVTKit和DVTFoundation四个。</li>
<li><a href="https://github.com/rickytan/RTImageAssets">RTImageAssets</a> - 一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本。<a href="https://itunes.apple.com/app/asset-catalog-creator-free/id866571115?mt=12">Asset Catalog Creator</a> 功能强大，能自动生成全部尺寸：包括App Icons、Image Sets、Launch Screens Generator。</li>
<li><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a> - 一个Xcode插件，build后，随手打开一个你之前的项目，然后在任意一个方法上面连按三下"/&ldquo;键盘，就ok了。</li>
<li><a href="https://github.com/Jintin/Swimat">Swimat</a> - Swimat，是一款Xcode 插件，帮你一键格式化 swift 代码。</li>
<li><a href="https://github.com/shjborage/Reveal-Plugin-for-XCode">Reveal-Plugin-for-XCode</a> - 一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。<a href="http://security.ios-wiki.com/issue-3-4/">Reveal：分析iOS UI的利器</a> 。</li>
<li><a href="https://github.com/google/j2objc">java2Objective-c</a> - Google公司出得java转Obje-C转换工具，转换逻辑，不转换UI。</li>
<li><a href="https://github.com/kzaher/RegX">RegX</a> - 专治代码强迫症的 Xcode 插件，使用 Swift 和 Objective-C 编写。其用竖向对齐特定源代码的元素，使得代码更易读和易理解。<a href="http://www.cocoachina.com/ios/20141224/10743.html">说明</a> ； 菜单：xcode——》Edit-》Regx 。</li>
<li><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed</a> - 自动完成，特别是如果你正在写Objective-C，如果Xcode能自动完成文件名难道不会很伟大吗？比如图像文件的名称。</li>
<li><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocomplete</a> - Xcode的实现自动完成还不完美，此插件能给出你所期望或想要的建议，设置：xcode-》Editor-》FuzzyAutocomplete-》plugin settings。</li>
<li><a href="https://github.com/johnno1962/GitDiff">GitDiff</a> - Xcode的代码编辑器的一个微妙的补强，加上了足够的可见信息以了解上次git提交以来发生了什么变化，设置：xcode-》Edit-》GitDiff。</li>
<li><a href="https://github.com/trawor/XToDo">XToDo</a> - 这个插件不仅凸显TODO，FIXME，???，以及！！！注释，也在便利列表呈现他们。 菜单：xcode-》view-》snippets;   调出列表显示: xcode-》view-》ToDo List ： ctrl + T 。</li>
<li><a href="https://github.com/limejelly/Backlight-for-XCode">Backlight</a> - 突出显示当前正在编辑的行。菜单：xcode-》view-》Backlight 。</li>
<li><a href="https://github.com/kattrali/cocoapods-xcode-plugin">CocoaPods</a> - 该CocoaPods的插件增加了一个CocoaPods菜单到Xcode的产品菜单。如果你不喜欢命令行，那么你一定会喜欢这个插件。 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做iOS程序的依赖管理 </a>。</li>
<li><a href="https://github.com/markohlebar/Peckham">Peckham</a> - 添加import语句比较麻烦，此插件 按Command-Control-P，给出的选项列表中选择要的头文件。先要安装<a href="http://alcatraz.io/">Alcatraz</a> ,在终端输入： <strong>curl -fsSL <a href="https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh">https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh</a> | sh</strong> ； 重启xcode-》window-》Package Manager：搜索 <strong>Peckham</strong> 安装，打开Peckham.xcodeproj，编译 Peckham target，重启Xcode 。</li>
<li><a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode">Auto-Importer</a> - Auto-Importer是一个自动导入类对应的头文件的Xcode插件。</li>
<li><a href="http://alcatraz.io/">Alcatraz</a> -使用Alcatraz来管理Xcode插件 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/03/05/use-alcatraz-to-manage-xcode-plugins/">使用说明</a> 。</li>
<li><a href="https://github.com/kimsungwhee/KSHObjcUML">KSHObjcUML</a> -KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。</li>
<li><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense-for-Xcode</a> - 颜色插件，安装之后，就不用根据RGB选择颜色，直接从取色板中取颜色，会自动补齐RGB代码。</li>
<li><a href="http://www.codeceo.com/article/10-ios-xcode-plugins.html">10款提高iOS开发效率的XCode插件</a> - 10款提高iOS开发效率的XCode插件：1. XcodeColors；5. ACCodeSnippetRepository；10. <a href="https://github.com/omz/Dash-Plugin-for-Xcode">Dash for Xcode</a>。</li>
<li><a href="https://github.com/MakeZL/ZLGotoSandboxPlugin">ZLGotoSandboxPlugin</a> - 支持Xcode快捷键了跳转当前应用沙盒了！快捷键是 Shift+Common+w。</li>
<li><a href="https://github.com/burczyk/XcodeSwiftSnippets">XcodeSwiftSnippets</a> - XcodeSwiftSnippets, 提供了很多可在 Xcode 上使用的 Swift 代码片段, 通过自动补全的方式极大的提高了开发效率， <a href="https://github.com/Xcode-Snippets/Objective-C">另外还有 Objective-C 版的</a>。</li>
<li><a href="https://vimeo.com/128713880">CoPilot</a> - 通过此插件， Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。</li>
<li><a href="https://github.com/EnjoySR/ESJsonFormat-Xcode">ESJsonFormat-Xcode</a> - 将Json格式化输出为模型的属性。</li>
<li><a href="https://github.com/stefanceriu/SCXcodeMiniMap">SCXcodeMiniMap</a> - Xcode迷你小地图-SCXcodeMiniMap。</li>
<li><a href="http://code.cocoachina.com/detail/316095/xTransCodelation/">xTransCodelation</a> - XCODE中英文翻译插件，提供API查询模式和网页模式，都是利用的百度翻译。另外集成了一个可以一键关闭其他所有APP的实用功能，方便开发者！</li>
<li><a href="https://github.com/jwaitzel/SuggestedColors/">SuggestedColors</a> - Xcode 插件SuggestedColors，用于 IB颜色设置 辅助插件，非常好用。</li>
<li><a href="https://github.com/paulot/Colorsp">Colors</a> - 打印彩色字符串，可以修改 Swift 中终端输出的字符串颜色，有趣的小工具。</li>
<li><a href="https://github.com/Sephiroth87/Crayons">Crayons</a> - Xcode调色板增强插件。</li>
<li><a href="https://github.com/johnno1962/injectionforxcode">injectionforxcode</a> - Injection for Xcode：成吨的提高开发效率,<a href="http://www.jianshu.com/p/27be46d5e5d4">使用说明</a>。</li>
<li><a href="https://github.com/kaphacius/IconMaker">IconMaker</a> - 只需要一步，自动生成不同尺寸的App icon。超级方便。</li>
<li><a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode">BuildTimeAnalyzer-for-Xcode</a> - 实用的编译时间分析 Xcode 插件。</li>
<li><a href="https://github.com/music4kid/FastStub-Xcode">FastStub-Xcode</a> - 一只快速生成代码的Xcode插件，<a href="http://mrpeak.cn/blog/faststub/">说明</a>。</li>
<li><a href="https://github.com/EnjoySR/ESTranslate-Xcode">ESTranslate-Xcode</a> - 一个快速翻译Xcode代码里面单词(我主要用于翻译句子～)的插件，快捷键：Ctrl+Shift+T。</li>
</ul>


<hr />

<h4>美工资源</h4>

<ul>
<li><a href="https://github.com/markohlebar/Peckham">TWG_Retina_Icons</a> - 一套支持 Retina 高清屏的 iPhone 免费图标集。</li>
<li><a href="https://github.com/cparnot/ASCIImage">ASCIImage</a> - 使用 NSString 创建 image，<a href="http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring/">说明</a>。</li>
<li><a href="https://github.com/RayPS/my-sketch-colors">my-sketch-colors</a> - 配色。</li>
<li><a href="http://www.imooc.com/wenda/detail/250367">Font Awesome</a> - Font Awesome：一套绝佳的图标字体库和CSS框架，详细的安装方法请参考<a href="http://fortawesome.github.io/Font-Awesome/icons/">官方网站</a><a href="http://fontawesome.dashgame.com/">中文网站</a>,<a href="https://github.com/FortAwesome/Font-Awesome">GitHub地址</a> 。</li>
<li><a href="https://github.com/yannickl/DynamicColor">DynamicColor</a> - 强大的颜色操作扩展类。通过该类，你可以通过扩展方法基于某个颜色得到不同深浅、饱和度、灰度、色相，以及反转后的新颜色。是不可多得的好类库。</li>
<li><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a> - Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。</li>
<li><a href="https://github.com/ArtSabintsev/FontBlaster">FontBlaster</a> - 载入定制字体时更简单。</li>
</ul>


<h4>其他资源</h4>

<ul>
<li><a href="http://githuber.info/#/index">githuber</a> - 最好用的GitHub人才搜索工具。</li>
<li><a href="https://www.codatlas.com">codatlas</a> - 源代码搜索利器。</li>
<li><a href="https://searchcode.com/">searchcode</a> - 源代码搜索利器：来自悉尼的代码搜索引擎汇聚了 Github, Bitbucket, Sourceforge&hellip;等多家开源站点超20万个项目、180亿行源代码，能以特殊字符、语言、仓库和源方式从90多种语言找到函数、API的真实代码。</li>
<li><a href="https://github.com/docker/kitematic">kitematic</a> - Mac 上使用 Docker 最简单的方案。</li>
</ul>


<hr />

<h4>开发资源</h4>

<h5>开发资料</h5>

<ul>
<li><a href="https://www.douban.com/note/276160185/?type=like">豆瓣iOS开源库列表</a> - 豆瓣iOS开源库列表，很多开源项目。</li>
<li><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques">iOS-Core-Animation-Advanced-Techniques</a> - 中文版iOS 高级动画技术。</li>
<li><a href="http://www.jianshu.com/p/50b63a221f09">iOS开发的一些奇巧淫技1</a> - TableView不显示没内容的Cell怎么办; 键盘事件：<a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a>;  app不流畅:<a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a>;  CoreData用起来好烦:<a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a>;  CollectionView实现悬停的header:<a href="https://github.com/jamztang/CSStickyHeaderFlowLayout">CSStickyHeaderFlowLayout</a>。</li>
<li><a href="http://www.jianshu.com/p/08f194e9904c">iOS开发的一些奇巧淫技2</a> -  用一个pan手势来代替UISwipegesture的各个方向、拉伸图片、播放GIF、上拉刷新、把tableview里cell的小对勾的颜色改变、navigationbar弄成透明的而不是带模糊的效果、改变uitextfield placeholder的颜色和位置。</li>
<li><a href="http://code4app.com/article/cocoapods-install-usage">cocoapods安装指南</a> - cocoapods安装指南。</li>
<li><a href="https://github.com/johnno1962/Remote">RemoteControl</a> - Control your iPhone from inside Xcode for end-to-end testing 。</li>
<li><a href="http://objccn.io/issue-13-1/">MVVM 介绍</a> - 替换MVC的开发模式。</li>
<li><p><a href="http://apistore.baidu.com/astore/index">第三方接口</a> - 基本所有第三方接口都在这，再也不用那么麻烦去找了。</p></li>
<li><p><a href="http://yyny.me/ios/%E6%8F%90%E9%AB%98iOS%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7/">提高iOS开发效率的方法和工具</a> - 提高iOS开发效率的方法和工具。</p></li>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a> - 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）。</li>
<li><a href="http://www.imooc.com/article/1216">Objective-C编码规范：26个方面解决iOS开发问题</a> - 【Objective-C编码规范：26个方面解决iOS开发问题：“我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。”今天分享的规范来自raywenderlich.com团队成员共同完成的，希望对学习OC的朋友们有所指导和帮助。</li>
</ul>


<h6>swift</h6>

<ul>
<li><a href="http://dev.swiftguide.cn/archive/featured-open-source-projects-in-swift_v1.0.html">Swift 开源项目精选－v1.0</a> - Swift 开源项目精选－v1.0。</li>
<li><a href="https://github.com/ipader/SwiftGuide/blob/master/Featured.md">Swift开源项目精选</a> - Swift开源项目精选&ndash;推荐，每周都有更新。</li>
<li><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese">Swift中文指南</a> - 中文版Apple官方Swift教程《The Swift Programming Language》，<a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/">老码版本</a>  <a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter1/03_revision_history.html">历史版本更新说明</a>。</li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/">The Swift Programming Language 中文版</a> - The Swift Programming Language 中文版。</li>
<li><a href="http://www.swifttoolbox.io/">swifttoolbox</a> -  swifttoolbox swift开发的开源库汇总。</li>
<li><p><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a> -  这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排&ndash; 非常不错，值得推荐。</p></li>
<li><p><a href="https://swift.zeef.com/robin.eggenkamp">Awesome Swift</a> - 一个收集了很多 Swift 开发资源的网站。</p></li>
<li><a href="https://github.com/CS193P-Translation-Group/Developing_iOS_8_Apps_With_Swift">Developing_iOS_8_Apps_With_Swift</a> - Developing iOS 8 Apps with Swift 字幕简体中文翻译项目（斯坦福白胡子老头swift教学视频）。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS">Swift-On-iOS</a> - JohnLui 的 Swift On iOS 代码仓库。</li>
<li><a href="https://github.com/allenwong/30DaysofSwiftp">30DaysofSwift</a> - 30DaysofSwift 自学 iOS - <a href="http://weibo.com/ttarticle/p/show?id=2309403942494873235448">三十天三十个 Swift 项目</a>。</li>
</ul>


<h5>他人开源总结</h5>

<ul>
<li><a href="https://github.com/iCHAIT/awesome-osx">awesome-osx</a> - Awesome OS X。</li>
<li><a href="http://www.code4app.com/">code4app</a> - 最多国人用的代码库。</li>
<li><a href="http://code.cocoachina.com/">cocoachina</a> - 国内最热门的iOS社区的代码库。</li>
<li><a href="https://github.com/vsouza/awesome-ios">awesome-ios</a> - 一个老外整理的，<a href="http://app.memect.com/doc/ios.html">中文版</a>。</li>
<li><a href="https://github.com/cjwirth/awesome-ios-ui">awesome-ios-ui</a> - 收集了不少 iOS UI/UX 库, 包含了很多酷炫的动画效果。</li>
<li><a href="http://www.ios-cosmos.com/">ios-cosmos</a> - The iOS Cosmos：收录了iOS绝大部分的开源框架和工具。</li>
<li><a href="https://haskell.zeef.com/konstantin.skipor#block_28362_basics">Awesome Haskell资料大全</a> -    Awesome Haskell 资料大全：框架，库和软件。</li>
<li><a href="http://ios-cosmos.com">Cosmos</a> - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。</li>
<li><a href="https://www.cocoacontrols.com/">cocoacontrols</a> -  收集了很多UI控件效果代码，缺点是需要翻墙，而且代码分类不够好。</li>
<li><a href="https://github.com/lexrus">lexrus</a> -  lexrus国内出名的iOS开源coder，非常酷的label动画、textfield动画。</li>
<li><a href="https://github.com/dkhamsing/open-source-ios-apps">open-source-ios-apps</a> - iOS App集合，分：swift与Objective-C&ndash;国外人整理。</li>
<li><a href="http://www.csdn.net/article/2015-03-04/2824108-ios-developers-sites">适合iOS开发者的15大网站推荐</a> -  适合 iOS 开发者的 15 大网站推荐 &mdash; 英文网站。</li>
<li><a href="https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md">Objective-C GitHub 排名前 100 项目简介</a> -  主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况。</li>
<li><a href="http://github.ibireme.com/github/list/ios/">Github-iOS备忘</a> -整理了比较常用的iOS第三方组件，以及github上的统计。</li>
<li><a href="http://www.cocoachina.com/ios/20160121/14988.html">超全！整理常用的iOS第三方资源</a> - 超全！整理常用的iOS第三方资源。</li>
<li><a href="https://github.com/JanzTam/MyGithubMark">MyGithubMark</a> - Github上的iOS资料-个人记录（持续更新）。</li>
<li><a href="http://ios.jobbole.com/84684/">Github 上的 iOS 开源项目</a> - Github 上的 iOS 开源项目总结。</li>
<li><a href="https://github.com/jobbole/awesome-ios-cn">iOS资源大全中文版</a> - iOS资源大全中文版。</li>
<li><a href="http://www.ioscookies.com/">iOSCookies.swift</a> - 外国开发者弄了个Swift开源库、开源Apps等超全资源整合网站！不得不说真用心啊！</li>
</ul>


<h5>开发博客列表</h5>

<ul>
<li><a href="https://github.com/tangqiaoboy/iOSBlogCN">唐巧整理</a> - 猿题库唐巧整理。</li>
<li><a href="http://www.cocoachina.com/ios/20150626/11348.html">11个超棒的iOS开发学习国外网站</a> - 11个超棒的iOS开发学习网站:<a href="https://www.objc.io">objc.io</a> ;<a href="http://subjc.com">subjc.com</a> ;<a href="http://nshipster.com">NSHipster</a> ;<a href="http://petersteinberger.com">Peter Steinberger</a> ;<a href="http://oleb.net">Ole Begemann</a> ;<a href="http://floriankugler.com">Florian Kugler</a> ;<a href="https://www.mikeash.com/pyblog/">NSBlog</a> ;<a href="http://cocoa.tumblr.com">Cocoa</a> ;<a href="http://iosdevweekly.com">iOS Dev Weekly</a> ;<a href="http://iosdevelopertips.com">iOS Developer Tips</a> ;<a href="http://ios-goodies.com">iOS Goodies</a> ;<a href="http://www.appcoda.com">AppCoda</a> 香港人创建;<a href="http://merowing.info">Krzysztof Zab?ocki</a> ;<a href="http://iosdevtips.co">iOS Development tips</a> ;</li>
</ul>


<table>
<thead>
<tr>
<th>博客地址 </th>
<th> RSS地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://southpeak.github.io/">南峰子的技术博客</a> </td>
<td> 南峰子的技术博客。</td>
</tr>
<tr>
<td><a href="http://blog.devtang.com">唐巧的技术博客</a> </td>
<td> <a href="http://blog.devtang.com/atom.xml">http://blog.devtang.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="https://onevcat.com">OneV&rsquo;s Den</a> </td>
<td> <a href="https://onevcat.com/atom.xml">https://onevcat.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://objccn.io/">objc 中国</a> </td>
<td> 为中国 Objective-C 社区带来最佳实践和先进技术。</td>
</tr>
<tr>
<td><a href="http://beyondvincent.com">破船之家</a> </td>
<td> <a href="http://beyondvincent.com/atom.xml">http://beyondvincent.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nshipster.cn">NSHipster</a> </td>
<td> <a href="http://nshipster.cn/feed.xml">http://nshipster.cn/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://limboy.me/">Limboy 无网不剩</a> </td>
<td> <a href="http://feeds.feedburner.com/lzyy">http://feeds.feedburner.com/lzyy</a></td>
</tr>
<tr>
<td><a href="http://lextang.com">Lex iOS notes</a> </td>
<td> <a href="http://ios.lextang.com/rss">http://ios.lextang.com/rss</a></td>
</tr>
<tr>
<td><a href="http://nianxi.net">念茜的博客</a> </td>
<td> <a href="http://nianxi.net/feed.xml">http://nianxi.net/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.xcodev.com">Xcode Dev</a> </td>
<td> <a href="http://blog.xcodev.com/atom.xml">http://blog.xcodev.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wufawei.com/">Ted&rsquo;s Homepage</a></td>
<td> <a href="http://wufawei.com/feed">http://wufawei.com/feed</a></td>
</tr>
<tr>
<td><a href="http://blog.t-xx.me">txx&rsquo;s blog</a> </td>
<td> <a href="http://blog.t-xx.me/atom.xml">http://blog.t-xx.me/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imkevin.me">KEVIN BLOG</a> </td>
<td> <a href="http://imkevin.me/rss">http://imkevin.me/rss</a></td>
</tr>
<tr>
<td><a href="http://xiangwangfeng.com/">阿毛的蛋疼地</a> </td>
<td> <a href="http://xiangwangfeng.com/atom.xml">http://xiangwangfeng.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://billwang1990.github.io">亚庆的 Blog</a> </td>
<td> <a href="http://billwang1990.github.io/atom.xml">http://billwang1990.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nonomori.farbox.com">Nonomori</a> </td>
<td> <a href="http://nonomori.farbox.com/feed">http://nonomori.farbox.com/feed</a></td>
</tr>
<tr>
<td><a href="http://tang3w.com">言无不尽</a> </td>
<td> <a href="http://tang3w.com/atom.xml">http://tang3w.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wonderffee.github.io">Wonderffee&rsquo;s Blog</a> </td>
<td> <a href="http://wonderffee.github.io/atom.xml">http://wonderffee.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imtx.me">I&rsquo;m TualatriX</a> </td>
<td> <a href="http://imtx.me/feed/latest/">http://imtx.me/feed/latest/</a></td>
</tr>
<tr>
<td><a href="http://www.vclwei.com/">vclwei</a> </td>
<td> <a href="http://www.vclwei.com/posts.rss">http://www.vclwei.com/posts.rss</a></td>
</tr>
<tr>
<td><a href="http://blog.cocoabit.com">Cocoabit</a> </td>
<td> <a href="http://blog.cocoabit.com/atom.xml">http://blog.cocoabit.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nixzhu.me">nixzhu on scriptogr.am</a> </td>
<td> <a href="http://nixzhu.me/feed">http://nixzhu.me/feed</a></td>
</tr>
<tr>
<td><a href="http://studentdeng.github.io">不会开机的男孩</a> </td>
<td> <a href="http://studentdeng.github.io/atom.xml">http://studentdeng.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.taofengping.com">Nico</a> </td>
<td> <a href="http://www.taofengping.com/rss.xml">http://www.taofengping.com/rss.xml</a></td>
</tr>
<tr>
<td><a href="http://hufeng825.github.io">阿峰的技术窝窝</a> </td>
<td> <a href="http://hufeng825.github.io/atom.xml">http://hufeng825.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://answerhuang.duapp.com">answer_huang</a> </td>
<td> <a href="http://answerhuang.duapp.com/index.php/feed/">http://answerhuang.duapp.com/index.php/feed/</a></td>
</tr>
<tr>
<td><a href="http://webfrogs.me">webfrogs</a> </td>
<td> <a href="http://webfrogs.me/feed/">http://webfrogs.me/feed/</a></td>
</tr>
<tr>
<td><a href="http://joeyio.com">代码手工艺人</a> </td>
<td> <a href="http://joeyio.com/atom.xml">http://joeyio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://gracelancy.com">Lancy&rsquo;s Blog</a> </td>
<td> <a href="http://gracelancy.com/atom.xml">http://gracelancy.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imallen.com/">I&rsquo;m Allen</a> </td>
<td> <a href="http://imallen.com/atom.xml">http://imallen.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imi.im/">Travis' Blog</a></td>
<td> <a href="http://imi.im/feed">http://imi.im/feed</a></td>
</tr>
<tr>
<td><a href="http://wangzz.github.io/">王中周的技术博客</a> </td>
<td><a href="http://wangzz.github.io/atom.xml">http://wangzz.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://jiajun.org/">会写代码的猪</a></td>
<td><a href="http://gaosboy.com/feed/atom/">http://gaosboy.com/feed/atom/</a></td>
</tr>
<tr>
<td><a href="http://wangkewei.cnblogs.com/">克伟的博客</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/23857/rss">http://feed.cnblogs.com/blog/u/23857/rss</a></td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/biosli">摇滚诗人</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/35410/rss">http://feed.cnblogs.com/blog/u/35410/rss</a></td>
</tr>
<tr>
<td><a href="http://geeklu.com/">Luke&rsquo;s Homepage</a> </td>
<td> <a href="http://geeklu.com/feed/">http://geeklu.com/feed/</a></td>
</tr>
<tr>
<td><a href="http://iiiyu.com/">萧宸宇</a> </td>
<td> <a href="http://iiiyu.com/atom.xml">http://iiiyu.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.heyuan110.com/">Yuan博客</a> </td>
<td> <a href="http://www.heyuan110.com/?feed=rss2">http://www.heyuan110.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="http://shiningio.com/">Shining IO</a> </td>
<td> <a href="http://shiningio.com/atom.xml">http://shiningio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.yifeiyang.net/">YIFEIYANG&ndash;易飞扬的博客</a> </td>
<td> <a href="http://www.yifeiyang.net/feed">http://www.yifeiyang.net/feed</a></td>
</tr>
<tr>
<td><a href="http://koofrank.com/">KooFrank&rsquo;s Blog</a> </td>
<td> <a href="http://koofrank.com/rss">http://koofrank.com/rss</a></td>
</tr>
<tr>
<td><a href="http://helloitworks.com">hello it works</a> </td>
<td> <a href="http://helloitworks.com/feed">http://helloitworks.com/feed</a></td>
</tr>
<tr>
<td><a href="http://msching.github.io/">码农人生</a> </td>
<td> <a href="http://msching.github.io/atom.xml">http://msching.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://yulingtianxia.com">玉令天下的Blog</a> </td>
<td> <a href="http://yulingtianxia.com/atom.xml">http://yulingtianxia.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.hotobear.com/">不掏蜂窝的熊</a> </td>
<td> <a href="http://www.hotobear.com/?feed=rss2">http://www.hotobear.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="https://andelf.github.io/">猫·仁波切</a> </td>
<td> <a href="https://andelf.github.io/atom.xml">https://andelf.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://ivoryxiong.org/">煲仔饭</a> </td>
<td> <a href="http://ivoryxiong.org/feed.xml">http://ivoryxiong.org/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://adad184.com">里脊串的开发随笔</a> </td>
<td> <a href="http://adad184.com/atom.xml">http://adad184.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.ibireme.com/">ibireme伽蓝之堂</a> </td>
<td> <a href="http://blog.ibireme.com/feed/">http://blog.ibireme.com/feed/</a></td>
</tr>
</tbody>
</table>


<h4>物联网</h4>

<ul>
<li><a href="https://github.com/phodal/awesome-iot">awesome-iot</a> - 这份物联网学习参考大全太给力。从物联网协议、嵌入式系统、相关开源库、相关书籍、博客、学习笔记、标准应有尽有。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua/"/>
    <updated>2016-05-30T09:26:31+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua</id>
    <content type="html"><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要使用用户的需求以及为执行各种任务而改变状态。</p>

<p>在这些状态之间转换时，清晰的揭示正在发生什么是非常重要的。而不是在页面之间跳跃，动画帮助我们解释用户从哪里来，要到哪里去。</p>

<!--more-->


<p>键盘在View中滑进滑出给了我们一个错觉，让我们以为它是简单的被隐藏在屏幕下方的，并且是手机很自然的一个部分。View Controller转场加强了我们的应用程序的导航结构，并且给了用户正在移向那个方向的提示。微妙的反弹和碰撞使界面栩栩如生，并且激发出了物理的质感。要是没有这些的话，我们就只有一个没有视觉设计的干巴巴的环境了。</p>

<p>动画是叙述你的应用的故事的绝佳方式，在了解动画背景的基本原理之后，设计它们会轻松很多。</p>

<h2>首要任务</h2>

<p>在这篇文章中，我们将特别地针对  Core Anmiation进行探讨，虽然你将看到的很多东西也可以用更高级的UIKit的方法来完成，但是Core Animation将会让你更好的理解正在发生什么。它以一种更明确的方式来描述动画，这对这篇文章以及你自己的代码的读者来说都非常有用。</p>

<p>在看动画如何与我们的屏幕上的看到的内容交互之前，我们需要快速浏览一下Core Animation的<code>CALayer</code>，这是动画产生作用的地方。</p>

<p>你大概知道UIView实例，以及layer-backed的NSView,修改它们的layer来委托强大的Core Graphics框架来进行渲染。然而你务必要理解，当把动画添加到一个layer时，是不直接修改它的属性的。</p>

<p>取而代之，Core Animation维护了两个平行的layer层次结构:mode layer tree(模型层树)和presentation layer tree(表示层树)。前者中的layers反映了我们能直接看到的layers的状态，而后者的layers则是正在表现的值的近似。</p>

<p>考虑在view上增加一个渐出动画。如果在动画中的任意时刻，查看layer的opacity值，你是得不到与屏幕内容对应的透明度的。取而代之，你需要查看presentaion layer 以获得正确的结果。</p>

<p>虽然你可能不会去直接设置presentaion layer的属性，但是使用它的当前值来创建新的动画护着在动画发生时与layers交互式非常有用的。</p>

<p>通过使用 <code>-[CALayer presentaionLayer]</code>和<code>[CALayer modelLayer]</code>，你可以在两个layer之间轻松切换。</p>

<h2>基本动画</h2>

<p>可能最常见的情况是将一个View的属性从一个值改变为另一个值，考虑夏敏的这个例子。</p>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-linear.gif" alt="w" />
 
在这里，我们让红色小火箭的 x-position从77 变为455,刚好超过的parent View的边，为了填充所有路径，我们需要确定我们的火箭在任意时刻所到达的位置。这通常使用线性插值法来完成。</p>

<pre><code>X(T)=x0 + t△x
</code></pre>

<p>也就是说，对于动画给定的一个分数t,火箭的x坐标就是起始点的x坐标77，加上一个到终点的距离∆x = 378,乘以该分数的值。</p>

<p>使用<code>CABasicAnimation</code>，我们可以如下实现这个动画:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span></code></pre></td></tr></table></div></figure>


<p>请注意我们的动画键路径，也就是position.x,实际上包含一个存储在<code>position</code>属性中的CGPoint结构体成员。这是CoreAnimation一个非常方便的特性。请查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html">支持的键路径的完整列表</a></p>

<p>然而，当我们运行该代码时，我们意识到火箭在完成动画后马上回到了初始位置，这是因为在默认情况下，动画不会再超出其持续时间后还修改 presentaion layer.实际上，在结束时它甚至会被彻底移除。</p>

<p>一旦动画被移除，presentation layer将回到 model layer的值，并且因为我们从未修改该layer的 postion属性，所以我们的飞船将重新出现在它开始的地方。</p>

<p>这里有两种解决这个问题的方法:</p>

<p>第一种方法是直接在 model layer上更新尚需经，这是推荐的做法，因为它使得动画完全可选。</p>

<p>一旦动画完成并且从layer中移除，presentation layer将回到model layer设置的值，而这个值恰好与动画最后一个步骤相匹配</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rocket.layer.position = CGPointMake(455, 61);</span></code></pre></td></tr></table></div></figure>


<p>或者，你可以通过设置动画的fillMode属性为<code>kCAFillModeForward</code>，并设置<code>removedOnCompletion</code>为No以防止它被自动移除:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.fillMode = kCAFillModeForward;
</span><span class='line'>animation.removedOnCompletion = NO;
</span><span class='line'>
</span><span class='line'>[rectangle.layer addAnimation:animation forKey:@"basic"];</span></code></pre></td></tr></table></div></figure>


<p>如果将已完成的动画保持在layer上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>

<p>指的指出的是，实际上我们创建的动画对象在被添加到layer时立刻就复制了一份。这个特性在多个view中重用动画时这非常有用。比方说我们想要第二个火箭在第一个火箭起飞后不久后起飞：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.byValue = @378;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket1.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>rocket1.layer.position = CGPointMake(455, 61);
</span><span class='line'>
</span><span class='line'>animation.beginTime = CACurrentMediaTime() + 0.5;
</span><span class='line'>
</span><span class='line'>[rocket2.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>rocket2.layer.position = CGPointMake(455, 111);</span></code></pre></td></tr></table></div></figure>


<p>设置动画的<code>beginTime</code>为未来0.5秒将只会影响<code>rocket2</code>，因为动画在执行语句<code>[rocket1.layer addAnimation:animation forKey:@"basic"];</code>时已经被复制了，并且之后的rocket1也不会考虑对动画对象的改变。</p>

<p>不妨看一看David的<a href="http://ronnqvi.st/controlling-animation-timing/">关于动画时间的一篇很棒的文章</a>，通过它可以学习如何更精确的控制你的动画。</p>

<p>我决定再使用<code>CABasicAnimation</code>的byValule属性创建一个动画，这个动画从presentaion layer的当前值开始，加上byValue的值后结束。这使得动画更易于重用，因为你不需要精确的指定可能无法提前知道的from- 和 toValue的值。</p>

<p><code>fromValue</code>,<code>byValue</code>和<code>toValue</code>的不同组合可以用来实现不同的效果，如果你需要创建一个可以在你的不同应用中重用的动画，你可以<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">查看文档</a></p>

<h2>多步动画</h2>

<p>这很容易想到一个场景，你想要为你的冻哈定义超过两个步骤，我们可以使用更通用的<code>CAKeyframeAnimation</code>，而不是去链接多个<code>CABasicAnimation</code>实例。</p>

<p>关键帧(keyFrame)使我们能够定义动画中任意的一个点，然后让core Animation填充所谓的中间帧</p>

<p>比方说我们正在制作我们下一个Iphone应用程序汇总的登录表单，我们希望当用户输入错误的密码时表单会晃动，使用关键帧动画，看起来大概像是这样：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/form.gif" alt="d" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.values = @[ @0, @10, @-10, @10, @0 ];
</span><span class='line'>animation.keyTimes = @[ @0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1 ];
</span><span class='line'>animation.duration = 0.4;
</span><span class='line'>
</span><span class='line'>animation.additive = YES;
</span><span class='line'>
</span><span class='line'>[form.layer addAnimation:animation forKey:@"shake"];</span></code></pre></td></tr></table></div></figure>


<p>values数组定义了表单应该到哪些位置、</p>

<p>设置keytimes属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal">
请注意我是如何选择不同的值从0到10到-10转换以维持恒定的速度的。
</a></p></blockquote>

<p>设置additive尚需经为YES 使 Core Animation在更新 presentaion layer之前将动画的值添加到 model layer中去。这使得我们能够对所有形式的需要更新的元素重用相同的动画，且无需提前知道它们的位置。因为这个属性从<code>CAPropertyAnimation</code>继承，所以你也可以在使用<code>CABasicAnimation</code>时使用它。</p>

<h2>沿路径的动画</h2>

<p>虽然用代码实现一个简单的水平晃动并不难，但是沿着复杂路径的 动画就需要我们在关键帧的values数组中存储大量box化的CGPoint.指的庆幸的是，<code>CAKeyFrmeAnimaiton</code>提供了更加便利的Path属性作为代替</p>

<p>举个例子，我们如何让一个view做圆周运动:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets.gif" alt="1" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect boundingRect = CGRectMake(-150, -150, 300, 300);
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *orbit = [CAKeyframeAnimation animation];
</span><span class='line'>orbit.keyPath = @"position";
</span><span class='line'>orbit.path = CFAutorelease(CGPathCreateWithEllipseInRect(boundingRect, NULL));
</span><span class='line'>orbit.duration = 4;
</span><span class='line'>orbit.additive = YES;
</span><span class='line'>orbit.repeatCount = HUGE_VALF;
</span><span class='line'>orbit.calculationMode = kCAAnimationPaced;
</span><span class='line'>orbit.rotationMode = kCAAnimationRotateAuto;
</span><span class='line'>
</span><span class='line'>[satellite.layer addAnimation:orbit forKey:@"orbit"];</span></code></pre></td></tr></table></div></figure>


<p>使用<code>CGPathCreateWithEllipseInRect ()</code>，我们创建一个圆形的<code>CGPath</code>作为我们的关键帧动画的path.</p>

<p>使用<code>calculationMode</code>是控制关键帧动画时间的另一种方式。我们通过将其设置为<code>kCAAnimationPaced</code>，让Core Animation想被驱动的对象施加一个恒定速度，不管路径的各个线程有多长，将其设置为<code>kCAAnimationPaced</code>将无视所有我们已经设置的 keyTimes.</p>

<p>设置 rotationsMode属性为 <code>kCAAnimationRotateAuto</code>，确保飞船沿着路径旋转。作为对比，我们将该属性设置为nil，那动画会怎么样呢？</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets-incorrect.gif" alt="2" /></p>

<h2>时间函数</h2>

<p>让我们再次来看看第一个例子 ：</p>

<p>你会发现我们的火箭的动画有些看起来非常不自然的地方，那是因为我们在现实时间中看到的大部分运动需要时间来加速或者减速。对象瞬间达到最高速度，然后再立即停止往往看起来非常不自然。除非你在让机器人跳舞，但这很少是想要的结果。</p>

<p>为了给我们的动画一个存在惯性的感觉，我们可以使用我们上面提到的参数因子来进行插值。然而，如果我们接下来需要为每个需要加速或减速的行为创建一个新的插值函数，这将是一个很难扩展的方法。</p>

<p>取而代之，常见的做法是把要进行动画的属性的插值从动画的速度中解耦出来。这样一来，给动画提速会差生一种小火箭加速运动的效果，而不用改变我们的插值函数。</p>

<p>我们可以通过引入一个时间函数 （timing function）来实现这个目标。该函数通过修改持续时间的分数来控制动画的速度。</p>

<p>最简单的easing函数是linear.它在整个动画上维持一个恒定的速度。在 Core Animation中，这个功能由CAMediaTimingFunction来表示。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-linear.gif" alt="2" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x"; 
</span><span class='line'>animation.fromValue = @50;
</span><span class='line'>animation.toValue = @150;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
</span><span class='line'>
</span><span class='line'>[rectangle.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rectangle.layer.position = CGPointMake(150, 0);</span></code></pre></td></tr></table></div></figure>


<p>Core Animation附带了一些linear之外的内置easing函数，如:</p>

<ul>
<li><p>Ease in (kCAMediaTimingFunctionEaseIn):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easein.gif" alt="1" /></p></li>
<li><p>Ease out (kCAMediaTimingFunctionEaseOut):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeout.gif" alt="2" /></p></li>
<li><p>Ease in ease out (kCAMediaTimingFunctionEaseInEaseOut):</p></li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeineaseout.gif" alt="3" /></p>

<ul>
<li>默认 (kCAMediaTimingFunctionDefault):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-default.gif" alt="4" /></li>
</ul>


<p>在一定限度内，你也可以使用<code>+functionWithControlPoints::::</code>创建自己的easing函数。通过传递cubic Bezier曲线的两个控制点的x和y坐标，你可以轻松的创建自定义easying函数，比如我为我们的红色小火箭选择的那个。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-custom.gif" alt="custom" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0.5:0:0.9:0.7];
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rocket.layer.position = CGPointMake(150, 0);</span></code></pre></td></tr></table></div></figure>


<p>我不打算讲太多关于Bezier曲线的细节，在计算机图形学中，它们是创建平滑曲线的常用技术。你可能在基于矢量的绘图工具，比如Sketch或者Adobe lllustrotor中见过它们。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/bezier.png" alt="1" /></p>

<p>传递给 <code>+functionWithControlPoints::::</code>的值有效地控制了控制点的位置。所得到的定时函数将基于得到的路径来调整动画的速度。X轴代表时间的分数，而Y轴是插值函数的插入值。</p>

<p>遗憾的是，由于这些部分被锁定在[0-1]的范围内，我们不可能用它来创建一些像预期动作(Anticipation,一种像目标进发前先回退一点，到达目标后还过冲一会，见下图)这样的常见效果 .</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/anticipate.gif" alt="3" /></p>

<h2>动画组</h2>

<p>对于某些复杂的效果，可能需要同时为多个属性进行动画。想象一下，在一个媒体播放程序中，当切换到随机曲目时我们让随机动画效果，看起来就想下面这样:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/covers.gif" alt="animaiton" /></p>

<p>你可以看到，我们需要同时对上面的封面的 position,roation和 z-position进行动画，使用 CAAimationGroup来动画其中一个封面的代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *zPosition = [CABasicAnimation animation];
</span><span class='line'>zPosition.keyPath = @"zPosition";
</span><span class='line'>zPosition.fromValue = @-1;
</span><span class='line'>zPosition.toValue = @1;
</span><span class='line'>zPosition.duration = 1.2;
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *rotation = [CAKeyframeAnimation animation];
</span><span class='line'>rotation.keyPath = @"transform.rotation";
</span><span class='line'>rotation.values = @[ @0, @0.14, @0 ];
</span><span class='line'>rotation.duration = 1.2;
</span><span class='line'>rotation.timingFunctions = @[
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *position = [CAKeyframeAnimation animation];
</span><span class='line'>position.keyPath = @"position";
</span><span class='line'>position.values = @[
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointZero],
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointMake(110, -20)],
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointZero]
</span><span class='line'>];
</span><span class='line'>position.timingFunctions = @[
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
</span><span class='line'>];
</span><span class='line'>position.additive = YES;
</span><span class='line'>position.duration = 1.2;
</span><span class='line'>
</span><span class='line'>CAAnimationGroup *group = [[CAAnimationGroup alloc] init];
</span><span class='line'>group.animations = @[ zPosition, rotation, position ];
</span><span class='line'>group.duration = 1.2;
</span><span class='line'>group.beginTime = 0.5;
</span><span class='line'>
</span><span class='line'>[card.layer addAnimation:group forKey:@"shuffle"];
</span><span class='line'>
</span><span class='line'>card.layer.zPosition = 1;</span></code></pre></td></tr></table></div></figure>


<p>我们使用CAAimationGroup得到一个好处是可以将所有动画作为一个对象暴露出去。如果你要在应用程序中的多个地方用工厂对象创建的重用的动画的话，这将会非常有用。</p>

<p>你也可以使用动画组同时控制所有动画组成部分的时间</p>

<h2>Core Animation 之外</h2>

<p>你应该已经听过 UIKIT Dynamics了，这是ios7中引入的一个物理模拟框架，它允许你使用约束和力来为 views做动画。与core Animation不同，它与你在屏幕上看到的内容交互更为间接，但是它的动态特性让你可以在事先不知道结果时创建动画。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift语法小技巧]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/26/swiftyu-fa-xiao-ji-qiao/"/>
    <updated>2016-05-26T15:09:59+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/26/swiftyu-fa-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<h3><a name="判断某个对象是否响应了某个方法"> 判断某个对象是否响应了某个方法</a></h3>

<!--more-->


<p>没有参数的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(view.respondsToSelector(#selector(startAnimating))){
</span><span class='line'>        
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一个参数的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> if(self.modeView.respondsToSelector(#selector(hideAnimated(_:)))){
</span><span class='line'>          
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>多个参数的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> if(self.modeView.respondsToSelector(#selector(setProgress(_:animated:)))){
</span><span class='line'>            
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>第一个参数用<code>_</code>，第二个先参数名字，中间没有逗号</p>

<h3>Swift中如何使用 #Debug</h3>

<p>在oc中可以直接使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if DEBUG 
</span><span class='line'>  let a = 2
</span><span class='line'>#else 
</span><span class='line'>  let a = 3
</span><span class='line'>#endif</span></code></pre></td></tr></table></div></figure>


<p>但是swift没有引进预处理指令，但并不代表不可以使用预处理指令。</p>

<p>首先要在 setting中设置，在Swift Compiler - Custom Flags，找到 <code>Other Swift Flags</code>,添加如下标记 <code>-D DEBUG</code>,在release模式下添加 <code>-D RELEASE</code>,如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/661867-43c91f8c973acc77.png" alt="logo" /></p>

<p>现在就可以正常的使用#if DEBUG了</p>

<h3>UIColllectionView</h3>

<p>注册UIcollectionViewCell</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>    collectionView.registerClass(NN_XueTangCell.self, forCellWithReuseIdentifier: cellId)
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为iOS建立Travis CI]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci/"/>
    <updated>2016-05-23T14:30:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/23/wei-iosjian-li-travis-ci</id>
    <content type="html"><![CDATA[<p>你是否曾经试着为ios项目搭建一台支持<a href="http://baike.baidu.com/link?url=9m9zB2m909wrZ82wdNWMhtPBTt14PduTPIyi78YL0sS7ccrE-DN22S55wCuEhuobFZ0dL5T4MhKmQzFLx1q4-K">持续集成</a>的服务器，从我的个人经验而言，这可不是一个轻松的活。首先需要准备一台MAc电脑，并安装好全部所需的软件和插件。你要负责管理所有的用户账户，并提供安全保护。你需要授予访问仓库的权限，并配置所有的编译步骤和证书，在项目的运行时期，你需要保持服务器稳健和最新。</p>

<!--more-->


<p>最后，原本你想节省时间，会发现你花费了大量的时间去维护这台服务器，不过如果你的项目托管在github上，现在有了新的希望：<a href="https://travis-ci.org/">Travis CI</a>.该服务可以为你的项目提供持续集成的支持，也就意味着它会负责好托管一个项目的所有细节。在ruby的世界中，Travis CI以久负盛名。从2013年4月起，Travs也开始支持ios和mac平台</p>

<p>在这篇文章中，我将向你展示如何一步步的在项目中集成Travis.不仅包括项目的编译的单元测试运行，还包括将应用部署到你所有的测试设备上。</p>

<h2>GITHub集成</h2>

<p>我最喜欢Travis的一点就是它与GitHub的webUI集成的非常好，例如pull请求，Travis会为每次请求都执行编译操作。如果一切正常，pull请求在Github上看起来这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_ready_to_merge.jpg" alt="e" /></p>

<p>万一编译不成功，Github页面会修改相应的颜色。给予提醒:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/github_merge_with_caution.jpg" alt="1" /></p>

<h2>链接 Travis 和 GitHub</h2>

<p>让我们看一下如何将Github项目与Travis链接上，使用Github账号登录 <a href="https://travis-ci.org/">Travis 站点</a>。对于私有仓库，需要注册一个Travis 专业版账号</p>

<p>登录成功后，需要为项目开启Travis支持，导航到<a href="https://travis-ci.org/profile">属性页面</a>,该页面列出了所有的github项目，不过要注意，如果此后创建了一个新的仓库，要使用 sync now 按钮进行同步。Travis只会偶尔更新的项目列表.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_travis_flick.jpg" alt="test" /></p>

<p>现在只需要打开这个开关就可以在你的项目添加Travis服务，之后你会看到Travis会和Github项目设置关联。下一步就是告诉Travis，当它收到项目改动通知之后该做什么。</p>

<h2>最简单的项目配置</h2>

<p>Tranvis CI 需要项目的一些基本信息。在项目的根目录创建一个名为 .travis.yml的文件，文件中内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>language: objective-c</span></code></pre></td></tr></table></div></figure>


<p>Travis 编译器运行在虚拟机环境下，该编译器已经利用 <code>Ruby</code>,<code>homebrew</code>,<code>CocoaPods</code>和一些默认的编译脚本进行过<a href="http://about.travis-ci.org/docs/user/osx-ci-environment/">预配置</a>.上述的配置项已经足够编译你的项目了。</p>

<p>预装的编译脚本会分析你的Xcode项目，并对每个target进行编译。如果所有文件都没有编译错误，并且测试也没有被打断，那么项目就编译成功了。现在可以将改动push到GitHub上看看能否成功编译。</p>

<p>虽然上述配置过程真的很简单，不过对你的项目不一定适用。这里几乎没有什么文档来指导用户如何配置默认的编译行为。例如：有一次我没有用 iphonesimulator SDK 导致代码签名错误。如果刚刚那个最简单的配置对你的项目不适用的话，让我们来看一下如何对Travis使用自定义的编译命令</p>

<h3>自定义编译命令</h3>

<p>Travis 使用命令行对项目进行编译。因此，第一步就是使项目能够在本地编译。作为Xcode命令行工具的一部分，Apple提供了<code>xcodebuild</code>命令</p>

<p>打开终端并输入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcodebuild --help</span></code></pre></td></tr></table></div></figure>


<p>上述命令会列出xcodebuild所有可用的参数。如果命令执行失败了，确保命令行工具已经成功安装。一个常见的编译命令看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>'xcodebuild -project {project}.xcodeproj -target {target} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO</span></code></pre></td></tr></table></div></figure>


<p>使用 iphonesimulator SDK是为了避免签名错误，知道我们稍后引入证书之前，这一步是必须的。通过设置<code>ONLY_ACTIVE_ARCH=NO</code>我们可以确保利用模拟器架构编译工程。你也可以设置额外的属性，例如<code>configuration</code>,输入 man xcodebuild查看相关文档。</p>

<p>对于使用 CocoaPods的项目，需要用下面的命令来指定 workspace和scheme:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcodebuild -workspace {workspace}.xcworkspace -scheme {scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</span></code></pre></td></tr></table></div></figure>


<p>schemes 是由Xcode自动生成的，但这在服务器上不会发生。确保所有的scheme都被设置为 shared并加入到仓库中，否则它只会在本地工作而不会被Travis CI识别。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/objc_shared_schemes.jpg" alt="w" /></p>

<p>我们实例项目下的 .travis.yml文件现在看起来应该是这样</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>language: objective-c
</span><span class='line'>script: xcodebuild -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO</span></code></pre></td></tr></table></div></figure>


<h2>运行测试</h2>

<p>对月测试来说，通常使用如下这个命令(注意 test 属性)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcodebuild test -workspace {workspace}.xcworkspace -scheme {test_scheme} -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</span></code></pre></td></tr></table></div></figure>


<p>不幸的是，xcodebuild对于ios来说，并不能正确支持target和应用程序的测试。<a href="http://www.raingrove.com/2012/03/28/running-ocunit-and-specta-tests-from-command-line.html">这里有一些解决方案</a>不过我建议使用Xctool.</p>

<h3>Xctool</h3>

<p><a href="https://github.com/facebook/xctool">Xctool</a>是来自FaceBook的命令行工具，它可以简化程序的编译和测试。它的彩色输出信息比 xcodebuild更加简洁美观。同时还添加了对逻辑测试，应用测试的支持。</p>

<p>Travis中已经预装了xctool。要在本地测试的话，需要用homebrew安装xctool:</p>

<p>xctool用法非常简单，它使用的参数跟xcodebuild相同：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</span></code></pre></td></tr></table></div></figure>


<p>一旦相关命令在本地能正常工作，那么就是时候把它们添加到 .travis.yml中了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>language: objective-c
</span><span class='line'>script:
</span><span class='line'>  - xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO
</span><span class='line'>  - xctool test -workspace TravisExample.xcworkspace -scheme TravisExampleTests -sdk iphonesimulator ONLY_ACTIVE_ARCH=NO</span></code></pre></td></tr></table></div></figure>


<p>到此为止，介绍的内容对于使用Travis的library工程来说，已经足够了。我们可以确保项目正常编译并测试通过。但对于ios应用来说，我们希望能在真实的物理设备上进行测试。也就说我们需要将应用部署到我们的所有测试设备上。当然，我们希望Travis能自动完成这项任务。首先，我们需要给程序签名</p>

<h1>应用程序的签名</h1>

<p>为了在Travis中能给程序签名，我们需要准备好所有必须的证书和配置文件。就像每个ios开发人员指导的那样，这可能是最困难的一步。后面，我将写一些脚本在服务器上给应用程序签名。</p>

<h2>证书和配置文件</h2>

<h3>1.苹果全球开发者关系认证</h3>

<p>从<a href="http://developer.apple.com/certificationauthority/AppleWWDRCA.cer">苹果官网</a>或者从钥匙串中导出。并将保存到项目的目录<code>scripts/certs/apple.cer</code>中。</p>

<h3>2.iPhone发布证书 + 私钥</h3>

<p>如果还没有发布证书的话，先创建一个。登录<a href="https://developer.apple.com/account/overview.action">苹果开发者账号</a>,按照步骤，创建一个新的生产环境证书(<em>Certificates</em>)><em>Production</em>><em>Add</em>><em>App Store and ad hoc</em>)。然后下载并安装证书。之后，可以在钥匙串中找到它。打开Mac中的钥匙串应用程序：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/dist_cert_keychain.jpg" alt="key" /></p>

<p>右键单击证书，选择<code>Export ....</code>将证书导出至<code>scripts/certs/dist.cer</code>.然后导出私钥并保存至<code>cripts/certs/dist.p12</code>.记得输入私钥的密码.</p>

<p>由于Travis需要知道私钥密码，因此我们要把这个密码存储在某个地方，当然，我们不希望已明文的形式存储。我们可以用<a href="http://about.travis-ci.org/docs/user/build-configuration/#Secure-environment-variables">Travis的安全环境变量</a>。打开终端，并定位到包含 .travis.yml文件所在目录。首先用 <code>gem install travis</code>命令安装Travis gem.之后用下面的命令添加秘钥密码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>travis encrypt "KEY_PASSWORD={password}" --add</span></code></pre></td></tr></table></div></figure>


<p>上面的命令会安装一个叫做<code>Key_Password</code>的加密环境变量到 .travis.yml 配置文件中。这样就可以在被 Travis CI执行的脚本中使用这个变量</p>

<h3>3.ios 配置文件(发布)</h3>

<p>如果还没有用于发布的配置文件，那么也创建一个新的。根据开发者账号类型，可以选择创建 <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/TestingYouriOSApp/TestingYouriOSApp.html">ADHoc</a>或<a href="https://developer.apple.com/programs/ios/enterprise/gettingstarted/">IN House</a>配置文件<em>(Provisioning Profiles > Distribution > Add > Ad Hoc or In House)</em>.然后将其下载保存到<code>scripts/profile/</code>目录。</p>

<p>由于Travis需要访问这个配置文件，所以我们需要将这个文件的名字存储为一个全局变量。并将其添加到.travis.yml文件的全局环境变量section中。例如，如果配置文件的名字是 <code>TravisExample_Ad_Hoc.mobileprovision</code>,那么按照如下进行添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>env:
</span><span class='line'>  global:
</span><span class='line'>  - APP_NAME="TravisExample"
</span><span class='line'>  - 'DEVELOPER_NAME="iPhone Distribution: {your_name} ({code})"'
</span><span class='line'>  - PROFILE_NAME="TravisExample_Ad_Hoc"</span></code></pre></td></tr></table></div></figure>


<p>上面还声明了两个环境变量。第三行中的<code>APP_name</code>通常为项目默认的target的名字。第四行的<code>DEVELOPER_NAME</code>是xcode中，默认target里面Build Settings的Code Signing Identity > Release 对应的名字。然后搜索程序的<code>Ad Hod</code>或者<code>In house</code>配置文件，将其中黑体文字取出，根据设置的不同，括弧中可能不会有任何信息。</p>

<h2>加密证书和配置文件</h2>

<p>如果你的GitHub仓库是公开的，你可能希望对证书和配置文件进行加密。如果你的是私有仓库，可以跳过这一节</p>

<p>首先，我们需要一个密码来对所有的文件进行加密。在我们的实例中，密码为"foo",记住在你的工程中设置的密码应该更加复杂。在命令行汇总，我们使用<code>openssl</code>加密所有的敏感文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>openssl aes-256-cbc -k "foo" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -a
</span><span class='line'>openssl aes-256-cbc -k "foo" -in scripts/certs/dist.cer -out scripts/certs/dist.cer.enc -a
</span><span class='line'>openssl aes-256-cbc -k "foo" -in scripts/certs/dist.p12 -out scripts/certs/dist.cer.p12 -a</span></code></pre></td></tr></table></div></figure>


<p>通过上面的命令，可以创建出以 .enc结尾的加密文件。之后可以把原始文件忽略或者移除掉。至少不要把原始文件提交到GitHub中，否则原始文件会显示在GitHub中。如果你不小心把原始文件提交上去了，那么请看这里<a href="https://help.github.com/articles/remove-sensitive-data">如何解决</a></p>

<p>现在，我们的文件已经被加密了，接下来我们需要告诉Travis对文件进行解密。解密过程，需要用到密码。具体释放方法跟之前创建的<code>KEY_PASSOWORD</code>变量一样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>travis encrypt "ENCRYPTION_SECRET=foo" --add</span></code></pre></td></tr></table></div></figure>


<p>最后，我们需要告诉Travis那些文件需要进行解密.将下面的命令添加到 .travis.yml文件中的before-script部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>before_script:
</span><span class='line'>- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/profile/TravisExample_Ad_Hoc.mobileprovision.enc -d -a -out scripts/profile/TravisExample_Ad_Hoc.mobileprovision
</span><span class='line'>- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12
</span><span class='line'>- openssl aes-256-cbc -k "$ENCRYPTION_SECRET" -in scripts/certs/dist.p12.enc -d -a -out scripts/certs/dist.p12</span></code></pre></td></tr></table></div></figure>


<p>就这样，在GitHub上面的文件就安全了，并且Travis依旧能读取并使用这些加密后的文件。但是有一个安全问题你需要知道，在Travis的编译日志中可能会显示出解密环境变量。不过对pull请求来说不会出现</p>

<h2>添加脚本</h2>

<p>现在我们需要确保证书都导入到了Travis CI的钥匙串中。为此，我们需要在scripts文件夹中添加一个名为 <code>add-key.sh</code>的文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>security create-keychain -p travis ios-build.keychain
</span><span class='line'>security import ./scripts/certs/apple.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
</span><span class='line'>security import ./scripts/certs/dist.cer -k ~/Library/Keychains/ios-build.keychain -T /usr/bin/codesign
</span><span class='line'>security import ./scripts/certs/dist.p12 -k ~/Library/Keychains/ios-build.keychain -P $KEY_PASSWORD -T /usr/bin/codesign
</span><span class='line'>mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
</span><span class='line'>cp ./scripts/profile/$PROFILE_NAME.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/</span></code></pre></td></tr></table></div></figure>


<p>通过上面的命令创建了一个名为<code>ios-build</code>的临时钥匙串，里面包含了所有证书。注意，这里我们使用了<code>$Key_PASSWORD</code>来导入私钥。最后一步是将配置文件拷贝到LIbrary文件夹。</p>

<p>创建好文件之后，确保其授予了可执行的权限：在命令行输入:<code>chmod a+x scripts/add-key.sh</code>即可。为了正常使用脚本，必须要这样处理一下。</p>

<p>至此，已经导入了所有的证书和配置文件，我们可以开始给应用程序签名了。注意，在给程序签名之前必须对程序进行编译。由于我们需要知道编译结果存储在磁盘的具体位置，我建议在编译命令中使用<code>OBJROOT</code>和<code>SYMROOT</code>来指定输出目录，另外，为了创建 release版本，还需要把SDK设置为 iphones,以及configuration修改为 Release:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO 'CODE_SIGN_RESOURCE_RULES_PATH=$(SDKROOT)/ResourceRules.plist'
</span></code></pre></td></tr></table></div></figure>


<p>如果运行了上面的命令，那么编译完成之后，可以在<code>build/Release-iphoneos</code>目录中找到对应程序的二进制文件。接下来，就可以对其签名，并创建IPA文件了。为此，我们创建了一个新的脚本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>if [[ "$TRAVIS_PULL_REQUEST" != "false" ]]; then
</span><span class='line'>  echo "This is a pull request. No deployment will be done."
</span><span class='line'>  exit 0
</span><span class='line'>fi
</span><span class='line'>if [[ "$TRAVIS_BRANCH" != "master" ]]; then
</span><span class='line'>  echo "Testing on a branch other than master. No deployment will be done."
</span><span class='line'>  exit 0
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>PROVISIONING_PROFILE="$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_NAME.mobileprovision"
</span><span class='line'>OUTPUTDIR="$PWD/build/Release-iphoneos"
</span><span class='line'>
</span><span class='line'>xcrun -log -sdk iphoneos PackageApplication "$OUTPUTDIR/$APPNAME.app" -o "$OUTPUTDIR/$APPNAME.ipa" -sign "$DEVELOPER_NAME" -embed "$PROVISIONING_PROFILE"</span></code></pre></td></tr></table></div></figure>


<p>第二行至第九行非常重要。我们并不希望在某个特性分支上创建新的release.对Pull请求也一样的。由于安全环境变量被禁用，所有pull请求也不会编译。</p>

<p>第十四行，才是真正的签名操作。这个命令会在<code>build/Release-iphoneos</code>目录下生成2个文件：<code>TravisExample.ipa</code>和<code>TravisExample.app.dsym</code>。第一个文件包含了分发至手机上的应用程序。dsym文件包含了二进制文件的调试信息。这个文件对于记录设备上的crash信息非常重要。之后当我们部署应用程序的时候，会用到这两个文件。</p>

<p>最后一个脚本是移除之前创建的临时钥匙串，并删除配置文件。虽然这不是必须的，不过这有助于进行本地测试。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>security delete-keychain ios-build.keychain
</span><span class='line'>rm -f ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_NAME.mobileprovision</span></code></pre></td></tr></table></div></figure>


<p>最后一步，我们必须告诉Travis什么时候执行这三个脚本，在应用程序编译，签名和清楚等之前，需要先添加私钥。在 .travis.yml文件中添加如下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>before_script:
</span><span class='line'>- ./scripts/add-key.sh
</span><span class='line'>- ./scripts/update-bundle.sh
</span><span class='line'>script:
</span><span class='line'>- xctool -workspace TravisExample.xcworkspace -scheme TravisExample -sdk iphoneos -configuration Release OBJROOT=$PWD/build SYMROOT=$PWD/build ONLY_ACTIVE_ARCH=NO
</span><span class='line'>after_success:
</span><span class='line'>- ./scripts/sign-and-upload.sh
</span><span class='line'>after_script:
</span><span class='line'>- ./scripts/remove-key.sh</span></code></pre></td></tr></table></div></figure>


<p>完成上面的所有操作之后，我们就可将所有内容push到GItHub上，等待Travis对应用程序进行签名，我们可以在工程页面下的Travis控制台验证是否一切正常，如果一切正常的话，下面来看看如何将签名好的应用程序部署给测试人员。</p>

<h2>部署应用程序</h2>

<p>这里有两个知名的服务可以帮你发布应用程序:<a href="http://testflightapp.com/">TestFlight</a>和<a href="http://hockeyapp.net/">HockyeyApp</a>。不管选择哪个都能满足需求。就我个人而言，推荐使用 HockeyApp,不过这里我会对这两个服务都做介绍。</p>

<p>首先我们队 sign-and-build.sh脚本做一个扩充&ndash;在里面添加一些release记录:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RELEASE_DATE=`date '+%Y-%m-%d %H:%M:%S'`
</span><span class='line'>RELEASE_NOTES="Build: $TRAVIS_BUILD_NUMBER\nUploaded: $RELEASE_DATE"</span></code></pre></td></tr></table></div></figure>


<p>注意这里使用了一个Travis的全局变量<code>TRAVIS_BUILD_NUMBER</code>.</p>

<h2>TestFlight</h2>

<p>创建一个<a href="https://testflightapp.com/register/">TestFlight账号</a>，并配置好应用程序。为了使用TestFlight的API,首先需要获得<a href="https://testflightapp.com/account/#api">apitoken</a>和<a href="https://testflightapp.com/dashboard/team/edit/?next=/api/doc/">teamtoken</a>。再强调一次，我们需要确保它们是加密的。在命令行中执行如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>travis encrypt "TESTFLIGHT_API_TOKEN={api_token}" --add
</span><span class='line'>travis encrypt "TESTFLIGHT_TEAM_TOKEN={team_token}" --add</span></code></pre></td></tr></table></div></figure>


<p>现在我们可以调用相应的API了。并将下面的内容添加到<code>sign-and-build.sh:</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl http://testflightapp.com/api/builds.json \
</span><span class='line'>  -F file="@$OUTPUTDIR/$APPNAME.ipa" \
</span><span class='line'>  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
</span><span class='line'>  -F api_token="$TESTFLIGHT_API_TOKEN" \
</span><span class='line'>  -F team_token="$TESTFLIGHT_TEAM_TOKEN" \
</span><span class='line'>  -F distribution_lists='Internal' \
</span><span class='line'>  -F notes="$RELEASE_NOTES"</span></code></pre></td></tr></table></div></figure>


<p>千万不要使用verbose标记(-v)&ndash;这会暴露加密tokens.</p>

<h2>HOckeyApp</h2>

<p>注册一个<a href="http://hockeyapp.net/plans">HockeyApp账号</a>，并创建一个新的应用程序。然后在概述页面获取一个AppId.接下来，我们必须创建一个Api Token.打开<a href="https://rink.hockeyapp.net/manage/auth_tokens">这个页面</a>并创建一个。如果你希望自动的将新版本部署给所有的测试人员，那么请选择 Full Access版本。</p>

<p>对App Id 和token进行加密:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>travis encrypt "HOCKEY_APP_ID={app_id}" --add
</span><span class='line'>travis encrypt "HOCKEY_APP_TOKEN={api_token}" --add</span></code></pre></td></tr></table></div></figure>


<p>然后在sign-and-build.sh文件中调用相关的API:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl https://rink.hockeyapp.net/api/2/apps/$HOCKEY_APP_ID/app_versions \
</span><span class='line'>  -F status="2" \
</span><span class='line'>  -F notify="0" \
</span><span class='line'>  -F notes="$RELEASE_NOTES" \
</span><span class='line'>  -F notes_type="0" \
</span><span class='line'>  -F ipa="@$OUTPUTDIR/$APPNAME.ipa" \
</span><span class='line'>  -F dsym="@$OUTPUTDIR/$APPNAME.app.dSYM.zip" \
</span><span class='line'>  -H "X-HockeyAppToken: $HOCKEY_APP_TOKEN"</span></code></pre></td></tr></table></div></figure>


<p>注意我们还上传了dsym文件。如果集成了TestFlight或HockeyAppSdk，我们可以立即收集到易读的crash报告。</p>

<h2>Travis故障排除</h2>

<p>知道如何不通过直接访问编译环境就能找出问题是非常重要的。</p>

<p>在写本文的时候，还没有可以下载的虚拟机映像。如果Travis不能正常编译，首先试着在本地重现问题。在本地执行跟Travis相同的编译命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xctool ...</span></code></pre></td></tr></table></div></figure>


<p>为了调试shell脚本，首先需啊哟定义环境变量。我的做法是创建一个新的shell脚本来设置所有的环境变量。记得将这个脚本添加到 .gitignore文件中&ndash;因为我们不希望将该文件公开暴露出去。支队示例工程来说， config.sh脚本文件看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'># Standard app config
</span><span class='line'>export APP_NAME=TravisExample
</span><span class='line'>export DEVELOPER_NAME=iPhone Distribution: Mattes Groeger
</span><span class='line'>export PROFILE_NAME=TravisExample_Ad_Hoc
</span><span class='line'>export INFO_PLIST=TravisExample/TravisExample-Info.plist
</span><span class='line'>export BUNDLE_DISPLAY_NAME=Travis Example CI
</span><span class='line'>
</span><span class='line'># Edit this for local testing only, DON'T COMMIT it:
</span><span class='line'>export ENCRYPTION_SECRET=...
</span><span class='line'>export KEY_PASSWORD=...
</span><span class='line'>export TESTFLIGHT_API_TOKEN=...
</span><span class='line'>export TESTFLIGHT_TEAM_TOKEN=...
</span><span class='line'>export HOCKEY_APP_ID=...
</span><span class='line'>export HOCKEY_APP_TOKEN=...
</span><span class='line'>
</span><span class='line'># This just emulates Travis vars locally
</span><span class='line'>export TRAVIS_PULL_REQUEST=false
</span><span class='line'>export TRAVIS_BRANCH=master
</span><span class='line'>export TRAVIS_BUILD_NUMBER=0</span></code></pre></td></tr></table></div></figure>


<p>为了暴露所有的环境变量，执行如下命令(确保config.sh是可执行的)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>. ./config.sh</span></code></pre></td></tr></table></div></figure>


<p>然后试着运行 <code>echo $APP_NAME</code>,以此检查脚本是否正确。如果正确的话，那么现在我们不用做任何修改，就能在本地运行所有的shell脚本了。</p>

<p>如果在本地得到的是不同的编译信息，那么可能是使用了不同的库和gems.尽量试着将配置信息设置和Travis VM 相同的信息。Travis在这里列出了其所有的安装的软件版本，你也可以在travis的配置文件中添加调试信息得到所有库文件的版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem cocoapod --version
</span><span class='line'>brew --version
</span><span class='line'>xctool -version
</span><span class='line'>xcodebuild -version -sdk</span></code></pre></td></tr></table></div></figure>


<p>在本地安装好与服务器完全相同的软件之后，再重新编译项目。</p>

<p>如果获取的编译信息仍然不一样，试着将项目check out到一个新目录。并确保所有的缓存都已清空。每次编译程序时，Travis都会创建一个全新的虚拟机，所以不存在缓存的问题，但在你的本地机器上可能会出现。</p>

<p>一旦在本地重现出和服务器相同的错误，就可以开始调差具体问题了。当然导致问题的原因取决于具体问题。一般来说，通过Google都能找到引发问题的根源。</p>

<p>如果一个问题影响到了Travis上的其它项目，那么可能是Travis环境配置的原因。</p>

<h2>点评</h2>

<p>TravisCI跟市面上同类产品相比还是有一些限制。因为Travis运行在一个预先配置好的虚拟机上，因此必须为每次编译都安装一遍所有的依赖。这会花费一些额外的时间。不过Travis团队已经在着手提供一种缓存机制解决这个问题了。</p>

<p>在一定程度上，你会依赖于Travis所提供的配置。比如你只能使用Travis内置的Xcode版本进行编译。如果你本地使用的Xcode版本比较新，你的项目在服务器上可能无法编译通过。如果Travis能够为不同的Xcode版本都分别设置一个对应虚拟机会就好了。</p>

<p>对于复杂的项目来说，你可能希望把整个编译任务分为编译应用，运行集成测试等。这样你可以快速获得编译信息而不用等所有的测试都完后才能。目前Travis还没有直接支持有依赖的编译。</p>

<p>当项目被push到Github上时，travis会自动触发。不过编译动作不会立即触发，你的项目会被放到一个根据项目所用语言不同而不同的一个全局编译队列，不过专业版允许并发编译。</p>

<h2>总结</h2>

<p>Travis Ci提供了一个动能完整的持续集成环境，已进行应用程序的编译，测试和部署。对于开源项目来说，这项服务是完全免费的。很多社区都得益于GitHub强大的持续集成能力。</p>

<p>如果你还没有用过Travis.赶紧去试试吧，它棒极了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodejs-代码的组织和部署]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/22/nodejs-dai-ma-de-zu-zhi-he-bu-shu/"/>
    <updated>2016-05-22T09:45:22+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/22/nodejs-dai-ma-de-zu-zhi-he-bu-shu</id>
    <content type="html"><![CDATA[<p>有经验的C程序员在编写一个新程序时首先从make文件写起，同样的，使用nodejs编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修防止要先搭建脚手架。本章将介绍与之相关的各种知识</p>

<!--more-->


<ul>
<li><a href="#%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99">模块路径的解析规则</a></li>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F">命令行程序</a></li>
<li><a href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95">工程目录</a></li>
<li><a href="#NPM">NPM</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>


<h2><a name="模块路径的解析规则">模块路径的解析规则</a></h2>

<p>我们已经知道，require函数支持斜杠(/)或者盘符(C:)开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发而动全身。因此，require函数支持第三种形式的路径，写法类似foo/bar,并依次按照以上规则解析路径，知道找到模块位置。</p>

<h3>内置模块</h3>

<p>如果传递给require函数的是nodejs内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(&lsquo;fs&rsquo;)</p>

<h3>node_modules目录</h3>

<p>nodejs定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是 /home/user/hello.js,在该模块中使用require(&lsquo;foo/bar&rsquo;)方式加载模块时，则Nodejs依次尝试使用以下路径.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> /home/user/node_modules/foo/bar
</span><span class='line'> /home/node_modules/foo/bar
</span><span class='line'> /node_modules/foo/bar</span></code></pre></td></tr></table></div></figure>


<h3>NODE_PATH环境变量</h3>

<p>与PATH 环境变量类似，nodejs允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在LInux下使用<code>:</code>分隔，在windows下使用;分隔。例如定义了以下NODE_PATH环境变量:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NODE_PATH=/home/user/lib:/home/lib</span></code></pre></td></tr></table></div></figure>


<p>当使用require(&lsquo;foo/bar&rsquo;)的方式加载模块时，则nodejs依次尝试以下路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/home/user/lib/foo/bar
</span><span class='line'>/home/lib/foo/bar</span></code></pre></td></tr></table></div></figure>


<h2><a name="包">包</a></h2>

<p>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成，为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。</p>

<p>在组成一个包的所有子模块中，需要有个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/lib/
</span><span class='line'>    - cat/
</span><span class='line'>        head.js
</span><span class='line'>        body.js
</span><span class='line'>        main.js</span></code></pre></td></tr></table></div></figure>


<p>其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var head = require('./head');
</span><span class='line'>var body = require('./body');
</span><span class='line'>
</span><span class='line'>exports.create = function (name) {
</span><span class='line'>    return {
</span><span class='line'>        name: name,
</span><span class='line'>        head: head.create(),
</span><span class='line'>        body: body.create()
</span><span class='line'>    };
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require('/home/user/lib/cat/main')</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意，因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>

<h3>index.js</h3>

<p>当模块的文件件是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cat = require('/home/user/lib/cat');
</span><span class='line'>var cat = require('/home/user/lib/cat/index');</span></code></pre></td></tr></table></div></figure>


<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当做单个模块使用，更有整体感。</p>

<h3>package.json</h3>

<p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径，上例中的cat模块可以重构如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/lib/
</span><span class='line'>    - cat/
</span><span class='line'>        + doc/
</span><span class='line'>        - lib/
</span><span class='line'>            head.js
</span><span class='line'>            body.js
</span><span class='line'>            main.js
</span><span class='line'>        + tests/
</span><span class='line'>        package.json
</span><span class='line'>其中package.json内容如下。
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>    "name": "cat",
</span><span class='line'>    "main": "./lib/main.js"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如此一来，就同样可以使用require(&lsquo;/home/user/lib/cat&rsquo;)的方式加载模块。nodejs会根据包目录下的package.json找到入口模块所在位置。</p>

<h2><a name="命令行程序">命令行程序</a></h2>

<p>使用Nodejs编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>

<p>例如我们用nodejs写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要用以下终端命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node /home/user/bin/node-echo.js Hello World
</span><span class='line'>Hello World</span></code></pre></td></tr></table></div></figure>


<p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node-echo Hello World</span></code></pre></td></tr></table></div></figure>


<h3>Linux</h3>

<p>在linux系统下，我们可以把JS文件当做shell脚本来运行，从而达到上述目的，具体步骤如下：</p>

<p>在shell脚本中，可以通过 #! 注释来指定当前脚本使用的解析器。所以我们首先在 node-echo.js文件顶部增加以下一行注释，表明当前脚本使用nodejs解析。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> #! /usr/bin/env node</span></code></pre></td></tr></table></div></figure>


<p>NodeJs会忽略掉位于JS模块首行的 <code>#!</code>注释，不必担心这行注释是非法语句。</p>

<p>然后，我们使用以下命令赋予node-echo.js文件执行权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $ chmod +x /home/user/bin/node-echo.js</span></code></pre></td></tr></table></div></figure>


<p>最后，我们在PATH环境变量中指定的某个目录下，例如在 /usr/local/bin下创建了一个软连接文件，文件名与我们希望使用的终端命令同名，命令如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> $ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo
</span></code></pre></td></tr></table></div></figure>


<p>这样处理后，我们就可以在任何目录下使用 node-echo 命令了。</p>

<h2><a name="工程目录">工程目录</a></h2>

<p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/workspace/node-echo/   # 工程目录
</span><span class='line'>    - bin/                          # 存放命令行相关代码
</span><span class='line'>        node-echo
</span><span class='line'>    + doc/                          # 存放文档
</span><span class='line'>    - lib/                          # 存放API相关代码
</span><span class='line'>        echo.js
</span><span class='line'>    - node_modules/                 # 存放三方包
</span><span class='line'>        + argv/
</span><span class='line'>    + tests/                        # 存放测试用例
</span><span class='line'>    package.json                    # 元数据文件
</span><span class='line'>    README.md                       # 说明文件</span></code></pre></td></tr></table></div></figure>


<p>其中部分文件内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* bin/node-echo */
</span><span class='line'>var argv = require('argv'),
</span><span class='line'>    echo = require('../lib/echo');
</span><span class='line'>console.log(echo(argv.join(' ')));
</span><span class='line'>
</span><span class='line'>/* lib/echo.js */
</span><span class='line'>module.exports = function (message) {
</span><span class='line'>    return message;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>/* package.json */
</span><span class='line'>{
</span><span class='line'>    "name": "node-echo",
</span><span class='line'>    "main": "./lib/echo.js"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2><a name="NPM">NPM</a></h2>

<p>NPM是随同nodejs一起安装的包管理工具，能解决nodejs代码部署上的很多问题，常见的使用场景有以下几种：</p>

<ul>
<li>允许用户从NPM服务器上下载被人编写的三方包到本地使用</li>
<li>允许用户从NPM服务器上下载并安装别人编写的命令行程序到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>


<p>可以看到，NPM建立了一个nodejs生态圈，nodejs开发者和用户可以在里面胡同有无。以下分别介绍这三种场景下怎样使用NPM</p>

<h3>下载三方包</h3>

<p>需要使用第三方包时，首先得知道有那些包可用。虽然 nspmjs.org提供了搜索框可以根据报名来搜索，但如果连想使用的第三方包的名字都不确定的话，就请百度一下吧。知道了包名之后，比如上边中的argv,就可以在工程目录中打开终端，使用以下命令下载第三方包</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install argv
</span><span class='line'>...
</span><span class='line'>argv@0.0.2 node_modules\argv</span></code></pre></td></tr></table></div></figure>


<p>下载后之后，argb包就放在了工程目录下的node_modules目录中，因此在代码中只需要通过<code>require('argv')</code>的方式就好，无需指定第三方的包路径</p>

<p>以上命令默认下载最新版的第三方包，如果想要下载指定版本的话，可以在包名边上加上@(version),例如通过以下命令可以下载0.0.1版的argv</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install argv@0.0.1
</span><span class='line'>...
</span><span class='line'>argv@0.0.1 node_modules\argv</span></code></pre></td></tr></table></div></figure>


<p>如果使用到的第三方包比较多，在终端下一个包一条命令地安装未免太费劲了，因此NPM对 package.json的字段做了扩展，允许在其中申明三方包依赖，因此，上边的例子中的package.json可以改写如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": "node-echo",
</span><span class='line'>    "main": "./lib/echo.js",
</span><span class='line'>    "dependencies": {
</span><span class='line'>        "argv": "0.0.2"
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样处理后，在工程目录下就可以使用npm install 命令批量安装第三方包了。更重要的是，当以后node_echo也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的第三方包依赖自动下载进一步依赖的三方包。例如，使用 <code>npm install node-echo</code> 命令时，NPM会自动创建一下目录结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- project/
</span><span class='line'>    - node_modules/
</span><span class='line'>        - node-echo/
</span><span class='line'>            - node_modules/
</span><span class='line'>                + argv/
</span><span class='line'>            ...
</span><span class='line'>    ...</span></code></pre></td></tr></table></div></figure>


<p>如此一来，用户只需关心自己直接使用的第三方包，不需要自己去解决所有包的依赖关系。</p>

<h3>安装命令行程序</h3>

<p>从NPM服务器上下载安装一个命令行程序的方法与三方包类似，例如上例中的node-echo提供了命令行使用方式，只要node-echo自己配置好了相关的package.json字段，对于用户而言，只需要使用以下命令安装程序。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install node-echo -g</span></code></pre></td></tr></table></div></figure>


<p>参数中的 -g 表示全局安装，因此node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软连接或windows系统下需要的.cmd文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /usr/local/               # Linux系统下
</span><span class='line'>    - lib/node_modules/
</span><span class='line'>        + node-echo/
</span><span class='line'>        ...
</span><span class='line'>    - bin/
</span><span class='line'>        node-echo
</span><span class='line'>        ...
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>- %APPDATA%\npm\            # Windows系统下
</span><span class='line'>    - node_modules\
</span><span class='line'>        + node-echo\
</span><span class='line'>        ...
</span><span class='line'>    node-echo.cmd
</span><span class='line'>    ...</span></code></pre></td></tr></table></div></figure>


<h3>发布代码</h3>

<p>第一次使用NPM发布代码前需要注册一个账号。终端下运行 npm adduser,之后按照提示做即可。账号搞定后，接着我们需要编辑 package.json文件，加入NPM必需的字段。接着上边 node-echo的例子，package.json 里必要的字段如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "name": "node-echo",           # 包名，在NPM服务器上须要保持唯一
</span><span class='line'>    "version": "1.0.0",            # 当前版本号
</span><span class='line'>    "dependencies": {              # 三方包依赖，需要指定包名和版本号
</span><span class='line'>        "argv": "0.0.2"
</span><span class='line'>      },
</span><span class='line'>    "main": "./lib/echo.js",       # 入口模块位置
</span><span class='line'>    "bin" : {
</span><span class='line'>        "node-echo": "./bin/node-echo"      # 命令行程序名和主模块位置
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>之后，我们就可以在package.json所在目录下运行 npm publish 发布代码了。</p>

<h3>版本号</h3>

<p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>

<p>语义版本号分为X.Y.Z三位，分别代表主版本号，次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ 如果只是修复bug，需要更新Z位。
</span><span class='line'>
</span><span class='line'>+ 如果是新增了功能，但是向下兼容，需要更新Y位。
</span><span class='line'>
</span><span class='line'>+ 如果有大变动，向下不兼容，需要更新X位。</span></code></pre></td></tr></table></div></figure>


<h3>灵机一点</h3>

<p>除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc查看官方文档之外，这里再介绍一些NPM常用命令</p>

<ul>
<li>NPM提供了很多命令，例如install和publish，使用NPM help可查看所有命令</li>
<li>使用 npm help 可查看某条命令的详细帮助，例如 npm help install</li>
<li>在package.json所在目录下使用 <code>npm install -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update &lt;package&gt;</code>可以把当前目录下node_modules子目录边的对应模块更新至最新版本</li>
<li>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版</li>
<li>使用<code>npm cache clear</code>可以清空 NPM本地缓存，用于对付使用相同版本号发布新版本代码的人</li>
<li>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发不过的某个版本</li>
</ul>


<h2><a name="小结">小结</a></h2>

<ul>
<li>编写代码前先规划好目录结果，才能做到有条不紊</li>
<li>稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块</li>
<li>合理使用 node_modules和NODE_PATH来解耦包的使用方式和物理路径</li>
<li>使用NPM加入Nodejs生态圈互通有无</li>
<li>想到了心仪的包名时请提前在NPM上抢注</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodejs基础]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/21/nodejsji-chu/"/>
    <updated>2016-05-21T12:45:39+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/21/nodejsji-chu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNodeJS">什么是NodeJS</a></li>
<li><a href="#%E7%94%A8%E9%80%94">用途</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>


<!--more-->


<h2><a name="什么是NodeJS">什么是NodeJS</a></h2>

<p>JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在 HTML 页面里的 JS，浏览器充当了解析器的角色。而对于需要独立运行的 JS，NodeJS 就是一个解析器。</p>

<p>每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作 DOM，浏览器就提供了 document 之类的内置对象。而运行在 NodeJS 中的 JS 的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了 fs、http 等内置对象。</p>

<h2><a name="用途">用途</a></h2>

<p>尽管存在一听说可以直接运行JS文件就觉得很酷的同学，但大多数同学在接触新东西时首先关心的有啥用户，以及能带来什么价值</p>

<p>NodeJS的作者说，他创造NodeJS的目的是为了实现提高性能web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成了天然的选择。</p>

<p>如他所愿，NodeJs在服务器端活跃起来，出现了大批基于NodeJs的web服务。而另一方面，NOdeJS让前端如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。</p>

<p>因此，对于前端而言，虽然不是人人都要拿NodeJs写一个服务器端程序，但简单使用命令交互模式调试JS片段，复杂可至编写工具提升工作效率。</p>

<p>NodeJS生态圈正欣欣向荣</p>

<h2><a name="安装">安装</a></h2>

<p>NodeJs提供了一些安装程序，都可以在nodejs.org这里下载并安装</p>

<p>在MacOs系统下，选择.pkg后缀的安装文件.</p>

<h3>编译安装</h3>

<p>Linux系统下没有现成的安装程序可用，虽然一些发行版可以使用 apt-get之类的方式安装，但不一定能安装到最新版。因此Linux系统下一班使用以下方式编译方式安装NodeJs。</p>

<ol>
<li>确保系统下 g++版本在4.6以上，python版本在2.6以上</li>
<li>从nodejs.org下载tar.gz后缀的NodeJS最新版源代码包并解压到某个位置</li>
<li>进入解压到的目录，使用以下命令编译和安装</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./configure
</span><span class='line'>
</span><span class='line'>$ make
</span><span class='line'>
</span><span class='line'>$ sudo make install</span></code></pre></td></tr></table></div></figure>


<h2><a name="运行">运行</a></h2>

<p>打开终端，键入node进入命令交互模式，可以输入一条语句后立即执行并显示效果，例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node
</span><span class='line'>&gt; console.log('Hello World!');
</span><span class='line'>Hello World!</span></code></pre></td></tr></table></div></figure>


<p>如果要运行一大段代码的话，可以先写一个JS文件再运行，例如有以下hello.js</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function hello() {
</span><span class='line'>    console.log('Hello World!');
</span><span class='line'>}
</span><span class='line'>hello();</span></code></pre></td></tr></table></div></figure>


<p>写好后，在终端键入 node hello.js运行，结果如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node hello.js
</span><span class='line'>Hello World!</span></code></pre></td></tr></table></div></figure>


<h3>权限问题</h3>

<p>在Linux系统下，使用NodeJs监听80或者443端口提供HTTP(s)服务时需要root权限，有两种方式可以做到.</p>

<p>一种方式是使用sudo命令运行NodeJs,例如通过以下命令运行的server.js中有权限使用80和443端口，一般推荐这种方式，可以保证仅为有需要的js脚本提供root权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo node server.js</span></code></pre></td></tr></table></div></figure>


<p>另一种方式是使用chmod + s 命令让NodeJs总是以root权限运行，具体做法如下，因为这种方式让任何JS脚本都有了root权限，不太安全，因此在需要很考虑安全下不推荐使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo chown root /usr/local/bin/node
</span><span class='line'>$ sudo chmod +s /usr/local/bin/node</span></code></pre></td></tr></table></div></figure>


<h2><a name="模块">模块</a></h2>

<p>编写稍大一点的程序时一般都会讲代码模块化，在NOdeJs中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名.</p>

<p>在编写每一个模块时，都有 <code>require</code>,<code>exports</code>,<code>module</code>三个预先定义好的变量可供使用。</p>

<h3>3 Require</h3>

<p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径(以./开头)，或者是绝对路径(以/或C:之类的盘符开头).另外，模块名中的.js扩展名可以省略。以下是一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var foo1 = require('./foo');
</span><span class='line'>var foo2 = require('./foo.js')
</span><span class='line'>var foo3 = require('/home/user/foo')
</span><span class='line'>var foo4 = require('/home/user/foo.js')</span></code></pre></td></tr></table></div></figure>


<p>//foo1至foo4中保存的是统一模块的导出对象。另外可以使用以下方式加载和使用一个JSON文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var data = require('./data.json')</span></code></pre></td></tr></table></div></figure>


<h3>exports</h3>

<p>exports对象是当前模块的导出对象，用于导出模块共有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个共有方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exports.hello = function () {
</span><span class='line'>    console.log('Hello World!');
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>以上代码中，模块默认导出对象被替换为一个函数。</p>

<h3>模块初始化</h3>

<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>

<h3>主模块</h3>

<p>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。住模块负责调度祖成整个程序的其它模块完成工作，例如通过以下命令启动程序时，main.js就是主模块.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node main.js</span></code></pre></td></tr></table></div></figure>


<p>完整示例:</p>

<p>例如有以下目录:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/hello/
</span><span class='line'>    - util/
</span><span class='line'>        counter.js
</span><span class='line'>    main.js</span></code></pre></td></tr></table></div></figure>


<p>其中counter.js内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var i = 0;
</span><span class='line'>
</span><span class='line'>function count() {
</span><span class='line'>    return ++i;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>exports.count = count;</span></code></pre></td></tr></table></div></figure>


<p>该模块内部定义了一个私有变量i,并在exports对象导出了一个共有方法count.</p>

<p>主模块main.js内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var counter1 = require('./util/counter');
</span><span class='line'>var    counter2 = require('./util/counter');
</span><span class='line'>
</span><span class='line'>console.log(counter1.count());
</span><span class='line'>console.log(counter2.count());
</span><span class='line'>console.log(counter2.count());</span></code></pre></td></tr></table></div></figure>


<p>运行该程序的结果如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node main.js
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3</span></code></pre></td></tr></table></div></figure>


<p>可以看到，counter.js并没有因为被require了两次而初始化两次</p>

<h2><a name="小结">小结</a></h2>

<p>本章介绍了有关NodeJs的基本概念和使用方法，总结起来有以下知识点:</p>

<ul>
<li>NodeJs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把nodejs执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令</li>
<li>终端下直接输入node命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式</li>
<li>nodejs使用CMD模块系统，主模块作为程序入口点，所有模块在执行剁成中只初始化一次。</li>
<li>除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-构造函数]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu/"/>
    <updated>2016-05-16T15:38:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<p>本章包含的内容的如下:</p>

<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E8%B5%8B%E5%80%BC">存储属性的初始赋值</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">自定义构造过程</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8">默认构造器</a></li>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%90%86">值类型的构造器代理</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">类的集成和构造过程</a></li>
<li><a href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8">可失败构造器</a></li>
<li><a href="#%E5%BF%85%E8%A6%81%E6%9E%84%E9%80%A0%E5%99%A8">必要构造器</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E6%88%96%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">通过闭包或函数设置属性的默认值</a></li>
</ul>


<!--more-->


<p>构造过程是使用类，结构体或枚举型的实例之前的准备过程。在新实例可用钳必须执行这个过程，具体操作包括设置实例中的每个存储属性的初始值和执行其他必须的设置或初始化工作</p>

<p>通过定义构造器(Initializers)来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与Objc中的构造器不同，Swift的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>

<p>类的实例也可以通过定义析构器(deinitializer)在实例释放前执行特定的清除工作。</p>

<h2><a name="存储属性的初始赋值">存储属性的初始赋值</a></h2>

<p>类和结构体在创建实例时，必须为所有的存储属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>

<p>你可以在构造器中为存储属性赋初值，也可以在定义属性时为其设置默认值。以下小节详细讨论这两个方法。</p>

<blockquote><p><em>注意</em>
当你为存储型属性设置默认值或者在构造器中为期赋值时，它们的值是被直接设置的，不会触发任何属性观察期(property observers)</p></blockquote>

<h3>构造器</h3>

<p>构造器在创建某个特定类型的新实例时被调用。它的最简单形式类似于一个不带任何参数的实例方法，以关键字init命名:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(){
</span><span class='line'>  //在此执行构造过程
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit,它拥有一个<code>double</code>类型的存储型属性 temperature:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit{
</span><span class='line'>  var temperature:Double
</span><span class='line'>  init(){
</span><span class='line'>    temparture = 32.0
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var f = Fahrenheit()
</span><span class='line'>print("The default temperature is \(f.temperature)° Fahrenheit")
</span><span class='line'>// 输出 "The default temperature is 32.0° Fahrenheit”</span></code></pre></td></tr></table></div></figure>


<p>这个结构体定义了一个不带参数的构造器init,并在里面将存储属性temperature 的值初始化为32</p>

<h3>默认初始值</h3>

<p>如前所述，你可以在构造器中为存储型属性设置初始化，同样，你也可以在属性声明时为其设置默认值</p>

<blockquote><p><em>注意</em>
如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的。只不过使用默认值让属性的初始化和声明结合的更紧密。使用默认值能让你的构造器更简洁，更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器，构造器继承等特性</p></blockquote>

<p>你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit{
</span><span class='line'>  var temperature = 32.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2><a name="自定义构造过程">自定义构造过程</a></h2>

<p>你可以通过输入参数可可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。</p>

<h3>构造参数</h3>

<p>自定义构造过程时，可以在定义中提供构造函数，指定所需值的类型和名字。构造参数的功能和语法跟函数的方法的参数相同。</p>

<p>下面例子中定义了一个包含摄氏温度的结构体<code>Celsius</code>.它定义了两个不同的构造器:init(fromFahrenheit:)和init(fromKelvin:),两者分别通过接受不同温标下的温度值来创建新的实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
</span><span class='line'>// boilingPointOfWater.temperatureInCelsius 是 100.0
</span><span class='line'>let freezingPointOfWater = Celsius(fromKelvin: 273.15)
</span><span class='line'>// freezingPointOfWater.temperatureInCelsius 是 0.0”</span></code></pre></td></tr></table></div></figure>


<p>第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit;第二个构造器也拥有一个构造函数，其外部名字为 fromKelvin,内部名字为 kelvin.这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性temperatureInCelsius中</p>

<h3>参数的内部名称和外部名称</h3>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要工作构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift会为构造器的每个参数自动生成一个跟内部名字相同的外部名.</p>

<p>以下例子中定义了一个结构体Color,它包含了三个常量:<code>red</code>,<code>green</code>和<code>blue</code>.这些属性可以存储在0-1之间的值，用来表示红绿蓝成分的含量</p>

<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造函数，Color也可以提供第二个狗奥奇，它只包含名为white的double类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Color {
</span><span class='line'>    let red, green, blue: Double
</span><span class='line'>    init(red: Double, green: Double, blue: Double) {
</span><span class='line'>        self.red   = red
</span><span class='line'>        self.green = green
</span><span class='line'>        self.blue  = blue
</span><span class='line'>    }
</span><span class='line'>    init(white: Double) {
</span><span class='line'>        red   = white
</span><span class='line'>        green = white
</span><span class='line'>        blue  = white
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>两种构造器都能用于创建一个新的color实例，你需要为构造器每个外部参数传入值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</span><span class='line'>let halfGray = Color(white: 0.5)</span></code></pre></td></tr></table></div></figure>


<p>注意,如果不通过外部参数名子传值，你是没法调用这个构造器的，只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let veryGreen = Color(0.0, 1.0, 0.0)
</span><span class='line'>// 报编译时错误，需要外部名称</span></code></pre></td></tr></table></div></figure>


<h4>不带外部名的构造参数</h4>

<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为.</p>

<p>下面是之前的Celsius例子的扩展，跟之前相比添加了一个带有double类型参数的构造器，其外部名用_代替:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>    init(_ celsius: Double){
</span><span class='line'>        temperatureInCelsius = celsius
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let bodyTemperature = Celsius(37.0)
</span><span class='line'>// bodyTemperature.temperatureInCelsius 为 37.0</span></code></pre></td></tr></table></div></figure>


<p>调用Celsius(37.0)意图明确，不需要外部参数名称。以此适合使用
<code>Celsius(37.0)</code>这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。</p>

<h3>可选属性类型</h3>

<p>如果你你定制的类型包含一个逻辑上允许取值为空的存储性属性 &ndash; 无论是因为它无法再初始化时赋值，还是因为它在之后某个时间点可以赋值为空&ndash;你都需要将它定为可选类型(optional type).可选类型的属性将自动初始化为nil,表示这个属性是有意在初始化时设置为空的。</p>

<p>下面的例子中定义了类<code>SurveyQuestion</code>,它包含了一个可选字符串属性response:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    var text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        print(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
</span><span class='line'>cheeseQuestion.ask()
</span><span class='line'>// 输出 "Do you like cheese?"
</span><span class='line'>cheeseQuestion.response = "Yes, I do like cheese."</span></code></pre></td></tr></table></div></figure>


<p>迪奥哈问题的答案在回答前是无法确定的，因此我们将属性response声明为string?类型，或者说是可选字符串类型，当<code>SurveyQuestion</code>实例化时，它将自动赋值为nil,表明此字符串暂时还没有值</p>

<h3>构造过程中的属性修改</h3>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量尚需经被赋值，它将永远不可更改。</p>

<blockquote><p><em>注意:</em>
对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</p></blockquote>

<p>你可以修改上面的SurveyQuestion实例，用常量属性替代变量属性text,表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    let text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        print(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let beetsQuestion = SurveyQuestion(text: "How about beets?")
</span><span class='line'>beetsQuestion.ask()
</span><span class='line'>// 输出 "How about beets?"
</span><span class='line'>beetsQuestion.response = "I also like beets. (But not with cheese.)"</span></code></pre></td></tr></table></div></figure>


<h2><a name="默认构造器">默认构造器</a></h2>

<p>如果结构体或类的所有属性都有默认值，同事没有自定义的构造器，那么Swift会给这些结构体或类提供一个默认的构造器(default initalilizers)。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>

<p>下面例子中创建了一个类ShoppingListItem,它封装了购物清单中的某一个物品的属性:名字，数量和购买状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem {
</span><span class='line'>    var name: String?
</span><span class='line'>    var quantity = 1
</span><span class='line'>    var purchased = false
</span><span class='line'>}
</span><span class='line'>var item = ShoppingListItem()</span></code></pre></td></tr></table></div></figure>


<p>由于ShoppingListItem类中所有属性都有默认值，且它没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器，上面例子中使用默认构造创造了一个ShoppingListItem类的实例，并将其赋值给变量 item</p>

<h3>结构起的逐一成员的构造器</h3>

<p>除了上面提到的默认构造器，如果结构起没有提供自定义的构造器，他们将自动获得一个逐一成员构造器，及时结构天气的存储型尚需经没有默认值。</p>

<p>逐一成员构造器是用来初始化结构体新实例成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值</p>

<p>下面例子中定义了结构体size,包含两个属性width和height。swift可以根据这两个属性的初始赋值0自动推导出他们的类型为double</p>

<p>结构体size自动获得了一个逐一成员构造器init(width:height:)。你可以用它来为size创建新的实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>let twoByTwo = Size(width: 2.0, height: 2.0)</span></code></pre></td></tr></table></div></figure>


<h2><a name="值类型的构造器代理">值类型的构造器代理</a></h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程成为构造器代理，它能减少多个构造器间的代码重用。</p>

<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>

<p>对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init</p>

<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员的构造器）。这种限制可以防止你为值类型增加了一个额外的且十分负载的构造器之后，仍然有人错误的使用自动生成的构造器</p>

<blockquote><p><em>注意</em>
如果你希望默认构造器，逐一成员构造器以及你自己的自定义的构造器都能用来创建实例，可以将自定义的构造器写到扩展中，而不是写在值类型的原始定义中。</p></blockquote>

<p>下面的例子将定义一个结构体 rect,用来代表几何矩形。这个例子需要两个辅助的结构体Size和point,它们各自为其所有的属性提供了默认值0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以通过以下三种方式为Rect创建实例&ndash;使用被初始化为默认值的origin和Size属性来初始化；提供指定的origin和size实例来初始化；提供指定的center和size来初始化。在下面Rect结构体定义中，我们为这三种方式提供了三个自定义的构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    
</span><span class='line'>    init(){
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(origin:Point,size:Size){
</span><span class='line'>        self.origin = origin
</span><span class='line'>        self.size = size
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(center:Point,size:Size){
</span><span class='line'>        let originX = center.x - (size.width/2)
</span><span class='line'>        let originY = center.y - (size.height/2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第一个Rect构造器init(),在功能上跟没有自定义构造器自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号{}来表示，它没有指定任何构造过程。调用这个构造器将返回一个Rect实例，它的origin和size属性都是用定义时的默认值Point(x: 0.0, y: 0.0)和Size(width: 0.0, height: 0.0)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let basicRect = Rect()
</span><span class='line'>// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</span></code></pre></td></tr></table></div></figure>


<p>第二个Rect构造器init(origin:size:)，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单的将origin和size的参数值赋给对应的存储性属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<p>第三个Rect构造器init(center:size:)稍微复杂一点。它先通过center和size的值计算出origin的坐标，然后再调用init(origin:size:)构造器来将新的origin和size值赋值到对应的属性中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p>构造器init(center:size:)可以直接将origin和size 的新值赋值到对应的属性中。然而，利用恰好提供了相关功能的现有构造器会更为方便，构造器init(center:size:)的意图也会更加清晰</p>

<h2><a name="类的集成和构造过程">类的集成和构造过程</a></h2>

<p>类里面的所有存储性属性&ndash;包括所有继承自父类的属性&ndash;都必须在构造过程中设置初始值</p>

<p>Swift为类类型提供了两种构造器来确保实例中所有存储性属性都能获得初始值，它们分别是指定构造器和便利构造器</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链上调用父类的构造器来实现父类的初始化</p>

<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>

<p>便利构造器(convenience initializers)是类中比较次要的，辅助性的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或者特定输入值的实例</p>

<p>你应当只在必要的时候为类提供便利构造器，比方或某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造郭恒更清晰明了</p>

<h3>指定构造器和便利构造器的语法</h3>

<p>类的指定构造器的写法跟值类型简单构造器一样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>convenience init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>类的构造器代理规则</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift采用以下三条规则来限制构造器之间的代理调用:</p>

<ul>
<li>规则1 指定构造器必须调用其直接父类的指定构造器</li>
<li>规则2 便利构造器必须调用同一类中定义的其它构造器</li>
<li>规则3 便利构造器必须最终导致一个指定构造器被调用</li>
</ul>


<p>一个更方便记忆的方式是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p>这些规则可以通过下面的图例来说明:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation01_2x.png" alt="init" /></p>

<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到 规则2和3.而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则1</p>

<blockquote><p><em>注意</em>
这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类定义如何实现。</p></blockquote>

<p>下图中展示了一种涉及四个类的更复杂的类层次结构。它演示了指定构造器是如何在类层次中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation02_2x.png" alt="te" /></p>

<h3><a name="两段式构造过程">两段式构造过程</a></h3>

<p>Swift中类的构造过程包含两个阶段。第一个阶段，每个存储属性被引入它们的类指定一个初始值。当每个存储性属性的初始值被确定后，第二个阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储性属性。</p>

<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>

<blockquote><p><em>注意</em>
Swift的两段时构造过程跟Objective-C中的构造过程类似。最主要的区别在于阶段1，Objective-C给每一个属性赋值0或空值(比如说0或nil)。Swift的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</p></blockquote>

<p>Swift编译器将执行4种有效的安全检查，已确保两段式构造过程能不出错地完成：</p>

<p><em>安全检查1</em></p>

<p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类的构造器</p>

<p>如上所述，一个对象的内存只有在其所有存储性苏醒确定之后次啊能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>

<p><em>安全检查2</em></p>

<p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>

<p><em>安全检查3</em></p>

<p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中的其它指定构造器所覆盖</p>

<p><em>安全检查4</em></p>

<p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</p>

<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例会成为有效实例，才能访问属性和调用方法。</p>

<p>以下是两段式构造过程中基于上述安全检查的构造流程展示:</p>

<p><em>阶段1</em></p>

<ul>
<li>某个指定构造器或便利构造器被调用</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化</li>
<li>这个调用父类的构造器的过程沿着构造器链一直往上执行，知道到达构造器链的最顶层</li>
<li>当到达了构造器链的最顶部，且已确保所有势力包含的存储型属性都已经赋值，这个实例的内存被认为已经完成初始化。此时阶段1完成</li>
</ul>


<p><em>阶段2</em></p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self.修改它的属性并调用实例方法等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self</li>
</ul>


<p>下图展示了在假定的子类和父类之间的构造阶段1</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization01_2x.png" alt="1" /></p>

<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>

<p>如安全检查1所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程</p>

<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>

<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完成初始化，阶段1完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization02_2x.png" alt="2" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例。</p>

<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作。
最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作</p>

<h3>构造器的继承和重写</h3>

<p>跟Objc中的子类不同，Swift中的子类默认情况下不会继承父类的构造器。Swift的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>

<blockquote><p><em>注意</em></p>

<p>父类的构造器仅会在安全和适当的情况下被继承</p></blockquote>

<p>假如你希望自定义的子类中能提供一个或多个父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>

<p>当你编写与一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code>修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符。</p>

<p>正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>

<blockquote><p><em>注意</em>
当你重写了父类的指定构造器时，你总是需要写override修饰符，即使你的子类的指定构造器重写为了便利构造器</p></blockquote>

<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>

<p>在下面的例子中定义了一个叫做<code>Vehicle</code>的基类。基类中声明了一个存储型属性<code>numberOfWheels</code>,它是值为0的Int类型的存储型属性。numberOfWheel属性用于创建名为descrpiption的<code>String</code>类型的计算型属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Vehicle {
</span><span class='line'>    var numberOfWheels = 0
</span><span class='line'>    var description: String {
</span><span class='line'>        return "\(numberOfWheels) wheel(s)"
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Vehicle</code>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器，自动获得的默认构造器总会是类中的指定构造器，它可以用于创建numberOfWheels为0的Vehicle实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vehicle = Vehicle()
</span><span class='line'>print("Vehicle: \(vehicle.description)")
</span><span class='line'>// Vehicle: 0 wheel(s)</span></code></pre></td></tr></table></div></figure>


<p>下面例子中，定义了Vehicle的子类Bicycle:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Bicycle: Vehicle {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init()
</span><span class='line'>        numberOfWheels = 2
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>子类<code>Bicycle</code>定义了一个自定义的指定构造器init(),这个指定构造器和父类的指定构造器匹配，所以<code>Bicycle</code>中的指定构造器需要带上override修饰符</p>

<p><code>Bicycle</code>的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类<code>Vechicle</code>的默认构造器，这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被<code>Vehicle</code>类初始化。在调用super.init()之后，属性<code>numberOfWheels</code>的原值被新值2替换。</p>

<p>如果你创建了<code>Bicycle</code>实例，你可以调用继承的<code>description</code>计算型属性去查看属性<code>numberOfWheels</code>是否有改变:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let bicycle = Bicycle()
</span><span class='line'>print("Bicycle: \(bicycle.description)")
</span><span class='line'>// Bicycle: 2 wheel(s)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性</p></blockquote>

<h3>构造器的自动继承</h3>

<p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>

<p>假如你为子类中引入的所有新属性都提供了默认值，以下2个规则适用：</p>

<p><em>规则1</em></p>

<p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器</p>

<p><em>规则2</em></p>

<p>如果子类提供了所有父类指定构造器的实现&ndash;无论是通过规则1继承过来的，还是提供了自定义实现&ndash;它将自动继承所有父类的便利构造器。</p>

<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用</p>

<blockquote><p><em>注意</em>
对于规则2，子类可以将父类的指定构造器实现为便利构造器</p>

<p><em>总结:</em></p>

<p>如果子类继承父类，在子类的构造器中，如果是继承的属性，则先调用<code>super.init(...)</code>方法，先让父类完成属性初始化，然后再对继承的属性赋值;</p>

<p>如果子类中独有的属性，则先完成子类属性的初始化，再调用父类的<code>super.init(...)</code>方法</p></blockquote>

<h3>指定构造器和便利构造器实践</h3>

<p>接下来的例子将在实践中展示知道你给构造器，便利构造器以及构造器的自动继承。这个例子定义了包含三个类<code>Food</code>,<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示他们的构造器是如何相互作用的。</p>

<p>类层次中的基类是Food,它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建<code>Food</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Food {
</span><span class='line'>    var name:String
</span><span class='line'>    init(name:String){
</span><span class='line'>     self.name = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    convenience init(){
</span><span class='line'>        self.init(name:"[Unnamed]")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下图中展示了<code>Food</code>的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample01_2x.png" alt="1" /></p>

<p>类类型没有默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let namedMeat = Food(name: "Bacon")
</span><span class='line'>// namedMeat 的名字是 "Bacon”</span></code></pre></td></tr></table></div></figure>


<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保<code>Food</code>实例的所有存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造过程。</p>

<p>Food类同样提供了一个没有参数的便利构造器init().这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理指定构造器<code>init(name: String)</code>并给参数name传值[unnamed]来实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mysteryMeat = Food()
</span><span class='line'>// mysteryMeat 的名字是 [Unnamed]</span></code></pre></td></tr></table></div></figure>


<p>类层级中的第二类是Food的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了Int类型的属性<code>quantity</code>（以及从Food继承过来的name属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RecipeIngredient: Food {
</span><span class='line'>    var quantity:Int
</span><span class='line'>    init(name:String,quantity:Int){
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name:name)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override convenience init(name:String){
</span><span class='line'>        self.init(name:name,quantity: 1)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下图中展示了<code>RecipeIngredient</code>类的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample02_2x.png" alt="1" /></p>

<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来填充<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quanity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的尚需经。随后，构造器向上代理到父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足 <a href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">两段式构造过程中</a> 的安全检查1</p>

<p><code>RecipeIngredient</code>还定义了一个便利构造器 <code>init(name: String)</code>，它只通过 <code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为1，所以不需要显式指明数量即可创建出实例。</p>

<p>这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个<code>quantity</code>为1的<code>RecipeIngredient</code>实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并且为quantity参数传递1.</p>

<p>注意,<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>,因此必须在前面使用override修饰符</p>

<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>

<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器init().这个便利构造器会被<code>RecipeIngredient</code>继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是Food提供的版本。</p>

<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let oneMysteryItem = RecipeIngredient()
</span><span class='line'>let oneBacon = RecipeIngredient(name: "Bacon")
</span><span class='line'>let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)</span></code></pre></td></tr></table></div></figure>


<p>类层级中的第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>,这个类构建了购物单中出现的某一种调味料。</p>

<p>购物单中每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code>引入了布尔类型的属性<code>purchased</code>,它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>,它提供了关于<code>ShoppingListItem</code>实例的一个文字描述:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem: RecipeIngredient {
</span><span class='line'>    var purchased = false
</span><span class='line'>    var description: String {
</span><span class='line'>        var output = "\(quantity) x \(name)"
</span><span class='line'>        output += purchased ? " ✔" : " ✘"
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意:</em></p>

<blockquote><p><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p></blockquote></blockquote>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>

<p>下团展示了这三个类的构造器链:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample03_2x.png" alt="1" /></p>

<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var breakfastList = [
</span><span class='line'>    ShoppingListItem(),
</span><span class='line'>    ShoppingListItem(name: "Bacon"),
</span><span class='line'>    ShoppingListItem(name: "Eggs", quantity: 6),
</span><span class='line'>]
</span><span class='line'>breakfastList[0].name = "Orange juice"
</span><span class='line'>breakfastList[0].purchased = true
</span><span class='line'>for item in breakfastList {
</span><span class='line'>    print(item.description)
</span><span class='line'>}
</span><span class='line'>// 1 x orange juice ✔
</span><span class='line'>// 1 x bacon ✘
</span><span class='line'>// 6 x eggs ✘</span></code></pre></td></tr></table></div></figure>


<p>如上所述，例子中通过字面量方式创建了一个数组<code>breakfastList</code>，它包含了三个
<code>ShoppingListItem</code>实例，因此数组的类型也能被自动推导为<code>[ShoppingListItem]</code>.在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从[unnamed]更改为 <code>orange juice</code>，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>

<h2><a name="可失败构造器">可失败构造器</a></h2>

<p>如果一个类，结构起或枚举类型的对象，在构造过程中有可能失败，则为其定义个可失败的构造器。这里所指的<code>失败</code>是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或者是不满足某种必要的条件等。</p>

<p>为了妥善处理这种构造过程中可能会失败的情况，你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在init关键字后面添加问号(init?).</p>

<blockquote><p><em>注意:</em></p>

<p><b > 可失败构造器的参数名和参数类型，不能为其它非可失败构造器的参数名，及其参数类型相同 </b></p></blockquote>

<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过<code>return nil</code>语句来表明可失败构造器在何种情况下应该<code>失败</code>。</p>

<blockquote><blockquote><p><strong>注意</strong></p>

<p><a >严格来说，构造器都不支持返回值。以为构造器本身的租用，只是为了确保对象能被正确构造。因此你只是用<code>return nil</code>表明可失败构造器构造失败，而不要用关键字return来表明构造成功 </a></p></blockquote></blockquote>

<p>下例中，定义了一个名为<code>Animal</code>的结构体，其中有一个名为<code>species</code>的String类型的常量属性。同时该结构体还定义了一个接受一个名为<code>species</code>的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code>属性被赋值，构造成功。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Animal {
</span><span class='line'>    let species: String
</span><span class='line'>    init?(species: String) {
</span><span class='line'>        if species.isEmpty { return nil }
</span><span class='line'>        self.species = species
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以通过该可失败的构造器来创建一个Animal的实例，并检查构造过程是否成功。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someCreature = Animal(species: "Giraffe")
</span><span class='line'>// someCreature 的类型是 Animal? 而不是 Animal
</span><span class='line'>
</span><span class='line'>if let giraffe = someCreature {
</span><span class='line'>    print("An animal was initialized with a species of \(giraffe.species)")
</span><span class='line'>}
</span><span class='line'>// 打印 "An animal was initialized with a species of Giraffe"</span></code></pre></td></tr></table></div></figure>


<p>如果你给改可失败构造器传入一个空字符串作为参数，则会导致构造失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anonymousCreature = Animal(species: "")
</span><span class='line'>// anonymousCreature 的类型是 Animal?, 而不是 Animal
</span><span class='line'>
</span><span class='line'>if anonymousCreature == nil {
</span><span class='line'>    print("The anonymous creature could not be initialized")
</span><span class='line'>}
</span><span class='line'>// 打印 "The anonymous creature could not be initialized"</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong></p>

<p><p style="color:red;text-align:left;font-family:Arial;font-style:normal;"> 空字符串（如"&ldquo;,而不是"Giraffe"）和一个值为nil的可选类型的字符串是两个完全不同的概念。上例中的空字符串(&rdquo;&ldquo;)其实是一个幼小的，非可选类型的字符串。这里我们只所以让Animal的可失败构造器失败，只是因为对于<code>Animal</code>这个类的<code>species</code>属性来说，它更适合有一个具体的值，而不是空字符串。</p></p></blockquote>

<h3>枚举类型的可失败构造器</h3>

<p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>

<p>下例中，定义了一个名为<code>TemperatureUnit</code>的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据<code>Character</code>值找出所对应的枚举成员的可失败构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TemperatureUnit {
</span><span class='line'>    case Kelvin, Celsius, Fahrenheit
</span><span class='line'>    init?(symbol: Character) {
</span><span class='line'>        switch symbol {
</span><span class='line'>        case "K":
</span><span class='line'>            self = .Kelvin
</span><span class='line'>        case "C":
</span><span class='line'>            self = .Celsius
</span><span class='line'>        case "F":
</span><span class='line'>            self = .Fahrenheit
</span><span class='line'>        default:
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员匹配时，则构造失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let fahrenheitUnit = TemperatureUnit(symbol: "F")
</span><span class='line'>if fahrenheitUnit != nil {
</span><span class='line'>    print("This is a defined temperature unit, so initialization succeeded.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is a defined temperature unit, so initialization succeeded."
</span><span class='line'>
</span><span class='line'>let unknownUnit = TemperatureUnit(symbol: "X")
</span><span class='line'>if unknownUnit == nil {
</span><span class='line'>    print("This is not a defined temperature unit, so initialization failed.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is not a defined temperature unit, so initialization failed."</span></code></pre></td></tr></table></div></figure>


<h3>带原始值的枚举类型的可失败构造器</h3>

<p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue:)</code>，该可失败构造器有一个名为<code>rawvalue</code>的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败.</p>

<p>因此上面的<code>TemperatureUnit</code>的例子可以重写为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TemperatureUnit: Character {
</span><span class='line'>    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let fahrenheitUnit = TemperatureUnit(rawValue: "F")
</span><span class='line'>if fahrenheitUnit != nil {
</span><span class='line'>    print("This is a defined temperature unit, so initialization succeeded.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is a defined temperature unit, so initialization succeeded."
</span><span class='line'>
</span><span class='line'>let unknownUnit = TemperatureUnit(rawValue: "X")
</span><span class='line'>if unknownUnit == nil {
</span><span class='line'>    print("This is not a defined temperature unit, so initialization failed.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is not a defined temperature unit, so initialization failed."</span></code></pre></td></tr></table></div></figure>


<h3>构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其它可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>

<p>无论是向上代理还是横向代理，如果你代理的其它可失败构造器触发构造失败，整个构造过程将立即停止，接下来的任何构造代码不会再被执行。</p>

<blockquote><p><em>注意:</em></p>

<p><b style="font-style:normal">
可失败构造器也可以代理到其它的非可失败构造器，通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中
</b></p></blockquote>

<p>下面的例子中，定义了一个名为<code>CartItem</code>的<code>Product</code>类的子类，这个类建立了一个在线购物车中的物品的模型，它有一个名为<code>quantity</code>的常量存储型属性，并确保该属性的值至少为1:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Product {
</span><span class='line'>    let name: String
</span><span class='line'>    init?(name: String) {   
</span><span class='line'>        if name.isEmpty { return nil }
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class CartItem: Product {
</span><span class='line'>    let quantity: Int
</span><span class='line'>    init?(name: String, quantity: Int) {
</span><span class='line'>        if quantity &lt; 1 { return nil }
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>CartItem</code>可失败构造器首先验证接收的<code>quantity</code>值是否大于等于1.倘若<code>quantity</code>值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样滴，<code>Product</code>的可失败构造器首先检查name值，假如<code>name</code>值为空字符串，则构造器立即执行失败。</p>

<p>如果你通过传入一个非空字符串name以及一个值大于等于1的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么构造方法能够成功被执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let twoSocks = CartItem(name: "sock", quantity: 2) {
</span><span class='line'>    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
</span><span class='line'>}
</span><span class='line'>// 打印 "Item: sock, quantity: 2”</span></code></pre></td></tr></table></div></figure>


<p>倘若你以一个值为0的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么将导致<code>CartItem</code>构造器失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
</span><span class='line'>    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to initialize zero shirts")
</span><span class='line'>}
</span><span class='line'>// 打印 "Unable to initialize zero shirts”</span></code></pre></td></tr></table></div></figure>


<p>同样滴，如果你尝试传入一个值为空字符串的name来创建一个<code>CartItem</code>实例，那么将导致父类<code>Product</code>的构造过程失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let oneUnnamed = CartItem(name: "", quantity: 1) {
</span><span class='line'>    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to initialize one unnamed product")
</span><span class='line'>}
</span><span class='line'>// 打印 "Unable to initialize one unnamed product”</span></code></pre></td></tr></table></div></figure>


<h3>重写一个可失败构造器</h3>

<p>如同其他的构造器，你可以在子类中重写父类的可失败构造器，或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>

<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包</p>

<blockquote><p><em>注意</em></p>

<p><b style="font-style:normal">
你可以用非可失败构造器重写可失败构造器，但反过来却不行
</b></p></blockquote>

<p>下例中定义了一个名为<code>Document</code>的类，name属性的值必须为一个非空字符串或nil,但不能是一个空字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Document {
</span><span class='line'>    var name: String?
</span><span class='line'>    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
</span><span class='line'>    init() {}
</span><span class='line'>    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
</span><span class='line'>    init?(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        if name.isEmpty { return nil }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面的这个例子，定义了一个<code>Document</code>类的子类<code>AutomaticallyNamedDocument</code>。这个子类重写了父类的两个指定构造器，确保了无论使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串。生成的实例中的name属性总有初始"Untitled"；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AutomaticallyNamedDocument: Document {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init()
</span><span class='line'>        self.name = "[Untitled]"
</span><span class='line'>    }
</span><span class='line'>    override init(name: String) {
</span><span class='line'>        super.init()
</span><span class='line'>        if name.isEmpty {
</span><span class='line'>            self.name = "[Untitled]"
</span><span class='line'>        } else {
</span><span class='line'>            self.name = name
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器<code>init(name:)</code>重写父类的课失败构造器(init?(name:))。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>

<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如：下面的<code>UntitledDocument</code>子类的name属性的值总是"untitled"，它在构造过程中使用了父类的可失败构造器init?(name:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UntitledDocument: Document {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init(name: "[Untitled]")!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，如果在调用父类的可失败构造器init?(name:)时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误</p>

<h3>可失败构造器 init!</h3>

<p>通常来说我们通过在init关键字后添加问号的方式(init?)来定义一个可失败构造器，但你也可以通过在init后面添加感叹号的方式来定义一个可失败构造器(init!)，该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>

<p>你可以在init?中代理到init!,反之亦然。你也可以用init?重写init!,反之亦然。你还可以用init代理到init!,不过一旦init!构造失效，则会触发一个断言。</p>

<h2><a name="必要构造器">必要构造器</a></h2>

<p>在类的构造器前添加<code>required</code>修饰符表明所有该类的子类都必须实现该构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    required init() {
</span><span class='line'>        // 构造器的实现代码
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在子类重写父类的必要构造器时，必须在子类的构造前也添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeSubclass: SomeClass {
</span><span class='line'>    required init() {
</span><span class='line'>        // 构造器的实现代码
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p><a style="font-style:normal">
如果子类继承的构造器能满足必要构造器的要求，则无需在子类中显式提供必必要构造器的实现。
</a></p></blockquote>

<h2><a name="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</a></h2>

<p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用必要或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的必要或函数会被调用，而它们的返回值会当做默认值赋值给这个属性，</p>

<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>

<p>下面介绍了如何用闭包为属性提供默认值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    let someProperty: SomeType = {
</span><span class='line'>        // 在这个闭包中给 someProperty 创建一个默认值
</span><span class='line'>        // someValue 必须和 SomeType 类型相同
</span><span class='line'>        return someValue
</span><span class='line'>    }()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉Swift立即执行此比好。如果你忽略了这对括号，相当于将闭包本省作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal"></p>

<p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化，这意味着你不能在闭包里访问其它属性，即使这些属性都有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用任何实例方法
</a></p></blockquote>

<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Checkerboard {
</span><span class='line'>    let boardColors: [Bool] = {
</span><span class='line'>        var temporaryBoard = [Bool]()
</span><span class='line'>        var isBlack = false
</span><span class='line'>        for i in 1...8 {
</span><span class='line'>            for j in 1...8 {
</span><span class='line'>                temporaryBoard.append(isBlack)
</span><span class='line'>                isBlack = !isBlack
</span><span class='line'>            }
</span><span class='line'>            isBlack = !isBlack
</span><span class='line'>        }
</span><span class='line'>        return temporaryBoard
</span><span class='line'>    }()
</span><span class='line'>    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return boardColors[(row * 8) + column]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>没当一个新的<code>Checkerboard</code>实例被创建时，赋值闭包会被执行，<code>boardColors</code>的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组<code>temporaryBoard</code>中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到<code>boardColors</code>中，并可以通过工具函数
<code>squareIsBlackAtRow</code>来查询:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let board = Checkerboard()
</span><span class='line'>print(board.squareIsBlackAtRow(0, column: 1))
</span><span class='line'>// 打印 "true"
</span><span class='line'>print(board.squareIsBlackAtRow(7, column: 7))
</span><span class='line'>// 打印 "false"</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/catransform3d/"/>
    <updated>2016-05-04T17:25:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/catransform3d</id>
    <content type="html"><![CDATA[<h1>图层的几个坐标系</h1>

<p>对于ios来说，坐标系的(0,0)点在左下角，就是越往下，Y值越大。越向右，X值就越大.</p>

<!--more-->


<p>一个图层的frame,它是position,bounds,anchorPoint和transform尚需经的一部分。</p>

<p>设置一个新的frame将会相应的改变图层的position和bounds,但是frame本身并没有保存。</p>

<h3>position</h3>

<p>是一个CGPoint值，它指定图层相当于它父图层的位置，该值基于父图层的坐标系</p>

<h3>bounds</h3>

<p>是一个CGRect值，指定图层的大小(bounds.size)和图层的原点(bounds.origin)，这个坐标系是基于自身的。如果改变bounds的origin,那么在该图层的子图层，左边会跟着改变。也就是说，改变自身的坐标系，本身在福图层的位置不变，但它上面的自图层位置变化</p>

<h3>anchorPoint</h3>

<p>是一个CGPoint值，它是指定了一个基于bounds的符合坐标系的位置。锚点(anchor point)制定了bounds相对于position的值，同时也作为一个变化时候的中心点。锚点使用空间坐标系取值范围是0-1之间的数。默认是0.5,也就是图标的中心点，如果是(0,0)那么图层向左上方移动。如果是(1,1)就向右下方移动。</p>

<p>看下面的两个图，就能够清晰的看出锚点变化所带来的不一样。（此图为Mac OS 坐标系，如果是iOS，那么（0，0）点在图的左上方。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-ec88270eb7d8c9a0.png" alt="1" /></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-bfe77d9ab6636ce0.png" alt="2" /></p>

<p>对于anchorPoint的解释在ios中如图:</p>

<p>下图中的红点位置就是锚点的位置，默认是(0.5,0.5)。在对图像进行变化时，都是按照这个店来进行缩放，偏移等。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-76ff5832ae84e2f6.png" alt="1" /></p>

<p>一旦修改锚点位置为:(0,0),那么图像就会变成下图.各种变换就会按照这个点来运动.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-e6bcb36d43e12c4d.png" alt="2" /></p>

<p>所以说在ios系统中，锚点的坐标系是:左上角为(0,0),右下角为(1,1)。</p>

<p>根据此图，再理解上面的定义，就直观多了。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-47294f41d81081da.png" alt="1" /></p>

<h1>图层的几何变换</h1>

<p>可以通过矩阵来改变一个图层的几何形状。</p>

<p><em>CATransform3D</em>的数据结构定义了一个同质的三维变换(4*4 CGFloat值的矩阵),用于图层的旋转，缩放，偏移和应用的透视。</p>

<p>图层的2歌属性指定了变换矩阵:transform和sublayerTransform。</p>

<h3>transform</h3>

<p>是结合anchorPoint的位置来对图层和图层上的子图层进行变化</p>

<h3>sublayerTransform</h3>

<p>是结合anchorPoint的位置来对图层的子图层进行变化，不包括本身</p>

<h3>CATransform3DIdentity</h3>

<p>是单位矩阵，该矩阵没有缩放，旋转，歪斜，透视。该矩阵应用到图层上，就是设置默认值。</p>

<h1>变换函数</h1>

<h3>CATransform3DMakeTranslation</h3>

<p>官方文档:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Returns a transform that translates by '(tx, ty, tz)'. t' = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].
</span><span class='line'>
</span><span class='line'>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)。</span></code></pre></td></tr></table></div></figure>


<p>对于CATransform3D来说，它是一个4*4的 CGFloat的矩阵。而上面的值:<code>[1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].</code>给竖起来后，就发现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1    0    0    0
</span><span class='line'>
</span><span class='line'>0    1    0    0
</span><span class='line'>
</span><span class='line'>0    0    1    0
</span><span class='line'>
</span><span class='line'>tx   ty   tz   1</span></code></pre></td></tr></table></div></figure>


<p>竖起来就很明显了。</p>

<p>CATransform3D又是一个结构，他有自己的一个公式，可以进行套用.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct CATransform3D
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>CGFloat    m11（x缩放）,    m12（y切变）,      m13（旋转）,   m14（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m21（x切变）,    m22（y缩放）,      and（）   ,   m24（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m31（旋转）  ,    m32（ ）  ,      m33（z轴缩放）   ,   m34（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;
</span><span class='line'>
</span><span class='line'>CGFloat    m41（x平移）,    m42（y平移）,      m43（z平移） ,   m44（）;
</span><span class='line'>
</span><span class='line'>};
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>根据这个公式就一目了然了。</p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)参数的意思就是 <em>tx:：x平移。  ty：y平移。  tz：z平移</em></p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tx：X轴偏移位置，往下为正数。
</span><span class='line'>
</span><span class='line'>ty：Y轴偏移位置，往右为正数。
</span><span class='line'>
</span><span class='line'>tz：Z轴偏移位置，往外为正数。</span></code></pre></td></tr></table></div></figure>


<p>举个栗子:</p>

<p>如果有两个图层，一个是绿色的，一个是红色的，先加载绿色，后加载红色</p>

<p>tx,ty的偏移就先不说了</p>

<p>如果绿色的tz为-10，红色的tz为0，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-7d642630070e7554.png" alt="1" /></p>

<p>如果绿色的tz为0,红色的tz为-10，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-29ecdd06f03578f4.png" alt="2" /></p>

<p>对于tz来说，tz越大，那么图层就越靠近屏幕，值越小，图层越往里（离屏幕越远）</p>

<h4>CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz);</h4>

<p>t:就是上一个函数，其它都一样
就可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);</h4>

<p><em>sx:</em> x轴缩放，代表一个缩放比例，一般都是0-1之间的数字
<em>sy:</em> y轴上缩放
<em>sz:</em> 整体比例变换时，也就是m11(sx) == m22(sy)时，若m33(sz) > 1时，图形整体缩小，若0&lt;1,图形整体放大，若m33(sz) &lt; 0时，发生关于原点的对称等比变换。</p>

<p>当sx = 1时，sy = 1时，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-04771b49561f6d76.png" alt="1" /></p>

<p>当sx=0.5,sy=0.5时，如图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-6023b3794fd9917d.png" alt="2" /></p>

<h4>CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz)</h4>

<p>t：就是上一个函数。其他的都一样。</p>

<p>就可以理解为：函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>旋转效果</p>

<p>angle：旋转的弧度，所以要把角度转换成弧度：角度 * M_PI / 180</p>

<p>x:向X轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>y:向Y轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>z:向Z轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>原始图像如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-1.png" alt="1" /></p>

<p>例如：向X轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-2.png" alt="1" /></p>

<p>向Y轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-3.png" alt="1" /></p>

<p>向z轴方向旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-4.png" alt="test" /></p>

<p>向x轴和y轴都旋转60度，就是沿着对角线旋转</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-5.png" alt="t" /></p>

<h4>CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>t:就是上一个函数
可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DInvert (CATransform3D t);</h4>

<p>翻转效果</p>

<p>原始效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-6.png" alt="test" /></p>

<p>调用翻转后的效果:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-7.png" alt="result" /></p>

<h4>CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t);</h4>

<p>仿射效果</p>

<p>就是把一个CATransform3D对象转化成一个CGAffineTransform对象，也就是把CATransform3D矩阵转化成CGAffineTransform矩阵</p>

<p>变换函数同时提供了可以比较一个变换矩阵是否是单位矩阵，或者两个矩阵是否相等。</p>

<h4>bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);</h4>

<p>判断两个变换的矩阵是否相等</p>

<p>也可以通过修改数据结构和键值来设置变换效果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct CATransform3D
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>CGFloat m11, m12, m13, m14；
</span><span class='line'>
</span><span class='line'>CGFloat m21, m22, m23, m24；
</span><span class='line'>
</span><span class='line'>CGFloat m31, m32, m33, m34；
</span><span class='line'>
</span><span class='line'>CGFloat m41, m42, m43, m44；
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以直接修改其中一个值，来达到相同的效果</p>

<p>或者修改键值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[myLayer setValue:[NSNumber numberWithInt:0] forKeyPath:@"transform.rotation.x"];</span></code></pre></td></tr></table></div></figure>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-43f4b4134597cd19.png" alt="e" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime运行时入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men/"/>
    <updated>2016-05-04T14:36:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men</id>
    <content type="html"><![CDATA[<h2>什么是Rumtime</h2>

<p>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target dosomething]</code>会被转化成 <code>objc_msgSend(target,@selector(doSomething));</code>.</p>

<!--more-->


<p>oc中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，实际上一个类本质上也是一个对象，在runTime中用结构体表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 描述类中的一个方法
</span><span class='line'>typedef struct objc_method *Method;
</span><span class='line'>
</span><span class='line'>/// 实例变量
</span><span class='line'>typedef struct objc_ivar *Ivar;
</span><span class='line'>
</span><span class='line'>/// 类别Category
</span><span class='line'>typedef struct objc_category *Category;
</span><span class='line'>
</span><span class='line'>/// 类中声明的属性
</span><span class='line'>typedef struct objc_property *objc_property_t;</span></code></pre></td></tr></table></div></figure>


<p>类在rumtime中的表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//类在runtime中的表示
</span><span class='line'>struct objc_class {
</span><span class='line'>    Class isa;//指针，顾名思义，表示是一个什么，
</span><span class='line'>    //实例的isa指向类对象，类对象的isa指向元类
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__
</span><span class='line'>    Class super_class;  //指向父类
</span><span class='line'>    const char *name;  //类名
</span><span class='line'>    long version;
</span><span class='line'>    long info;
</span><span class='line'>    long instance_size
</span><span class='line'>    struct objc_ivar_list *ivars //成员变量列表
</span><span class='line'>    struct objc_method_list **methodLists; //方法列表
</span><span class='line'>    struct objc_cache *cache;//缓存
</span><span class='line'>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
</span><span class='line'>    struct objc_protocol_list *protocols //协议列表
</span><span class='line'>    #endif
</span><span class='line'>} OBJC2_UNAVAILABLE;
</span><span class='line'>/* Use `Class` instead of `struct objc_class *` */</span></code></pre></td></tr></table></div></figure>


<h2>获取列表</h2>

<p>有时会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配).</p>

<p>我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表，方法列表，成员变量等)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> unsigned int count;
</span><span class='line'>    //获取属性列表
</span><span class='line'>    objc_property_t *propertyList = class_copyPropertyList([self class], &count);
</span><span class='line'>    for (unsigned int i=0; i&lt;count; i++) {
</span><span class='line'>        const char *propertyName = property_getName(propertyList[i]);
</span><span class='line'>        NSLog(@"property----&gt;%@", [NSString stringWithUTF8String:propertyName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取方法列表
</span><span class='line'>    Method *methodList = class_copyMethodList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Method method = methodList[i];
</span><span class='line'>        NSLog(@"method----&gt;%@", NSStringFromSelector(method_getName(method)));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取成员变量列表
</span><span class='line'>    Ivar *ivarList = class_copyIvarList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Ivar myIvar = ivarList[i];
</span><span class='line'>        const char *ivarName = ivar_getName(myIvar);
</span><span class='line'>        NSLog(@"Ivar----&gt;%@", [NSString stringWithUTF8String:ivarName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取协议列表
</span><span class='line'>    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Protocol *myProtocal = protocolList[i];
</span><span class='line'>        const char *protocolName = protocol_getName(myProtocal);
</span><span class='line'>        NSLog(@"protocol----&gt;%@", [NSString stringWithUTF8String:protocolName]);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><em>注意：不要忘记在类的顶部导入头文件<code>#import &lt;objc/runtime.h&gt;</code></em></p>

<h2>方法调用</h2>

<p>让我们看一下在运行时方法的调用</p>

<p>如果用实例对象调用实例方法，回到实例的isa指针指向的对象（也就是类对象）操作。如果调用的是类方法，就回到类对象的isa指针指向的对象（也就是元类对象）中操作。</p>

<ol>
<li>首先，在相应操作的对象中的缓存方法列表汇总找调用的方法，如果找到，转向相应实现并执行</li>
<li>如果没有找到，在相应操作的对象 中的方法列表中找调用的方法，如果找到，转向相应的实现执行</li>
<li>如果没有找到，去父类指针所指向的对象中执行1,2</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用</li>
<li>如果没有重写拦截调用的方法，程序报错</li>
</ol>


<h2>拦截调用</h2>

<p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。
什么是拦截调用呢</p>

<p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写 NSObject的四个方法来处理.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)resolveClassMethod:(SEL)sel;
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel;
</span><span class='line'>//后两个方法需要转发到其他的类处理
</span><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector;
</span><span class='line'>- (void)forwardInvocation:(NSInvocation *)anInvocation;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>第一个方法是当你调用一个不存在的类或者方法的时候，会调用这个方法，默认返回NO,你可以加上自己的处理然后返回YES</li>
<li>第二个方法和第一个相似，只不过处理的是实例方法</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target</li>
<li>第四个方法是将你调用的不存在的方法打包成<code>NSinvocation</code>传给你，做完你自己的处理后，调用<em>invokeWithTarget:</em>方法让某个target触发这个方法</li>
</ul>


<h2>动态添加方法</h2>

<p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢?
有一个办法就是根据传进来的<em>sel</em>类型的selector动态添加一个方法。</p>

<p>首先从外部隐式调用一个不存在的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//隐式调用方法
</span><span class='line'>[target performSelector:@selector(resolveAdd:) withObject:@"test"];</span></code></pre></td></tr></table></div></figure>


<p>然后，在target对象内部重写拦截调用的方法，动态添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void runAddMethod(id self, SEL _cmd, NSString *string){
</span><span class='line'>    NSLog(@"add C IMP ", string);
</span><span class='line'>}
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel{
</span><span class='line'>
</span><span class='line'>    //给本类动态添加一个方法
</span><span class='line'>    if ([NSStringFromSelector(sel) isEqualToString:@"resolveAdd:"]) {
</span><span class='line'>        class_addMethod(self, sel, (IMP)runAddMethod, "v@:*");
</span><span class='line'>    }
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中<code>class_addMethod</code>的四个参数分别是:</p>

<ol>
<li><em>Class cls</em>给那个类添加方法，本例中是self</li>
<li><em>SEL name</em>添加的方法，本例中是重写的拦截调用传进来selector</li>
<li><em>IMP imp</em>方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现</li>
<li><code>"v@:*"</code>方法的签名，代表有一个参数的方法，返回值是void,如果是<code>i</code>，就是返回int</li>
</ol>


<h2>关联对象</h2>

<p>现在你准备用系统的一个类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。</p>

<p>这种情况的一般解决办法就是继承。</p>

<p>但是只增加一个属性，就去继承一个类，总是觉得太麻烦</p>

<p>这个时候，runtime的关联属性就发挥它的作用了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//首先定义一个全局变量，用它的地址作为关联对象的key
</span><span class='line'>static char associatedObjectKey;
</span><span class='line'>//设置关联对象
</span><span class='line'>objc_setAssociatedObject(target, &associatedObjectKey, @"添加的字符串属性", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象
</span><span class='line'>NSString *string = objc_getAssociatedObject(target, &associatedObjectKey);
</span><span class='line'>NSLog(@"AssociatedObject = %@", string);</span></code></pre></td></tr></table></div></figure>


<p><code>objc_setAssociatedObject</code>的四个参数:</p>

<ol>
<li><em>id object</em> 给谁设置关联对象</li>
<li><code>const void *key</code>关联对象唯一的key,获取时会用到</li>
<li><em>id value</em>关联对象</li>
<li><em>objc_AssociationPolicy</em>关联策略，共有以下几种策略</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, 
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>如果你熟悉OC，看名字就能知道几种策略的意思了吧</p>

<p><code>objc_getAssociatedObject</code>用来获取关联属性，它用到了两个参数:</p>

<ol>
<li><em>id object</em>获取谁的关联对象</li>
<li><code>const void *key</code>根据这个唯一的key获取关联对象</li>
</ol>


<p>其实，你还可以吧添加和获取关联对象的方法卸载你需要用到这个功能类的类别中，方便调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加关联对象
</span><span class='line'>- (void)addAssociatedObject:(id)object{
</span><span class='line'>    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</span><span class='line'>}
</span><span class='line'>//获取关联对象
</span><span class='line'>- (id)getAssociatedObject{
</span><span class='line'>    return objc_getAssociatedObject(self, _cmd);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p>这里我们把<code>getAssociatedObject</code>方法的地址作为唯一的key,<em>_cmd</em>代表当前调用方法的地址</p></blockquote>

<h2>方法交换</h2>

<p>方法交换，顾名思义，及时将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法的代码，反之亦然。</p>

<p>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。
方式一:继承系统的类，重写方法.
方式二:使用runtime,交换方法.</p>

<p>参考网上的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "UIViewController+swizzling.h"
</span><span class='line'>#import &lt;objc/runtime.h&gt;
</span><span class='line'>
</span><span class='line'>@implementation UIViewController (swizzling)
</span><span class='line'>
</span><span class='line'>//load方法会在类第一次加载的时候被调用
</span><span class='line'>//调用的时间比较靠前，适合在这个方法里做方法交换
</span><span class='line'>+ (void)load{
</span><span class='line'>    //方法交换应该被保证，在程序中只会执行一次
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>
</span><span class='line'>        //获得viewController的生命周期方法的selector
</span><span class='line'>        SEL systemSel = @selector(viewWillAppear:);
</span><span class='line'>        //自己实现的将要被交换的方法的selector
</span><span class='line'>        SEL swizzSel = @selector(swiz_viewWillAppear:);
</span><span class='line'>        //两个方法的Method
</span><span class='line'>        Method systemMethod = class_getInstanceMethod([self class], systemSel);
</span><span class='line'>        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);
</span><span class='line'>
</span><span class='line'>        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
</span><span class='line'>        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
</span><span class='line'>        if (isAdd) {
</span><span class='line'>            //如果成功，说明类中不存在这个方法的实现
</span><span class='line'>            //将被交换方法的实现替换到这个并不存在的实现
</span><span class='line'>            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
</span><span class='line'>        }else{
</span><span class='line'>            //否则，交换两个方法的实现
</span><span class='line'>            method_exchangeImplementations(systemMethod, swizzMethod);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)swiz_viewWillAppear:(BOOL)animated{
</span><span class='line'>    //这时候调用自己，看起来像是死循环
</span><span class='line'>    //但是其实自己的实现已经被替换了
</span><span class='line'>    [self swiz_viewWillAppear:animated];
</span><span class='line'>    NSLog(@"swizzle");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在一个自己定义的视图控制器中重写<em>viewWillAppear</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewWillAppear:(BOOL)animated{
</span><span class='line'>    [super viewWillAppear:animated];
</span><span class='line'>    NSLog(@"viewWillAppear");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac上如何把视频转成.Gif]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif/"/>
    <updated>2016-04-29T12:56:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif</id>
    <content type="html"><![CDATA[<p>之前看到很多github上的开源项目都带.gif的演示效果，感觉很好，今天就试着制作了一下，今天把我的制作过程记录下来，方便他人参考。</p>

<!--more-->


<h2>录制视频</h2>

<p>mac上自带的Quicktime就可以录制视频，选择录制屏幕</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160429-0.png" alt="1" /></p>

<p>录制完之后是 .mov 的后缀视频文件</p>

<h2>通过命令行转换</h2>

<p>在苹果系统上，可以通过命令行的方式转换视频，首先假定你的机器上已经安装了<a href="http://www.brew.sh">homebrew</a>.</p>

<p>然后打开终端，安装<a href="http://baike.baidu.com/link?url=H-RabHoLq9tR0Zxn-jduRSC7NAlSBkEjjsRnXEJ7Rw9RFE6dUNBnYyXidoiXNGCyOWKdcAtQMg-J8x_hFPSg5K">ffmpeg</a>插件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install ffmpeg</span></code></pre></td></tr></table></div></figure>


<p>然后定位到正确的目录，（有视频文件的那个目录，比如 Desktop）,假定你的视频名字是<code>ScreenFlow.mov</code>,你运行下面的命令就能生成GIF:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ffmpeg -i ScreenFlow.mov -pix_fmt rgb24 output.gif</span></code></pre></td></tr></table></div></figure>


<p>你会注意到生成文件很大，可以通过<a href="http://baike.baidu.com/link?url=WENMRejdDuoS2eXPiXrnvF2ohwpbTAe5oW_SOTsr2k099YbjyU4wCi-ngV31jzxvP0TvC-INM0FBcUk1sEDWQK"> image magick</a>工具来减少大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install imagemagick</span></code></pre></td></tr></table></div></figure>


<p>运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ convert -layers Optimize output.gif output_optimized.gif</span></code></pre></td></tr></table></div></figure>


<h2>通过软件生成.GIF</h2>

<p><a href="http://gifbrewery.com">GifBrewery</a>是一款GIF动态图片制作工具. 支持将视频文件剪裁输出成GIF动态图片。</p>

<p>并且支持裁剪视频的长度，本人感觉挺好用的。</p>

<h2>上传到云端</h2>

<p>最后把制作好的.gif图片上传到云端就行了，比如 dropbox,七牛,阿里云等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewController转场动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua/"/>
    <updated>2016-04-28T15:54:40+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua</id>
    <content type="html"><![CDATA[<h2>自定义转场动画</h2>

<p>ios7中最让我激动的特性之一就是提供了新的API来支持自定义ViewController之间的转场动画。</p>

<!--more-->


<p>在开始研究新的API之间，我们先看看ios7中 navigation controller之间默认的行为发生了那些改变:在navigation controller中，切换两个view controller的动画变得更有交互性。比方说你想要pop一个view controller出去，你可以用手指从屏幕的左边缘开始拖动，慢慢地把当前的viewcontroller向右拖出屏幕去.</p>

<p>接下来，我们来看看这个新API。很有趣，这部分API大量的使用了协议而不是具体的对象。这初看起来有点奇怪，但是我更喜欢这样的设计，因为这种设计给我们这些开发者更大的灵活性。下面，让我们来做件简单的事情:在Navigation Controller中，实现一个自定义的push动画效果，为了完成这个任务，需要实现UINavigationControllerDelegate中的新方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
</span><span class='line'>                   navigationController:(UINavigationController *)navigationController
</span><span class='line'>        animationControllerForOperation:(UINavigationControllerOperation)operation
</span><span class='line'>                     fromViewController:(UIViewController*)fromVC
</span><span class='line'>                       toViewController:(UIViewController*)toVC
</span><span class='line'>{
</span><span class='line'>    if (operation == UINavigationControllerOperationPush) {
</span><span class='line'>        return self.animator;
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码可以看出，我们可以根据不同的操作(push或pop)返回不同的animator.我们可以把anmitor存到一个属性中，从而在多个操作之间实现共享，或者我们也可以为每个操作都创建一个新的animator对象，这里的灵活性很多。</p>

<p>为了让动画运行起来，我们创建一个自定义类，并且实现<code>UIViewControllerAnimatedTransitioning</code>这个协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这个协议要求我们实现两个方法，其中一个定义了动画的持续时间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    return 0.25;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另一个方法描述整个动画的执行效果 ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>    [[transitionContext containerView] addSubview:toViewController.view];
</span><span class='line'>    toViewController.view.alpha = 0;
</span><span class='line'>
</span><span class='line'>    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
</span><span class='line'>        toViewController.view.alpha = 1;
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
</span><span class='line'>
</span><span class='line'>    }];
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的例子汇总，你可以看到如何运用洗衣的：这个方法中通过接受一个类型为<code>id&lt;UIViewControllerContextTransitioning&gt;</code>的参数，来获取transition context.值的注意的是，执行完动画之后，我们需要调用transitionContext的<code>completeTransition :</code>这个方法来更新ViewController的状态。剩下的代码和ios7之前的一样了，我们从transition context 中得到了需要做转场的两个View controller,然后使用最简单的Uiview animation来实现转场动画。这就是全部代码了，我们已经实现了缩放效果的转场动画了。</p>

<p>注意，这里只是为push操作实现了自定义效果的转场动画，对于pop操作，还是会使用默认的滑动效果，另外，上面我们实现的转场动画无法交互，下面我们就来看看解决这个问题。</p>

<h2>交互式的转场动画</h2>

<p>想要动画变地交互非常简单，我们只需要覆盖另一个UINavigationControllerDelegate的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
</span><span class='line'>                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
</span><span class='line'>{
</span><span class='line'>    return self.interactionController;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，在非交互式动画效果中，该方法返回nil.</p>

<p>这里返回的interaction controller是<code>UIPercentDrivenInteractionTransition</code>类的一个实例，开发者不需要任何配置就可以工作。我们创建了一个拖动收拾(Pan REcognizer),下面是处理该手势的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
</span><span class='line'>        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
</span><span class='line'>        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
</span><span class='line'>    }
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>只有当用户从屏幕的右半部分开始触摸的时候，我们才把下一次动画效果设置为交互的（通过设置interactionController这个属性来实现），然后执行方法performSegueWithIdentifier:（如果你不是使用的storyboards,那么就直接调用pushViewController&hellip;这类方法）。为了让转场动画持续进行，我们需要调用 interaction controller的一个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
</span><span class='line'>    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
</span><span class='line'>    [interactionController updateInteractiveTransition:d];
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>该方法会根据用户手指拖动的距离计算一个百分比，切换的动画效果也随着这个百分比来走，最酷的是，interaction controller会和animation controller一起协作，我们只使用了简单的UIView animation的动画效果，但是interaction controller却控制了动画的执行进度，我们并不需要吧interaction controller和Animation controller关联起来，因为所有这些系统都以一种解耦的方式自动地替我们完成了。</p>

<p>最后,我们需要更具用户收拾的停止状态来判断该操作是结束还是取消，先调用interaction controller 中对应的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
</span><span class='line'>    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
</span><span class='line'>        [interactionController finishInteractiveTransition];
</span><span class='line'>    } else {
</span><span class='line'>        [interactionController cancelInteractiveTransition];
</span><span class='line'>    }
</span><span class='line'>    navigationControllerDelegate.interactionController = nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，当切换完成或者取消的时候，记得把interaction controller设置为nil.因为如果下一次的转场是非交互的，我们不应该返回这个旧的interaction controller。</p>

<p>现在我们已经实现了一个完全自定义的可交互的转场动画了。通过简单的手势识别和UIKIT提供的一个类，用几行代码就达到完成了。对于大部分的应用场景，你读到这就够用了，使用上面提到的方法就可以达到你想要的动画效果了。但如果你想更深入了解转场动画或者交互效果进行深度定制，请继续阅读下面的内容。</p>

<h3>完整工程下载</h3>

<p><a href="https://github.com/TLiOSDemo/CustomTransitionController/archive/master.zip">完整的代码在这里下载</a></p>

<h2>使用GPUImage定制动画</h2>

<p>下面我们就看看如何真正的，彻底的定制动画效果。这一次我们不实用UIviw animation,甚至连Core Animation也不用，完全自己来实现所有的动画效果。</p>

<p>我们使用 <a href="https://github.com/BradLarson/GPUImage">GPUImage</a>来实现一个非常漂亮的动画效果，这里我们实现的转场动画效果是：两个View controller像素化，然后相互消融在一起。实现方法是先对两个view controller进行截屏，然后再用GPUImage的图片滤镜（filter）处理这两张截图。</p>

<p>首先，我们先创建一个自定义类，这个类实现了UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning这两个协议：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface GPUImageAnimator : NSObject
</span><span class='line'>  &lt;UIViewControllerAnimatedTransitioning,
</span><span class='line'>   UIViewControllerInteractiveTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@property (nonatomic) BOOL interactive;
</span><span class='line'>@property (nonatomic) CGFloat progress;
</span><span class='line'>
</span><span class='line'>- (void)finishInteractiveTransition;
</span><span class='line'>- (void)cancelInteractiveTransition;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>为了加速动画的运行，我们可以图片一次加载到GPU中，然后所有的处理和绘图都直接在GPU上执行，不需要再传送到CPU上处理（这种数据传输很慢）。通过使用GPUImageview，我们就可以直接使用OPenGL画图。</p>

<p>创建滤镜链(Filter chain)也非常的直观，我们可以直接在样例代码的setup方法中看到如何构造它。比较有挑战的是如何让滤镜也<code>动</code>起来。GPUImage没有直接提供给我们动画效果，因此我们需要每渲染一帧就更新一下滤镜来实现动态的滤镜效果。使用<em>CADisplayLink</em>可以完成这个工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
</span><span class='line'>[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span></code></pre></td></tr></table></div></figure>


<p>在frame方法中，我们可以根据时间来更新动画进度，并相应地更新滤镜:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)frame:(CADisplayLink*)link
</span><span class='line'>{
</span><span class='line'>    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
</span><span class='line'>    self.blend.mix = self.progress;
</span><span class='line'>    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
</span><span class='line'>    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
</span><span class='line'>    [self triggerRenderOfNextFrame];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好了，基本上这样就完成了。如果你想要实现交互式的转场效果，那么在这里，就不能使用时间，而是要根据手势来更新动画进度，其它的代码基本差不多。</p>

<p>这个功能非常强大，你可以使用GPUImage中任何已有的滤镜，或者写一个自己的OpenGL来达到你想要的效果。</p>

<h2>结论</h2>

<p>本文只探讨了在navigation controller中的两个view controller之间的转场动画，但是这些做法在tab bar  controller或者任何你自己定义的view controller容器中也是通用的。另外，在ios7中，<em>UIcollectionViewController</em>也进行了扩展，现在你可以在布局之间进行自动以及交互的动画切换，背后使用的也是同样的机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义AsyncDisplayKit-Node]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node/"/>
    <updated>2016-04-26T15:13:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchy.png" alt="node" /></p>

<p>假设你已经读过<a href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/">AsyncDisplayKit入门</a>,下面我们将继续介绍AsyncDisplayKit.</p>

<!--more-->


<p>这篇教程将解释如何充分利用框架探索AsyncDisplayKit节点的层次结构，通过这样做，你将会更加熟悉AsyncDisplayKit这个有名的框架，并且会使你的app程序异常平滑，同时能够构建灵活的和可重用的ui</p>

<p>这AsyncDisplayKit中一个核心概念就是<code>node</code>,正如你所知，AsyncDisplayKit nodes 是一个线程安全的抽象于UIview之上的，（UIview不是线程安全的）,你可以学习更多AsyncDisplayKit在<a href="http://asyncdisplaykit.org/">AsyncDisplayKit’s Quick Start introduction</a></p>

<p>好消息是你已经知道了UIKit,那么你已经了解AsyncDisplayKit一些属性和方法了，因为API是很相似的。随后，你将会学到:</p>

<ul>
<li>如何去创建你自己的 AsDisplayNode</li>
<li>如何嵌套一个node到一个单个Node容器中，并且管理和重用</li>
<li>如何用一个Node层次结构支持View的层次结构，因为你自动减少在主线程绘制的机会，保持你的界面平滑和响应</li>
</ul>


<p>下面是你将要做的：你将要创建一个容器Node,并且添加两个子Node-其中一个是图片node,其中一个是文本node,你将会看到容器是如何测量他们的子Node尺寸和大小的.最后，你将会转化一个已经存在的UIview容器为一个ASDisplaytNode子类。</p>

<p>效果图如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt="node" /></p>

<h2>开始</h2>

<p>这个app,你将要创建一个卡片展示世界上一个奇观-泰姬陵</p>

<p>下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Starter.zip">开始工程</a></p>

<p>这个工程只有一个ViewController,这个工程是用 cocoaPods构建的，所以你必须安装 pods,然后创建 Podfile,引入 AsyncDisplayKit.</p>

<blockquote><p><em>注意</em>
如果你不了解 Pods,请学习<a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2">Introduction to CocoaPods Tutorial</a></p></blockquote>

<p>打开  ViewController.swift，然后注意到这个view controller只有一个常量<code>card</code>,它保存了一个泰姬陵的模型对象，你将会使用这个模型创建一个卡片的node去展示。</p>

<p>编译运行工程，你将会看到一个空的黑色屏幕
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-1-281x500.jpg" alt="logo" /></p>

<h2>创建并且显示一个容器Node</h2>

<p>现在你要开始构建你的第一个Node层次结构，它是非常相似的和创建一个UIview的层次结构</p>

<p>打开 Wonders-Bridging-Header.h，然后添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/ASDisplayNode+Subclasses.h&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>ASDisplayNode+Subclasses.h</code>是AsDisplayNode的一个内部方法，你需要在<code>ASDisplayNode</code>子类中实现这个header中定义的方法，但是你只能调用这些方法在你的 ASDisplayNode的子类中，这是和<code>UIGestureRecognizer</code>模式很相似的。</p>

<p>打开CardNode.swift，然后添加ASDisplayNode子类实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {}</span></code></pre></td></tr></table></div></figure>


<p>定义了一个新的ASDisplayNode子类，你将会把它作为一个容器去处理用户的交互</p>

<p>打开ViewController.swift,在viewDidLoad()中实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // Create, configure, and lay out container node
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  // Create container node’s view and add to view hierarchy
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码创建了一个新的卡片node,它定位在左上角并且高宽都是100.
不用担心之前的约束，你将会定位到中心在这个view controller中。</p>

<p>编译运行 ：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-2-281x500.jpg" alt="logo" /></p>

<p>太好了！你已经有了一个自定义的node在屏幕上显示，下一步是给你的子node取名为 <code>CardNode</code>,并且计算它的尺寸。在view中居中这是必须要知道的，你应该理解node布局引擎的工作原理。</p>

<h2>Node布局引擎</h2>

<p>下一步是询问Node去计算自己的尺寸通过调用<code>measure(constrainedSize:)</code>,你将会通过方法中constrainedSize参数去告诉node去计算一个尺寸去适应constrainedSize</p>

<p>通俗的说,这意味着计算大小不能大于限制大小。例如,考虑下面的图
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_measure.png" alt="logo" /></p>

<p>这个展示了一个约束的尺寸使用确定的宽度和高度，这个计算尺寸是和宽度相等的，但是比高度要小，它可能和宽度和高度都相等，或者比宽度和高度都要小，但是宽度和高度都不允许比约束的尺寸要大。</p>

<p>这个工作和UIView&rsquo;s<code>sizeThatFits(size:)</code>方法很相似。但是不同之处在于<code>measure(constrainedSize:)</code>计算它的尺寸，允许你访问缓存
node的calculatedSize属性。</p>

<p>一个例子就是当计算的高度和宽度的尺寸比约束尺寸更小的时候：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_constrained2.png" alt="lgo" /></p>

<p>这里图片的尺寸是更小比约束的尺寸，没有任何的sizing-to-fit，这里计算的尺寸比约束尺寸更小。</p>

<p>原因就是AsyncDisplayKit经常需要花费时间去计算尺寸，读取一个图片从硬盘中，可能会非常慢，通过合并尺寸到nodeApi,这个是线程安全的操作，这意味着计算尺寸可以在后台线程中运行！优雅的！它是一个有用的特性让你的UI程序平滑如黄油一般。</p>

<p>一个Node将会运行计算尺寸加入它没有存储值的话，假如这个约束尺寸提供是不同的，约束尺寸常常决定缓存的计算大小。</p>

<p>在程序中，工作如下:</p>

<ul>
<li>measure(constrainedSize:)返回一个存储你的尺寸或者进行一个计算尺寸通过调用calculateSizeThatFits(constrainedSize:)</li>
<li>你替换所有的尺寸计算通过<code>calculateSizeThatFits(constrainedSize:)</code>在你的ASDisplayNode子类中</li>
</ul>


<blockquote><p><em>注意</em>
calculateSizeThatFits(constrainedSize:)是ASDisplayNode的内部方法，你不应该在外部调用它</p></blockquote>

<h2>测量Node的大小</h2>

<p>现在是时候测量你的自己的node大小了。</p>

<p>打开CardNode.swift,然后替换这个类中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {
</span><span class='line'> 
</span><span class='line'>  override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>    return CGSize(width: constrainedSize.width * 0.2, height: constrainedSize.height * 0.2)
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>到现在为止，这个方法返回的大小是约束提供尺寸的20%.</p>

<p>打开ViewController.swift,删除viewDidLoad() 中的实现，然后实现下面的<code>createCardNode(containerRect:)</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'> 
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // 1
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'> 
</span><span class='line'>  // 2
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>func createCardNode(#containerRect: CGRect) -&gt; CardNode {
</span><span class='line'>  // 3
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  cardNode.measure(containerRect.size)
</span><span class='line'> 
</span><span class='line'>  // 4
</span><span class='line'>  let size = cardNode.calculatedSize
</span><span class='line'>  let origin = containerRect.originForCenteredRectWithSize(size)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  return cardNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>删除之前创建的代码，配置和布局代码</li>
<li>删除之前的代码，把node加入到view的层次结构中</li>
<li>createCardNode(containerRect:) 创建了一个卡片Node使用相同的背景颜色和容器node,它用作一个容器去约束卡片node的大小，所以这个卡片Node不能比containerRect’的尺寸更大</li>
<li>通过originForCenteredRectWithSize(size:) 方法设置卡片到中心位置。</li>
</ol>


<p>定位到createCardNode(containerRect:) 这个方法，替换viewDidLoad():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  let cardNode = createCardNode(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当视图加载的时候，createCardNode(containerRect:)创建一个新的CardNode,这个卡片的Node不能比主屏幕的bounds尺寸更大。</p>

<p>在这个观点中，这个ViewController的视图还没有加载出来，因此，它不是安全的对用于ViewContrller的bounds尺寸。所以你使用主屏幕的尺寸去约束卡片Node的大小。</p>

<p>运行起来，尽管达不到优雅，因为这个视图控制器横跨了整个屏幕，稍后，我们将添加适当的方法，现在，它工作还可以。</p>

<p>编译运行，你将会看到你的node在正中心了.
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>异步节点设置和布局</h2>

<p>有时它会花费人们很多时间去解析复杂的层次结构，假如这是在主线程发生，这将会阻塞主线程，假如你想取悦用户的话，你不能让用户一直等待，之前用户是不能和程序有任何交互的。</p>

<p>因为这个原因，你将会在后台线程创建设置nodes，这样你能避免阻塞主线程。</p>

<p>在createCardNode(containerRect:)和viewDidLoad():中实现addCardViewAsynchronously(containerRect:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addCardViewAsynchronously(#containerRect: CGRect) {
</span><span class='line'>  dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)) {
</span><span class='line'>    let cardNode = self.createCardNode(containerRect: containerRect)
</span><span class='line'>    dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>      self.view.addSubview(cardNode.view)
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>addCardViewAsynchronously(containerRect:)</code>创建这个<code>CardNode</code>在一个线程队列中，这是很好的，因为nodes是线程安全的！创建好之后，配置这个Node,然后异步调用主线程把Node添加到视图控制器中&ndash;毕竟，UIKit不是线程安全的！</p>

<blockquote><p><em>注意</em>
一旦你创建了Node的视图，所有访问node的节点只在主线程</p></blockquote>

<p>重新实现viewDidLoad()通过调用<code>addCardViewAsynchronously(containerRect:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将不再阻塞主线程，确保用户界面是可以随时响应的。</p>

<p>编译运行，和之前一样，不过所有的操作都是在后台线程执行的</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>约束节点大小</h2>

<p>记得之前我你会使用一个更优雅的解决方案节点不仅仅依靠屏幕尺寸的大小
?现在我来兑换我的诺言</p>

<p>打开 ViewController.swift，添加下面的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cardViewSetupStarted = false</span></code></pre></td></tr></table></div></figure>


<p>然后替换viewDidLoad()为viewWillLayoutSubviews():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>override func viewWillLayoutSubviews() {
</span><span class='line'>  super.viewWillLayoutSubviews()
</span><span class='line'>  if !cardViewSetupStarted {
</span><span class='line'>    addCardViewAsynchronously(containerRect: view.bounds)
</span><span class='line'>    cardViewSetupStarted = true
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换掉了住屏幕的尺寸，这上面的逻辑是视图控制器的尺寸去约束卡片的尺寸。</p>

<p>现在它是线程安全的,去用这个视图控制器的尺寸，当viewWillLayoutSubviews()替换调viewDidLoad()。这一次在这个声明周期中，这个视图控制器已经设置好了它的尺寸。</p>

<p>这种加载方式是很出众的，因为一个视图控制器能被设置任何尺寸,你不想依赖视图控制器去横跨整个屏幕</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/screen_size_tyranny.png" alt="log" /></p>

<p>这个视图可能会加载多次，所以viewWillLayoutSubviews()能被调用多次，你仅仅想创建这个CardNode一次，所以这就是为什么你需要一个cardViewSetupStarted标识去证明这个视图控制创建多次。</p>

<p>编译运行：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>Node层次结构</h2>

<p>现在你有一个空的Node容器在屏幕上，现在你想展示一些内容，方式的就是你添加一些子node到这个Node容器中，下面的结构图展示了简单的Node结构图</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_Nodes.png" alt="node" /></p>

<p>添加子Node看起来将会非常像你在UIview中添加子View的过程。</p>

<p>第一步你需要添加一个图片的node,但是首先你的需要了解容器Node是如何布局子Node的。</p>

<h2>子Node的布局</h2>

<p>你现在知道了如何去测量容器的尺寸和如何去计算容器尺寸去布局容器内的node视图，但是这个容器node是如何布局它们的子Node呢？</p>

<p>有以下两步:</p>

<ol>
<li>第一，你测量每个子Node的尺寸在<code>calculateSizeThatFits(constrainedSize:).</code>中，这将确保每一个子Node都缓存一个计算好的尺寸</li>
<li>在UIKIt的主线程布局中，AsyncDisplayKit将会调用<code>layout()</code>在你的自定义的ASDisplayNode子类中，<code>layout()</code>的工作就像UIview的 <code>layoutSubivews()</code>，除了这个<code>layout()</code>不会计算所有子视图的尺寸，布局()简单查询计算每个节点的大小</li>
</ol>


<p>回到UI上，这个泰姬陵卡片尺寸将会和它的图片大小一样，并且这个标题将会适合它的大小。最简单的方式就是去测量这个<code>泰姬陵图片</code>node的大小并且使用这个结果去约束文本node的尺寸，所以这个文本node将会适合图片尺寸的大小</p>

<p>接下来，你将要使用lay out去布局你的卡片子Node,让我们开始</p>

<h2>添加一个子Node</h2>

<p>打开CardNode.swift,然后添加下面的代码在CardNode</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let imageNode: ASImageNode
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>init(card: Card) {
</span><span class='line'>  imageNode = ASImageNode()
</span><span class='line'>  super.init()
</span><span class='line'>  setUpSubnodesWithCard(card)
</span><span class='line'>  buildSubnodeHierarchy()
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>func setUpSubnodesWithCard(card: Card) {
</span><span class='line'>  // Set up image node
</span><span class='line'>  imageNode.image = card.image
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 4
</span><span class='line'>func buildSubnodeHierarchy() {
</span><span class='line'>  addSubnode(imageNode)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>图片Node属性:这行代码添加一个图片Node的属性，去引用卡片图像的子Node</li>
<li>初始化:这个设计的初始化使用一个卡片模型保存卡片的图像和文本</li>
<li>设置子Node:这个方法使用卡片模型的图像去保存开始项目中的子Node图片</li>
<li>容器层次结构:你设置Node的层次结构就像你能设置视图的层次结构一样，这个方法创建卡片的层次结构通过添加一个子Node来实现。</li>
</ol>


<p>下一步，实现calculateSizeThatFits(constrainedSize:):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>  // 1 
</span><span class='line'>  imageNode.measure(constrainedSize)
</span><span class='line'> 
</span><span class='line'>  // 2 
</span><span class='line'>  let cardSize = imageNode.calculatedSize
</span><span class='line'> 
</span><span class='line'>  // 3 
</span><span class='line'>  return cardSize
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>这个卡片的尺寸就会匹配背景图片的大小，这个测量背景图片的尺寸会适合内嵌的约束尺寸，所有Node的子类都会被AsyncDisplay框架感知并且知道如何设置它们的尺寸，包括AsImageNode</li>
<li>这行代码临时存储图片计算的尺寸，特别说明的是，它使用图片Node测量尺寸正如卡片Node尺寸去约束子NOde，当添加更多的子Node的时候，你将会使用这个值</li>
<li>返回这个卡片Node的计算好的尺寸</li>
</ol>


<p>下一步，覆盖layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layout() {
</span><span class='line'>  imageNode.frame =
</span><span class='line'>    CGRect(origin: CGPointZero, size: imageNode.calculatedSize).integerRect
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个图片的逻辑位置在左上角，坐标轴原点，它也确保了这个图片Node的frame没有任何多余的值，所以你能避免像素边界显示问题</p>

<p>注意这个方法是如何使用图片的Node去缓存计算尺寸的在布局的过程中。</p>

<p>因为这个图片Node的尺寸决定了卡片Node的尺寸，这个图片将会横跨这个卡片</p>

<p>回到ViewController.swift，然后添加一个createCardNode(containerRect:), 替换到之前初始化的<code>CardNode</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cardNode = CardNode(card: card)</span></code></pre></td></tr></table></div></figure>


<p>这行代码使用新的初始化去添加一个卡片Node,这个卡片值将会在初始化的时候被传入，并且存储这个泰姬陵的卡片模型</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-6-281x500.jpg" alt="t" /></p>

<p>漂亮，你成功的创建了容器Node并且呈现了Node的层次结构，当然，这个很简单，但是它是一个完成的Node层次！</p>

<h2>添加更多的子Node</h2>

<p>也许你已经注意到了，没有添加标题，不用担心，让我们开始添加吧。</p>

<p>打开CardNode.swift，然后添加下面的属性titleTextNode在类中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode: ASTextNode</span></code></pre></td></tr></table></div></figure>


<p>在<code>init(card:)</code>方法中初始化<code>titleTextNode</code>，在super.init()这行代码之前:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode = ASTextNode()</span></code></pre></td></tr></table></div></figure>


<p>添加下面的这行代码在<code>setUpSubnodesWithCard(card:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(card.name)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码给titleTextNode设置了富文本内容，<code>attributedStringForTitleText(text:)</code>是一个帮助方法被加到了NSAttributedString扩展属性中。在之前的开始工程中，它创建了富文本使用提供的标题。</p>

<p>下一步，在<code>buildSubnodeHierarchy():</code>的结尾增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>要确保它是在添加到图片Node的后面，不然图片将会遮盖住标题。</p>

<p>在内置的方法<code>calculateSizeThatFits(constrainedSize:)</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.measure(cardSize)</span></code></pre></td></tr></table></div></figure>


<p>使用子Node的测量尺寸来作为卡片的约束尺寸</p>

<p>添加如下的布局代码layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame =
</span><span class='line'>  FrameCalculator.titleFrameForSize(titleTextNode.calculatedSize, containerFrame: imageNode.frame)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码计算标题Node的frame通过工具方法FrameCalculator</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-281x500.jpg" alt="test" /></p>

<p>至此，你已经构建了完整的子Node层次结构，使用了容器Node,并且添加了两个子Node</p>

<h2>完整工程</h2>

<p><a href="https://github.com/TLSwiftDemo/Wonders/archive/master.zip">完整工程在这里下载</a></p>

<p>have fun 😀~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ColletionView布局]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju/"/>
    <updated>2016-04-24T21:05:32+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju</id>
    <content type="html"><![CDATA[<p>UICollectionView在ios6中第一次被引入，也是UIKit <a href="http://oleb.net/blog/2012/09/uicollectionview/">视图类中的一颗新星</a>
。它和UITableview共享一套API设计，但也在UItableView上做了一些扩展。UICOllectionView最强大，同时显著超出UITableView的特色就是其完全灵活的布局结构。这这篇文章中，<!--more--> 我们将会实现一个相当复杂的自定义Collection view布局，并且顺便讨论一下这个类设计的重要部分，项目的实例代码在 <a href="https://github.com/objcio/issue-3-collection-view-layouts">GitHub</a>上。</p>

<h2>布局对象(Layout Objects)</h2>

<p>UITableView和UICollectionView都是 data-source和delegate驱动的。他们在显示其子视图集的过程中仅扮演容器角色,且对子视图集真正的内容毫不知情。</p>

<p>UICollectioNView在此之上进行了进一步抽象。它将子视图的位置，大小和外观的控制权拖过给一个单独的布局对象。通过提供一个自定义布局对象，你技术可以实现任何你能想象到的布局。布局继承自UICollectionVieLayout抽象基类.IOS6中以UICollectionViewFloyLayout类的形式提出了一个具体的布局实现。</p>

<p>我们可以使用flow layout实现一个标准的gridview,这可能是colle tion view中最常见的使用案例了。尽管大多数人都这么想，但是Apple很聪明，没有明确的命名这个类为UIColletionViewGridLayout,而使用了更为通用的术语 flow layout,更好的描述了该类的功能：它通过一个接一个的放置cell来建立自己的布局，当需要的时候，插入横排或竖排的分栏符。通过自定义滚动方向，大小和cell之间的间距，flow layout 也可以在单行或单列中布局cell。实际上，UITableView的布局可以想象成flow layout的一种特殊情况。</p>

<p>在你准备自己写一个UICollectionViewLayout的子类之前，你需要问你自己，你是否能够使用UICollectionViewFlowlayout实现你心里的布局。这个类是<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout">很容易定制的</a>,并且可以继承本身进行进一步的定制，感兴趣的看<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4">这篇文章</a></p>

<h2>Cells和其他Views</h2>

<p>为了适应任意布局,collection view简历了一个类似，但比 table view更灵活的视图层级，像往常一样，你的主要内容显示在cell中，cell可以被任意分组到section中。CollectionView的cell必须是UICollectionViewCell的子类。除了cell，collection view额外管理着两种视图:supplementary views和decoration views.</p>

<p>collection view中的Supplemnetary views相当于table view的section header和footer views.像cells一样，他们的内容都有数据源对象驱动，然而和tableview 中用法不一样，supplementary view并不一定会作为header或footer view;他们的数量和位置完全由布局控制.</p>

<p>Decoration views纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从dataSource 获取的contents.当布局对象指定需要一个decoration view的时候，collection view会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views和decoration views必须是UICollectionReusableView的子类。布局使用的每个视图类都需要在collection view中注册，这样当data Source让它们从reuse pool中出列时，它们才能够创建新的实例。如果你是使用的interface Builder，则可以通过在可视化编辑器中拖拽一个cell到collection view上完成cell在collection view中的注册。同样的方法也可以用在supplementary view上，前提是你使用了UIcollectionviewFlowLayout.如果没有，你只能通过调用 <code>registerClass:</code>或者<code>registerNib:</code>方法手动注册视图类了。你需要在<code>viewDidload</code>中做这些操作.</p>

<h2>自定义布局</h2>

<p>作为一个非常有意义的自定义collection view布局的例子，我们不妨想一个典型的日历应用程序中的周视图。日历一次显示一周，星期中的每一天现在列中，每一个日历事件将会在我们的colleectio view中以一个cell显示，位置和大小代表事件起始日期事件和持续时间。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/calendar-collection-view-layout.png" alt="test" />
一般有两种类型的 collection view布局:</p>

<ol>
<li>独立于内容的布局计算.这正是你所知道的像UITableview和UIcollectionViewFlowLayout这些情况。每个cell的位置和外观不是基于其显示的内容，但所有cell的显示顺序是基于内容的顺序。可以把默认的flow layout作为例子。每个cell都是基于前一个cell的放置(或者如果没有足够的空间，则从下一行开始).布局对象不必访问实际数据来计算布局.</li>
<li>基于内容的布局计算。我们的日历视图正式这样类型的例子。为了计算显示事件的气势和街二叔事件，布局对象需要直接访问 collection view的数据源。在很多情况下，布局对象不仅需要取出当前可见cell的数据，还需要从所有记录中取出一些决定当前那些cell可见的数据。</li>
</ol>


<p>在我们的日历示例中，布局对象如果访问某一个矩形内的cells的属性，那就必须迭代数据源提供的所有事件来决定那些位于要求的时间窗口个中。与一些相对简单，数据源独立计算的flow layout比起来，这足够计算出cell在一个矩形内的index paths了（假设网格中所有的cells的大小都一样）.</p>

<p>如果有一个依赖内容的布局，那就是暗示你需要些自定义的布局类了，同时不能使用自定义的UICOllectionViewFlowLayout，所以这正是我们需要做的事情。</p>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html">UICollectionViewLayout文档</a>列出了子类需要重写的方法.</p>

<h2>collectionViewContentSize</h2>

<p>由于 collection view对它的content并不知情，所以布局首先要提供的信息就是滚动区域的大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。注意，尽管大多数经典的collection view限制在一个轴方向上滚动(正如UIcollectionviewFlowLayout一样)，但是这不是必须的。</p>

<p>在我们的日历示例中，我们想要视图垂直的滚动。比如，如果我们想要在垂直空间上一个小时占去100点，这样显示一整天的内容高度就是2400点。注意，我们不能够水平滚动，这就意味这我们collectionview只能显示一周。为了能够在日历中的多个星期间分页，我们可以在一个独立的scroll view中（可以使用U<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html">IPageViewController</a>）中使用多个 collection view（一周一个）,或者坚持使用一个collection view并且返回足够大的内容宽度，这回使得用户感觉在两个方向上滑动自由。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (CGSize)collectionViewContentSize
</span><span class='line'>{
</span><span class='line'>    // Don't scroll horizontally
</span><span class='line'>    CGFloat contentWidth = self.collectionView.bounds.size.width;
</span><span class='line'>
</span><span class='line'>    // Scroll vertically to display a full day
</span><span class='line'>    CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay);
</span><span class='line'>
</span><span class='line'>    CGSize contentSize = CGSizeMake(contentWidth, contentHeight);
</span><span class='line'>    return contentSize;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了简单起见，我选择布局在一个非常简单的模型上：假定每周天数相同，每天时长相同，也就是说天数用0-6表示。在一个真实的日历程序中，布局将会为自己的几段大量使用基于 <code>NSCalendaar</code>的日期</p>

<h2>layoutAttributesForElementsInRect：</h2>

<p>这是任何布局类中最重要的方法了，同时可能也是最容易让人迷惑的方法。collection view调用这个方法并传递一个自身坐标系统中的矩形过去。这个矩形代表了这个视图的可见矩形区域(也即是它的bounds)，你需要准备好处理传给你的任何矩形。</p>

<p>你的视线必须返回一个包含 UICollectionviewLayoutAttributes对象的数组，为每一个cell包含一个这样的对象，supplementary View或decoration view在矩形区域内是可见的。UICollectionViewLayoutAttributes类包含了colletion view内item的所有相关的布局属性。默认情况下，这个类包含 frame,center,size,transform3D,alpha,Zindex和hidden属性。如果你的布局想要控制其他视图的属性(比如背景颜色)，你可以创建一个UICollectionViewLayoutAttributes的子类，然后加上你自己的属性。</p>

<p>布局属性对象(Layout attributes objects)通过indexPath属性和他们对应的cell,supplementary view或者decoration view关联在一起。collection view为所有items从布局对象中请求到布局属性后，它将会实例化所有视图，并将对应的属性应用到每个视图上去。</p>

<p>注意!这个方法涉及到所有类型的视图，也就是cell,supplementary views和decoration views.一个幼稚的实现可能会选择忽略传入的矩形，并且为collection view中所有的视图返回布局属性。在原型设计和开发布局阶段，这是一个有效的方法。但是，这将会性能产生非常坏的影响，特别是可见cell远少于所有cell数量的时候，collection view和布局对象将会为那些不可见的而试图做额外不必要的工作。</p>

<p>你的视线需要做这几步:</p>

<ol>
<li>创建一个空的可变数组来存放所有的布局属性</li>
<li>确定index paths中那些cells的frame完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你视线的<code>layoutattributesForItemIndexPath:</code>方法为每个index path创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</li>
<li>如果你的布局包含supplementary views,计算矩形内可见supplementary view的index paths.在循环中调用你实现的<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>,并且将这些对象加到数组中。通过为kind参数传递你选择的不同字符，你可以却分出不同种类的supplementary views(比如headers和footers)。当需要创建视图时，collectionview会将kind字符传回到你的数据源。记住supplermentary 和decoration views的数量和种类完全有布局控制。你不会受到headers和footers的限制.</li>
<li>如果布局包含decoration views，计算矩形内可见decoration views的index paths.在循环中调用你实现的<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>
，并且将这些对象加到数组中</li>
<li>返回数组</li>
</ol>


<p>我们自定义的布局没有使用 decoration views,但是使用了两种supplermentary views(column headers和row headers):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    NSMutableArray *layoutAttributes = [NSMutableArray array];
</span><span class='line'>    // Cells
</span><span class='line'>    // We call a custom helper method -indexPathsOfItemsInRect: here
</span><span class='line'>    // which computes the index paths of the cells that should be included
</span><span class='line'>    // in rect.
</span><span class='line'>    NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in visibleIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForItemAtIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Supplementary views
</span><span class='line'>    NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"DayHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"HourHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>    return layoutAttributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>layoutAttributesFor…IndexPath</h2>

<p>有时，collection view会为某个特殊的cell,supplementary 或者decoration view向布局对象请求布局属性，而非所有可见的对象。这就是当其他三个方法开始起作用时，你实现的<code>layoutAttributesForItemAtIndexPath:</code>需要创建并返回一个单独的布局属性对象，这样才能正确的格式化传给你的index path 所对应的cell.</p>

<p>你可以通过调用<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，然后根据index path修改属性。为了得到需要显示在这个index path内的数据，你可能需要访问collection view的数据源。到目前为止，至少确保设置了frame尚需经，除非你所有的cell都位于彼此上方。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>    CalendarDataSource *dataSource = self.collectionView.dataSource;
</span><span class='line'>    id event = [dataSource eventAtIndexPath:indexPath];
</span><span class='line'>    UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>    [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>    attributes.frame = [self frameForEvent:event];
</span><span class='line'>    return attributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你正在使用自动布局，你可能会赶到惊讶，我们正在直接修改布局参数的frame属性，而不是和约束共事，但这正是UIcollectionViewLayout的工作。尽管你坑你使用自动布局来定义collection view的frame和它内部每个cel的布局，但cells的frames还是需要通过老式的方法计算出来。</p>

<p>类似的，<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>和<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>方法分别需要为supplementary 和decoration views做相同的事。只有你的布局包含这样的视图你才需要实现这两个方法。UICollectionViewlayoutAttributes包含另外两个工厂方法，</p>

<p><code>+layoutAttributesForSupplementaryViewOfKind:withIndexPath:</code> 和 <code>+layoutAttributesForDecorationViewOfKind:withIndexPath:</code>，用他们来创建正确的布局属性对象</p>

<h2>shouldInvalidateLayoutForBoundsChange:</h2>

<p>最后，当collection view的bounds改变时，布局需要告诉collection view是否需要重新计算布局。我的猜想是：当collectionview改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个优质的实现可能只会简单的返回YES。芮然实现功能很重要，但是scrollview的bounds在滚动时也会改变，这意味着你的布局美妙会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。</p>

<p>当collection view的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view将它的bounds传给<code>shouldInvalidateLayoutForBoundsChange:</code>方法，这样我们便能比较视图当前的bounds和新的bounds来确定返回值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
</span><span class='line'>{
</span><span class='line'>    CGRect oldBounds = self.collectionView.bounds;
</span><span class='line'>    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>        return NO;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>动画</h2>

<h3>插入和删除</h3>

<p>UITableview中的cell自带了一套非常漂亮的插入和删除的动画。但是当为UIcollectionView增加和删除cell定义动画功能时，UIKit工程师们遇到这样一个问题：如果Collection view的布局是完全可变的，那么预先定义好的动画就没办法和开发者自定义的布局很好的融合。他们提出了一个优雅的方法：当一个cell(或者supplementary 或者 decoration View)被插入到collection view中时，collection View不仅向其布局请求cell正常正常状态下的布局尚需经，同时还请求其初始的布局尚需经，比如，需要在开始有插入动画的cell。CollectionView会简单的创建一个anmiation block,并在这个block中，将所有cell的属性从初始状态改变到常态</p>

<p>通过提供不同的初始布局属性，你可以完全自定义插入动画。比如设置初始的alpha为0将会产生一个淡入的动画。同时设置一个平移或者缩放将会产生移动缩放的效果。</p>

<p>同样的原理应用到删除上，这次动画是从常态到一些列你设置的最终布局属性。这些逗你需要在布局类中为initial或final布局参数实现的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>initialLayoutAttributesForAppearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:</span></code></pre></td></tr></table></div></figure>


<h2>布局间切换</h2>

<p>可以通过类似的方式将一个collection view布局动态的切换到另外一个布局。当发送一个<code>setCollectionViewLayout:animated:</code>消息时，collection view会为cells在新的布局中查询新的布局参数，然后动态的将每个cell从旧参数变换到新的布局参数。你不需要做任何事情。</p>

<h2>结论</h2>

<p>根据自定义collection view布局的复杂性，写一个通常很不容易。确切的说，本质上这和从头写一个完整的实现相同布局自定义视图类一样困难了。因为所涉及的计算需要确定去那些子视图是当前可见的，以及他们的位置。尽管如此，使用UIcollectionview还是给你带来了一些很好的效果，比如cell重用，自动支持动画，更不要提整洁的独立布局，子视图管理。</p>

<p>自定义collection view布局也是向<a href="http://objccn.io/issue-1-1/">轻量级view Controller</a>迈出了很好的异步，正如你的view controller不要包含任何布局代码。应该和一二个独立的dataSource类结合在一起，collection view的视图控制器将很难再包含任何代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OHHTTPStubs介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao/"/>
    <updated>2016-04-22T17:18:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>是一个模拟网络请求的一个框架，它使用起来非常方便和强大，它能帮你</p>

<ol>
<li>测试你的app仿真一个服务器（比如加载一个本地文件）,模拟网络慢的情况等</li>
<li>使用伪造的网络数据编写单元测试</li>
</ol>


<!--more-->


<h2>简单用法</h2>

<h2>在Objc中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>  return [request.URL.host isEqualToString:@"mywebservice.com"];
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h2>在swift中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stub(isHost("mywebservice.com")) { _ in
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  let stubPath = OHPathForFile("wsresponse.json", self.dynamicType)
</span><span class='line'>  return fixture(stubPath!, headers: ["Content-Type":"application/json"])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>语法讲解</h2>

<p><code>OHHTTPStubs stubRequestsPassingTest:</code>方法创建了模拟服务器，<code>request</code>是请求的标准判断，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[request.URL.host isEqualToString:@"mywebservice.com"]</span></code></pre></td></tr></table></div></figure>


<p>意思就是如果请求的url是<code>mywebservice.com</code>，我们就返回response,要不然不执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];</span></code></pre></td></tr></table></div></figure>


<p>返回一个respoinse,其中包含了返回的数据，</p>

<ol>
<li>获取的一个本地文件</li>
<li>返回的状态码 200  (200表示正确返回)</li>
<li>headers：返回的头,如果是json一般是:@{@&ldquo;Content-Type&rdquo;:@&ldquo;application/json&rdquo;}</li>
</ol>


<h1>快速开始一个Demo</h1>

<h2>创建一个空工程</h2>

<p>用xcode创建一个工程，用pods创建一个Podfile</p>

<p>内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'OHHTTPStubs', '~&gt; 5.0.0'
</span><span class='line'>
</span><span class='line'>target :OHHTTPStubsDemoTests, :exclusive =&gt; true do
</span><span class='line'>    link_with 'OHHTTPStubsDemoTests'
</span><span class='line'>    
</span><span class='line'>    pod 'OHHTTPStubs'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>执行 <code>pod install</code></p>

<p>成功安装OHHTTPStubs后，在OHHTTPStubsDemoTests目录中编写测试类:</p>

<h3>创建session</h3>

<p>在顶部声明一个变量session</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (nonatomic,strong) NSURLSession *session;</span></code></pre></td></tr></table></div></figure>


<p>在setUp方法中，创建该变量实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.session=[NSURLSession sharedSession];</span></code></pre></td></tr></table></div></figure>


<p>在 testExample()方法中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  返回自定义的普通文本
</span><span class='line'> */
</span><span class='line'>- (void)testExample {
</span><span class='line'>    
</span><span class='line'>    //开始模拟服务器
</span><span class='line'>    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //发送请求的url后缀必须是.com结尾的
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"com"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //创建一个字符串
</span><span class='line'>        NSData * stubData = [@"hello world" dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>        //响应数据
</span><span class='line'>        /**
</span><span class='line'>         *  responseWithData:返回的数据
</span><span class='line'>            statusCode:状态码,200表示成功
</span><span class='line'>            headers:http的header
</span><span class='line'>         */
</span><span class='line'>        return [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:@{@"Content-Type":@"text/plain"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //在XCT测试框架中，这个表示期望值，因为这个期望值是支持异步测试的，我们是异步请求，所以一定要是使用XCTestExpectation这个特性
</span><span class='line'>     XCTestExpectation *expectation=[self expectationWithDescription:@"sessionDataTask expectation"];
</span><span class='line'>    
</span><span class='line'>    //创建session任务
</span><span class='line'>    NSURLSessionDataTask *dataTask=[self.session dataTaskWithURL:[NSURL URLWithString:@"hello.com"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        //解析返回的字符串
</span><span class='line'>        NSString *resultStr=[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的数据:%@",resultStr);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(resultStr!=nil);
</span><span class='line'>        
</span><span class='line'>        //断言返回的字符串是hello world,如果不是，则断言失败
</span><span class='line'>        XCTAssertTrue([resultStr isEqualToString:@"hello world"]);
</span><span class='line'>        
</span><span class='line'>        //在想异步测试的地方加上下面这行代码
</span><span class='line'>        [expectation fulfill];
</span><span class='line'>    }];
</span><span class='line'>    //启动任务
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //使用XCTestExpectation,必须设置如下的waitForExpectationsWithTimeout方法，如果超时则失败
</span><span class='line'>    [self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%s",__FUNCTION__);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>   
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里面使用到了 <code>XCTestExpectation</code>，这是特性是用来测试异步程序代码的。在想测试异步代码的地方加上<code>[expectation fulfill];</code>,
最后，要加上<code>waitForExpectationsWithTimeout</code>方法，它们是配对出现的。</p>

<p>OHHTTPStubs创建了模拟服务器后，下面发的任何网络请求都会被模拟服务器返回，正如上面的代码所示，测试结果:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-3.png" alt="test" />
断言成功！</p>

<h2>添加本地文件</h2>

<ol>
<li>在本地创建一个stub.txt的文本文件，内容自定</li>
<li>在本地创建一个stub.jpg的图片，图片自定</li>
</ol>


<p>图片
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-5.png" alt="1" /></p>

<p>文本
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-4.png" alt="2" /></p>

<h3>创建文本的TextStub</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建文本的TextStub
</span><span class='line'> */
</span><span class='line'>-(void)createTextStub{
</span><span class='line'>    // #1
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; textStub = nil;
</span><span class='line'>    
</span><span class='line'>    // #2
</span><span class='line'>    textStub= [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"txt"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        
</span><span class='line'>        NSString *path = OHPathForFile(@"stub.txt",self.class);
</span><span class='line'>        
</span><span class='line'>       //#3
</span><span class='line'>        return [[OHHTTPStubsResponse responseWithFileAtPath:path
</span><span class='line'>                                                 statusCode:200 headers:@{@"Content-Type":@"text/plain"}]
</span><span class='line'>                requestTime:1.0f
</span><span class='line'>                responseTime:OHHTTPStubsDownloadSpeedWifi];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    //#4
</span><span class='line'>    textStub.name = @"text stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面代码意义如下:</p>

<ol>
<li>声明一个返回的OHHTTPStubsDescriptor,这是创建模拟服务器的返回结果描述</li>
<li>开始创建模拟服务器</li>
<li>返回response，其中设置了返回数据，状态码，请求时间等</li>
<li>给textStub起个名字</li>
</ol>


<h2>测试文本的模拟服务器</h2>

<p>创建一个testStubTextTask方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试文本的Stub任务
</span><span class='line'> */
</span><span class='line'>-(void)testStubTextTask{
</span><span class='line'>    //创建文本的模拟服务器
</span><span class='line'>    [self createTextStub];
</span><span class='line'>    //创建一个期望值
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"high expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSession *session=[NSURLSession sharedSession];
</span><span class='line'>    
</span><span class='line'>    NSString *urlString=@"stub.txt";
</span><span class='line'>    NSURLSessionDataTask *dataTask = [session dataTaskWithURL:[NSURL URLWithString:urlString] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        NSString* receivedText = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
</span><span class='line'>        NSLog(@"返回的结果:%@",receivedText);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(receivedText!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:5 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>创建图片的stub</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建Image的stub
</span><span class='line'> */
</span><span class='line'>-(void)createImageStub{
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; imageStub = nil;
</span><span class='line'>    
</span><span class='line'>    imageStub=[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"png"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFile(@"stub.jpg", self.class) statusCode:200 headers:@{@"Content-Type":@"image/jpeg"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    imageStub.name=@"Image stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>测试Image的模拟服务器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试Image的模拟服务器
</span><span class='line'> */
</span><span class='line'>- (void)testImageStubTask{
</span><span class='line'>    
</span><span class='line'>    [self createImageStub];
</span><span class='line'>    
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"Image Expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSessionDataTask *dataStask=[self.session dataTaskWithURL:[NSURL URLWithString:@"test.png" relativeToURL:nil] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        UIImage *image=[UIImage imageWithData:data];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的image:%@",image.description);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(image!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataStask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:3 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>完整工程</h2>

<p><a href="https://github.com/TLOpenSpring/OHHTTPStubsDemo/archive/master.zip">完整工程在这里下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode更新后插件失效的解决方案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an/"/>
    <updated>2016-04-22T16:17:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<p>Xcode的插件对于开发者来说无疑是一把利器，让开发者能够将更多的时间和精力放在代码上面。但是开发者都会遇到一个问题，就是每次Xcode更新到最新的版本，之前的插件全部都失效了，需要重新安装一遍很是麻烦。</p>

<!--more-->


<p>插件失效的原因:</p>

<blockquote><blockquote><ul>
<li>系统安装了一个Xcode</li>
<li>开发者未正确的将自己的DVTPlugInCompatibilityUUID添加到插件中</li>
<li>成功安装了插件，但是却在Xcode识别插件的时候，选了 Skip Bundle</li>
</ul>
</blockquote></blockquote>

<h2>终端指令实现</h2>

<p>//获取DVTPlugInCompatibilityUUID字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID
</span></code></pre></td></tr></table></div></figure>


<h2>找到插件的目录</h2>

<ol>
<li>打开xcode插件所在的目录:<code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>,打开路径的快捷键是shift＋command＋g 然后输入上面的地址</li>
<li>选择已经安装的插件，例如:VVDocumenter-Xcode，右键显示包内容</li>
<li>找到info.plist文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item,value的值为之前的Xcode的UUID,(或者直接在item0中value修改也可以)保存</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-1.png" alt="step2" /></p>

<h2>重启xcode</h2>

<p>重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-0.png" alt="step1" /></p>

<h2>效果如下</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-2.png" alt="s" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试并发程序]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu/"/>
    <updated>2016-04-21T17:38:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试时一个很重要的工具。在过去，当并发不是应用程序架构中重要组成部分的时候，测试就想单简单。随着这几年的发展，使用并发设计模式变得越来越重要了，想要测试好并发应用程序，已成了一个不小的挑战.</p>

<!--more-->


<p>测试并发代码最主要的困难在于程序或信息流不是反应在调用堆栈上。函数并不会立即返回给调用者，而是通过回调函数block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然后，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h1>异步测试的问题</h1>

<p>首先，我们来看一个简单地同步单元测试的例子，两个数求和的方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b {
</span><span class='line'>    return a + b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>测试这个方法很简单，只需要比较该方法返回值是否和期望值相同，如果不相同，则测试失败。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddition {
</span><span class='line'>    int result = [Calculator add:2 to:2];
</span><span class='line'>    STAssertEquals(result, 4, nil);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们利用block将该方法改成异步返回结果，为了模拟测试失败，我们会在方法实现中故意添加一个bug.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
</span><span class='line'>    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
</span><span class='line'>        block(a - b); // 带有bug的实现
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>虽然这是一个人为的例子，但是它却真实的反映了编程中可能经常遇到的问题，只不过实际过程更加复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到Block中。尽管我们的方法实现中存在bug,但是这种测试永远不是失败的；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 千万不要使用这些代码！
</span><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block:^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil); // 永远不会被调用到
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的断言为什么没失败呢？</p>

<h1>关于SenTestingKit</h1>

<p>在老版本的xcode中所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKit-call-stack.png" alt="test" /></p>

<p>在测试框架在主run loop开始运行之后，主要执行了一下几个步骤:</p>

<ol>
<li>配置一个包含所有相关测试的测试包</li>
<li>运行测试包，内部会调用所有以test开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。</li>
<li>调用exit()退出测试</li>
</ol>


<p>这其中我们最感兴趣的是单个测试时如何被调用的。在异步测试中，包含断言的Block会被加到run loop。当所有的测试执行完毕后，测试框架就会退出，而block却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方法来解决这个问题。但是素有的方法都必须在住run loop中运行，而且在测试方法返回和比较结果之前需要处理已入队的所有操作。</p>

<p><a href="https://github.com/allending/Kiwi">kiwi</a>使用测试轮询，它可以在测试方法中被滴啊用。<a href="https://github.com/gabriel/gh-unit/">GHUnit</a>编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接受一个通知。以上两种方式都是通过编写相应的代码来确保异步异步测试方法在测试结束之前都不会返回。</p>

<h1>SenTesgingKit的异步扩展</h1>

<p>我们对这个问题的解决方案是对SenTestingKit添加一个扩展，它在栈上使用同步执行，并把每个部分加入到主队列中。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或失败的Block就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKitAsync-call-stack.png" alt="test" /></p>

<p>如果测试方法以Async结尾，框架就睡认为该方法是异步测试。此外，在异步测试中，我们必须手动的报告测试成功，同时为了防止Block永远不会被调用，我们还需要添加了一个超时方法，之前的错误的测试方法修改如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil);
</span><span class='line'>        STSuccess(); // 通过调用这个宏来判断是否测试成功
</span><span class='line'>    }];
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>设计异步测试</h1>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的Bug,在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识.</p>

<p>为了运行到实际中，我们创建了一个实例框架: <a href="sd">AsyncTestDemo</a>,它从一个虚拟的服务器获取图像信息，框架中包含了一个资源管理器，它对外提供了一个可以根据图像Id获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/PinacotecaCore.png" alt="test" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试:</p>

<ol>
<li>模型层</li>
<li>模拟服务器请求的服务器接口控制器(API Controller)</li>
<li>管理Core data堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>


<h2>模型层</h2>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的core data堆栈，并在其中执行各自的操作。</p>

<p>在这个测试实例中，我们就是在 setup 方法中设置core data堆栈，然后检查 PCImage实体的描述是否存在，如果不存在就构造一个，并更新它的值，当然这和异步测试没有关系，我们就不深入细说了。</p>

<h2>服务器接口控制器</h2>

<p>框架中的第二个组件就是服务器接口控制器，它主要处理服务器请求以及服务器API到模型的映射关系。让我们来看一下下面这个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- [PCServerAPIController fetchImageWithId:queue:completionHandler:]</span></code></pre></td></tr></table></div></figure>


<p>调用它需要三个形参：一个图片对象Id，所在的执行队列，以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好<a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个bundle,发送给客户端。</p>

<p>为了能stub请求，OHHTTPStubs需要在测试类初始化时或者 setup方法中进行配置。首先我们需要加载一个包含请求响应对象(response)的bundle:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSURL *url = [[NSBundle bundleForClass:[self class]]
</span><span class='line'>                        URLForResource:@"ServerAPIResponses"
</span><span class='line'>                         withExtension:@"bundle"];
</span><span class='line'>
</span><span class='line'>NSBundle *bundle = [NSBundle url];</span></code></pre></td></tr></table></div></figure>


<p>然后我们从bundle加载response对象，作为请求的响应值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OHHTTPStubsResponse *response;
</span><span class='line'>response = [OHHTTPStubsResponse responseNamed:@"images/123"
</span><span class='line'>                                   fromBundle:responsesBundle
</span><span class='line'>                                 responseTime:0.1];
</span><span class='line'>
</span><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>    return YES /* 如果所返回的request是我们所期望的，就返回YES */;
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
</span><span class='line'>    return response;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m">测试服务器接口控制器</a>如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFetchImageAsync
</span><span class='line'>{
</span><span class='line'>    [self.server
</span><span class='line'>        fetchImageWithId:@"123"
</span><span class='line'>                   queue:[NSOperationQueue mainQueue]
</span><span class='line'>       completionHandler:^(id imageData, NSError *error) {
</span><span class='line'>          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
</span><span class='line'>          STAssertNil(error, [error localizedDescription]);
</span><span class='line'>          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);
</span><span class='line'>
</span><span class='line'>          // 检查返回的字典中的值.
</span><span class='line'>
</span><span class='line'>          STSuccess();
</span><span class='line'>       }];
</span><span class='line'>    STFailAfter(2.0, nil);    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>资源管理器</h2>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和膜形成呢个联系起来，还管理着core data堆栈。下面我们想测试获取一个图片对象的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]</span></code></pre></td></tr></table></div></figure>


<p>该方法根据Id返回一个图片对象。如果图片在数据库中不存在，它会创建一个包含Id的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用<a href="http://ocmock.org/">OCMock</a>来模拟，如果要做方法的部分stub,它是一个理想的框架.如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m">资源管理器测试</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OCMockObject *mo;
</span><span class='line'>mo = [OCMockObject partialMockForObject:self.resourceManager.server];
</span><span class='line'>
</span><span class='line'>id exp = [[serverMock expect] 
</span><span class='line'>             andCall:@selector(fetchImageWithId:queue:completionHandler:)
</span><span class='line'>            onObject:self];
</span><span class='line'>[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];</span></code></pre></td></tr></table></div></figure>


<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们卸载测试类中的方法。</p>

<p>用上面的作坊，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的使我们模拟的服务器接口控制器的方法，这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testGetImageAsync
</span><span class='line'>{
</span><span class='line'>    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
</span><span class='line'>    __block PCImage *img;
</span><span class='line'>    img = [self.resourceManager imageWithId:@"123"
</span><span class='line'>                  usingManagedObjectContext:ctx
</span><span class='line'>                                      queue:[NSOperationQueue mainQueue]
</span><span class='line'>                              updateHandler:^(NSError *error) {
</span><span class='line'>                                       // 检查error是否为空以及image是否已经被更新 
</span><span class='line'>                                       STSuccess();
</span><span class='line'>                                   }];    
</span><span class='line'>    STAssertNotNil(img, nil);
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>总结</h1>

<p>刚开始的时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了他们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>😀fun~</p>
]]></content>
  </entry>
  
</feed>
