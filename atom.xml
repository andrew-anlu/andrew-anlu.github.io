<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-05-22T10:36:05+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nodejs-代码的组织和部署]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/22/nodejs-dai-ma-de-zu-zhi-he-bu-shu/"/>
    <updated>2016-05-22T09:45:22+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/22/nodejs-dai-ma-de-zu-zhi-he-bu-shu</id>
    <content type="html"><![CDATA[<p>有经验的C程序员在编写一个新程序时首先从make文件写起，同样的，使用nodejs编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修防止要先搭建脚手架。本章将介绍与之相关的各种知识</p>

<!--more-->


<ul>
<li><a href="#%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99">模块路径的解析规则</a></li>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F">命令行程序</a></li>
<li><a href="#%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95">工程目录</a></li>
<li><a href="#NPM">NPM</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>


<h2><a name="模块路径的解析规则">模块路径的解析规则</a></h2>

<p>我们已经知道，require函数支持斜杠(/)或者盘符(C:)开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发而动全身。因此，require函数支持第三种形式的路径，写法类似foo/bar,并依次按照以上规则解析路径，知道找到模块位置。</p>

<h3>内置模块</h3>

<p>如果传递给require函数的是nodejs内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(&lsquo;fs&rsquo;)</p>

<h3>node_modules目录</h3>

<p>nodejs定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是 /home/user/hello.js,在该模块中使用require(&lsquo;foo/bar&rsquo;)方式加载模块时，则Nodejs依次尝试使用以下路径.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> /home/user/node_modules/foo/bar
</span><span class='line'> /home/node_modules/foo/bar
</span><span class='line'> /node_modules/foo/bar</span></code></pre></td></tr></table></div></figure>


<h3>NODE_PATH环境变量</h3>

<p>与PATH 环境变量类似，nodejs允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在LInux下使用<code>:</code>分隔，在windows下使用;分隔。例如定义了以下NODE_PATH环境变量:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NODE_PATH=/home/user/lib:/home/lib</span></code></pre></td></tr></table></div></figure>


<p>当使用require(&lsquo;foo/bar&rsquo;)的方式加载模块时，则nodejs依次尝试以下路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/home/user/lib/foo/bar
</span><span class='line'>/home/lib/foo/bar</span></code></pre></td></tr></table></div></figure>


<h2><a name="包">包</a></h2>

<p>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成，为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。</p>

<p>在组成一个包的所有子模块中，需要有个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/lib/
</span><span class='line'>    - cat/
</span><span class='line'>        head.js
</span><span class='line'>        body.js
</span><span class='line'>        main.js</span></code></pre></td></tr></table></div></figure>


<p>其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var head = require('./head');
</span><span class='line'>var body = require('./body');
</span><span class='line'>
</span><span class='line'>exports.create = function (name) {
</span><span class='line'>    return {
</span><span class='line'>        name: name,
</span><span class='line'>        head: head.create(),
</span><span class='line'>        body: body.create()
</span><span class='line'>    };
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require('/home/user/lib/cat/main')</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意，因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>

<h3>index.js</h3>

<p>当模块的文件件是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cat = require('/home/user/lib/cat');
</span><span class='line'>var cat = require('/home/user/lib/cat/index');</span></code></pre></td></tr></table></div></figure>


<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当做单个模块使用，更有整体感。</p>

<h3>package.json</h3>

<p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径，上例中的cat模块可以重构如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/lib/
</span><span class='line'>    - cat/
</span><span class='line'>        + doc/
</span><span class='line'>        - lib/
</span><span class='line'>            head.js
</span><span class='line'>            body.js
</span><span class='line'>            main.js
</span><span class='line'>        + tests/
</span><span class='line'>        package.json
</span><span class='line'>其中package.json内容如下。
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>    "name": "cat",
</span><span class='line'>    "main": "./lib/main.js"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如此一来，就同样可以使用require(&lsquo;/home/user/lib/cat&rsquo;)的方式加载模块。nodejs会根据包目录下的package.json找到入口模块所在位置。</p>

<h2><a name="命令行程序">命令行程序</a></h2>

<h2><a name="工程目录">工程目录</a></h2>

<h2><a name="NPM">NPM</a></h2>

<h2><a name="小结">小结</a></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodejs基础]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/21/nodejsji-chu/"/>
    <updated>2016-05-21T12:45:39+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/21/nodejsji-chu</id>
    <content type="html"><![CDATA[<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNodeJS">什么是NodeJS</a></li>
<li><a href="#%E7%94%A8%E9%80%94">用途</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>


<!--more-->


<h2><a name="什么是NodeJS">什么是NodeJS</a></h2>

<p>JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在 HTML 页面里的 JS，浏览器充当了解析器的角色。而对于需要独立运行的 JS，NodeJS 就是一个解析器。</p>

<p>每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作 DOM，浏览器就提供了 document 之类的内置对象。而运行在 NodeJS 中的 JS 的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了 fs、http 等内置对象。</p>

<h2><a name="用途">用途</a></h2>

<p>尽管存在一听说可以直接运行JS文件就觉得很酷的同学，但大多数同学在接触新东西时首先关心的有啥用户，以及能带来什么价值</p>

<p>NodeJS的作者说，他创造NodeJS的目的是为了实现提高性能web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成了天然的选择。</p>

<p>如他所愿，NodeJs在服务器端活跃起来，出现了大批基于NodeJs的web服务。而另一方面，NOdeJS让前端如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。</p>

<p>因此，对于前端而言，虽然不是人人都要拿NodeJs写一个服务器端程序，但简单使用命令交互模式调试JS片段，复杂可至编写工具提升工作效率。</p>

<p>NodeJS生态圈正欣欣向荣</p>

<h2><a name="安装">安装</a></h2>

<p>NodeJs提供了一些安装程序，都可以在nodejs.org这里下载并安装</p>

<p>在MacOs系统下，选择.pkg后缀的安装文件.</p>

<h3>编译安装</h3>

<p>Linux系统下没有现成的安装程序可用，虽然一些发行版可以使用 apt-get之类的方式安装，但不一定能安装到最新版。因此Linux系统下一班使用以下方式编译方式安装NodeJs。</p>

<ol>
<li>确保系统下 g++版本在4.6以上，python版本在2.6以上</li>
<li>从nodejs.org下载tar.gz后缀的NodeJS最新版源代码包并解压到某个位置</li>
<li>进入解压到的目录，使用以下命令编译和安装</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./configure
</span><span class='line'>
</span><span class='line'>$ make
</span><span class='line'>
</span><span class='line'>$ sudo make install</span></code></pre></td></tr></table></div></figure>


<h2><a name="运行">运行</a></h2>

<p>打开终端，键入node进入命令交互模式，可以输入一条语句后立即执行并显示效果，例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node
</span><span class='line'>&gt; console.log('Hello World!');
</span><span class='line'>Hello World!</span></code></pre></td></tr></table></div></figure>


<p>如果要运行一大段代码的话，可以先写一个JS文件再运行，例如有以下hello.js</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function hello() {
</span><span class='line'>    console.log('Hello World!');
</span><span class='line'>}
</span><span class='line'>hello();</span></code></pre></td></tr></table></div></figure>


<p>写好后，在终端键入 node hello.js运行，结果如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node hello.js
</span><span class='line'>Hello World!</span></code></pre></td></tr></table></div></figure>


<h3>权限问题</h3>

<p>在Linux系统下，使用NodeJs监听80或者443端口提供HTTP(s)服务时需要root权限，有两种方式可以做到.</p>

<p>一种方式是使用sudo命令运行NodeJs,例如通过以下命令运行的server.js中有权限使用80和443端口，一般推荐这种方式，可以保证仅为有需要的js脚本提供root权限。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo node server.js</span></code></pre></td></tr></table></div></figure>


<p>另一种方式是使用chmod + s 命令让NodeJs总是以root权限运行，具体做法如下，因为这种方式让任何JS脚本都有了root权限，不太安全，因此在需要很考虑安全下不推荐使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo chown root /usr/local/bin/node
</span><span class='line'>$ sudo chmod +s /usr/local/bin/node</span></code></pre></td></tr></table></div></figure>


<h2><a name="模块">模块</a></h2>

<p>编写稍大一点的程序时一般都会讲代码模块化，在NOdeJs中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名.</p>

<p>在编写每一个模块时，都有 <code>require</code>,<code>exports</code>,<code>module</code>三个预先定义好的变量可供使用。</p>

<h3>3 Require</h3>

<p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径(以./开头)，或者是绝对路径(以/或C:之类的盘符开头).另外，模块名中的.js扩展名可以省略。以下是一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var foo1 = require('./foo');
</span><span class='line'>var foo2 = require('./foo.js')
</span><span class='line'>var foo3 = require('/home/user/foo')
</span><span class='line'>var foo4 = require('/home/user/foo.js')</span></code></pre></td></tr></table></div></figure>


<p>//foo1至foo4中保存的是统一模块的导出对象。另外可以使用以下方式加载和使用一个JSON文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var data = require('./data.json')</span></code></pre></td></tr></table></div></figure>


<h3>exports</h3>

<p>exports对象是当前模块的导出对象，用于导出模块共有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。以下例子中导出了一个共有方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>exports.hello = function () {
</span><span class='line'>    console.log('Hello World!');
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>以上代码中，模块默认导出对象被替换为一个函数。</p>

<h3>模块初始化</h3>

<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>

<h3>主模块</h3>

<p>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。住模块负责调度祖成整个程序的其它模块完成工作，例如通过以下命令启动程序时，main.js就是主模块.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node main.js</span></code></pre></td></tr></table></div></figure>


<p>完整示例:</p>

<p>例如有以下目录:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- /home/user/hello/
</span><span class='line'>    - util/
</span><span class='line'>        counter.js
</span><span class='line'>    main.js</span></code></pre></td></tr></table></div></figure>


<p>其中counter.js内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var i = 0;
</span><span class='line'>
</span><span class='line'>function count() {
</span><span class='line'>    return ++i;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>exports.count = count;</span></code></pre></td></tr></table></div></figure>


<p>该模块内部定义了一个私有变量i,并在exports对象导出了一个共有方法count.</p>

<p>主模块main.js内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var counter1 = require('./util/counter');
</span><span class='line'>var    counter2 = require('./util/counter');
</span><span class='line'>
</span><span class='line'>console.log(counter1.count());
</span><span class='line'>console.log(counter2.count());
</span><span class='line'>console.log(counter2.count());</span></code></pre></td></tr></table></div></figure>


<p>运行该程序的结果如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ node main.js
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3</span></code></pre></td></tr></table></div></figure>


<p>可以看到，counter.js并没有因为被require了两次而初始化两次</p>

<h2><a name="小结">小结</a></h2>

<p>本章介绍了有关NodeJs的基本概念和使用方法，总结起来有以下知识点:</p>

<ul>
<li>NodeJs是一个js脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把nodejs执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令</li>
<li>终端下直接输入node命令可进入命令交互模式，很适合用来测试一些JS代码片段，比如正则表达式</li>
<li>nodejs使用CMD模块系统，主模块作为程序入口点，所有模块在执行剁成中只初始化一次。</li>
<li>除非JS模块不能满足需求，否则不要轻易使用二进制模块，否则你的用户会叫苦连天</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-构造函数]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu/"/>
    <updated>2016-05-16T15:38:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/16/swift-gou-zao-han-shu</id>
    <content type="html"><![CDATA[<p>本章包含的内容的如下:</p>

<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%9D%E5%A7%8B%E8%B5%8B%E5%80%BC">存储属性的初始赋值</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">自定义构造过程</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8">默认构造器</a></li>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%90%86">值类型的构造器代理</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">类的集成和构造过程</a></li>
<li><a href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8">可失败构造器</a></li>
<li><a href="#%E5%BF%85%E8%A6%81%E6%9E%84%E9%80%A0%E5%99%A8">必要构造器</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E6%88%96%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">通过闭包或函数设置属性的默认值</a></li>
</ul>


<!--more-->


<p>构造过程是使用类，结构体或枚举型的实例之前的准备过程。在新实例可用钳必须执行这个过程，具体操作包括设置实例中的每个存储属性的初始值和执行其他必须的设置或初始化工作</p>

<p>通过定义构造器(Initializers)来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与Objc中的构造器不同，Swift的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>

<p>类的实例也可以通过定义析构器(deinitializer)在实例释放前执行特定的清除工作。</p>

<h2><a name="存储属性的初始赋值">存储属性的初始赋值</a></h2>

<p>类和结构体在创建实例时，必须为所有的存储属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>

<p>你可以在构造器中为存储属性赋初值，也可以在定义属性时为其设置默认值。以下小节详细讨论这两个方法。</p>

<blockquote><p><em>注意</em>
当你为存储型属性设置默认值或者在构造器中为期赋值时，它们的值是被直接设置的，不会触发任何属性观察期(property observers)</p></blockquote>

<h3>构造器</h3>

<p>构造器在创建某个特定类型的新实例时被调用。它的最简单形式类似于一个不带任何参数的实例方法，以关键字init命名:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(){
</span><span class='line'>  //在此执行构造过程
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit,它拥有一个<code>double</code>类型的存储型属性 temperature:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit{
</span><span class='line'>  var temperature:Double
</span><span class='line'>  init(){
</span><span class='line'>    temparture = 32.0
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var f = Fahrenheit()
</span><span class='line'>print("The default temperature is \(f.temperature)° Fahrenheit")
</span><span class='line'>// 输出 "The default temperature is 32.0° Fahrenheit”</span></code></pre></td></tr></table></div></figure>


<p>这个结构体定义了一个不带参数的构造器init,并在里面将存储属性temperature 的值初始化为32</p>

<h3>默认初始值</h3>

<p>如前所述，你可以在构造器中为存储型属性设置初始化，同样，你也可以在属性声明时为其设置默认值</p>

<blockquote><p><em>注意</em>
如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的。只不过使用默认值让属性的初始化和声明结合的更紧密。使用默认值能让你的构造器更简洁，更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器，构造器继承等特性</p></blockquote>

<p>你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Fahrenheit{
</span><span class='line'>  var temperature = 32.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2><a name="自定义构造过程">自定义构造过程</a></h2>

<p>你可以通过输入参数可可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。</p>

<h3>构造参数</h3>

<p>自定义构造过程时，可以在定义中提供构造函数，指定所需值的类型和名字。构造参数的功能和语法跟函数的方法的参数相同。</p>

<p>下面例子中定义了一个包含摄氏温度的结构体<code>Celsius</code>.它定义了两个不同的构造器:init(fromFahrenheit:)和init(fromKelvin:),两者分别通过接受不同温标下的温度值来创建新的实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
</span><span class='line'>// boilingPointOfWater.temperatureInCelsius 是 100.0
</span><span class='line'>let freezingPointOfWater = Celsius(fromKelvin: 273.15)
</span><span class='line'>// freezingPointOfWater.temperatureInCelsius 是 0.0”</span></code></pre></td></tr></table></div></figure>


<p>第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit;第二个构造器也拥有一个构造函数，其外部名字为 fromKelvin,内部名字为 kelvin.这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性temperatureInCelsius中</p>

<h3>参数的内部名称和外部名称</h3>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要工作构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift会为构造器的每个参数自动生成一个跟内部名字相同的外部名.</p>

<p>以下例子中定义了一个结构体Color,它包含了三个常量:<code>red</code>,<code>green</code>和<code>blue</code>.这些属性可以存储在0-1之间的值，用来表示红绿蓝成分的含量</p>

<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造函数，Color也可以提供第二个狗奥奇，它只包含名为white的double类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Color {
</span><span class='line'>    let red, green, blue: Double
</span><span class='line'>    init(red: Double, green: Double, blue: Double) {
</span><span class='line'>        self.red   = red
</span><span class='line'>        self.green = green
</span><span class='line'>        self.blue  = blue
</span><span class='line'>    }
</span><span class='line'>    init(white: Double) {
</span><span class='line'>        red   = white
</span><span class='line'>        green = white
</span><span class='line'>        blue  = white
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>两种构造器都能用于创建一个新的color实例，你需要为构造器每个外部参数传入值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
</span><span class='line'>let halfGray = Color(white: 0.5)</span></code></pre></td></tr></table></div></figure>


<p>注意,如果不通过外部参数名子传值，你是没法调用这个构造器的，只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let veryGreen = Color(0.0, 1.0, 0.0)
</span><span class='line'>// 报编译时错误，需要外部名称</span></code></pre></td></tr></table></div></figure>


<h4>不带外部名的构造参数</h4>

<p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为.</p>

<p>下面是之前的Celsius例子的扩展，跟之前相比添加了一个带有double类型参数的构造器，其外部名用_代替:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Celsius {
</span><span class='line'>    var temperatureInCelsius: Double
</span><span class='line'>    init(fromFahrenheit fahrenheit: Double) {
</span><span class='line'>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
</span><span class='line'>    }
</span><span class='line'>    init(fromKelvin kelvin: Double) {
</span><span class='line'>        temperatureInCelsius = kelvin - 273.15
</span><span class='line'>    }
</span><span class='line'>    init(_ celsius: Double){
</span><span class='line'>        temperatureInCelsius = celsius
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let bodyTemperature = Celsius(37.0)
</span><span class='line'>// bodyTemperature.temperatureInCelsius 为 37.0</span></code></pre></td></tr></table></div></figure>


<p>调用Celsius(37.0)意图明确，不需要外部参数名称。以此适合使用
<code>Celsius(37.0)</code>这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。</p>

<h3>可选属性类型</h3>

<p>如果你你定制的类型包含一个逻辑上允许取值为空的存储性属性 &ndash; 无论是因为它无法再初始化时赋值，还是因为它在之后某个时间点可以赋值为空&ndash;你都需要将它定为可选类型(optional type).可选类型的属性将自动初始化为nil,表示这个属性是有意在初始化时设置为空的。</p>

<p>下面的例子中定义了类<code>SurveyQuestion</code>,它包含了一个可选字符串属性response:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    var text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        print(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
</span><span class='line'>cheeseQuestion.ask()
</span><span class='line'>// 输出 "Do you like cheese?"
</span><span class='line'>cheeseQuestion.response = "Yes, I do like cheese."</span></code></pre></td></tr></table></div></figure>


<p>迪奥哈问题的答案在回答前是无法确定的，因此我们将属性response声明为string?类型，或者说是可选字符串类型，当<code>SurveyQuestion</code>实例化时，它将自动赋值为nil,表明此字符串暂时还没有值</p>

<h3>构造过程中的属性修改</h3>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量尚需经被赋值，它将永远不可更改。</p>

<blockquote><p><em>注意:</em>
对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改</p></blockquote>

<p>你可以修改上面的SurveyQuestion实例，用常量属性替代变量属性text,表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SurveyQuestion {
</span><span class='line'>    let text: String
</span><span class='line'>    var response: String?
</span><span class='line'>    init(text: String) {
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>    func ask() {
</span><span class='line'>        print(text)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>let beetsQuestion = SurveyQuestion(text: "How about beets?")
</span><span class='line'>beetsQuestion.ask()
</span><span class='line'>// 输出 "How about beets?"
</span><span class='line'>beetsQuestion.response = "I also like beets. (But not with cheese.)"</span></code></pre></td></tr></table></div></figure>


<h2><a name="默认构造器">默认构造器</a></h2>

<p>如果结构体或类的所有属性都有默认值，同事没有自定义的构造器，那么Swift会给这些结构体或类提供一个默认的构造器(default initalilizers)。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>

<p>下面例子中创建了一个类ShoppingListItem,它封装了购物清单中的某一个物品的属性:名字，数量和购买状态</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem {
</span><span class='line'>    var name: String?
</span><span class='line'>    var quantity = 1
</span><span class='line'>    var purchased = false
</span><span class='line'>}
</span><span class='line'>var item = ShoppingListItem()</span></code></pre></td></tr></table></div></figure>


<p>由于ShoppingListItem类中所有属性都有默认值，且它没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器，上面例子中使用默认构造创造了一个ShoppingListItem类的实例，并将其赋值给变量 item</p>

<h3>结构起的逐一成员的构造器</h3>

<p>除了上面提到的默认构造器，如果结构起没有提供自定义的构造器，他们将自动获得一个逐一成员构造器，及时结构天气的存储型尚需经没有默认值。</p>

<p>逐一成员构造器是用来初始化结构体新实例成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值</p>

<p>下面例子中定义了结构体size,包含两个属性width和height。swift可以根据这两个属性的初始赋值0自动推导出他们的类型为double</p>

<p>结构体size自动获得了一个逐一成员构造器init(width:height:)。你可以用它来为size创建新的实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>let twoByTwo = Size(width: 2.0, height: 2.0)</span></code></pre></td></tr></table></div></figure>


<h2><a name="值类型的构造器代理">值类型的构造器代理</a></h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程成为构造器代理，它能减少多个构造器间的代码重用。</p>

<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>

<p>对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init</p>

<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员的构造器）。这种限制可以防止你为值类型增加了一个额外的且十分负载的构造器之后，仍然有人错误的使用自动生成的构造器</p>

<blockquote><p><em>注意</em>
如果你希望默认构造器，逐一成员构造器以及你自己的自定义的构造器都能用来创建实例，可以将自定义的构造器写到扩展中，而不是写在值类型的原始定义中。</p></blockquote>

<p>下面的例子将定义一个结构体 rect,用来代表几何矩形。这个例子需要两个辅助的结构体Size和point,它们各自为其所有的属性提供了默认值0</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Size {
</span><span class='line'>    var width = 0.0, height = 0.0
</span><span class='line'>}
</span><span class='line'>struct Point {
</span><span class='line'>    var x = 0.0, y = 0.0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以通过以下三种方式为Rect创建实例&ndash;使用被初始化为默认值的origin和Size属性来初始化；提供指定的origin和size实例来初始化；提供指定的center和size来初始化。在下面Rect结构体定义中，我们为这三种方式提供了三个自定义的构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Rect {
</span><span class='line'>    var origin = Point()
</span><span class='line'>    var size = Size()
</span><span class='line'>    
</span><span class='line'>    init(){
</span><span class='line'>    
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(origin:Point,size:Size){
</span><span class='line'>        self.origin = origin
</span><span class='line'>        self.size = size
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    init(center:Point,size:Size){
</span><span class='line'>        let originX = center.x - (size.width/2)
</span><span class='line'>        let originY = center.y - (size.height/2)
</span><span class='line'>        self.init(origin: Point(x: originX, y: originY), size: size)
</span><span class='line'>        
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第一个Rect构造器init(),在功能上跟没有自定义构造器自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号{}来表示，它没有指定任何构造过程。调用这个构造器将返回一个Rect实例，它的origin和size属性都是用定义时的默认值Point(x: 0.0, y: 0.0)和Size(width: 0.0, height: 0.0)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let basicRect = Rect()
</span><span class='line'>// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</span></code></pre></td></tr></table></div></figure>


<p>第二个Rect构造器init(origin:size:)，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单的将origin和size的参数值赋给对应的存储性属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
</span><span class='line'>    size: Size(width: 5.0, height: 5.0))
</span><span class='line'>// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</span></code></pre></td></tr></table></div></figure>


<p>第三个Rect构造器init(center:size:)稍微复杂一点。它先通过center和size的值计算出origin的坐标，然后再调用init(origin:size:)构造器来将新的origin和size值赋值到对应的属性中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
</span><span class='line'>    size: Size(width: 3.0, height: 3.0))
</span><span class='line'>// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</span></code></pre></td></tr></table></div></figure>


<p>构造器init(center:size:)可以直接将origin和size 的新值赋值到对应的属性中。然而，利用恰好提供了相关功能的现有构造器会更为方便，构造器init(center:size:)的意图也会更加清晰</p>

<h2><a name="类的集成和构造过程">类的集成和构造过程</a></h2>

<p>类里面的所有存储性属性&ndash;包括所有继承自父类的属性&ndash;都必须在构造过程中设置初始值</p>

<p>Swift为类类型提供了两种构造器来确保实例中所有存储性属性都能获得初始值，它们分别是指定构造器和便利构造器</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链上调用父类的构造器来实现父类的初始化</p>

<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>

<p>便利构造器(convenience initializers)是类中比较次要的，辅助性的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或者特定输入值的实例</p>

<p>你应当只在必要的时候为类提供便利构造器，比方或某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造郭恒更清晰明了</p>

<h3>指定构造器和便利构造器的语法</h3>

<p>类的指定构造器的写法跟值类型简单构造器一样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>convenience init(parameters) {
</span><span class='line'>    statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>类的构造器代理规则</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift采用以下三条规则来限制构造器之间的代理调用:</p>

<ul>
<li>规则1 指定构造器必须调用其直接父类的指定构造器</li>
<li>规则2 便利构造器必须调用同一类中定义的其它构造器</li>
<li>规则3 便利构造器必须最终导致一个指定构造器被调用</li>
</ul>


<p>一个更方便记忆的方式是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p>这些规则可以通过下面的图例来说明:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation01_2x.png" alt="init" /></p>

<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到 规则2和3.而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则1</p>

<blockquote><p><em>注意</em>
这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类定义如何实现。</p></blockquote>

<p>下图中展示了一种涉及四个类的更复杂的类层次结构。它演示了指定构造器是如何在类层次中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializerDelegation02_2x.png" alt="te" /></p>

<h3><a name="两段式构造过程">两段式构造过程</a></h3>

<p>Swift中类的构造过程包含两个阶段。第一个阶段，每个存储属性被引入它们的类指定一个初始值。当每个存储性属性的初始值被确定后，第二个阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储性属性。</p>

<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>

<blockquote><p><em>注意</em>
Swift的两段时构造过程跟Objective-C中的构造过程类似。最主要的区别在于阶段1，Objective-C给每一个属性赋值0或空值(比如说0或nil)。Swift的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</p></blockquote>

<p>Swift编译器将执行4种有效的安全检查，已确保两段式构造过程能不出错地完成：</p>

<p><em>安全检查1</em></p>

<p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类的构造器</p>

<p>如上所述，一个对象的内存只有在其所有存储性苏醒确定之后次啊能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>

<p><em>安全检查2</em></p>

<p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>

<p><em>安全检查3</em></p>

<p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中的其它指定构造器所覆盖</p>

<p><em>安全检查4</em></p>

<p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</p>

<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例会成为有效实例，才能访问属性和调用方法。</p>

<p>以下是两段式构造过程中基于上述安全检查的构造流程展示:</p>

<p><em>阶段1</em></p>

<ul>
<li>某个指定构造器或便利构造器被调用</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化</li>
<li>这个调用父类的构造器的过程沿着构造器链一直往上执行，知道到达构造器链的最顶层</li>
<li>当到达了构造器链的最顶部，且已确保所有势力包含的存储型属性都已经赋值，这个实例的内存被认为已经完成初始化。此时阶段1完成</li>
</ul>


<p><em>阶段2</em></p>

<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self.修改它的属性并调用实例方法等</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self</li>
</ul>


<p>下图展示了在假定的子类和父类之间的构造阶段1</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization01_2x.png" alt="1" /></p>

<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>

<p>如安全检查1所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程</p>

<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>

<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完成初始化，阶段1完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/twoPhaseInitialization02_2x.png" alt="2" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例。</p>

<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作。
最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作</p>

<h3>构造器的继承和重写</h3>

<p>跟Objc中的子类不同，Swift中的子类默认情况下不会继承父类的构造器。Swift的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>

<blockquote><p><em>注意</em></p>

<p>父类的构造器仅会在安全和适当的情况下被继承</p></blockquote>

<p>假如你希望自定义的子类中能提供一个或多个父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>

<p>当你编写与一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code>修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符。</p>

<p>正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>

<blockquote><p><em>注意</em>
当你重写了父类的指定构造器时，你总是需要写override修饰符，即使你的子类的指定构造器重写为了便利构造器</p></blockquote>

<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>

<p>在下面的例子中定义了一个叫做<code>Vehicle</code>的基类。基类中声明了一个存储型属性<code>numberOfWheels</code>,它是值为0的Int类型的存储型属性。numberOfWheel属性用于创建名为descrpiption的<code>String</code>类型的计算型属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Vehicle {
</span><span class='line'>    var numberOfWheels = 0
</span><span class='line'>    var description: String {
</span><span class='line'>        return "\(numberOfWheels) wheel(s)"
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Vehicle</code>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器，自动获得的默认构造器总会是类中的指定构造器，它可以用于创建numberOfWheels为0的Vehicle实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let vehicle = Vehicle()
</span><span class='line'>print("Vehicle: \(vehicle.description)")
</span><span class='line'>// Vehicle: 0 wheel(s)</span></code></pre></td></tr></table></div></figure>


<p>下面例子中，定义了Vehicle的子类Bicycle:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Bicycle: Vehicle {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init()
</span><span class='line'>        numberOfWheels = 2
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>子类<code>Bicycle</code>定义了一个自定义的指定构造器init(),这个指定构造器和父类的指定构造器匹配，所以<code>Bicycle</code>中的指定构造器需要带上override修饰符</p>

<p><code>Bicycle</code>的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类<code>Vechicle</code>的默认构造器，这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被<code>Vehicle</code>类初始化。在调用super.init()之后，属性<code>numberOfWheels</code>的原值被新值2替换。</p>

<p>如果你创建了<code>Bicycle</code>实例，你可以调用继承的<code>description</code>计算型属性去查看属性<code>numberOfWheels</code>是否有改变:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let bicycle = Bicycle()
</span><span class='line'>print("Bicycle: \(bicycle.description)")
</span><span class='line'>// Bicycle: 2 wheel(s)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性</p></blockquote>

<h3>构造器的自动继承</h3>

<p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>

<p>假如你为子类中引入的所有新属性都提供了默认值，以下2个规则适用：</p>

<p><em>规则1</em></p>

<p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器</p>

<p><em>规则2</em></p>

<p>如果子类提供了所有父类指定构造器的实现&ndash;无论是通过规则1继承过来的，还是提供了自定义实现&ndash;它将自动继承所有父类的便利构造器。</p>

<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用</p>

<blockquote><p><em>注意</em>
对于规则2，子类可以将父类的指定构造器实现为便利构造器</p>

<p><em>总结:</em></p>

<p>如果子类继承父类，在子类的构造器中，如果是继承的属性，则先调用<code>super.init(...)</code>方法，先让父类完成属性初始化，然后再对继承的属性赋值;</p>

<p>如果子类中独有的属性，则先完成子类属性的初始化，再调用父类的<code>super.init(...)</code>方法</p></blockquote>

<h3>指定构造器和便利构造器实践</h3>

<p>接下来的例子将在实践中展示知道你给构造器，便利构造器以及构造器的自动继承。这个例子定义了包含三个类<code>Food</code>,<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示他们的构造器是如何相互作用的。</p>

<p>类层次中的基类是Food,它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建<code>Food</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Food {
</span><span class='line'>    var name:String
</span><span class='line'>    init(name:String){
</span><span class='line'>     self.name = name
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    convenience init(){
</span><span class='line'>        self.init(name:"[Unnamed]")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下图中展示了<code>Food</code>的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample01_2x.png" alt="1" /></p>

<p>类类型没有默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let namedMeat = Food(name: "Bacon")
</span><span class='line'>// namedMeat 的名字是 "Bacon”</span></code></pre></td></tr></table></div></figure>


<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保<code>Food</code>实例的所有存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造过程。</p>

<p>Food类同样提供了一个没有参数的便利构造器init().这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理指定构造器<code>init(name: String)</code>并给参数name传值[unnamed]来实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let mysteryMeat = Food()
</span><span class='line'>// mysteryMeat 的名字是 [Unnamed]</span></code></pre></td></tr></table></div></figure>


<p>类层级中的第二类是Food的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了Int类型的属性<code>quantity</code>（以及从Food继承过来的name属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RecipeIngredient: Food {
</span><span class='line'>    var quantity:Int
</span><span class='line'>    init(name:String,quantity:Int){
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name:name)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    override convenience init(name:String){
</span><span class='line'>        self.init(name:name,quantity: 1)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下图中展示了<code>RecipeIngredient</code>类的构造器链:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample02_2x.png" alt="1" /></p>

<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来填充<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quanity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的尚需经。随后，构造器向上代理到父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足 <a href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">两段式构造过程中</a> 的安全检查1</p>

<p><code>RecipeIngredient</code>还定义了一个便利构造器 <code>init(name: String)</code>，它只通过 <code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为1，所以不需要显式指明数量即可创建出实例。</p>

<p>这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个<code>quantity</code>为1的<code>RecipeIngredient</code>实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并且为quantity参数传递1.</p>

<p>注意,<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>,因此必须在前面使用override修饰符</p>

<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>

<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器init().这个便利构造器会被<code>RecipeIngredient</code>继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是Food提供的版本。</p>

<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let oneMysteryItem = RecipeIngredient()
</span><span class='line'>let oneBacon = RecipeIngredient(name: "Bacon")
</span><span class='line'>let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)</span></code></pre></td></tr></table></div></figure>


<p>类层级中的第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>,这个类构建了购物单中出现的某一种调味料。</p>

<p>购物单中每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code>引入了布尔类型的属性<code>purchased</code>,它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>,它提供了关于<code>ShoppingListItem</code>实例的一个文字描述:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ShoppingListItem: RecipeIngredient {
</span><span class='line'>    var purchased = false
</span><span class='line'>    var description: String {
</span><span class='line'>        var output = "\(quantity) x \(name)"
</span><span class='line'>        output += purchased ? " ✔" : " ✘"
</span><span class='line'>        return output
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意:</em></p>

<blockquote><p><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p></blockquote></blockquote>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>

<p>下团展示了这三个类的构造器链:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/initializersExample03_2x.png" alt="1" /></p>

<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var breakfastList = [
</span><span class='line'>    ShoppingListItem(),
</span><span class='line'>    ShoppingListItem(name: "Bacon"),
</span><span class='line'>    ShoppingListItem(name: "Eggs", quantity: 6),
</span><span class='line'>]
</span><span class='line'>breakfastList[0].name = "Orange juice"
</span><span class='line'>breakfastList[0].purchased = true
</span><span class='line'>for item in breakfastList {
</span><span class='line'>    print(item.description)
</span><span class='line'>}
</span><span class='line'>// 1 x orange juice ✔
</span><span class='line'>// 1 x bacon ✘
</span><span class='line'>// 6 x eggs ✘</span></code></pre></td></tr></table></div></figure>


<p>如上所述，例子中通过字面量方式创建了一个数组<code>breakfastList</code>，它包含了三个
<code>ShoppingListItem</code>实例，因此数组的类型也能被自动推导为<code>[ShoppingListItem]</code>.在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从[unnamed]更改为 <code>orange juice</code>，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>

<h2><a name="可失败构造器">可失败构造器</a></h2>

<p>如果一个类，结构起或枚举类型的对象，在构造过程中有可能失败，则为其定义个可失败的构造器。这里所指的<code>失败</code>是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或者是不满足某种必要的条件等。</p>

<p>为了妥善处理这种构造过程中可能会失败的情况，你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在init关键字后面添加问号(init?).</p>

<blockquote><p><em>注意:</em></p>

<p><b > 可失败构造器的参数名和参数类型，不能为其它非可失败构造器的参数名，及其参数类型相同 </b></p></blockquote>

<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过<code>return nil</code>语句来表明可失败构造器在何种情况下应该<code>失败</code>。</p>

<blockquote><blockquote><p><strong>注意</strong></p>

<p><a >严格来说，构造器都不支持返回值。以为构造器本身的租用，只是为了确保对象能被正确构造。因此你只是用<code>return nil</code>表明可失败构造器构造失败，而不要用关键字return来表明构造成功 </a></p></blockquote></blockquote>

<p>下例中，定义了一个名为<code>Animal</code>的结构体，其中有一个名为<code>species</code>的String类型的常量属性。同时该结构体还定义了一个接受一个名为<code>species</code>的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code>属性被赋值，构造成功。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Animal {
</span><span class='line'>    let species: String
</span><span class='line'>    init?(species: String) {
</span><span class='line'>        if species.isEmpty { return nil }
</span><span class='line'>        self.species = species
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以通过该可失败的构造器来创建一个Animal的实例，并检查构造过程是否成功。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someCreature = Animal(species: "Giraffe")
</span><span class='line'>// someCreature 的类型是 Animal? 而不是 Animal
</span><span class='line'>
</span><span class='line'>if let giraffe = someCreature {
</span><span class='line'>    print("An animal was initialized with a species of \(giraffe.species)")
</span><span class='line'>}
</span><span class='line'>// 打印 "An animal was initialized with a species of Giraffe"</span></code></pre></td></tr></table></div></figure>


<p>如果你给改可失败构造器传入一个空字符串作为参数，则会导致构造失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let anonymousCreature = Animal(species: "")
</span><span class='line'>// anonymousCreature 的类型是 Animal?, 而不是 Animal
</span><span class='line'>
</span><span class='line'>if anonymousCreature == nil {
</span><span class='line'>    print("The anonymous creature could not be initialized")
</span><span class='line'>}
</span><span class='line'>// 打印 "The anonymous creature could not be initialized"</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong></p>

<p><p style="color:red;text-align:left;font-family:Arial;font-style:normal;"> 空字符串（如"&ldquo;,而不是"Giraffe"）和一个值为nil的可选类型的字符串是两个完全不同的概念。上例中的空字符串(&rdquo;&ldquo;)其实是一个幼小的，非可选类型的字符串。这里我们只所以让Animal的可失败构造器失败，只是因为对于<code>Animal</code>这个类的<code>species</code>属性来说，它更适合有一个具体的值，而不是空字符串。</p></p></blockquote>

<h3>枚举类型的可失败构造器</h3>

<p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>

<p>下例中，定义了一个名为<code>TemperatureUnit</code>的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据<code>Character</code>值找出所对应的枚举成员的可失败构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TemperatureUnit {
</span><span class='line'>    case Kelvin, Celsius, Fahrenheit
</span><span class='line'>    init?(symbol: Character) {
</span><span class='line'>        switch symbol {
</span><span class='line'>        case "K":
</span><span class='line'>            self = .Kelvin
</span><span class='line'>        case "C":
</span><span class='line'>            self = .Celsius
</span><span class='line'>        case "F":
</span><span class='line'>            self = .Fahrenheit
</span><span class='line'>        default:
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员匹配时，则构造失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let fahrenheitUnit = TemperatureUnit(symbol: "F")
</span><span class='line'>if fahrenheitUnit != nil {
</span><span class='line'>    print("This is a defined temperature unit, so initialization succeeded.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is a defined temperature unit, so initialization succeeded."
</span><span class='line'>
</span><span class='line'>let unknownUnit = TemperatureUnit(symbol: "X")
</span><span class='line'>if unknownUnit == nil {
</span><span class='line'>    print("This is not a defined temperature unit, so initialization failed.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is not a defined temperature unit, so initialization failed."</span></code></pre></td></tr></table></div></figure>


<h3>带原始值的枚举类型的可失败构造器</h3>

<p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue:)</code>，该可失败构造器有一个名为<code>rawvalue</code>的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败.</p>

<p>因此上面的<code>TemperatureUnit</code>的例子可以重写为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum TemperatureUnit: Character {
</span><span class='line'>    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let fahrenheitUnit = TemperatureUnit(rawValue: "F")
</span><span class='line'>if fahrenheitUnit != nil {
</span><span class='line'>    print("This is a defined temperature unit, so initialization succeeded.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is a defined temperature unit, so initialization succeeded."
</span><span class='line'>
</span><span class='line'>let unknownUnit = TemperatureUnit(rawValue: "X")
</span><span class='line'>if unknownUnit == nil {
</span><span class='line'>    print("This is not a defined temperature unit, so initialization failed.")
</span><span class='line'>}
</span><span class='line'>// 打印 "This is not a defined temperature unit, so initialization failed."</span></code></pre></td></tr></table></div></figure>


<h3>构造失败的传递</h3>

<p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其它可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>

<p>无论是向上代理还是横向代理，如果你代理的其它可失败构造器触发构造失败，整个构造过程将立即停止，接下来的任何构造代码不会再被执行。</p>

<blockquote><p><em>注意:</em></p>

<p><b style="font-style:normal">
可失败构造器也可以代理到其它的非可失败构造器，通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中
</b></p></blockquote>

<p>下面的例子中，定义了一个名为<code>CartItem</code>的<code>Product</code>类的子类，这个类建立了一个在线购物车中的物品的模型，它有一个名为<code>quantity</code>的常量存储型属性，并确保该属性的值至少为1:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Product {
</span><span class='line'>    let name: String
</span><span class='line'>    init?(name: String) {   
</span><span class='line'>        if name.isEmpty { return nil }
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class CartItem: Product {
</span><span class='line'>    let quantity: Int
</span><span class='line'>    init?(name: String, quantity: Int) {
</span><span class='line'>        if quantity &lt; 1 { return nil }
</span><span class='line'>        self.quantity = quantity
</span><span class='line'>        super.init(name: name)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>CartItem</code>可失败构造器首先验证接收的<code>quantity</code>值是否大于等于1.倘若<code>quantity</code>值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样滴，<code>Product</code>的可失败构造器首先检查name值，假如<code>name</code>值为空字符串，则构造器立即执行失败。</p>

<p>如果你通过传入一个非空字符串name以及一个值大于等于1的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么构造方法能够成功被执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let twoSocks = CartItem(name: "sock", quantity: 2) {
</span><span class='line'>    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
</span><span class='line'>}
</span><span class='line'>// 打印 "Item: sock, quantity: 2”</span></code></pre></td></tr></table></div></figure>


<p>倘若你以一个值为0的<code>quantity</code>来创建一个<code>CartItem</code>实例，那么将导致<code>CartItem</code>构造器失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
</span><span class='line'>    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to initialize zero shirts")
</span><span class='line'>}
</span><span class='line'>// 打印 "Unable to initialize zero shirts”</span></code></pre></td></tr></table></div></figure>


<p>同样滴，如果你尝试传入一个值为空字符串的name来创建一个<code>CartItem</code>实例，那么将导致父类<code>Product</code>的构造过程失败:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let oneUnnamed = CartItem(name: "", quantity: 1) {
</span><span class='line'>    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to initialize one unnamed product")
</span><span class='line'>}
</span><span class='line'>// 打印 "Unable to initialize one unnamed product”</span></code></pre></td></tr></table></div></figure>


<h3>重写一个可失败构造器</h3>

<p>如同其他的构造器，你可以在子类中重写父类的可失败构造器，或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>

<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包</p>

<blockquote><p><em>注意</em></p>

<p><b style="font-style:normal">
你可以用非可失败构造器重写可失败构造器，但反过来却不行
</b></p></blockquote>

<p>下例中定义了一个名为<code>Document</code>的类，name属性的值必须为一个非空字符串或nil,但不能是一个空字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Document {
</span><span class='line'>    var name: String?
</span><span class='line'>    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
</span><span class='line'>    init() {}
</span><span class='line'>    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
</span><span class='line'>    init?(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        if name.isEmpty { return nil }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面的这个例子，定义了一个<code>Document</code>类的子类<code>AutomaticallyNamedDocument</code>。这个子类重写了父类的两个指定构造器，确保了无论使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串。生成的实例中的name属性总有初始"Untitled"；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AutomaticallyNamedDocument: Document {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init()
</span><span class='line'>        self.name = "[Untitled]"
</span><span class='line'>    }
</span><span class='line'>    override init(name: String) {
</span><span class='line'>        super.init()
</span><span class='line'>        if name.isEmpty {
</span><span class='line'>            self.name = "[Untitled]"
</span><span class='line'>        } else {
</span><span class='line'>            self.name = name
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器<code>init(name:)</code>重写父类的课失败构造器(init?(name:))。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>

<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如：下面的<code>UntitledDocument</code>子类的name属性的值总是"untitled"，它在构造过程中使用了父类的可失败构造器init?(name:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UntitledDocument: Document {
</span><span class='line'>    override init() {
</span><span class='line'>        super.init(name: "[Untitled]")!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，如果在调用父类的可失败构造器init?(name:)时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误</p>

<h3>可失败构造器 init!</h3>

<p>通常来说我们通过在init关键字后添加问号的方式(init?)来定义一个可失败构造器，但你也可以通过在init后面添加感叹号的方式来定义一个可失败构造器(init!)，该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>

<p>你可以在init?中代理到init!,反之亦然。你也可以用init?重写init!,反之亦然。你还可以用init代理到init!,不过一旦init!构造失效，则会触发一个断言。</p>

<h2><a name="必要构造器">必要构造器</a></h2>

<p>在类的构造器前添加<code>required</code>修饰符表明所有该类的子类都必须实现该构造器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    required init() {
</span><span class='line'>        // 构造器的实现代码
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在子类重写父类的必要构造器时，必须在子类的构造前也添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeSubclass: SomeClass {
</span><span class='line'>    required init() {
</span><span class='line'>        // 构造器的实现代码
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p><a style="font-style:normal">
如果子类继承的构造器能满足必要构造器的要求，则无需在子类中显式提供必必要构造器的实现。
</a></p></blockquote>

<h2><a name="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</a></h2>

<p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用必要或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的必要或函数会被调用，而它们的返回值会当做默认值赋值给这个属性，</p>

<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>

<p>下面介绍了如何用闭包为属性提供默认值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    let someProperty: SomeType = {
</span><span class='line'>        // 在这个闭包中给 someProperty 创建一个默认值
</span><span class='line'>        // someValue 必须和 SomeType 类型相同
</span><span class='line'>        return someValue
</span><span class='line'>    }()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉Swift立即执行此比好。如果你忽略了这对括号，相当于将闭包本省作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal"></p>

<p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化，这意味着你不能在闭包里访问其它属性，即使这些属性都有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用任何实例方法
</a></p></blockquote>

<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Checkerboard {
</span><span class='line'>    let boardColors: [Bool] = {
</span><span class='line'>        var temporaryBoard = [Bool]()
</span><span class='line'>        var isBlack = false
</span><span class='line'>        for i in 1...8 {
</span><span class='line'>            for j in 1...8 {
</span><span class='line'>                temporaryBoard.append(isBlack)
</span><span class='line'>                isBlack = !isBlack
</span><span class='line'>            }
</span><span class='line'>            isBlack = !isBlack
</span><span class='line'>        }
</span><span class='line'>        return temporaryBoard
</span><span class='line'>    }()
</span><span class='line'>    func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
</span><span class='line'>        return boardColors[(row * 8) + column]
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>没当一个新的<code>Checkerboard</code>实例被创建时，赋值闭包会被执行，<code>boardColors</code>的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组<code>temporaryBoard</code>中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到<code>boardColors</code>中，并可以通过工具函数
<code>squareIsBlackAtRow</code>来查询:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let board = Checkerboard()
</span><span class='line'>print(board.squareIsBlackAtRow(0, column: 1))
</span><span class='line'>// 打印 "true"
</span><span class='line'>print(board.squareIsBlackAtRow(7, column: 7))
</span><span class='line'>// 打印 "false"</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/catransform3d/"/>
    <updated>2016-05-04T17:25:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/catransform3d</id>
    <content type="html"><![CDATA[<h1>图层的几个坐标系</h1>

<p>对于ios来说，坐标系的(0,0)点在左下角，就是越往下，Y值越大。越向右，X值就越大.</p>

<!--more-->


<p>一个图层的frame,它是position,bounds,anchorPoint和transform尚需经的一部分。</p>

<p>设置一个新的frame将会相应的改变图层的position和bounds,但是frame本身并没有保存。</p>

<h3>position</h3>

<p>是一个CGPoint值，它指定图层相当于它父图层的位置，该值基于父图层的坐标系</p>

<h3>bounds</h3>

<p>是一个CGRect值，指定图层的大小(bounds.size)和图层的原点(bounds.origin)，这个坐标系是基于自身的。如果改变bounds的origin,那么在该图层的子图层，左边会跟着改变。也就是说，改变自身的坐标系，本身在福图层的位置不变，但它上面的自图层位置变化</p>

<h3>anchorPoint</h3>

<p>是一个CGPoint值，它是指定了一个基于bounds的符合坐标系的位置。锚点(anchor point)制定了bounds相对于position的值，同时也作为一个变化时候的中心点。锚点使用空间坐标系取值范围是0-1之间的数。默认是0.5,也就是图标的中心点，如果是(0,0)那么图层向左上方移动。如果是(1,1)就向右下方移动。</p>

<p>看下面的两个图，就能够清晰的看出锚点变化所带来的不一样。（此图为Mac OS 坐标系，如果是iOS，那么（0，0）点在图的左上方。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-ec88270eb7d8c9a0.png" alt="1" /></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-bfe77d9ab6636ce0.png" alt="2" /></p>

<p>对于anchorPoint的解释在ios中如图:</p>

<p>下图中的红点位置就是锚点的位置，默认是(0.5,0.5)。在对图像进行变化时，都是按照这个店来进行缩放，偏移等。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-76ff5832ae84e2f6.png" alt="1" /></p>

<p>一旦修改锚点位置为:(0,0),那么图像就会变成下图.各种变换就会按照这个点来运动.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-e6bcb36d43e12c4d.png" alt="2" /></p>

<p>所以说在ios系统中，锚点的坐标系是:左上角为(0,0),右下角为(1,1)。</p>

<p>根据此图，再理解上面的定义，就直观多了。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-47294f41d81081da.png" alt="1" /></p>

<h1>图层的几何变换</h1>

<p>可以通过矩阵来改变一个图层的几何形状。</p>

<p><em>CATransform3D</em>的数据结构定义了一个同质的三维变换(4*4 CGFloat值的矩阵),用于图层的旋转，缩放，偏移和应用的透视。</p>

<p>图层的2歌属性指定了变换矩阵:transform和sublayerTransform。</p>

<h3>transform</h3>

<p>是结合anchorPoint的位置来对图层和图层上的子图层进行变化</p>

<h3>sublayerTransform</h3>

<p>是结合anchorPoint的位置来对图层的子图层进行变化，不包括本身</p>

<h3>CATransform3DIdentity</h3>

<p>是单位矩阵，该矩阵没有缩放，旋转，歪斜，透视。该矩阵应用到图层上，就是设置默认值。</p>

<h1>变换函数</h1>

<h3>CATransform3DMakeTranslation</h3>

<p>官方文档:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Returns a transform that translates by '(tx, ty, tz)'. t' = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].
</span><span class='line'>
</span><span class='line'>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)。</span></code></pre></td></tr></table></div></figure>


<p>对于CATransform3D来说，它是一个4*4的 CGFloat的矩阵。而上面的值:<code>[1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].</code>给竖起来后，就发现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1    0    0    0
</span><span class='line'>
</span><span class='line'>0    1    0    0
</span><span class='line'>
</span><span class='line'>0    0    1    0
</span><span class='line'>
</span><span class='line'>tx   ty   tz   1</span></code></pre></td></tr></table></div></figure>


<p>竖起来就很明显了。</p>

<p>CATransform3D又是一个结构，他有自己的一个公式，可以进行套用.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct CATransform3D
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>CGFloat    m11（x缩放）,    m12（y切变）,      m13（旋转）,   m14（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m21（x切变）,    m22（y缩放）,      and（）   ,   m24（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m31（旋转）  ,    m32（ ）  ,      m33（z轴缩放）   ,   m34（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;
</span><span class='line'>
</span><span class='line'>CGFloat    m41（x平移）,    m42（y平移）,      m43（z平移） ,   m44（）;
</span><span class='line'>
</span><span class='line'>};
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>根据这个公式就一目了然了。</p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)参数的意思就是 <em>tx:：x平移。  ty：y平移。  tz：z平移</em></p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tx：X轴偏移位置，往下为正数。
</span><span class='line'>
</span><span class='line'>ty：Y轴偏移位置，往右为正数。
</span><span class='line'>
</span><span class='line'>tz：Z轴偏移位置，往外为正数。</span></code></pre></td></tr></table></div></figure>


<p>举个栗子:</p>

<p>如果有两个图层，一个是绿色的，一个是红色的，先加载绿色，后加载红色</p>

<p>tx,ty的偏移就先不说了</p>

<p>如果绿色的tz为-10，红色的tz为0，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-7d642630070e7554.png" alt="1" /></p>

<p>如果绿色的tz为0,红色的tz为-10，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-29ecdd06f03578f4.png" alt="2" /></p>

<p>对于tz来说，tz越大，那么图层就越靠近屏幕，值越小，图层越往里（离屏幕越远）</p>

<h4>CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz);</h4>

<p>t:就是上一个函数，其它都一样
就可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);</h4>

<p><em>sx:</em> x轴缩放，代表一个缩放比例，一般都是0-1之间的数字
<em>sy:</em> y轴上缩放
<em>sz:</em> 整体比例变换时，也就是m11(sx) == m22(sy)时，若m33(sz) > 1时，图形整体缩小，若0&lt;1,图形整体放大，若m33(sz) &lt; 0时，发生关于原点的对称等比变换。</p>

<p>当sx = 1时，sy = 1时，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-04771b49561f6d76.png" alt="1" /></p>

<p>当sx=0.5,sy=0.5时，如图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-6023b3794fd9917d.png" alt="2" /></p>

<h4>CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz)</h4>

<p>t：就是上一个函数。其他的都一样。</p>

<p>就可以理解为：函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>旋转效果</p>

<p>angle：旋转的弧度，所以要把角度转换成弧度：角度 * M_PI / 180</p>

<p>x:向X轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>y:向Y轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>z:向Z轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>原始图像如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-1.png" alt="1" /></p>

<p>例如：向X轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-2.png" alt="1" /></p>

<p>向Y轴旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-3.png" alt="1" /></p>

<p>向z轴方向旋转60度</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-4.png" alt="test" /></p>

<p>向x轴和y轴都旋转60度，就是沿着对角线旋转</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-5.png" alt="t" /></p>

<h4>CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>t:就是上一个函数
可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DInvert (CATransform3D t);</h4>

<p>翻转效果</p>

<p>原始效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-6.png" alt="test" /></p>

<p>调用翻转后的效果:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160505-7.png" alt="result" /></p>

<h4>CGAffineTransform CATransform3DGetAffineTransform (CATransform3D t);</h4>

<p>仿射效果</p>

<p>就是把一个CATransform3D对象转化成一个CGAffineTransform对象，也就是把CATransform3D矩阵转化成CGAffineTransform矩阵</p>

<p>变换函数同时提供了可以比较一个变换矩阵是否是单位矩阵，或者两个矩阵是否相等。</p>

<h4>bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);</h4>

<p>判断两个变换的矩阵是否相等</p>

<p>也可以通过修改数据结构和键值来设置变换效果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct CATransform3D
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>CGFloat m11, m12, m13, m14；
</span><span class='line'>
</span><span class='line'>CGFloat m21, m22, m23, m24；
</span><span class='line'>
</span><span class='line'>CGFloat m31, m32, m33, m34；
</span><span class='line'>
</span><span class='line'>CGFloat m41, m42, m43, m44；
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以直接修改其中一个值，来达到相同的效果</p>

<p>或者修改键值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[myLayer setValue:[NSNumber numberWithInt:0] forKeyPath:@"transform.rotation.x"];</span></code></pre></td></tr></table></div></figure>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-43f4b4134597cd19.png" alt="e" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime运行时入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men/"/>
    <updated>2016-05-04T14:36:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men</id>
    <content type="html"><![CDATA[<h2>什么是Rumtime</h2>

<p>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target dosomething]</code>会被转化成 <code>objc_msgSend(target,@selector(doSomething));</code>.</p>

<!--more-->


<p>oc中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，实际上一个类本质上也是一个对象，在runTime中用结构体表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 描述类中的一个方法
</span><span class='line'>typedef struct objc_method *Method;
</span><span class='line'>
</span><span class='line'>/// 实例变量
</span><span class='line'>typedef struct objc_ivar *Ivar;
</span><span class='line'>
</span><span class='line'>/// 类别Category
</span><span class='line'>typedef struct objc_category *Category;
</span><span class='line'>
</span><span class='line'>/// 类中声明的属性
</span><span class='line'>typedef struct objc_property *objc_property_t;</span></code></pre></td></tr></table></div></figure>


<p>类在rumtime中的表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//类在runtime中的表示
</span><span class='line'>struct objc_class {
</span><span class='line'>    Class isa;//指针，顾名思义，表示是一个什么，
</span><span class='line'>    //实例的isa指向类对象，类对象的isa指向元类
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__
</span><span class='line'>    Class super_class;  //指向父类
</span><span class='line'>    const char *name;  //类名
</span><span class='line'>    long version;
</span><span class='line'>    long info;
</span><span class='line'>    long instance_size
</span><span class='line'>    struct objc_ivar_list *ivars //成员变量列表
</span><span class='line'>    struct objc_method_list **methodLists; //方法列表
</span><span class='line'>    struct objc_cache *cache;//缓存
</span><span class='line'>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
</span><span class='line'>    struct objc_protocol_list *protocols //协议列表
</span><span class='line'>    #endif
</span><span class='line'>} OBJC2_UNAVAILABLE;
</span><span class='line'>/* Use `Class` instead of `struct objc_class *` */</span></code></pre></td></tr></table></div></figure>


<h2>获取列表</h2>

<p>有时会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配).</p>

<p>我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表，方法列表，成员变量等)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> unsigned int count;
</span><span class='line'>    //获取属性列表
</span><span class='line'>    objc_property_t *propertyList = class_copyPropertyList([self class], &count);
</span><span class='line'>    for (unsigned int i=0; i&lt;count; i++) {
</span><span class='line'>        const char *propertyName = property_getName(propertyList[i]);
</span><span class='line'>        NSLog(@"property----&gt;%@", [NSString stringWithUTF8String:propertyName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取方法列表
</span><span class='line'>    Method *methodList = class_copyMethodList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Method method = methodList[i];
</span><span class='line'>        NSLog(@"method----&gt;%@", NSStringFromSelector(method_getName(method)));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取成员变量列表
</span><span class='line'>    Ivar *ivarList = class_copyIvarList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Ivar myIvar = ivarList[i];
</span><span class='line'>        const char *ivarName = ivar_getName(myIvar);
</span><span class='line'>        NSLog(@"Ivar----&gt;%@", [NSString stringWithUTF8String:ivarName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取协议列表
</span><span class='line'>    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Protocol *myProtocal = protocolList[i];
</span><span class='line'>        const char *protocolName = protocol_getName(myProtocal);
</span><span class='line'>        NSLog(@"protocol----&gt;%@", [NSString stringWithUTF8String:protocolName]);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><em>注意：不要忘记在类的顶部导入头文件<code>#import &lt;objc/runtime.h&gt;</code></em></p>

<h2>方法调用</h2>

<p>让我们看一下在运行时方法的调用</p>

<p>如果用实例对象调用实例方法，回到实例的isa指针指向的对象（也就是类对象）操作。如果调用的是类方法，就回到类对象的isa指针指向的对象（也就是元类对象）中操作。</p>

<ol>
<li>首先，在相应操作的对象中的缓存方法列表汇总找调用的方法，如果找到，转向相应实现并执行</li>
<li>如果没有找到，在相应操作的对象 中的方法列表中找调用的方法，如果找到，转向相应的实现执行</li>
<li>如果没有找到，去父类指针所指向的对象中执行1,2</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用</li>
<li>如果没有重写拦截调用的方法，程序报错</li>
</ol>


<h2>拦截调用</h2>

<p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。
什么是拦截调用呢</p>

<p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写 NSObject的四个方法来处理.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)resolveClassMethod:(SEL)sel;
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel;
</span><span class='line'>//后两个方法需要转发到其他的类处理
</span><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector;
</span><span class='line'>- (void)forwardInvocation:(NSInvocation *)anInvocation;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>第一个方法是当你调用一个不存在的类或者方法的时候，会调用这个方法，默认返回NO,你可以加上自己的处理然后返回YES</li>
<li>第二个方法和第一个相似，只不过处理的是实例方法</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target</li>
<li>第四个方法是将你调用的不存在的方法打包成<code>NSinvocation</code>传给你，做完你自己的处理后，调用<em>invokeWithTarget:</em>方法让某个target触发这个方法</li>
</ul>


<h2>动态添加方法</h2>

<p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢?
有一个办法就是根据传进来的<em>sel</em>类型的selector动态添加一个方法。</p>

<p>首先从外部隐式调用一个不存在的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//隐式调用方法
</span><span class='line'>[target performSelector:@selector(resolveAdd:) withObject:@"test"];</span></code></pre></td></tr></table></div></figure>


<p>然后，在target对象内部重写拦截调用的方法，动态添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void runAddMethod(id self, SEL _cmd, NSString *string){
</span><span class='line'>    NSLog(@"add C IMP ", string);
</span><span class='line'>}
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel{
</span><span class='line'>
</span><span class='line'>    //给本类动态添加一个方法
</span><span class='line'>    if ([NSStringFromSelector(sel) isEqualToString:@"resolveAdd:"]) {
</span><span class='line'>        class_addMethod(self, sel, (IMP)runAddMethod, "v@:*");
</span><span class='line'>    }
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中<code>class_addMethod</code>的四个参数分别是:</p>

<ol>
<li><em>Class cls</em>给那个类添加方法，本例中是self</li>
<li><em>SEL name</em>添加的方法，本例中是重写的拦截调用传进来selector</li>
<li><em>IMP imp</em>方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现</li>
<li><code>"v@:*"</code>方法的签名，代表有一个参数的方法，返回值是void,如果是<code>i</code>，就是返回int</li>
</ol>


<h2>关联对象</h2>

<p>现在你准备用系统的一个类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。</p>

<p>这种情况的一般解决办法就是继承。</p>

<p>但是只增加一个属性，就去继承一个类，总是觉得太麻烦</p>

<p>这个时候，runtime的关联属性就发挥它的作用了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//首先定义一个全局变量，用它的地址作为关联对象的key
</span><span class='line'>static char associatedObjectKey;
</span><span class='line'>//设置关联对象
</span><span class='line'>objc_setAssociatedObject(target, &associatedObjectKey, @"添加的字符串属性", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象
</span><span class='line'>NSString *string = objc_getAssociatedObject(target, &associatedObjectKey);
</span><span class='line'>NSLog(@"AssociatedObject = %@", string);</span></code></pre></td></tr></table></div></figure>


<p><code>objc_setAssociatedObject</code>的四个参数:</p>

<ol>
<li><em>id object</em> 给谁设置关联对象</li>
<li><code>const void *key</code>关联对象唯一的key,获取时会用到</li>
<li><em>id value</em>关联对象</li>
<li><em>objc_AssociationPolicy</em>关联策略，共有以下几种策略</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, 
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>如果你熟悉OC，看名字就能知道几种策略的意思了吧</p>

<p><code>objc_getAssociatedObject</code>用来获取关联属性，它用到了两个参数:</p>

<ol>
<li><em>id object</em>获取谁的关联对象</li>
<li><code>const void *key</code>根据这个唯一的key获取关联对象</li>
</ol>


<p>其实，你还可以吧添加和获取关联对象的方法卸载你需要用到这个功能类的类别中，方便调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加关联对象
</span><span class='line'>- (void)addAssociatedObject:(id)object{
</span><span class='line'>    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</span><span class='line'>}
</span><span class='line'>//获取关联对象
</span><span class='line'>- (id)getAssociatedObject{
</span><span class='line'>    return objc_getAssociatedObject(self, _cmd);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p>这里我们把<code>getAssociatedObject</code>方法的地址作为唯一的key,<em>_cmd</em>代表当前调用方法的地址</p></blockquote>

<h2>方法交换</h2>

<p>方法交换，顾名思义，及时将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法的代码，反之亦然。</p>

<p>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。
方式一:继承系统的类，重写方法.
方式二:使用runtime,交换方法.</p>

<p>参考网上的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "UIViewController+swizzling.h"
</span><span class='line'>#import &lt;objc/runtime.h&gt;
</span><span class='line'>
</span><span class='line'>@implementation UIViewController (swizzling)
</span><span class='line'>
</span><span class='line'>//load方法会在类第一次加载的时候被调用
</span><span class='line'>//调用的时间比较靠前，适合在这个方法里做方法交换
</span><span class='line'>+ (void)load{
</span><span class='line'>    //方法交换应该被保证，在程序中只会执行一次
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>
</span><span class='line'>        //获得viewController的生命周期方法的selector
</span><span class='line'>        SEL systemSel = @selector(viewWillAppear:);
</span><span class='line'>        //自己实现的将要被交换的方法的selector
</span><span class='line'>        SEL swizzSel = @selector(swiz_viewWillAppear:);
</span><span class='line'>        //两个方法的Method
</span><span class='line'>        Method systemMethod = class_getInstanceMethod([self class], systemSel);
</span><span class='line'>        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);
</span><span class='line'>
</span><span class='line'>        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
</span><span class='line'>        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
</span><span class='line'>        if (isAdd) {
</span><span class='line'>            //如果成功，说明类中不存在这个方法的实现
</span><span class='line'>            //将被交换方法的实现替换到这个并不存在的实现
</span><span class='line'>            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
</span><span class='line'>        }else{
</span><span class='line'>            //否则，交换两个方法的实现
</span><span class='line'>            method_exchangeImplementations(systemMethod, swizzMethod);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)swiz_viewWillAppear:(BOOL)animated{
</span><span class='line'>    //这时候调用自己，看起来像是死循环
</span><span class='line'>    //但是其实自己的实现已经被替换了
</span><span class='line'>    [self swiz_viewWillAppear:animated];
</span><span class='line'>    NSLog(@"swizzle");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在一个自己定义的视图控制器中重写<em>viewWillAppear</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewWillAppear:(BOOL)animated{
</span><span class='line'>    [super viewWillAppear:animated];
</span><span class='line'>    NSLog(@"viewWillAppear");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac上如何把视频转成.Gif]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif/"/>
    <updated>2016-04-29T12:56:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif</id>
    <content type="html"><![CDATA[<p>之前看到很多github上的开源项目都带.gif的演示效果，感觉很好，今天就试着制作了一下，今天把我的制作过程记录下来，方便他人参考。</p>

<!--more-->


<h2>录制视频</h2>

<p>mac上自带的Quicktime就可以录制视频，选择录制屏幕</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160429-0.png" alt="1" /></p>

<p>录制完之后是 .mov 的后缀视频文件</p>

<h2>通过命令行转换</h2>

<p>在苹果系统上，可以通过命令行的方式转换视频，首先假定你的机器上已经安装了<a href="http://www.brew.sh">homebrew</a>.</p>

<p>然后打开终端，安装<a href="http://baike.baidu.com/link?url=H-RabHoLq9tR0Zxn-jduRSC7NAlSBkEjjsRnXEJ7Rw9RFE6dUNBnYyXidoiXNGCyOWKdcAtQMg-J8x_hFPSg5K">ffmpeg</a>插件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install ffmpeg</span></code></pre></td></tr></table></div></figure>


<p>然后定位到正确的目录，（有视频文件的那个目录，比如 Desktop）,假定你的视频名字是<code>ScreenFlow.mov</code>,你运行下面的命令就能生成GIF:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ffmpeg -i ScreenFlow.mov -pix_fmt rgb24 output.gif</span></code></pre></td></tr></table></div></figure>


<p>你会注意到生成文件很大，可以通过<a href="http://baike.baidu.com/link?url=WENMRejdDuoS2eXPiXrnvF2ohwpbTAe5oW_SOTsr2k099YbjyU4wCi-ngV31jzxvP0TvC-INM0FBcUk1sEDWQK"> image magick</a>工具来减少大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install imagemagick</span></code></pre></td></tr></table></div></figure>


<p>运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ convert -layers Optimize output.gif output_optimized.gif</span></code></pre></td></tr></table></div></figure>


<h2>通过软件生成.GIF</h2>

<p><a href="http://gifbrewery.com">GifBrewery</a>是一款GIF动态图片制作工具. 支持将视频文件剪裁输出成GIF动态图片。</p>

<p>并且支持裁剪视频的长度，本人感觉挺好用的。</p>

<h2>上传到云端</h2>

<p>最后把制作好的.gif图片上传到云端就行了，比如 dropbox,七牛,阿里云等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewController转场动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua/"/>
    <updated>2016-04-28T15:54:40+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua</id>
    <content type="html"><![CDATA[<h2>自定义转场动画</h2>

<p>ios7中最让我激动的特性之一就是提供了新的API来支持自定义ViewController之间的转场动画。</p>

<!--more-->


<p>在开始研究新的API之间，我们先看看ios7中 navigation controller之间默认的行为发生了那些改变:在navigation controller中，切换两个view controller的动画变得更有交互性。比方说你想要pop一个view controller出去，你可以用手指从屏幕的左边缘开始拖动，慢慢地把当前的viewcontroller向右拖出屏幕去.</p>

<p>接下来，我们来看看这个新API。很有趣，这部分API大量的使用了协议而不是具体的对象。这初看起来有点奇怪，但是我更喜欢这样的设计，因为这种设计给我们这些开发者更大的灵活性。下面，让我们来做件简单的事情:在Navigation Controller中，实现一个自定义的push动画效果，为了完成这个任务，需要实现UINavigationControllerDelegate中的新方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
</span><span class='line'>                   navigationController:(UINavigationController *)navigationController
</span><span class='line'>        animationControllerForOperation:(UINavigationControllerOperation)operation
</span><span class='line'>                     fromViewController:(UIViewController*)fromVC
</span><span class='line'>                       toViewController:(UIViewController*)toVC
</span><span class='line'>{
</span><span class='line'>    if (operation == UINavigationControllerOperationPush) {
</span><span class='line'>        return self.animator;
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码可以看出，我们可以根据不同的操作(push或pop)返回不同的animator.我们可以把anmitor存到一个属性中，从而在多个操作之间实现共享，或者我们也可以为每个操作都创建一个新的animator对象，这里的灵活性很多。</p>

<p>为了让动画运行起来，我们创建一个自定义类，并且实现<code>UIViewControllerAnimatedTransitioning</code>这个协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这个协议要求我们实现两个方法，其中一个定义了动画的持续时间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    return 0.25;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另一个方法描述整个动画的执行效果 ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>    [[transitionContext containerView] addSubview:toViewController.view];
</span><span class='line'>    toViewController.view.alpha = 0;
</span><span class='line'>
</span><span class='line'>    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
</span><span class='line'>        toViewController.view.alpha = 1;
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
</span><span class='line'>
</span><span class='line'>    }];
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的例子汇总，你可以看到如何运用洗衣的：这个方法中通过接受一个类型为<code>id&lt;UIViewControllerContextTransitioning&gt;</code>的参数，来获取transition context.值的注意的是，执行完动画之后，我们需要调用transitionContext的<code>completeTransition :</code>这个方法来更新ViewController的状态。剩下的代码和ios7之前的一样了，我们从transition context 中得到了需要做转场的两个View controller,然后使用最简单的Uiview animation来实现转场动画。这就是全部代码了，我们已经实现了缩放效果的转场动画了。</p>

<p>注意，这里只是为push操作实现了自定义效果的转场动画，对于pop操作，还是会使用默认的滑动效果，另外，上面我们实现的转场动画无法交互，下面我们就来看看解决这个问题。</p>

<h2>交互式的转场动画</h2>

<p>想要动画变地交互非常简单，我们只需要覆盖另一个UINavigationControllerDelegate的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
</span><span class='line'>                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
</span><span class='line'>{
</span><span class='line'>    return self.interactionController;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，在非交互式动画效果中，该方法返回nil.</p>

<p>这里返回的interaction controller是<code>UIPercentDrivenInteractionTransition</code>类的一个实例，开发者不需要任何配置就可以工作。我们创建了一个拖动收拾(Pan REcognizer),下面是处理该手势的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
</span><span class='line'>        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
</span><span class='line'>        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
</span><span class='line'>    }
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>只有当用户从屏幕的右半部分开始触摸的时候，我们才把下一次动画效果设置为交互的（通过设置interactionController这个属性来实现），然后执行方法performSegueWithIdentifier:（如果你不是使用的storyboards,那么就直接调用pushViewController&hellip;这类方法）。为了让转场动画持续进行，我们需要调用 interaction controller的一个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
</span><span class='line'>    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
</span><span class='line'>    [interactionController updateInteractiveTransition:d];
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>该方法会根据用户手指拖动的距离计算一个百分比，切换的动画效果也随着这个百分比来走，最酷的是，interaction controller会和animation controller一起协作，我们只使用了简单的UIView animation的动画效果，但是interaction controller却控制了动画的执行进度，我们并不需要吧interaction controller和Animation controller关联起来，因为所有这些系统都以一种解耦的方式自动地替我们完成了。</p>

<p>最后,我们需要更具用户收拾的停止状态来判断该操作是结束还是取消，先调用interaction controller 中对应的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
</span><span class='line'>    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
</span><span class='line'>        [interactionController finishInteractiveTransition];
</span><span class='line'>    } else {
</span><span class='line'>        [interactionController cancelInteractiveTransition];
</span><span class='line'>    }
</span><span class='line'>    navigationControllerDelegate.interactionController = nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，当切换完成或者取消的时候，记得把interaction controller设置为nil.因为如果下一次的转场是非交互的，我们不应该返回这个旧的interaction controller。</p>

<p>现在我们已经实现了一个完全自定义的可交互的转场动画了。通过简单的手势识别和UIKIT提供的一个类，用几行代码就达到完成了。对于大部分的应用场景，你读到这就够用了，使用上面提到的方法就可以达到你想要的动画效果了。但如果你想更深入了解转场动画或者交互效果进行深度定制，请继续阅读下面的内容。</p>

<h3>完整工程下载</h3>

<p><a href="https://github.com/TLiOSDemo/CustomTransitionController/archive/master.zip">完整的代码在这里下载</a></p>

<h2>使用GPUImage定制动画</h2>

<p>下面我们就看看如何真正的，彻底的定制动画效果。这一次我们不实用UIviw animation,甚至连Core Animation也不用，完全自己来实现所有的动画效果。</p>

<p>我们使用 <a href="https://github.com/BradLarson/GPUImage">GPUImage</a>来实现一个非常漂亮的动画效果，这里我们实现的转场动画效果是：两个View controller像素化，然后相互消融在一起。实现方法是先对两个view controller进行截屏，然后再用GPUImage的图片滤镜（filter）处理这两张截图。</p>

<p>首先，我们先创建一个自定义类，这个类实现了UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning这两个协议：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface GPUImageAnimator : NSObject
</span><span class='line'>  &lt;UIViewControllerAnimatedTransitioning,
</span><span class='line'>   UIViewControllerInteractiveTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@property (nonatomic) BOOL interactive;
</span><span class='line'>@property (nonatomic) CGFloat progress;
</span><span class='line'>
</span><span class='line'>- (void)finishInteractiveTransition;
</span><span class='line'>- (void)cancelInteractiveTransition;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>为了加速动画的运行，我们可以图片一次加载到GPU中，然后所有的处理和绘图都直接在GPU上执行，不需要再传送到CPU上处理（这种数据传输很慢）。通过使用GPUImageview，我们就可以直接使用OPenGL画图。</p>

<p>创建滤镜链(Filter chain)也非常的直观，我们可以直接在样例代码的setup方法中看到如何构造它。比较有挑战的是如何让滤镜也<code>动</code>起来。GPUImage没有直接提供给我们动画效果，因此我们需要每渲染一帧就更新一下滤镜来实现动态的滤镜效果。使用<em>CADisplayLink</em>可以完成这个工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
</span><span class='line'>[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span></code></pre></td></tr></table></div></figure>


<p>在frame方法中，我们可以根据时间来更新动画进度，并相应地更新滤镜:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)frame:(CADisplayLink*)link
</span><span class='line'>{
</span><span class='line'>    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
</span><span class='line'>    self.blend.mix = self.progress;
</span><span class='line'>    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
</span><span class='line'>    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
</span><span class='line'>    [self triggerRenderOfNextFrame];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好了，基本上这样就完成了。如果你想要实现交互式的转场效果，那么在这里，就不能使用时间，而是要根据手势来更新动画进度，其它的代码基本差不多。</p>

<p>这个功能非常强大，你可以使用GPUImage中任何已有的滤镜，或者写一个自己的OpenGL来达到你想要的效果。</p>

<h2>结论</h2>

<p>本文只探讨了在navigation controller中的两个view controller之间的转场动画，但是这些做法在tab bar  controller或者任何你自己定义的view controller容器中也是通用的。另外，在ios7中，<em>UIcollectionViewController</em>也进行了扩展，现在你可以在布局之间进行自动以及交互的动画切换，背后使用的也是同样的机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义AsyncDisplayKit-Node]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node/"/>
    <updated>2016-04-26T15:13:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchy.png" alt="node" /></p>

<p>假设你已经读过<a href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/">AsyncDisplayKit入门</a>,下面我们将继续介绍AsyncDisplayKit.</p>

<!--more-->


<p>这篇教程将解释如何充分利用框架探索AsyncDisplayKit节点的层次结构，通过这样做，你将会更加熟悉AsyncDisplayKit这个有名的框架，并且会使你的app程序异常平滑，同时能够构建灵活的和可重用的ui</p>

<p>这AsyncDisplayKit中一个核心概念就是<code>node</code>,正如你所知，AsyncDisplayKit nodes 是一个线程安全的抽象于UIview之上的，（UIview不是线程安全的）,你可以学习更多AsyncDisplayKit在<a href="http://asyncdisplaykit.org/">AsyncDisplayKit’s Quick Start introduction</a></p>

<p>好消息是你已经知道了UIKit,那么你已经了解AsyncDisplayKit一些属性和方法了，因为API是很相似的。随后，你将会学到:</p>

<ul>
<li>如何去创建你自己的 AsDisplayNode</li>
<li>如何嵌套一个node到一个单个Node容器中，并且管理和重用</li>
<li>如何用一个Node层次结构支持View的层次结构，因为你自动减少在主线程绘制的机会，保持你的界面平滑和响应</li>
</ul>


<p>下面是你将要做的：你将要创建一个容器Node,并且添加两个子Node-其中一个是图片node,其中一个是文本node,你将会看到容器是如何测量他们的子Node尺寸和大小的.最后，你将会转化一个已经存在的UIview容器为一个ASDisplaytNode子类。</p>

<p>效果图如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt="node" /></p>

<h2>开始</h2>

<p>这个app,你将要创建一个卡片展示世界上一个奇观-泰姬陵</p>

<p>下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Starter.zip">开始工程</a></p>

<p>这个工程只有一个ViewController,这个工程是用 cocoaPods构建的，所以你必须安装 pods,然后创建 Podfile,引入 AsyncDisplayKit.</p>

<blockquote><p><em>注意</em>
如果你不了解 Pods,请学习<a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2">Introduction to CocoaPods Tutorial</a></p></blockquote>

<p>打开  ViewController.swift，然后注意到这个view controller只有一个常量<code>card</code>,它保存了一个泰姬陵的模型对象，你将会使用这个模型创建一个卡片的node去展示。</p>

<p>编译运行工程，你将会看到一个空的黑色屏幕
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-1-281x500.jpg" alt="logo" /></p>

<h2>创建并且显示一个容器Node</h2>

<p>现在你要开始构建你的第一个Node层次结构，它是非常相似的和创建一个UIview的层次结构</p>

<p>打开 Wonders-Bridging-Header.h，然后添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/ASDisplayNode+Subclasses.h&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>ASDisplayNode+Subclasses.h</code>是AsDisplayNode的一个内部方法，你需要在<code>ASDisplayNode</code>子类中实现这个header中定义的方法，但是你只能调用这些方法在你的 ASDisplayNode的子类中，这是和<code>UIGestureRecognizer</code>模式很相似的。</p>

<p>打开CardNode.swift，然后添加ASDisplayNode子类实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {}</span></code></pre></td></tr></table></div></figure>


<p>定义了一个新的ASDisplayNode子类，你将会把它作为一个容器去处理用户的交互</p>

<p>打开ViewController.swift,在viewDidLoad()中实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // Create, configure, and lay out container node
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  // Create container node’s view and add to view hierarchy
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码创建了一个新的卡片node,它定位在左上角并且高宽都是100.
不用担心之前的约束，你将会定位到中心在这个view controller中。</p>

<p>编译运行 ：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-2-281x500.jpg" alt="logo" /></p>

<p>太好了！你已经有了一个自定义的node在屏幕上显示，下一步是给你的子node取名为 <code>CardNode</code>,并且计算它的尺寸。在view中居中这是必须要知道的，你应该理解node布局引擎的工作原理。</p>

<h2>Node布局引擎</h2>

<p>下一步是询问Node去计算自己的尺寸通过调用<code>measure(constrainedSize:)</code>,你将会通过方法中constrainedSize参数去告诉node去计算一个尺寸去适应constrainedSize</p>

<p>通俗的说,这意味着计算大小不能大于限制大小。例如,考虑下面的图
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_measure.png" alt="logo" /></p>

<p>这个展示了一个约束的尺寸使用确定的宽度和高度，这个计算尺寸是和宽度相等的，但是比高度要小，它可能和宽度和高度都相等，或者比宽度和高度都要小，但是宽度和高度都不允许比约束的尺寸要大。</p>

<p>这个工作和UIView&rsquo;s<code>sizeThatFits(size:)</code>方法很相似。但是不同之处在于<code>measure(constrainedSize:)</code>计算它的尺寸，允许你访问缓存
node的calculatedSize属性。</p>

<p>一个例子就是当计算的高度和宽度的尺寸比约束尺寸更小的时候：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_constrained2.png" alt="lgo" /></p>

<p>这里图片的尺寸是更小比约束的尺寸，没有任何的sizing-to-fit，这里计算的尺寸比约束尺寸更小。</p>

<p>原因就是AsyncDisplayKit经常需要花费时间去计算尺寸，读取一个图片从硬盘中，可能会非常慢，通过合并尺寸到nodeApi,这个是线程安全的操作，这意味着计算尺寸可以在后台线程中运行！优雅的！它是一个有用的特性让你的UI程序平滑如黄油一般。</p>

<p>一个Node将会运行计算尺寸加入它没有存储值的话，假如这个约束尺寸提供是不同的，约束尺寸常常决定缓存的计算大小。</p>

<p>在程序中，工作如下:</p>

<ul>
<li>measure(constrainedSize:)返回一个存储你的尺寸或者进行一个计算尺寸通过调用calculateSizeThatFits(constrainedSize:)</li>
<li>你替换所有的尺寸计算通过<code>calculateSizeThatFits(constrainedSize:)</code>在你的ASDisplayNode子类中</li>
</ul>


<blockquote><p><em>注意</em>
calculateSizeThatFits(constrainedSize:)是ASDisplayNode的内部方法，你不应该在外部调用它</p></blockquote>

<h2>测量Node的大小</h2>

<p>现在是时候测量你的自己的node大小了。</p>

<p>打开CardNode.swift,然后替换这个类中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {
</span><span class='line'> 
</span><span class='line'>  override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>    return CGSize(width: constrainedSize.width * 0.2, height: constrainedSize.height * 0.2)
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>到现在为止，这个方法返回的大小是约束提供尺寸的20%.</p>

<p>打开ViewController.swift,删除viewDidLoad() 中的实现，然后实现下面的<code>createCardNode(containerRect:)</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'> 
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // 1
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'> 
</span><span class='line'>  // 2
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>func createCardNode(#containerRect: CGRect) -&gt; CardNode {
</span><span class='line'>  // 3
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  cardNode.measure(containerRect.size)
</span><span class='line'> 
</span><span class='line'>  // 4
</span><span class='line'>  let size = cardNode.calculatedSize
</span><span class='line'>  let origin = containerRect.originForCenteredRectWithSize(size)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  return cardNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>删除之前创建的代码，配置和布局代码</li>
<li>删除之前的代码，把node加入到view的层次结构中</li>
<li>createCardNode(containerRect:) 创建了一个卡片Node使用相同的背景颜色和容器node,它用作一个容器去约束卡片node的大小，所以这个卡片Node不能比containerRect’的尺寸更大</li>
<li>通过originForCenteredRectWithSize(size:) 方法设置卡片到中心位置。</li>
</ol>


<p>定位到createCardNode(containerRect:) 这个方法，替换viewDidLoad():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  let cardNode = createCardNode(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当视图加载的时候，createCardNode(containerRect:)创建一个新的CardNode,这个卡片的Node不能比主屏幕的bounds尺寸更大。</p>

<p>在这个观点中，这个ViewController的视图还没有加载出来，因此，它不是安全的对用于ViewContrller的bounds尺寸。所以你使用主屏幕的尺寸去约束卡片Node的大小。</p>

<p>运行起来，尽管达不到优雅，因为这个视图控制器横跨了整个屏幕，稍后，我们将添加适当的方法，现在，它工作还可以。</p>

<p>编译运行，你将会看到你的node在正中心了.
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>异步节点设置和布局</h2>

<p>有时它会花费人们很多时间去解析复杂的层次结构，假如这是在主线程发生，这将会阻塞主线程，假如你想取悦用户的话，你不能让用户一直等待，之前用户是不能和程序有任何交互的。</p>

<p>因为这个原因，你将会在后台线程创建设置nodes，这样你能避免阻塞主线程。</p>

<p>在createCardNode(containerRect:)和viewDidLoad():中实现addCardViewAsynchronously(containerRect:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addCardViewAsynchronously(#containerRect: CGRect) {
</span><span class='line'>  dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)) {
</span><span class='line'>    let cardNode = self.createCardNode(containerRect: containerRect)
</span><span class='line'>    dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>      self.view.addSubview(cardNode.view)
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>addCardViewAsynchronously(containerRect:)</code>创建这个<code>CardNode</code>在一个线程队列中，这是很好的，因为nodes是线程安全的！创建好之后，配置这个Node,然后异步调用主线程把Node添加到视图控制器中&ndash;毕竟，UIKit不是线程安全的！</p>

<blockquote><p><em>注意</em>
一旦你创建了Node的视图，所有访问node的节点只在主线程</p></blockquote>

<p>重新实现viewDidLoad()通过调用<code>addCardViewAsynchronously(containerRect:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将不再阻塞主线程，确保用户界面是可以随时响应的。</p>

<p>编译运行，和之前一样，不过所有的操作都是在后台线程执行的</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>约束节点大小</h2>

<p>记得之前我你会使用一个更优雅的解决方案节点不仅仅依靠屏幕尺寸的大小
?现在我来兑换我的诺言</p>

<p>打开 ViewController.swift，添加下面的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cardViewSetupStarted = false</span></code></pre></td></tr></table></div></figure>


<p>然后替换viewDidLoad()为viewWillLayoutSubviews():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>override func viewWillLayoutSubviews() {
</span><span class='line'>  super.viewWillLayoutSubviews()
</span><span class='line'>  if !cardViewSetupStarted {
</span><span class='line'>    addCardViewAsynchronously(containerRect: view.bounds)
</span><span class='line'>    cardViewSetupStarted = true
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换掉了住屏幕的尺寸，这上面的逻辑是视图控制器的尺寸去约束卡片的尺寸。</p>

<p>现在它是线程安全的,去用这个视图控制器的尺寸，当viewWillLayoutSubviews()替换调viewDidLoad()。这一次在这个声明周期中，这个视图控制器已经设置好了它的尺寸。</p>

<p>这种加载方式是很出众的，因为一个视图控制器能被设置任何尺寸,你不想依赖视图控制器去横跨整个屏幕</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/screen_size_tyranny.png" alt="log" /></p>

<p>这个视图可能会加载多次，所以viewWillLayoutSubviews()能被调用多次，你仅仅想创建这个CardNode一次，所以这就是为什么你需要一个cardViewSetupStarted标识去证明这个视图控制创建多次。</p>

<p>编译运行：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>Node层次结构</h2>

<p>现在你有一个空的Node容器在屏幕上，现在你想展示一些内容，方式的就是你添加一些子node到这个Node容器中，下面的结构图展示了简单的Node结构图</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_Nodes.png" alt="node" /></p>

<p>添加子Node看起来将会非常像你在UIview中添加子View的过程。</p>

<p>第一步你需要添加一个图片的node,但是首先你的需要了解容器Node是如何布局子Node的。</p>

<h2>子Node的布局</h2>

<p>你现在知道了如何去测量容器的尺寸和如何去计算容器尺寸去布局容器内的node视图，但是这个容器node是如何布局它们的子Node呢？</p>

<p>有以下两步:</p>

<ol>
<li>第一，你测量每个子Node的尺寸在<code>calculateSizeThatFits(constrainedSize:).</code>中，这将确保每一个子Node都缓存一个计算好的尺寸</li>
<li>在UIKIt的主线程布局中，AsyncDisplayKit将会调用<code>layout()</code>在你的自定义的ASDisplayNode子类中，<code>layout()</code>的工作就像UIview的 <code>layoutSubivews()</code>，除了这个<code>layout()</code>不会计算所有子视图的尺寸，布局()简单查询计算每个节点的大小</li>
</ol>


<p>回到UI上，这个泰姬陵卡片尺寸将会和它的图片大小一样，并且这个标题将会适合它的大小。最简单的方式就是去测量这个<code>泰姬陵图片</code>node的大小并且使用这个结果去约束文本node的尺寸，所以这个文本node将会适合图片尺寸的大小</p>

<p>接下来，你将要使用lay out去布局你的卡片子Node,让我们开始</p>

<h2>添加一个子Node</h2>

<p>打开CardNode.swift,然后添加下面的代码在CardNode</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let imageNode: ASImageNode
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>init(card: Card) {
</span><span class='line'>  imageNode = ASImageNode()
</span><span class='line'>  super.init()
</span><span class='line'>  setUpSubnodesWithCard(card)
</span><span class='line'>  buildSubnodeHierarchy()
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>func setUpSubnodesWithCard(card: Card) {
</span><span class='line'>  // Set up image node
</span><span class='line'>  imageNode.image = card.image
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 4
</span><span class='line'>func buildSubnodeHierarchy() {
</span><span class='line'>  addSubnode(imageNode)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>图片Node属性:这行代码添加一个图片Node的属性，去引用卡片图像的子Node</li>
<li>初始化:这个设计的初始化使用一个卡片模型保存卡片的图像和文本</li>
<li>设置子Node:这个方法使用卡片模型的图像去保存开始项目中的子Node图片</li>
<li>容器层次结构:你设置Node的层次结构就像你能设置视图的层次结构一样，这个方法创建卡片的层次结构通过添加一个子Node来实现。</li>
</ol>


<p>下一步，实现calculateSizeThatFits(constrainedSize:):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>  // 1 
</span><span class='line'>  imageNode.measure(constrainedSize)
</span><span class='line'> 
</span><span class='line'>  // 2 
</span><span class='line'>  let cardSize = imageNode.calculatedSize
</span><span class='line'> 
</span><span class='line'>  // 3 
</span><span class='line'>  return cardSize
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>这个卡片的尺寸就会匹配背景图片的大小，这个测量背景图片的尺寸会适合内嵌的约束尺寸，所有Node的子类都会被AsyncDisplay框架感知并且知道如何设置它们的尺寸，包括AsImageNode</li>
<li>这行代码临时存储图片计算的尺寸，特别说明的是，它使用图片Node测量尺寸正如卡片Node尺寸去约束子NOde，当添加更多的子Node的时候，你将会使用这个值</li>
<li>返回这个卡片Node的计算好的尺寸</li>
</ol>


<p>下一步，覆盖layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layout() {
</span><span class='line'>  imageNode.frame =
</span><span class='line'>    CGRect(origin: CGPointZero, size: imageNode.calculatedSize).integerRect
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个图片的逻辑位置在左上角，坐标轴原点，它也确保了这个图片Node的frame没有任何多余的值，所以你能避免像素边界显示问题</p>

<p>注意这个方法是如何使用图片的Node去缓存计算尺寸的在布局的过程中。</p>

<p>因为这个图片Node的尺寸决定了卡片Node的尺寸，这个图片将会横跨这个卡片</p>

<p>回到ViewController.swift，然后添加一个createCardNode(containerRect:), 替换到之前初始化的<code>CardNode</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cardNode = CardNode(card: card)</span></code></pre></td></tr></table></div></figure>


<p>这行代码使用新的初始化去添加一个卡片Node,这个卡片值将会在初始化的时候被传入，并且存储这个泰姬陵的卡片模型</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-6-281x500.jpg" alt="t" /></p>

<p>漂亮，你成功的创建了容器Node并且呈现了Node的层次结构，当然，这个很简单，但是它是一个完成的Node层次！</p>

<h2>添加更多的子Node</h2>

<p>也许你已经注意到了，没有添加标题，不用担心，让我们开始添加吧。</p>

<p>打开CardNode.swift，然后添加下面的属性titleTextNode在类中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode: ASTextNode</span></code></pre></td></tr></table></div></figure>


<p>在<code>init(card:)</code>方法中初始化<code>titleTextNode</code>，在super.init()这行代码之前:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode = ASTextNode()</span></code></pre></td></tr></table></div></figure>


<p>添加下面的这行代码在<code>setUpSubnodesWithCard(card:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(card.name)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码给titleTextNode设置了富文本内容，<code>attributedStringForTitleText(text:)</code>是一个帮助方法被加到了NSAttributedString扩展属性中。在之前的开始工程中，它创建了富文本使用提供的标题。</p>

<p>下一步，在<code>buildSubnodeHierarchy():</code>的结尾增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>要确保它是在添加到图片Node的后面，不然图片将会遮盖住标题。</p>

<p>在内置的方法<code>calculateSizeThatFits(constrainedSize:)</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.measure(cardSize)</span></code></pre></td></tr></table></div></figure>


<p>使用子Node的测量尺寸来作为卡片的约束尺寸</p>

<p>添加如下的布局代码layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame =
</span><span class='line'>  FrameCalculator.titleFrameForSize(titleTextNode.calculatedSize, containerFrame: imageNode.frame)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码计算标题Node的frame通过工具方法FrameCalculator</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-281x500.jpg" alt="test" /></p>

<p>至此，你已经构建了完整的子Node层次结构，使用了容器Node,并且添加了两个子Node</p>

<h2>完整工程</h2>

<p><a href="https://github.com/TLSwiftDemo/Wonders/archive/master.zip">完整工程在这里下载</a></p>

<p>have fun 😀~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ColletionView布局]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju/"/>
    <updated>2016-04-24T21:05:32+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju</id>
    <content type="html"><![CDATA[<p>UICollectionView在ios6中第一次被引入，也是UIKit <a href="http://oleb.net/blog/2012/09/uicollectionview/">视图类中的一颗新星</a>
。它和UITableview共享一套API设计，但也在UItableView上做了一些扩展。UICOllectionView最强大，同时显著超出UITableView的特色就是其完全灵活的布局结构。这这篇文章中，<!--more--> 我们将会实现一个相当复杂的自定义Collection view布局，并且顺便讨论一下这个类设计的重要部分，项目的实例代码在 <a href="https://github.com/objcio/issue-3-collection-view-layouts">GitHub</a>上。</p>

<h2>布局对象(Layout Objects)</h2>

<p>UITableView和UICollectionView都是 data-source和delegate驱动的。他们在显示其子视图集的过程中仅扮演容器角色,且对子视图集真正的内容毫不知情。</p>

<p>UICollectioNView在此之上进行了进一步抽象。它将子视图的位置，大小和外观的控制权拖过给一个单独的布局对象。通过提供一个自定义布局对象，你技术可以实现任何你能想象到的布局。布局继承自UICollectionVieLayout抽象基类.IOS6中以UICollectionViewFloyLayout类的形式提出了一个具体的布局实现。</p>

<p>我们可以使用flow layout实现一个标准的gridview,这可能是colle tion view中最常见的使用案例了。尽管大多数人都这么想，但是Apple很聪明，没有明确的命名这个类为UIColletionViewGridLayout,而使用了更为通用的术语 flow layout,更好的描述了该类的功能：它通过一个接一个的放置cell来建立自己的布局，当需要的时候，插入横排或竖排的分栏符。通过自定义滚动方向，大小和cell之间的间距，flow layout 也可以在单行或单列中布局cell。实际上，UITableView的布局可以想象成flow layout的一种特殊情况。</p>

<p>在你准备自己写一个UICollectionViewLayout的子类之前，你需要问你自己，你是否能够使用UICollectionViewFlowlayout实现你心里的布局。这个类是<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout">很容易定制的</a>,并且可以继承本身进行进一步的定制，感兴趣的看<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4">这篇文章</a></p>

<h2>Cells和其他Views</h2>

<p>为了适应任意布局,collection view简历了一个类似，但比 table view更灵活的视图层级，像往常一样，你的主要内容显示在cell中，cell可以被任意分组到section中。CollectionView的cell必须是UICollectionViewCell的子类。除了cell，collection view额外管理着两种视图:supplementary views和decoration views.</p>

<p>collection view中的Supplemnetary views相当于table view的section header和footer views.像cells一样，他们的内容都有数据源对象驱动，然而和tableview 中用法不一样，supplementary view并不一定会作为header或footer view;他们的数量和位置完全由布局控制.</p>

<p>Decoration views纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从dataSource 获取的contents.当布局对象指定需要一个decoration view的时候，collection view会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views和decoration views必须是UICollectionReusableView的子类。布局使用的每个视图类都需要在collection view中注册，这样当data Source让它们从reuse pool中出列时，它们才能够创建新的实例。如果你是使用的interface Builder，则可以通过在可视化编辑器中拖拽一个cell到collection view上完成cell在collection view中的注册。同样的方法也可以用在supplementary view上，前提是你使用了UIcollectionviewFlowLayout.如果没有，你只能通过调用 <code>registerClass:</code>或者<code>registerNib:</code>方法手动注册视图类了。你需要在<code>viewDidload</code>中做这些操作.</p>

<h2>自定义布局</h2>

<p>作为一个非常有意义的自定义collection view布局的例子，我们不妨想一个典型的日历应用程序中的周视图。日历一次显示一周，星期中的每一天现在列中，每一个日历事件将会在我们的colleectio view中以一个cell显示，位置和大小代表事件起始日期事件和持续时间。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/calendar-collection-view-layout.png" alt="test" />
一般有两种类型的 collection view布局:</p>

<ol>
<li>独立于内容的布局计算.这正是你所知道的像UITableview和UIcollectionViewFlowLayout这些情况。每个cell的位置和外观不是基于其显示的内容，但所有cell的显示顺序是基于内容的顺序。可以把默认的flow layout作为例子。每个cell都是基于前一个cell的放置(或者如果没有足够的空间，则从下一行开始).布局对象不必访问实际数据来计算布局.</li>
<li>基于内容的布局计算。我们的日历视图正式这样类型的例子。为了计算显示事件的气势和街二叔事件，布局对象需要直接访问 collection view的数据源。在很多情况下，布局对象不仅需要取出当前可见cell的数据，还需要从所有记录中取出一些决定当前那些cell可见的数据。</li>
</ol>


<p>在我们的日历示例中，布局对象如果访问某一个矩形内的cells的属性，那就必须迭代数据源提供的所有事件来决定那些位于要求的时间窗口个中。与一些相对简单，数据源独立计算的flow layout比起来，这足够计算出cell在一个矩形内的index paths了（假设网格中所有的cells的大小都一样）.</p>

<p>如果有一个依赖内容的布局，那就是暗示你需要些自定义的布局类了，同时不能使用自定义的UICOllectionViewFlowLayout，所以这正是我们需要做的事情。</p>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html">UICollectionViewLayout文档</a>列出了子类需要重写的方法.</p>

<h2>collectionViewContentSize</h2>

<p>由于 collection view对它的content并不知情，所以布局首先要提供的信息就是滚动区域的大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。注意，尽管大多数经典的collection view限制在一个轴方向上滚动(正如UIcollectionviewFlowLayout一样)，但是这不是必须的。</p>

<p>在我们的日历示例中，我们想要视图垂直的滚动。比如，如果我们想要在垂直空间上一个小时占去100点，这样显示一整天的内容高度就是2400点。注意，我们不能够水平滚动，这就意味这我们collectionview只能显示一周。为了能够在日历中的多个星期间分页，我们可以在一个独立的scroll view中（可以使用U<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html">IPageViewController</a>）中使用多个 collection view（一周一个）,或者坚持使用一个collection view并且返回足够大的内容宽度，这回使得用户感觉在两个方向上滑动自由。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (CGSize)collectionViewContentSize
</span><span class='line'>{
</span><span class='line'>    // Don't scroll horizontally
</span><span class='line'>    CGFloat contentWidth = self.collectionView.bounds.size.width;
</span><span class='line'>
</span><span class='line'>    // Scroll vertically to display a full day
</span><span class='line'>    CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay);
</span><span class='line'>
</span><span class='line'>    CGSize contentSize = CGSizeMake(contentWidth, contentHeight);
</span><span class='line'>    return contentSize;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了简单起见，我选择布局在一个非常简单的模型上：假定每周天数相同，每天时长相同，也就是说天数用0-6表示。在一个真实的日历程序中，布局将会为自己的几段大量使用基于 <code>NSCalendaar</code>的日期</p>

<h2>layoutAttributesForElementsInRect：</h2>

<p>这是任何布局类中最重要的方法了，同时可能也是最容易让人迷惑的方法。collection view调用这个方法并传递一个自身坐标系统中的矩形过去。这个矩形代表了这个视图的可见矩形区域(也即是它的bounds)，你需要准备好处理传给你的任何矩形。</p>

<p>你的视线必须返回一个包含 UICollectionviewLayoutAttributes对象的数组，为每一个cell包含一个这样的对象，supplementary View或decoration view在矩形区域内是可见的。UICollectionViewLayoutAttributes类包含了colletion view内item的所有相关的布局属性。默认情况下，这个类包含 frame,center,size,transform3D,alpha,Zindex和hidden属性。如果你的布局想要控制其他视图的属性(比如背景颜色)，你可以创建一个UICollectionViewLayoutAttributes的子类，然后加上你自己的属性。</p>

<p>布局属性对象(Layout attributes objects)通过indexPath属性和他们对应的cell,supplementary view或者decoration view关联在一起。collection view为所有items从布局对象中请求到布局属性后，它将会实例化所有视图，并将对应的属性应用到每个视图上去。</p>

<p>注意!这个方法涉及到所有类型的视图，也就是cell,supplementary views和decoration views.一个幼稚的实现可能会选择忽略传入的矩形，并且为collection view中所有的视图返回布局属性。在原型设计和开发布局阶段，这是一个有效的方法。但是，这将会性能产生非常坏的影响，特别是可见cell远少于所有cell数量的时候，collection view和布局对象将会为那些不可见的而试图做额外不必要的工作。</p>

<p>你的视线需要做这几步:</p>

<ol>
<li>创建一个空的可变数组来存放所有的布局属性</li>
<li>确定index paths中那些cells的frame完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你视线的<code>layoutattributesForItemIndexPath:</code>方法为每个index path创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</li>
<li>如果你的布局包含supplementary views,计算矩形内可见supplementary view的index paths.在循环中调用你实现的<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>,并且将这些对象加到数组中。通过为kind参数传递你选择的不同字符，你可以却分出不同种类的supplementary views(比如headers和footers)。当需要创建视图时，collectionview会将kind字符传回到你的数据源。记住supplermentary 和decoration views的数量和种类完全有布局控制。你不会受到headers和footers的限制.</li>
<li>如果布局包含decoration views，计算矩形内可见decoration views的index paths.在循环中调用你实现的<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>
，并且将这些对象加到数组中</li>
<li>返回数组</li>
</ol>


<p>我们自定义的布局没有使用 decoration views,但是使用了两种supplermentary views(column headers和row headers):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    NSMutableArray *layoutAttributes = [NSMutableArray array];
</span><span class='line'>    // Cells
</span><span class='line'>    // We call a custom helper method -indexPathsOfItemsInRect: here
</span><span class='line'>    // which computes the index paths of the cells that should be included
</span><span class='line'>    // in rect.
</span><span class='line'>    NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in visibleIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForItemAtIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Supplementary views
</span><span class='line'>    NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"DayHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"HourHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>    return layoutAttributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>layoutAttributesFor…IndexPath</h2>

<p>有时，collection view会为某个特殊的cell,supplementary 或者decoration view向布局对象请求布局属性，而非所有可见的对象。这就是当其他三个方法开始起作用时，你实现的<code>layoutAttributesForItemAtIndexPath:</code>需要创建并返回一个单独的布局属性对象，这样才能正确的格式化传给你的index path 所对应的cell.</p>

<p>你可以通过调用<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，然后根据index path修改属性。为了得到需要显示在这个index path内的数据，你可能需要访问collection view的数据源。到目前为止，至少确保设置了frame尚需经，除非你所有的cell都位于彼此上方。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>    CalendarDataSource *dataSource = self.collectionView.dataSource;
</span><span class='line'>    id event = [dataSource eventAtIndexPath:indexPath];
</span><span class='line'>    UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>    [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>    attributes.frame = [self frameForEvent:event];
</span><span class='line'>    return attributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你正在使用自动布局，你可能会赶到惊讶，我们正在直接修改布局参数的frame属性，而不是和约束共事，但这正是UIcollectionViewLayout的工作。尽管你坑你使用自动布局来定义collection view的frame和它内部每个cel的布局，但cells的frames还是需要通过老式的方法计算出来。</p>

<p>类似的，<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>和<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>方法分别需要为supplementary 和decoration views做相同的事。只有你的布局包含这样的视图你才需要实现这两个方法。UICollectionViewlayoutAttributes包含另外两个工厂方法，</p>

<p><code>+layoutAttributesForSupplementaryViewOfKind:withIndexPath:</code> 和 <code>+layoutAttributesForDecorationViewOfKind:withIndexPath:</code>，用他们来创建正确的布局属性对象</p>

<h2>shouldInvalidateLayoutForBoundsChange:</h2>

<p>最后，当collection view的bounds改变时，布局需要告诉collection view是否需要重新计算布局。我的猜想是：当collectionview改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个优质的实现可能只会简单的返回YES。芮然实现功能很重要，但是scrollview的bounds在滚动时也会改变，这意味着你的布局美妙会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。</p>

<p>当collection view的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view将它的bounds传给<code>shouldInvalidateLayoutForBoundsChange:</code>方法，这样我们便能比较视图当前的bounds和新的bounds来确定返回值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
</span><span class='line'>{
</span><span class='line'>    CGRect oldBounds = self.collectionView.bounds;
</span><span class='line'>    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>        return NO;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>动画</h2>

<h3>插入和删除</h3>

<p>UITableview中的cell自带了一套非常漂亮的插入和删除的动画。但是当为UIcollectionView增加和删除cell定义动画功能时，UIKit工程师们遇到这样一个问题：如果Collection view的布局是完全可变的，那么预先定义好的动画就没办法和开发者自定义的布局很好的融合。他们提出了一个优雅的方法：当一个cell(或者supplementary 或者 decoration View)被插入到collection view中时，collection View不仅向其布局请求cell正常正常状态下的布局尚需经，同时还请求其初始的布局尚需经，比如，需要在开始有插入动画的cell。CollectionView会简单的创建一个anmiation block,并在这个block中，将所有cell的属性从初始状态改变到常态</p>

<p>通过提供不同的初始布局属性，你可以完全自定义插入动画。比如设置初始的alpha为0将会产生一个淡入的动画。同时设置一个平移或者缩放将会产生移动缩放的效果。</p>

<p>同样的原理应用到删除上，这次动画是从常态到一些列你设置的最终布局属性。这些逗你需要在布局类中为initial或final布局参数实现的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>initialLayoutAttributesForAppearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:</span></code></pre></td></tr></table></div></figure>


<h2>布局间切换</h2>

<p>可以通过类似的方式将一个collection view布局动态的切换到另外一个布局。当发送一个<code>setCollectionViewLayout:animated:</code>消息时，collection view会为cells在新的布局中查询新的布局参数，然后动态的将每个cell从旧参数变换到新的布局参数。你不需要做任何事情。</p>

<h2>结论</h2>

<p>根据自定义collection view布局的复杂性，写一个通常很不容易。确切的说，本质上这和从头写一个完整的实现相同布局自定义视图类一样困难了。因为所涉及的计算需要确定去那些子视图是当前可见的，以及他们的位置。尽管如此，使用UIcollectionview还是给你带来了一些很好的效果，比如cell重用，自动支持动画，更不要提整洁的独立布局，子视图管理。</p>

<p>自定义collection view布局也是向<a href="http://objccn.io/issue-1-1/">轻量级view Controller</a>迈出了很好的异步，正如你的view controller不要包含任何布局代码。应该和一二个独立的dataSource类结合在一起，collection view的视图控制器将很难再包含任何代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OHHTTPStubs介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao/"/>
    <updated>2016-04-22T17:18:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>是一个模拟网络请求的一个框架，它使用起来非常方便和强大，它能帮你</p>

<ol>
<li>测试你的app仿真一个服务器（比如加载一个本地文件）,模拟网络慢的情况等</li>
<li>使用伪造的网络数据编写单元测试</li>
</ol>


<!--more-->


<h2>简单用法</h2>

<h2>在Objc中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>  return [request.URL.host isEqualToString:@"mywebservice.com"];
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h2>在swift中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stub(isHost("mywebservice.com")) { _ in
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  let stubPath = OHPathForFile("wsresponse.json", self.dynamicType)
</span><span class='line'>  return fixture(stubPath!, headers: ["Content-Type":"application/json"])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>语法讲解</h2>

<p><code>OHHTTPStubs stubRequestsPassingTest:</code>方法创建了模拟服务器，<code>request</code>是请求的标准判断，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[request.URL.host isEqualToString:@"mywebservice.com"]</span></code></pre></td></tr></table></div></figure>


<p>意思就是如果请求的url是<code>mywebservice.com</code>，我们就返回response,要不然不执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];</span></code></pre></td></tr></table></div></figure>


<p>返回一个respoinse,其中包含了返回的数据，</p>

<ol>
<li>获取的一个本地文件</li>
<li>返回的状态码 200  (200表示正确返回)</li>
<li>headers：返回的头,如果是json一般是:@{@&ldquo;Content-Type&rdquo;:@&ldquo;application/json&rdquo;}</li>
</ol>


<h1>快速开始一个Demo</h1>

<h2>创建一个空工程</h2>

<p>用xcode创建一个工程，用pods创建一个Podfile</p>

<p>内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'OHHTTPStubs', '~&gt; 5.0.0'
</span><span class='line'>
</span><span class='line'>target :OHHTTPStubsDemoTests, :exclusive =&gt; true do
</span><span class='line'>    link_with 'OHHTTPStubsDemoTests'
</span><span class='line'>    
</span><span class='line'>    pod 'OHHTTPStubs'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>执行 <code>pod install</code></p>

<p>成功安装OHHTTPStubs后，在OHHTTPStubsDemoTests目录中编写测试类:</p>

<h3>创建session</h3>

<p>在顶部声明一个变量session</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (nonatomic,strong) NSURLSession *session;</span></code></pre></td></tr></table></div></figure>


<p>在setUp方法中，创建该变量实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.session=[NSURLSession sharedSession];</span></code></pre></td></tr></table></div></figure>


<p>在 testExample()方法中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  返回自定义的普通文本
</span><span class='line'> */
</span><span class='line'>- (void)testExample {
</span><span class='line'>    
</span><span class='line'>    //开始模拟服务器
</span><span class='line'>    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //发送请求的url后缀必须是.com结尾的
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"com"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //创建一个字符串
</span><span class='line'>        NSData * stubData = [@"hello world" dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>        //响应数据
</span><span class='line'>        /**
</span><span class='line'>         *  responseWithData:返回的数据
</span><span class='line'>            statusCode:状态码,200表示成功
</span><span class='line'>            headers:http的header
</span><span class='line'>         */
</span><span class='line'>        return [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:@{@"Content-Type":@"text/plain"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //在XCT测试框架中，这个表示期望值，因为这个期望值是支持异步测试的，我们是异步请求，所以一定要是使用XCTestExpectation这个特性
</span><span class='line'>     XCTestExpectation *expectation=[self expectationWithDescription:@"sessionDataTask expectation"];
</span><span class='line'>    
</span><span class='line'>    //创建session任务
</span><span class='line'>    NSURLSessionDataTask *dataTask=[self.session dataTaskWithURL:[NSURL URLWithString:@"hello.com"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        //解析返回的字符串
</span><span class='line'>        NSString *resultStr=[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的数据:%@",resultStr);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(resultStr!=nil);
</span><span class='line'>        
</span><span class='line'>        //断言返回的字符串是hello world,如果不是，则断言失败
</span><span class='line'>        XCTAssertTrue([resultStr isEqualToString:@"hello world"]);
</span><span class='line'>        
</span><span class='line'>        //在想异步测试的地方加上下面这行代码
</span><span class='line'>        [expectation fulfill];
</span><span class='line'>    }];
</span><span class='line'>    //启动任务
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //使用XCTestExpectation,必须设置如下的waitForExpectationsWithTimeout方法，如果超时则失败
</span><span class='line'>    [self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%s",__FUNCTION__);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>   
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里面使用到了 <code>XCTestExpectation</code>，这是特性是用来测试异步程序代码的。在想测试异步代码的地方加上<code>[expectation fulfill];</code>,
最后，要加上<code>waitForExpectationsWithTimeout</code>方法，它们是配对出现的。</p>

<p>OHHTTPStubs创建了模拟服务器后，下面发的任何网络请求都会被模拟服务器返回，正如上面的代码所示，测试结果:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-3.png" alt="test" />
断言成功！</p>

<h2>添加本地文件</h2>

<ol>
<li>在本地创建一个stub.txt的文本文件，内容自定</li>
<li>在本地创建一个stub.jpg的图片，图片自定</li>
</ol>


<p>图片
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-5.png" alt="1" /></p>

<p>文本
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-4.png" alt="2" /></p>

<h3>创建文本的TextStub</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建文本的TextStub
</span><span class='line'> */
</span><span class='line'>-(void)createTextStub{
</span><span class='line'>    // #1
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; textStub = nil;
</span><span class='line'>    
</span><span class='line'>    // #2
</span><span class='line'>    textStub= [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"txt"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        
</span><span class='line'>        NSString *path = OHPathForFile(@"stub.txt",self.class);
</span><span class='line'>        
</span><span class='line'>       //#3
</span><span class='line'>        return [[OHHTTPStubsResponse responseWithFileAtPath:path
</span><span class='line'>                                                 statusCode:200 headers:@{@"Content-Type":@"text/plain"}]
</span><span class='line'>                requestTime:1.0f
</span><span class='line'>                responseTime:OHHTTPStubsDownloadSpeedWifi];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    //#4
</span><span class='line'>    textStub.name = @"text stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面代码意义如下:</p>

<ol>
<li>声明一个返回的OHHTTPStubsDescriptor,这是创建模拟服务器的返回结果描述</li>
<li>开始创建模拟服务器</li>
<li>返回response，其中设置了返回数据，状态码，请求时间等</li>
<li>给textStub起个名字</li>
</ol>


<h2>测试文本的模拟服务器</h2>

<p>创建一个testStubTextTask方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试文本的Stub任务
</span><span class='line'> */
</span><span class='line'>-(void)testStubTextTask{
</span><span class='line'>    //创建文本的模拟服务器
</span><span class='line'>    [self createTextStub];
</span><span class='line'>    //创建一个期望值
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"high expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSession *session=[NSURLSession sharedSession];
</span><span class='line'>    
</span><span class='line'>    NSString *urlString=@"stub.txt";
</span><span class='line'>    NSURLSessionDataTask *dataTask = [session dataTaskWithURL:[NSURL URLWithString:urlString] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        NSString* receivedText = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
</span><span class='line'>        NSLog(@"返回的结果:%@",receivedText);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(receivedText!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:5 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>创建图片的stub</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建Image的stub
</span><span class='line'> */
</span><span class='line'>-(void)createImageStub{
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; imageStub = nil;
</span><span class='line'>    
</span><span class='line'>    imageStub=[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"png"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFile(@"stub.jpg", self.class) statusCode:200 headers:@{@"Content-Type":@"image/jpeg"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    imageStub.name=@"Image stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>测试Image的模拟服务器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试Image的模拟服务器
</span><span class='line'> */
</span><span class='line'>- (void)testImageStubTask{
</span><span class='line'>    
</span><span class='line'>    [self createImageStub];
</span><span class='line'>    
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"Image Expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSessionDataTask *dataStask=[self.session dataTaskWithURL:[NSURL URLWithString:@"test.png" relativeToURL:nil] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        UIImage *image=[UIImage imageWithData:data];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的image:%@",image.description);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(image!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataStask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:3 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>完整工程</h2>

<p><a href="https://github.com/TLOpenSpring/OHHTTPStubsDemo/archive/master.zip">完整工程在这里下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode更新后插件失效的解决方案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an/"/>
    <updated>2016-04-22T16:17:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<p>Xcode的插件对于开发者来说无疑是一把利器，让开发者能够将更多的时间和精力放在代码上面。但是开发者都会遇到一个问题，就是每次Xcode更新到最新的版本，之前的插件全部都失效了，需要重新安装一遍很是麻烦。</p>

<!--more-->


<p>插件失效的原因:</p>

<blockquote><blockquote><ul>
<li>系统安装了一个Xcode</li>
<li>开发者未正确的将自己的DVTPlugInCompatibilityUUID添加到插件中</li>
<li>成功安装了插件，但是却在Xcode识别插件的时候，选了 Skip Bundle</li>
</ul>
</blockquote></blockquote>

<h2>终端指令实现</h2>

<p>//获取DVTPlugInCompatibilityUUID字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID
</span></code></pre></td></tr></table></div></figure>


<h2>找到插件的目录</h2>

<ol>
<li>打开xcode插件所在的目录:<code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>,打开路径的快捷键是shift＋command＋g 然后输入上面的地址</li>
<li>选择已经安装的插件，例如:VVDocumenter-Xcode，右键显示包内容</li>
<li>找到info.plist文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item,value的值为之前的Xcode的UUID,(或者直接在item0中value修改也可以)保存</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-1.png" alt="step2" /></p>

<h2>重启xcode</h2>

<p>重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-0.png" alt="step1" /></p>

<h2>效果如下</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-2.png" alt="s" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试并发程序]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu/"/>
    <updated>2016-04-21T17:38:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试时一个很重要的工具。在过去，当并发不是应用程序架构中重要组成部分的时候，测试就想单简单。随着这几年的发展，使用并发设计模式变得越来越重要了，想要测试好并发应用程序，已成了一个不小的挑战.</p>

<!--more-->


<p>测试并发代码最主要的困难在于程序或信息流不是反应在调用堆栈上。函数并不会立即返回给调用者，而是通过回调函数block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然后，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h1>异步测试的问题</h1>

<p>首先，我们来看一个简单地同步单元测试的例子，两个数求和的方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b {
</span><span class='line'>    return a + b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>测试这个方法很简单，只需要比较该方法返回值是否和期望值相同，如果不相同，则测试失败。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddition {
</span><span class='line'>    int result = [Calculator add:2 to:2];
</span><span class='line'>    STAssertEquals(result, 4, nil);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们利用block将该方法改成异步返回结果，为了模拟测试失败，我们会在方法实现中故意添加一个bug.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
</span><span class='line'>    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
</span><span class='line'>        block(a - b); // 带有bug的实现
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>虽然这是一个人为的例子，但是它却真实的反映了编程中可能经常遇到的问题，只不过实际过程更加复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到Block中。尽管我们的方法实现中存在bug,但是这种测试永远不是失败的；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 千万不要使用这些代码！
</span><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block:^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil); // 永远不会被调用到
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的断言为什么没失败呢？</p>

<h1>关于SenTestingKit</h1>

<p>在老版本的xcode中所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKit-call-stack.png" alt="test" /></p>

<p>在测试框架在主run loop开始运行之后，主要执行了一下几个步骤:</p>

<ol>
<li>配置一个包含所有相关测试的测试包</li>
<li>运行测试包，内部会调用所有以test开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。</li>
<li>调用exit()退出测试</li>
</ol>


<p>这其中我们最感兴趣的是单个测试时如何被调用的。在异步测试中，包含断言的Block会被加到run loop。当所有的测试执行完毕后，测试框架就会退出，而block却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方法来解决这个问题。但是素有的方法都必须在住run loop中运行，而且在测试方法返回和比较结果之前需要处理已入队的所有操作。</p>

<p><a href="https://github.com/allending/Kiwi">kiwi</a>使用测试轮询，它可以在测试方法中被滴啊用。<a href="https://github.com/gabriel/gh-unit/">GHUnit</a>编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接受一个通知。以上两种方式都是通过编写相应的代码来确保异步异步测试方法在测试结束之前都不会返回。</p>

<h1>SenTesgingKit的异步扩展</h1>

<p>我们对这个问题的解决方案是对SenTestingKit添加一个扩展，它在栈上使用同步执行，并把每个部分加入到主队列中。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或失败的Block就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKitAsync-call-stack.png" alt="test" /></p>

<p>如果测试方法以Async结尾，框架就睡认为该方法是异步测试。此外，在异步测试中，我们必须手动的报告测试成功，同时为了防止Block永远不会被调用，我们还需要添加了一个超时方法，之前的错误的测试方法修改如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil);
</span><span class='line'>        STSuccess(); // 通过调用这个宏来判断是否测试成功
</span><span class='line'>    }];
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>设计异步测试</h1>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的Bug,在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识.</p>

<p>为了运行到实际中，我们创建了一个实例框架: <a href="sd">AsyncTestDemo</a>,它从一个虚拟的服务器获取图像信息，框架中包含了一个资源管理器，它对外提供了一个可以根据图像Id获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/PinacotecaCore.png" alt="test" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试:</p>

<ol>
<li>模型层</li>
<li>模拟服务器请求的服务器接口控制器(API Controller)</li>
<li>管理Core data堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>


<h2>模型层</h2>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的core data堆栈，并在其中执行各自的操作。</p>

<p>在这个测试实例中，我们就是在 setup 方法中设置core data堆栈，然后检查 PCImage实体的描述是否存在，如果不存在就构造一个，并更新它的值，当然这和异步测试没有关系，我们就不深入细说了。</p>

<h2>服务器接口控制器</h2>

<p>框架中的第二个组件就是服务器接口控制器，它主要处理服务器请求以及服务器API到模型的映射关系。让我们来看一下下面这个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- [PCServerAPIController fetchImageWithId:queue:completionHandler:]</span></code></pre></td></tr></table></div></figure>


<p>调用它需要三个形参：一个图片对象Id，所在的执行队列，以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好<a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个bundle,发送给客户端。</p>

<p>为了能stub请求，OHHTTPStubs需要在测试类初始化时或者 setup方法中进行配置。首先我们需要加载一个包含请求响应对象(response)的bundle:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSURL *url = [[NSBundle bundleForClass:[self class]]
</span><span class='line'>                        URLForResource:@"ServerAPIResponses"
</span><span class='line'>                         withExtension:@"bundle"];
</span><span class='line'>
</span><span class='line'>NSBundle *bundle = [NSBundle url];</span></code></pre></td></tr></table></div></figure>


<p>然后我们从bundle加载response对象，作为请求的响应值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OHHTTPStubsResponse *response;
</span><span class='line'>response = [OHHTTPStubsResponse responseNamed:@"images/123"
</span><span class='line'>                                   fromBundle:responsesBundle
</span><span class='line'>                                 responseTime:0.1];
</span><span class='line'>
</span><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>    return YES /* 如果所返回的request是我们所期望的，就返回YES */;
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
</span><span class='line'>    return response;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m">测试服务器接口控制器</a>如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFetchImageAsync
</span><span class='line'>{
</span><span class='line'>    [self.server
</span><span class='line'>        fetchImageWithId:@"123"
</span><span class='line'>                   queue:[NSOperationQueue mainQueue]
</span><span class='line'>       completionHandler:^(id imageData, NSError *error) {
</span><span class='line'>          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
</span><span class='line'>          STAssertNil(error, [error localizedDescription]);
</span><span class='line'>          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);
</span><span class='line'>
</span><span class='line'>          // 检查返回的字典中的值.
</span><span class='line'>
</span><span class='line'>          STSuccess();
</span><span class='line'>       }];
</span><span class='line'>    STFailAfter(2.0, nil);    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>资源管理器</h2>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和膜形成呢个联系起来，还管理着core data堆栈。下面我们想测试获取一个图片对象的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]</span></code></pre></td></tr></table></div></figure>


<p>该方法根据Id返回一个图片对象。如果图片在数据库中不存在，它会创建一个包含Id的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用<a href="http://ocmock.org/">OCMock</a>来模拟，如果要做方法的部分stub,它是一个理想的框架.如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m">资源管理器测试</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OCMockObject *mo;
</span><span class='line'>mo = [OCMockObject partialMockForObject:self.resourceManager.server];
</span><span class='line'>
</span><span class='line'>id exp = [[serverMock expect] 
</span><span class='line'>             andCall:@selector(fetchImageWithId:queue:completionHandler:)
</span><span class='line'>            onObject:self];
</span><span class='line'>[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];</span></code></pre></td></tr></table></div></figure>


<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们卸载测试类中的方法。</p>

<p>用上面的作坊，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的使我们模拟的服务器接口控制器的方法，这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testGetImageAsync
</span><span class='line'>{
</span><span class='line'>    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
</span><span class='line'>    __block PCImage *img;
</span><span class='line'>    img = [self.resourceManager imageWithId:@"123"
</span><span class='line'>                  usingManagedObjectContext:ctx
</span><span class='line'>                                      queue:[NSOperationQueue mainQueue]
</span><span class='line'>                              updateHandler:^(NSError *error) {
</span><span class='line'>                                       // 检查error是否为空以及image是否已经被更新 
</span><span class='line'>                                       STSuccess();
</span><span class='line'>                                   }];    
</span><span class='line'>    STAssertNotNil(img, nil);
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>总结</h1>

<p>刚开始的时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了他们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>😀fun~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中的多任务]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu/"/>
    <updated>2016-04-19T10:17:49+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu</id>
    <content type="html"><![CDATA[<p>在ios7之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限，除了VOIP和基于地理位置特性之外，唯一能做的地方就是后台任务(background tasks)让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，或者备份用户的照片到你的服务器上，你都仅能完成一部分工作.</p>

<p> <!--more--></p>

<p>ios7添加了两个新的API以便你的程序可以在后台更新界面以及内容。首先是后台获取(background Fetch)，它允许你定义地从网络获取新的内容。第二个API就是远程通知(Remote Notifications)，这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务(Background Trasnfer service)中执行定期的任务，也允许你在进程之外可以执行网络传输(下载和上传)工作</p>

<p>后台获取(Background Fetch)和远程通知(Remote notification)基于简单的 ApplicationDelegate钩子，在应用程序挂起之前的30秒时间执行工作。它们不是用于CPU频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>

<p>对于用户来说,多任务处理有点显而易见的改变就是新的应用切换程序，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的&ndash;现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络，新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>

<h2>后台获取</h2>

<p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前出发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午一点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你想系统报告新数据无法获取，ios会适应并使用此信息避免会继续获取。</p>

<p>开启后台获取的第一步是在info plist文件中对UIBackgroundModes键指定特定的值。最简单的途径是在Xcode的project editor中新的Capabilities标签页设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/capabilities-on-bgfetch.jpg" alt="logo" /></p>

<p>或者你可以手动配置这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;UIBackgroundModes&lt;/key&gt;
</span><span class='line'>&lt;array&gt;
</span><span class='line'>    &lt;string&gt;fetch&lt;/string&gt;
</span><span class='line'>&lt;/array&gt;  </span></code></pre></td></tr></table></div></figure>


<p>接下来，告诉IOS多久进行一次数据获取</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</span><span class='line'>{
</span><span class='line'>    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];
</span><span class='line'>
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ios默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该制定一个你想要的时间间隔。例如，一个天气的应用程序，可能只需要几个小时更新一次，IOS将会在后台获取之间至少等待你指定的时间间隔。</p>

<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把minimumBackgroundFetchInterval设置为UIApplicationBackgroundFetchIntervalNever,专业那个可以节省资源。</p>

<p>最后一步是在应用程序委托中实现下列方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)                application:(UIApplication *)application 
</span><span class='line'>  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
</span><span class='line'>    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];
</span><span class='line'>
</span><span class='line'>    NSURL *url = [[NSURL alloc] initWithString:@"http://yourserver.com/data.json"];
</span><span class='line'>    NSURLSessionDataTask *task = [session dataTaskWithURL:url 
</span><span class='line'>                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
</span><span class='line'>
</span><span class='line'>        if (error) {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultFailed);
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // 解析响应/数据以决定新内容是否可用
</span><span class='line'>        BOOL hasNewData = ...
</span><span class='line'>        if (hasNewData) {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>        } else {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultNoData);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>
</span><span class='line'>    // 开始任务
</span><span class='line'>    [task resume];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有30秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面，30秒时间应该足够去网络获取数据和获取界面的缩略图，但是最多只有30秒，当完成了网络请求和更新界面后，你应该执行完成的回调。</p>

<p>完成回调的执行有两个目的，首先，系统会估量你的进程消耗的电量，并根据你传递的UIBackgroundFetchResult参数记录新数据是否可用，其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器，当用户在应用间切换时，用户将会看到新内容，这种通过completion handler来报告并且生成截图的方法，在新的多任务处理API中是很常见的。</p>

<p>在实际的应用中，你应该将completionHandler传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>

<p>在这里，你可能想知道ios是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的声明周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想象为用户从Springboard启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>

<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看UIAppcation的applicationState属性来判断应用是不是从后台启动。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Launched in background %d", UIApplicationStateBackground == application.applicationState);
</span><span class='line'>
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>测试后台数据获取</h2>

<p>有两种可以模拟后台获取的途径。最简单是从Xcode运行你的应用，当应用运行时，在Xcode的Debug菜单选择Simulate Background Fetch.</p>

<p>第二种方法，使用scheme更改Xcode运行程序的方式。在Xcode菜单的Product选项，选择Scheme然后选择Manager Schemes.在这里，你可以编辑或者添加一个新的scheme,然后选中Launch due to a background fetch event ,如下图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/edit-scheme-simulate-background-fetch.png" alt="logo" /></p>

<h2>远程通知</h2>

<p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时消息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载一遍离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中有两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候的才会启动。</p>

<p>一条远程通知实际上只是一条普通的带有content-available 标志的推送通知。你可以发送一条带有提醒消息的推送去告诉用户有事情发生了，同时在后台对界面进行更新。但远程通知也可以做到安静的，没有提醒消息或者任何声音 的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>

<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。ios和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，知道设备下次发送保持活动状态的数据包，或者受到另外一个通知。</p>

<h2>发送远程通知</h2>

<p>要发送一条远程通知，需要在推送通知的有效负载设置content－available 标志。content－available 标志和用来通知报刊应用的键值是一样的。因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>

<p>我建议在开发的时候，使用<a href="http://nomad-cli.com/#houston">Nomand CLI&rsquo;s Houston</a>工具发送推送消息，当然你可以使用你喜欢的库或者脚本。</p>

<p>你可以通过nomad-cli ruby gem来安装Houston</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install nomad-cli</span></code></pre></td></tr></table></div></figure>


<p>然后通过包含在Noman的apn实用工具发送一条通知:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Send a Push Notification to your Device
</span><span class='line'>apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42</span></code></pre></td></tr></table></div></figure>


<p>在这里，-n标志指定应该包含content-available 健值,-d标志允许添加我们自定义的数据键值到有效负荷.
通知的有效负荷(payload)结果和下面类似:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "aps" : {
</span><span class='line'>        "content-available" : 1
</span><span class='line'>    },
</span><span class='line'>    "content-id" : 42
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ios7中添加了新的应用程序委托方法，当接收到一条带有 content－available的推送通知时，下面的方法会被调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)application:(UIApplication *)application 
</span><span class='line'>  didReceiveRemoteNotification:(NSDictionary *)userInfo 
</span><span class='line'>        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Remote Notification userInfo is %@", userInfo);
</span><span class='line'>
</span><span class='line'>    NSNumber *contentID = userInfo[@"content-id"];
</span><span class='line'>    // 根据 content ID 进行操作
</span><span class='line'>    completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>和后台抓取一样，应用程序进入后台启动，也有30秒时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>

<h2>NSurlSession和后台传输服务(Background Transfer Service)</h2>

<p>NSURLSession是ios7添加的一个新类，它也是Foundation Networking中的新技术。作为NSURLConnection的替代品，一些熟悉的概念和类都保留下来了，例如NSURL,NSURLRequest,NSURLResponse.所以，你可以使用NSURLSessionTask这一NSURLConnnection的替代品，来处理网络请求及响应。一共有3种回话任务：数据，下载和上传。每一种都向NSURLSessionTask添加了语法糖，根据你的需要，适当选择一种。</p>

<p>一个NSURLSession对象协调一个或多个NSURLSessionTask对象，并根据NSURLSessionTask创建的NSURLSessionConfiguration实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的NSURLSessionTask对象。要利用后台传输服务，你将会使用<code>[NSURLSessionConfiguration backgroundSessionConfiguration]</code>来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>

<p>NSURLSessionConfiguration允许你设置默认的HTTP头，配置缓存策略，限制使用蜂窝煤数据等等。其中一个选项是discretionary标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备足够电量时，设备才通过wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>

<p>目前为止，我们大概了解了NSURLSession，以及一个后台回话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传入服务的下载队列。当下载完成后，我们会通知用户该文件已经可以用了。</p>

<h2>NSURLSessionDownloadTask</h2>

<p>首先，我们先处理一条远程通知，并把一个NSURLSessionDownloadTask添加到后台传输服务的队列。在backgroundURLSession方法张，我们根据后台回话配置，创建一个NSURLSession对象，并把application delegate作为回话的委托对象。文档不建议对于相同的标识符(identifier)创建多个回话对象，所以我们使用dispatch_once来避免潜在的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSURLSession *)backgroundURLSession
</span><span class='line'>{
</span><span class='line'>    static NSURLSession *session = nil;
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        NSString *identifier = @"io.objc.backgroundTransferExample";
</span><span class='line'>        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
</span><span class='line'>        session = [NSURLSession sessionWithConfiguration:sessionConfig 
</span><span class='line'>                                                delegate:self 
</span><span class='line'>                                           delegateQueue:[NSOperationQueue mainQueue]];
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    return session;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)           application:(UIApplication *)application 
</span><span class='line'>  didReceiveRemoteNotification:(NSDictionary *)userInfo 
</span><span class='line'>        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Received remote notification with userInfo %@", userInfo);
</span><span class='line'>
</span><span class='line'>    NSNumber *contentID = userInfo[@"content-id"];
</span><span class='line'>    NSString *downloadURLString = [NSString stringWithFormat:@"http://yourserver.com/downloads/%d.mp3", [contentID intValue]];
</span><span class='line'>    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];
</span><span class='line'>
</span><span class='line'>    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];
</span><span class='line'>    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];
</span><span class='line'>    task.taskDescription = [NSString stringWithFormat:@"Podcast Episode %d", [contentID intValue]];
</span><span class='line'>    [task resume];
</span><span class='line'>
</span><span class='line'>    completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们使用NSURLSession类方法创建爱你一个下载任务，配置请求，并提供说明供以后使用。因为所有回话任务一开始处于挂起状态，你必须谨记要调用[task resume]保证开始了任务。</p>

<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现NSURLSessionDelegate或NSURLSessionTaskDelegate的方法，你应该阅读Apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42">Life Cycle of a URL Session with Custom Delegates</a>文档，它讲解了所有类型回话任务的完成生命周期。</p>

<p>NSURLSessionDownloadDelegate中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时URL.你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#Pragma Mark - NSURLSessionDownloadDelegate
</span><span class='line'>
</span><span class='line'>- (void)         URLSession:(NSURLSession *)session 
</span><span class='line'>               downloadTask:(NSURLSessionDownloadTask *)downloadTask
</span><span class='line'>  didFinishDownloadingToURL:(NSURL *)location
</span><span class='line'>{
</span><span class='line'>    NSLog(@"downloadTask:%@ didFinishDownloadingToURL:%@", downloadTask.taskDescription, location);
</span><span class='line'>
</span><span class='line'>    // 用 NSFileManager 将文件复制到应用的存储中
</span><span class='line'>    // ...
</span><span class='line'>
</span><span class='line'>    // 通知 UI 刷新
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)  URLSession:(NSURLSession *)session 
</span><span class='line'>        downloadTask:(NSURLSessionDownloadTask *)downloadTask 
</span><span class='line'>   didResumeAtOffset:(int64_t)fileOffset 
</span><span class='line'>  expectedTotalBytes:(int64_t)expectedTotalBytes
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)         URLSession:(NSURLSession *)session 
</span><span class='line'>               downloadTask:(NSURLSessionDownloadTask *)downloadTask 
</span><span class='line'>               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten 
</span><span class='line'>  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
</span><span class='line'>{
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会受到一系列消息。App delegate的: handleEventsForBackgroundURLSession：方法会在这些NSURLSession委托的消息发送前被调用，然后URLSessionDidFinishEventsForBackgroundURLSession在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler）,并在后面的方法中执行回调以便更新界面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)                  application:(UIApplication *)application 
</span><span class='line'>  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
</span><span class='line'>{
</span><span class='line'>    // 你必须重新建立一个后台 seesiong 的参照
</span><span class='line'>    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为
</span><span class='line'>    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession
</span><span class='line'>    NSURLSession *backgroundSession = [self backgroundURLSession];
</span><span class='line'>
</span><span class='line'>    NSLog(@"Rejoining session with identifier %@ %@", identifier, backgroundSession);
</span><span class='line'>
</span><span class='line'>    // 保存 completion handler 以在处理 session 事件后更新 UI
</span><span class='line'>    [self addCompletionHandler:completionHandler forSession:identifier];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Background URL session %@ finished events.\n", session);
</span><span class='line'>
</span><span class='line'>    if (session.configuration.identifier) {
</span><span class='line'>        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler
</span><span class='line'>        [self callCompletionHandlerForSession:session.configuration.identifier];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier
</span><span class='line'>{
</span><span class='line'>    if ([self.completionHandlerDictionary objectForKey:identifier]) {
</span><span class='line'>        NSLog(@"Error: Got multiple handlers for a single session identifier.  This should not happen.\n");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    [self.completionHandlerDictionary setObject:handler forKey:identifier];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)callCompletionHandlerForSession: (NSString *)identifier
</span><span class='line'>{
</span><span class='line'>    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];
</span><span class='line'>
</span><span class='line'>    if (handler) {
</span><span class='line'>        [self.completionHandlerDictionary removeObjectForKey: identifier];
</span><span class='line'>        NSLog(@"Calling completion handler for session %@", identifier);
</span><span class='line'>
</span><span class='line'>        handler();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果当后台传输完成时，应用程序不再停留在前台，那么对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用陈谷根本没有在运行，ios将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在application:didFinishLaunchingWithOptions: 方法被调用之后被调用.</p>

<h2>配置和限制</h2>

<p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读NSURLSessionConfiguration部分，以便最好滴满足你的使用场景。例如:NSURLSessionTasks通过NSURLSessionConfiguration的timeoutIntervalForResource属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限wifi宽带的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>

<p>除了下载任务，NSURLSession也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像ios6那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要再后台运行，一个比较好的做法是,把NSURLSessionConfiguration的sessionSendsLaunchEvents属性设置为NO。高效利用系统资源，是一件让Ios和用户都高兴的事。</p>

<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对NSURLSession的使用简单的基于block的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用Http重定向。后台传输服务只支持HTTP和HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>

<p>另外，要注意的是在后台回话中，NSURLSessionDataTasks是完全不支持的，你应该只处于短期的，小请求为目的的使用这些任务，而不是用来下载或上传。</p>

<h2>总结</h2>

<p>在ios7中强大的多任务和网络API为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的API，一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>

<ul>
<li>使用适当的新的API来为你的应用程序提供内容</li>
<li>尽可能早地调用completion handler以提高效率</li>
<li>让completion hander为应用程序更新界面快照</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsynDisplayKit入门篇]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/"/>
    <updated>2016-04-15T10:22:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>FaceBook的Paper团队给我们开源了一个很棒的库:<a href="https://github.com/facebook/AsyncDisplayKit">AsynDisplayKit</a>,这个库能让你通过将图像解码，布局以及渲染操作都放到后台线程处理，从而带来了快速响应的用户界面，也就是说不再会因为界面卡顿尔阻断用户交互。</p>

<!--more-->


<p>例如，对于非常复杂的界面，你可以使用 AsyncDisplayKit构建它而得到一种如丝般顺滑的，60帧每秒的滑动体验。而平常的UIkit优化就不太可能克服这样的性能挑战。</p>

<p>从本教程中，你将从一个初始项目开始，它主要有一个UICollectionView的滑动问题，而使用AysncDisplayKit将大大提供其滑动性能。一路上，你将学会如何在旧项目上使用AsyncDisplaykit.</p>

<blockquote><p><em>注意</em>，在本教程之前，你应该熟悉 Swift,Core Animation以及Core Graphics.</p></blockquote>

<h2>开始</h2>

<p>开始之前，请先看看<a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/">AsyncDisplayKit介绍</a>,对它有个简要的概念，知道它是解决什么问题的。</p>

<p>准备好了，就下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/04/Layers-Start.zip">开始项目</a>,你需要至少Xcode6.1和iosSDK 8.1来编译它，如果用最新Xcode打开，swift语法需要做下转换和修改，请自行解决这些兼容问题.</p>

<p>你要研究的项目是由UICollectionView制作的卡片式界面来描述不同的雨林动物，每张信息卡上包含了一个图片，名字以及一个队雨林动物的描述，卡片的背景图是主图片的模糊感，视觉上设计的效果保证了文字的清晰可读。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20141124/1416797117122129.png" alt="logo" />
在Xcode中，打开初始项目的 Layers.xcworkspace。</p>

<p>在本教程里，请遵循以下原则以体会AsyncDisplayKit的那些十分吸引人的好处。</p>

<p>将应用运行到真机上，在模拟器上很难看出性能改善。</p>

<p>应用是通用的，但在ipad上看起来最好。</p>

<p>最后，要真正感谢这个库为你所有的事情，请尽量在最旧的ios8.1的设备上去运行该应用，第三代的ipad最好，因为它随让是视网膜屏，但是运行的不是很快。</p>

<p>运行该项目，效果如下:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt="logo" /></p>

<p>试着滑动CollectionVie并注意那可怜的帧率，在第三代ipad上，帧率只有15-20FPS，实在丢掉太多帧了，在本教程的最后，你能在60 FPS的帧率下滑动它.</p>

<blockquote><p><em>注意</em>
你所看到的图像都是在App的asset目录里，并不是从网络里获取的。</p></blockquote>

<p>在一个旧项目中使用AsyncDisplayKit前，你应该通过Instruments测量你的UI的性能，这样才能有一个基准线以便对比改动的效果。</p>

<p>最重要的是，你要知道是CPU-绑定，还是GPU-绑定，也就是说是CPU还是GPU拉低了应用的帧率，这个信息会告诉你该充分利用AsyncDisplayKit的那个特性以优化应用的性能。</p>

<p>如果你有时间，看看之前提到的WWDC2012 session 或在真实的设备上使用Instruments来评估初始项目的时间曲线。滑动性能是CPU-绑定的，你能猜到是什么原因导致了 CollectionView 丢掉了这么多帧吗?</p>

<h2>为项目准备好使用 AsyncDisplayKit</h2>

<p>在旧项目里使用AsyncDisplayKit，总结起来就是使用 Display Node 层级结构替换视图层级结构或Layer树，各种Display Node是AsyncDisplayKit的关键所在，它们位于视图之上，而且是线程安全的，也就是说之前在主线程才能执行的任务现在也可以在非主线程中执行。这就是减少主线程的工作量以执行其它操作，例如处理触摸事件，或如下本应用的情况下，处理CollectionView的滑动。</p>

<p>这就意味着在本教程里，你的第一步是移除视图层级结构。</p>

<h3>移除视图的层次结构</h3>

<p>打开 RainForestCardCell.Swift并删除awakeFromNib() 中所有的 addSubview(&hellip;.)调用，然后得到如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'>  contentView.layer.borderColor =
</span><span class='line'>    UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>  contentView.layer.borderWidth = 1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，替换LayoutSubviews()的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再讲configureCellDisplayWithCardInfo(cardInfo:)的内容替换如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>删除RainforestCardCell的所有视图属性，只留一个如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后编译运行，你看的的是黑洞洞的一片:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt="logo" /></p>

<p>现在所有的cell都空了，滑动起来就很顺滑，你的目标是保证之后添加完各个Node之后，依然顺滑如初。</p>

<h3>添加一个占位图</h3>

<p>打开RainforestCardCell.swift,给RainforestCardCell添加一个可选的 CALayer变量，名为placeholderLayer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要一个占位图是因为显示会异步完成，如果这个过程需要一些时间，那用户就会看到空的cell 。就如同如果你要从网络上获取图像，那么就需要用占位图来填充Cell,这能让你的用户知道内容还没准备好。随让在我们这种情况下，你是在后台线程绘制而不是从网络上下载。</p>

<p>在awakeFromNib()里，删除contentView的border设置，再创建并配置一个placeholderLayer.将其添加到cell的contentview的layer上，现在这个方法如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer = CALayer()
</span><span class='line'>  placeholderLayer.contents = UIImage(named: "cardPlaceholder")!.CGImage
</span><span class='line'>  placeholderLayer.contentsGravity = kCAGravityCenter
</span><span class='line'>  placeholderLayer.contentsScale = UIScreen.mainScreen().scale
</span><span class='line'>  placeholderLayer.backgroundColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 1).CGColor
</span><span class='line'>  contentView.layer.addSublayer(placeholderLayer)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在layoutSubviews()里，你需要布局placeholderLayer.替换这个方法为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译并运行，你从虚无的边缘回来了:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt="logo" /></p>

<p>普通的CALayer不是由UIview支持的，当它们改变frame时，默认会有隐式动画，这就是你看到layer在布局放大时，要修复这个问题，改动layoutSubviews()如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  CATransaction.begin()
</span><span class='line'>  CATransaction.setValue(kCFBooleanTrue, forKey: kCATransactionDisableActions)
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>  CATransaction.commit()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，问题解决了。</p>

<p>现在占位图不会乱动，不再动画它们的frame了。</p>

<h2>第一个Node</h2>

<p>重建App的第一步就是给每一个UICollectionView cell 添加一个背景图片的Node,步骤如下:</p>

<ol>
<li>创建，布局并添加一个图像Node到UICollectionView cell</li>
<li>处理cell重用Node和它们的layer</li>
<li>模糊图像Node</li>
</ol>


<p>但在做之前，打开 Layers-Bridging-Header.h 并导入 AsyncDisplayKit :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</span><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>这会让所有的Swift文件都能访问AsyncDisplayKit类库。</p>

<p>编译一下，确保没有错误</p>

<p>现在，我们来看看Collectin View的祖成:</p>

<ul>
<li>View Controller: RainforestViewController没有什么花哨的东西，它只是为所有的雨林卡片获取一个数据数组，并为UIcollectioNView实现DataSource.事实上，你不需要花太多时间在这个上</li>
<li>DataSource:大部分时间都将花在Cell类的RainforestCardCell上，ViewController出队每个cell，并将雨林卡片的数据用configureCellDisplayWithCardInfo(cardInfo:) 传给它。cell就使用这个数据来配置自身.</li>
<li>Cell: 在configureCellDisplayWithCardInfo(cardInfo:)里，cell创建，配置，布局以及添加Node到它自己身上。这就意味着每次ViewController出队一个cell,这个cell就会创建并添加它自己一个新的Node层级结构</li>
</ul>


<p>如果你使用View而不是Node，那么这样做对于性能来说就不是最佳策略。但因为你可以异步的创建，配置以及布局，而且Node也是异步地绘制，所以这不会是一个问题。真正的难点是在cell准备重用时取消任何在进行额异步操作并移除旧的node.</p>

<p>然而，在实际生产中，你最好使用ASRangeController来缓存你的Node,这样你就不用每次在cell重用时重建它的Node层级结构，ASRangeController超出了本教程的范围。</p>

<p>OK，动手!</p>

<h3>添加背景图片Node</h3>

<p>现在你要走一遍用Node配置cell的过程，一次一步：
打开RainforestCardCell.swift 并替换configureCellDisplayWithCardInfo(cardInfo:) 为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个ASImageNode常量，叫做backgroundImageNode.</p>

<p>AsyncDisplayKit带有好几种Node类型，包括ASImageNode，用于显示图片。它相当于UIImageView,除了ASImageNode是默认异步的解码图片。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这让backgroundImageNode变为layer支持的Node.</p>

<p>Node可由UIview支持或CALayer支持，当node需要处理事件时（例如触摸事件），你就要使用UIView支持的Node.如果你不需要处理事件，只需要显示一下内容，那使用Layer支持的Node会更加轻量，因此可以获得一个小的性能提升。</p>

<p>因为本教程的APP不需要处理事件，所以你可以让所有的Node都设置为Layer支持的。在上面的代码中，由于backgroundImageNode为Layer支持的。AsyncDisplayKit会创建一个CALayer用于雨林动物图像内容的显示.</p>

<p>继续在 configureCellDisplayWithCardInfo(cardInfo:)添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>这里使用FrameCalculator为backgroundImageNode布局.</p>

<p>FrameCalculator是一个帮助类，负责给每个Node布局。注意所有的东西都是手动布局的，没有使用AutoLayout约束。<strong>如果你需要构建自适应布局或者本地化驱动的布局，那就要注意，因为你不能给Node添加约束</strong></p>

<p>接下来，添加如下代码到configureCellDisplayWithCardInfo(cardInfo:)底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layer and Wrap Up Section
</span><span class='line'>self.contentView.layer.addSublayer(backgroundImageNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>这句将backgroundImageNode的layer添加到cell ContentView的layer上。</p>

<blockquote><p><strong>注意</strong>
AsyncDisplayKit会为backgroundImageNode创建一个Layer.然而，你必须要将Node放到某个Layer树中才能在屏幕上显示，这个Node会异步地绘制，所以直到绘制完成，它的内容都不会显示，尽管它的Layer已经在一个Layer树中。</p></blockquote>

<p>从技术的角度来说，layer一直都存在。但渲染图像是异步进行的。layer初始化时没有内容，一旦渲染完成，layer的contents就会更新为包含图像的内容。</p>

<p>在这个点，cell的contentView的layer将会包含两个Sublayer:一个占位图和Node的layer。在node完成绘制前，只有占位图会显示。</p>

<p>注意到configureCellDisplayWithCardInfo(cardInfo:)会在每次cell出队时被调用。每次cell被回收，这个逻辑会添加一个新的sublayer到cell的contentview layer上。不要担心，你很快会解决这个问题。</p>

<p>回到RainforestCardCell.swift开头，给RainforestCardCell添加一个ASImageNode变量存为属性backgroundImageNode，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要这个属性是因为必须要有某个东西将backgroundImageNode的引用保留住，否则ARC就会将其释放，也就不会有任何东西显示出来了&ndash;即使Node的在一个layer树中，你依然需要保留Node.</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:)底部的Node Layer and Wrap Up Section ,设置cell新的backgroundImageNode为之前的backgroundImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>下面是完整的configureCellDisplayWithCardInfo(cardInfo:) 方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>  backgroundImageNode.layerBacked = true
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layout Section
</span><span class='line'>  backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layer and Wrap Up Section
</span><span class='line'>  self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>  self.backgroundImageNode = backgroundImageNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，观察AsyncDisplaytKit是如何异步地使用图像设置Layer的Contents的。这能让你在CPU还在绘制layer的内容的同事上下滑动页面。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>如果你运行在旧设备上，注意图像是如何弹出到位置&ndash;这是爆米花效果，但不总是让人喜欢。本教程的最后一节将会搞定这个不令人愉快的弹出效果，给你展示图像如何弹入弹出，如同摇滚巨星。</p>

<p>如同之前所讨论的，新的Node会在每次cell被重用时创建，这并不理想，因为这意味着新的Layer会在每次cell被重用时加入。</p>

<p>如果你想看看Sublayer堆积太多的影响，那就不停的滑上滑下，然后加断点打印出cell的contentview的Layer的sublayers属性。你会看到很多layer,这不好.</p>

<h2>处理cell重用</h2>

<p>继续RainforestCardCell.swift,给RainforestCardCell 添加一个contentLayer的CALayer属性，这个属性也是一个可选类型:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你将使用此属性去移除Cell的ContentView的Layer树中旧的Node Layer.虽然你可以简单地保留Node并访问其Layer属性，但上面的写法更加明确。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 结尾：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.contentLayer = backgroundImageNode.layer</span></code></pre></td></tr></table></div></figure>


<p>这句让backgroundImageNode的Layer保留到contentLayer属性。</p>

<p>替换prepareForReuse()的实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'>  backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为AsyncDisplaytKit能够异步地绘制Node,所以Node让你能预防从头绘制或取消任何在进行的绘制。无论是你需要预防或取消绘制，都可将preventOrcancelDisplay设置为true,如上面的代码所示，在本来中，你要在cell被重用前取消任何正在进行的绘制活动.</p>

<p>接下来，添加如下代码到prepareForReuse（）尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer?.removeFromSuperlayer()</span></code></pre></td></tr></table></div></figure>


<p>这将contentLayer从其SuperLayer(也就是contentview的Layer)中移除.</p>

<p>每次一个cell被回收时，这个代码就移除Node的旧Layer,因而解决了堆积问题。所以在任何时间，你的Node最多只有两个sublayer:占位图和Node的Layer.</p>

<p>接下来添加如下代码到prepareForReuse()尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer = nil
</span><span class='line'>backgroundImageNode = nil</span></code></pre></td></tr></table></div></figure>


<p>这确保cell释放它们的引用，这样如有必要，ARC才好做清理工作。</p>

<p>编译运行，这次，没有sublayer会堆积的问题，且所有不必要的绘制都将被取消.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>是时候来点模糊效果了!
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/asyncscroll.png" alt="blue" /></p>

<h2>模糊图像</h2>

<p>要实现模糊图像，你要添加一个额外的步骤到图像Node的显示过程里。</p>

<p>继续RainforestCardCell.swift ,在configureCellDisplayWithCardInfo(cardInfo:) 的设置backgroundImageNode.layerBacked 的后面，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'>  if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>    30,
</span><span class='line'>    tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>    saturationDeltaFactor: 1.8,
</span><span class='line'>    maskImage: nil, 
</span><span class='line'>    didCancel:{ return false }) {
</span><span class='line'>      return blurredImage
</span><span class='line'>  } else {
</span><span class='line'>    return image
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ASImageNode的imageModificationBlock给你一个积水在显示之前去处理底层的图像，这是非常实用的功能，它让你对图像Node做一些操作，例如添加滤镜等。</p>

<p>在上面的代码中，你使用imageModificationBlock来为cell的背景图像应用模糊效果。关键点就是图像Node将会绘制它的内容并在后台执行这个闭包，而主线程依然顺滑流畅。这个闭包接受原始的UIImage并返回一个修改过的UIimage.</p>

<p>上面的代码使用了UIImage的模糊category,它由Apple在WWDC2013提供。使用了Accelerate framework 在CPU上模糊图像。因为模糊会消耗很多时间和内存，这个版本的category被修改为包含了取消机制。这个模糊方法将定期调用didCancel闭包来决定是否应该停止模糊。</p>

<p>现在，上面的代码给didCancel简单地返回false,之后你可以重写didCancel闭包.</p>

<blockquote><p><em>注意</em>
还记得第一次运行APP时collectionView那可怜的滑动效果吗？模糊方法阻塞了主线程。通过使用AsyncDisplayKit将模糊放入后台线程，你就大幅度地提高了CollectionView的滑动性能。简直天壤之别。</p></blockquote>

<p>编译并运行，观察模糊效果:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="lgo" />
注意你可以非常流畅的滑动页面了</p>

<p>当Collectionview出队一个cell时，一个模糊操作将开始后台线程，当用户快速滑动时，CollectionView会重用每个cell多次，并开始许多模糊操作。我们的目标是在cell准备重用时取消正在进行中的模糊操作。</p>

<p>你已经在prepareForReuse()里取消了Node的绘制操作，但一旦控制被移交给处理你图像修改的闭包，那就是你的责任来处理Node的preventOrCancelDisplay的设置。</p>

<h2>取消模糊操作</h2>

<p>要取消进行中的模糊操作，你需要实现模糊方法的didCancel闭包.</p>

<p>添加一个捕获列表到imageModificationBlock以捕捉一个backgroundImageNode的weak引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>   ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你需啊哟weak引用来避免闭包和图像Node之间的循环引用问题。你将使用这个weak  backgroundImageNode 来确定是否要取消模糊操作。</p>

<p>是时候构建模糊取消碧波啊了。添加如下代码到imageModificationBlock:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  let didCancelBlur: () -&gt; Bool = {
</span><span class='line'>    var isCancelled = true
</span><span class='line'>    // 1
</span><span class='line'>    if let strongBackgroundImageNode = backgroundImageNode {
</span><span class='line'>      // 2
</span><span class='line'>      let isCancelledClosure = {
</span><span class='line'>        isCancelled = strongBackgroundImageNode.preventOrCancelDisplay
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      // 3
</span><span class='line'>      if NSThread.isMainThread() {
</span><span class='line'>        isCancelledClosure()
</span><span class='line'>      } else {
</span><span class='line'>        dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    return isCancelled
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这些代码：</p>

<ol>
<li>得到backgroundImageNode的Strong引用，准备其干活。如果backgroundImageNode在本次运行时小时，那么isCancelled将保持为true,然后模糊操作会被取消，如果没有Node需要显示，自然没有必要继续模糊操作。</li>
<li>在此你将操作取消检查包在闭包里，因为一旦Node创建它的Layer或View，那就只能在主线程访问Node的属性。由于你需要访问preventOrCancelDisplay，所以你必须在主线程检查。</li>
<li>最后，确保isCancelledClosure是在主线程进行，无论是在主线程直接运行，还是不再主线程而通过dispatch_sync来调度。它必须是一个同步的调度，因为我们需要闭包完成，并在didCancelblue闭包返回之前设置isCancelled.</li>
</ol>


<p>在调用applyBlurWithRadius(&hellip;)中，修改传递给didCancel的参数，替换一直返回false的闭包为你刚才定义并保留在didCancelBlur的闭包。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>  30,
</span><span class='line'>  tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>  saturationDeltaFactor: 1.8,
</span><span class='line'>  maskImage: nil,
</span><span class='line'>  didCancel: didCancelBlur) {
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你看你不会注意到太多差别，但现在任何在cell离开屏幕时还未完成的模糊都会被取消了。这就意味着设备比之前做的更少。你可能观察到轻微的性能提升，特别是在较慢的设备如第三代iPad上运行。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<p>你的卡片需要内容，通过下面四个小节，你将学会:</p>

<ul>
<li>创建一个容器Node,它将所有的SubNode绘制到一个单独的CALayer里</li>
<li>构建一个Node层次结构</li>
<li>创建一个自定义的ASDispalyNode子类，并在后台构建并布局Node层次结构</li>
</ul>


<p>做完这些，你就会得到一个看起来和添加AsyncDisplayKit之前一样的APP，但有着黄油版顺滑的滑动体验。</p>

<h2>栅格化的容器Node</h2>

<p>直到现在，你一直在操作cell内的一个单独的Node，接下来，你将创建一个容器Node，它会包含所有卡片内容。</p>

<h3>添加一个容器Node</h3>

<p>继续 RainforestCardCell.swift,在 configureCellDisplayWithCardInfo(cardInfo:) 的backgroundImageNode.imageModificationBlock后面以及Node Layout Section前面添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Container Node Creation Section
</span><span class='line'>let containerNode = ASDisplayNode()
</span><span class='line'>containerNode.layerBacked = true
</span><span class='line'>containerNode.shouldRasterizeDescendants = true
</span><span class='line'>containerNode.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>containerNode.borderWidth = 1</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做containerNode的ASDisplayNode常量。注意这个容器的shouldRasterizeDescendants,这是一个关于节点如何工作的提示以及一个如何让它们工作的更好的机会.</p>

<p>如单词<code>descendants (子孙)</code>所暗示的，你可以创建 AsyncDisplayKit Node的层次结构或树，就如你可以创建Core Animation Layer 的层次结构一样。例如，如果你有一个都是Layer支持的Node层级结构，那么AsyncDisplaykit将会为每个Node创建一个分离的CALayer,Layer层次结构将会和Node层级结构一样，如同镜像。</p>

<p>这听起来很熟悉：它类似于当你使用UIkit时，Layer层次结构镜像于View层次结构。然而，这个Layer的栈有一些不同的效果。</p>

<p>首先，因为是异步渲染，你就不会看到每个layer一个接一个的显示，当AsyncDisplayKit绘制完成每个layer，它马上制作layer的显示内容，所以如果你有一个layer的绘制比其他layer耗时更长，那么它将会在它们之后显示。用户会看到零碎的layer组件，这个过程通常是不可见的，因为Core Animation会在显示任何东西之前重绘所有必须的Layer。</p>

<p>第二，有需要Layer能够引起性能问题。每个CALayer都需要一个支持存储来保存它的像素位图和内容。同样，CoreAnimation必须将每个Layer通过XPC发给渲染服务器。最后，渲染服务器可能需要重绘一些Layer以复合它们，例如在混合layer时，总的来说，更多的Layer意味着CoreAnimation更多的工作。所以限制layer使用的数量有许多不同的好处。</p>

<p>为了解决这个问题，AsyncDisplayKit有一个方便的特性，它允许你绘制一个Node层次结构到一个单独的Layer容器里。这就是shouldRasterizeDescendants所做的，当你设置它，那在完成素有的subnode的绘制之前，ASDisplayNode将不会设置Layer的Contents。</p>

<p>所以在之前的步骤里，设置容器Node的shouldRasterizeDescendants为true有两个好处:</p>

<ol>
<li>它确保卡片一次显示所有的Node，如同旧的同步绘制</li>
<li>而且它通过栅格化Layer栈为单个Layer并较少未来的合成而提高了效率</li>
</ol>


<p>不足之处是，由于你将所有的layer放入了一个位图，你就不能再之后单独动画某个Node了。</p>

<p>接下来，在 Container Node Creation Section后，添加backgroundImageNode为containerNode的subnode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em>
添加Node的顺序很重要，就如同subview和sublayer,最先添加的Node会被之后添加的阻挡显示</p></blockquote>

<p>替换 Node Layout Section 的第一行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>containerNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>最后，使用FrameCalculator布局backgroundImageNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForBackgroundImage(
</span><span class='line'>  containerBounds: containerNode.bounds)</span></code></pre></td></tr></table></div></figure>


<p>这设置backgroundImageNode填满整个containerNode.</p>

<p>你几乎完成了新的Node层次结构，但首先你需要正确地设置Layer层次结构，因为容器Node现在是根。</p>

<h3>管理容器Node的Layer</h3>

<p>在Node Layer and Wrap Up Section，将backgroundImageNode的Layer添加到containerNode的layer上，而不是containerView的Layer上:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentView.layer.addSublayer(containerNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>删除下面的backgroundImageNode保留:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>因为cell只需要单独保留容器Node,所以你要移除backgroundImageNode属性。</p>

<p>不再设置cell的contentLayer属性为backgroundImageNode的Layer,现在将其设置为containerNode的layer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentLayer = backgroundImageNode.layer
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentLayer = containerNode.layer</span></code></pre></td></tr></table></div></figure>


<p>给RainforestCardCell添加一个可选的ASDisplayNode实例存储为属性containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>记住你需要保留你自己的Node，如果你不怎么做它们就会被立即释放。</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:)，在Node Layer and Wrap Up Section 最后，设置containerNode属性为containerNode常量:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>编译运行，模糊的图形将会再次显示！但还有最后一件事要去改变，因为现在有了新的Node层次结构，回忆之前cell重用时你将图像停止显示。现在你需要让整个Node层次结构停止显示。</p>

<h3>在新的Node层次结构上处理cell重用</h3>

<p>继续RainforestCardCell.swift ，在prepareForReuse()里，替换设置backgroundImageNode.preventOrCancelDisplay 为在 containerNode 上调用 recursiveSetPreventOrCancelDisplay(&hellip;) 并传递 true：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'> 
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你要取消整个Node层次结构的绘制，就使用 recursiveSetPreventOrCancelDisplay()。这个方法将会设置这个node以及所有子Node的preventOrCancelDisplay属性，无论true或false。</p>

<p>接下来，依然在prepareForReuse(),用设置containerNode为nil替换设置backgroundImageNode为nil:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  ...
</span><span class='line'>  contentLayer = nil
</span><span class='line'>
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode = nil
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>移除RainforestCardCell的backgroundImageNode属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  // var backgroundImageNode: ASImageNode? ///&lt; REMOVE THIS LINE
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，这个APP就如之前一样，但现在你的图像Node在容器Node内，而重用依然和它应有的方式一样.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<h2>cell内容</h2>

<p>目前为止你有了一个Node层级结构，但容器内还只有一个Node&ndash;图像Node.现在是时候设置Node层次结构去复制在添加AsyncDisplayKit之前时应用的视图层次结构了。这意味着添加text和一个未模糊的特征图像。</p>

<h3>添加特征图像</h3>

<p>我们要添加特征图像了，它是一个未模糊的图像，显示在卡片的顶部。</p>

<p>打开RainforestCardCell.swift ，并找到configureCellDisplayWithCardInfo(cardInfo:).在Node Creation Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let featureImageNode = ASImageNode()
</span><span class='line'>featureImageNode.layerBacked = true
</span><span class='line'>featureImageNode.contentMode = .ScaleAspectFit
</span><span class='line'>featureImageNode.image = image</span></code></pre></td></tr></table></div></figure>


<p>这会创建并配置一个叫做featureImageNode的ASImageNode常量。它被设置为Layer支持的，放大以适用，并设置显示图像，这次不需要模糊。</p>

<p>在Node Hierarchy Section的最后，添加featureImageNode为containerNode的subNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(featureImageNode)
</span></code></pre></td></tr></table></div></figure>


<p>你正在用更多Node填充容器哦!</p>

<p>在Node Layout Section中，使用FrameCalculator布局featureImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>featureImageNode.frame = FrameCalculator.frameForFeatureImage(
</span><span class='line'>  featureImageSize: image.size,
</span><span class='line'>  containerFrameWidth: containerNode.frame.size.width)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你就会看到特征图像在卡片的顶部出现，位于模糊图像的上方，注意特征图像和模糊图像是如何在同一时间跳出。这是你之前添加的shouldRasterizeDescendants在起作用.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0015.png" alt="logo" /></p>

<h2>添加Title文本</h2>

<p>接下来添加文字Label,以显示动物的名字和描述，首先来添加动物名字吧。</p>

<p>继续configureCellDisplayWithCardInfo(cardInfo:),找到Node Creation Section。添加下列代码到这节尾部，就在创建featureImageNode之后：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode = ASTextNode()
</span><span class='line'>titleTextNode.layerBacked = true
</span><span class='line'>titleTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(cardInfo.name)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做titleTextNode的AsTextNode常量。</p>

<p>ASTextNode是另一个AsyncDisplayKit提供的Node子类，其用于显示文本。他是一个具有UIlabel效果的Node.它接受一个attributedString,由TextKit支持，有许多特性如文本链接，要学到更多关于这个Node的功能，去看ASTextNode.h吧。</p>

<p>初始羡慕包含一个NSAttributedString的扩展，它提供了一个工厂方法去生成一个属性字符串用于Title和Description文本以显示在雨林卡片上。上面的代码使用了这个扩展的attributedStringForTitleText(&hellip;) 方法。</p>

<p>现在在Node Hierarchy Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>这就添加了titleTextNode到Node层次结构里，它将位于特征图像和背景图像智商，因为它在它们之后添加。</p>

<p>在Node Layout Section底部添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame = FrameCalculator.frameForTitleText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>一样使用FrameCalculator布局titleTextNode,就像backgroundImageNode和featureImageNode那样。</p>

<p>编译运行，你就有了一个title显示在特征图像的顶部。再次说明，Label只会在整个Cell准备好渲染时才渲染。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0017.png" alt="logo" /></p>

<h2>添加Description文本</h2>

<p>添加一个有着Description文本的Node和添加Title文本的Node类似.</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:),在 Node Creation Section 最后，添加如下代码。就在之前创建titleTextNode的语句之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let descriptionTextNode = ASTextNode()
</span><span class='line'>descriptionTextNode.layerBacked = true
</span><span class='line'>descriptionTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>descriptionTextNode.attributedString = 
</span><span class='line'>  NSAttributedString.attributedStringForDescriptionText(cardInfo.description)</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做descriptionTextNode的AStextNode实例。</p>

<p>在 Node Hierarchy Section最后，添加descriptionTextNode到containerNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>在 Node Layout Section,一样使用FrameCalculator布局descriptionTextNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>descriptionTextNode.frame = FrameCalculator.frameForDescriptionText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，现在你能看到Description文本了。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0018.png" alt="logo" /></p>

<h2>自定义Node子类</h2>

<p>目前为止，你使用了ASImageNode和AStextNode,但有些时候你需要自己定义Node,就如同某些时候在传统的UIKit编程里你需要自己的View一样。</p>

<h3>创建梯度Node类</h3>

<p>接下来，你将给GradientView.swift 添加Core Graphics 代码来构建一个自定义的梯度Display Node,这回被用于创建一个绘制梯度的自定义Node.梯度图会显示在特征图像的地步以便让Title看起来更加明显。</p>

<p>打开Layers-Bridging-Header.h，并添加如下代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>需要这一步是因为这个类没有包含在主头文件中，你在子类化任何ASDisplayNode或者_ASDisplayLayer时都需要访问这个类。</p>

<p>菜单 File\New\File… 。选择 iOS\Source\Cocoa Touch Class 。命名类为 GradientNode 并使其作为 ASDisplayNode 的子类。选择 Swift 语言并点击 Next 。保存文件再打开 GradientNode.swift 。</p>

<p>添加如下方法到这个类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如同Uiview或者CALayer,你可以子类化ASDisplayNode去做自定义绘制。你可以使用如同用于UIView的Layer或单独的CALayer的绘制代码，这取决于客户Node如何配置Node.查看ASDisplayNode+Subclasses.h 获取更多关于子类化 ASDisplayNode 的信息。</p>

<p>进一步，ASDisplayNode的绘制方法比在UIView和CALayer里接受更多参数，给你提供方法少做工作，更有效率。</p>

<p>要为你的自定义DisplayNode填充内容，你需要实现来自<em>ASDisplayLayerDelegate协议的drawRect(&hellip;) 或 displayWithParameters(&hellip;)。在继续之前，看看 </em>ASDisplayLayer.h 得到这个方法和它们参数的信息。搜索_ASDisplayLayerDelegate。重点看看头文件注释里关于drawRect(..)的描述。</p>

<p>因为梯度图位于特征图的上方，使用Core Graphics 绘制，所以你需要使用drawRect.</p>

<p>打开GradientView.swift 并拷贝drawRect(&hellip;)的内容到GradientNode.swift 的drawRect(&hellip;)，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>  let myContext = UIGraphicsGetCurrentContext()
</span><span class='line'>  CGContextSaveGState(myContext)
</span><span class='line'>  CGContextClipToRect(myContext, bounds)
</span><span class='line'>
</span><span class='line'>  let componentCount: UInt = 2
</span><span class='line'>  let locations: [CGFloat] = [0.0, 1.0]
</span><span class='line'>  let components: [CGFloat] = [0.0, 0.0, 0.0, 1.0,
</span><span class='line'>    0.0, 0.0, 0.0, 0.0]
</span><span class='line'>  let myColorSpace = CGColorSpaceCreateDeviceRGB()
</span><span class='line'>  let myGradient = CGGradientCreateWithColorComponents(myColorSpace, components,
</span><span class='line'>    locations, componentCount)
</span><span class='line'>
</span><span class='line'>  let myStartPoint = CGPoint(x: bounds.midX, y: bounds.maxY)
</span><span class='line'>  let myEndPoint = CGPoint(x: bounds.midX, y: bounds.midY)
</span><span class='line'>  CGContextDrawLinearGradient(myContext, myGradient, myStartPoint,
</span><span class='line'>    myEndPoint, UInt32(kCGGradientDrawsAfterEndLocation))
</span><span class='line'>
</span><span class='line'>  CGContextRestoreGState(myContext)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后删除GradientView.swift,确保编译没有错误</p>

<h3>添加梯度Node</h3>

<p>打开RainforestCardCell.swift并找到configureCellDisplayWithCardInfo(cardInfo:)，在Node Creation Section底部，添加如下代码，就在创建descriptionTextNode的代码之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let gradientNode = GradientNode()
</span><span class='line'>gradientNode.opaque = false
</span><span class='line'>gradientNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做gradientNode的GradientNode常量。</p>

<p>在Node Hierarchy Section，在添加featureImageNode那样下面，添加gradientNode到containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)
</span><span class='line'>containerNode.addSubnode(featureImageNode)
</span><span class='line'>containerNode.addSubnode(gradientNode) ///&lt; ADD THIS LINE
</span><span class='line'>containerNode.addSubnode(titleTextNode)
</span><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>梯度Node需要这个位置才能在特征图之后，Title之下。</p>

<p>然后添加如下代码到Node Layout Section底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gradientNode.frame = FrameCalculator.frameForGradient(
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你将看到梯度在特征图的底部，title确实看的更清楚了</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>爆米花特效</h2>

<p>如之前提到的，cell的Node内容会在完成绘制时“弹出”，这不是很理想，所以让我们继续，以修复这个问题，但首先，更加深入AsyncDisplayKit以看看它是怎么工作的。</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:) 的Container Node Creation Section，关闭容器Node的shouldRasterizeDescendants：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = false</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你会注意到现在容器层次结构里不同的Node一个接一个的弹出。你会看到文字弹出然后是特征图，然后是模糊背景图。</p>

<p>当shouldRasterizeDescendants关闭后，AsyncDisplayKit就不是绘制一个容器Layer了，它会创建一个镜像卡片Node层次结构的Layer数。记得爆米花特效存在是因为每个Layer都在它绘制结束后立即出现，而某些Layer比另外一个花费更多时间在绘制上。</p>

<p>这不是我们所需要的，但它描述了AsyncDisplayKit的工作方式，我们不想要这个行为，所以还是将shouldRasterizeDescendants打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = true</span></code></pre></td></tr></table></div></figure>


<h2>在后台构造Node</h2>

<p>除了异步的绘制，使用AsyncDisplayKit,你同样可以异步地创建，配置以及布局。深呼吸一下，接下来开始做事情。</p>

<h3>创建一个Node构造操作(OPeration)</h3>

<p>你要讲Node层次结构的构造包装到一个NSOperation中，这样做很棒，因为这个操作能很容易的在不同的操作队列中执行，包括后台队列。</p>

<p>打开RainforestCardCell.swift ，然后添加如下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func nodeConstructionOperationWithCardInfo(cardInfo: RainforestCardInfo, image: UIImage) -&gt; NSOperation {
</span><span class='line'>  let nodeConstructionOperation = NSBlockOperation()
</span><span class='line'>  nodeConstructionOperation.addExecutionBlock { 
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>  return nodeConstructionOperation
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>绘制并不是唯一会拖慢主线程的操作，对于复杂的屏幕，布局计算也有可能变得昂退。目前为止，本教程当前状态的项目，一个缓慢的Node布局会引起Collectionview丢帧。</p>

<p>60FPS意味着你有大约17ms的时间让你的cell准备好显示，否则一个或者多个帧就会被丢掉。这在Table view和 collection view有很复杂的cell时时非常常见的，滑动时丢帧就是这个原因。</p>

<p>AsyncDisplayKit前来救援</p>

<p>你将使用上面的nodeConstructionOperation将所有Node层次结构以及布局从主线程剥离并放入后台NSOperatonQueue，进一步确保Collection view能尽量以接近60 fps的帧率滑动。</p>

<blockquote><p><em>注意</em>
你可以在后台访问并设置Node的属性，但只能在Node的Layer或View被创建之前，也就是当你第一次访问Node的Layer或View属性时。</p></blockquote>

<p>一旦Node的Layer或View被创建，你必须在主线程才能访问和设置Node的属性，因为Node将会转发这些调用到它的Layer或View.如果你得到一个崩溃log说“Incorrect display node thread affinity”,那就意味着在创建Node的Layer或View之后，你依然尝试在后台访问或设置Node的属性。</p>

<p>修改nodeConstructionOperation 操作Block的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nodeConstructionOperation.addExecutionBlock {
</span><span class='line'>  [weak self, unowned nodeConstructionOperation] in
</span><span class='line'>  if nodeConstructionOperation.cancelled {
</span><span class='line'>    return
</span><span class='line'>  }
</span><span class='line'>  if let strongSelf = self {
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个操作运行时，cell可能已经被释放了，在那种情况下，你不需要做任何工作。类似的，如果操作被取消了，那一样也没有工作要做了。</p>

<p>之所以对nodeConstructionOperation使用 unowner无主引用是为了避免在操作和执行必要之间产生循环引用。</p>

<p>现在找到configureCellDisplayWithCardInfo(cardInfo:)。将任何在Image Size Section之后的代码移动到nodeConstructionOperation的执行闭包里，将代码放在strongSelf的条件语句里，即 TODO的位置，之后configureCellDisplayWithCardInfo(cardInfo:)将开起来如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>目前，你会有一些编译错误，这是因为操作Block里的self是weak引用，因此是可选的。但你有一个self的strong引用，因为代码在可选绑定语句内。所以替换错误的几行成下面的样子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>strongSelf.contentLayer = containerNode.layer
</span><span class='line'>strongSelf.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>最后，添加如下代码到你刚改动的三行之下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.setNeedsDisplay()</span></code></pre></td></tr></table></div></figure>


<p>编译确保没有错误。如果你现在运行，那么之后占位图会显示，因为Node的创建操作还没有实际使用。让我们来添加它</p>

<h3>使用Node创建操作</h3>

<p>打开 RainforestCardCell.swift 并添加如下属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  var nodeConstructionOperation: NSOperation? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就添加了一个叫做nodeConstructionOperation可选属性。
当Cell准备回收时，你会使用这个属性取消Node的构造。这会在用户非常快速地滑动Collection View时发生，特别是如果布局还需要一些计算时间的话。</p>

<p>在prepareForReuse()添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let operation = nodeConstructionOperation {
</span><span class='line'>    operation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  contentLayer = nil
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就在cell重用时取消了操作，所以如果Node创建还没完成，它也不会完成。</p>

<p>现在找到 configureCellDisplayWithCardInfo(cardInfo:) ,并添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let oldNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    oldNodeConstructionOperation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个Cell现在会在它准备重用并开始配置时，取消任何进行中的 Node构造操作。这确保了操作被取消，即使cell在准备重用前就被重新配置。</p>

<p>在主线程运行</p>

<p>AsyncDisplayKit允许你在非主线程做许多工作。但当它要面对UIKit和CoreAnimation时，你还是需要在主线程做。目前为止，你从主线程移走了所有的Node创建，但还有一件事需要被放在主线程&ndash;即设置coreAnimation的Layer层次结构。</p>

<p>在RainforestCardCell.swift里，找到nodeConstructionOperationWithCardInfo(cardInfo:image:) 并替换Node Layer and Wrap Up Section 为如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>dispatch_async(dispatch_get_main_queue()) { [weak nodeConstructionOperation] in
</span><span class='line'>  if let strongNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    // 2
</span><span class='line'>    if strongNodeConstructionOperation.cancelled {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 3
</span><span class='line'>    if strongSelf.nodeConstructionOperation !== strongNodeConstructionOperation {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 4
</span><span class='line'>    if containerNode.preventOrCancelDisplay {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 5
</span><span class='line'>    //MARK: Node Layer and Wrap Up Section
</span><span class='line'>    strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>    containerNode.setNeedsDisplay()
</span><span class='line'>    strongSelf.contentLayer = containerNode.layer
</span><span class='line'>    strongSelf.containerNode = containerNode
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面描述一下:</p>

<ol>
<li>回忆当Node的Layer属性被第一个访问时，所有的Layer会被创建。这就是为何你必须运行Node Layer并在主线程包装小节，因此代码访问Node的Layer.</li>
<li>操作被检查以确定是否在添加Layer之前就已经取消了。在操作完成前，cell被重用或者重新配置，就很可能出现这样的情况，那你就不应该添加Layer了。</li>
<li>作为一个保险，确保Node当前的nodeConstructionOperation和调度闭包的操作是同一个NSOperation</li>
<li>如果containerNode的preventOrCancel是true就立即返回。如果构造操作完成，但node的绘制还没有被取消，你依然不想Node的layer现在在cell里</li>
<li>最后，添加Node的Layer到层次结构中，如果必要，这就创建Layer.</li>
</ol>


<p>编译确保没有错误</p>

<h3>开始Node创建操作</h3>

<p>你依然没有实际创建和开始操作，让我们开始吧</p>

<p>继续在RainforestCardCell.swift里，改变configureCellDisplayWithCardInfo(cardInfo:) 的方法签名为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(
</span><span class='line'>  cardInfo: RainforestCardInfo,
</span><span class='line'>  nodeConstructionQueue: NSOperationQueue)</span></code></pre></td></tr></table></div></figure>


<p>这里添加了一个新的参数nodeConstructionQueue.它就是一个用于Node创建操作入队的NSOperationQueue.</p>

<p>在func configureCellDisplayWithCardInfo(
  cardInfo: RainforestCardInfo,
  nodeConstructionQueue: NSOperationQueue) 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let newNodeConstructionOperation = nodeConstructionOperationWithCardInfo(cardInfo, image: image)
</span><span class='line'>nodeConstructionOperation = newNodeConstructionOperation
</span><span class='line'>nodeConstructionQueue.addOperation(newNodeConstructionOperation)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个Node构造操作，将其保留在nodeConstructionOperation属性，并将其添加到传入的队列。</p>

<p>最后打开 RainforestViewController.swift ，给RainforestViewController添加一个叫做nodeConstructionQueue 的初始化为常量的属性，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestViewController: UICollectionViewController {
</span><span class='line'>  let rainforestCardsInfo = getAllCardInfo()
</span><span class='line'>  let nodeConstructionQueue = NSOperationQueue() ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，在collectionView(collectionView:cellForItemAtIndexPath indexPath:)里，传递View Controller的 nodeConstructionQueue到 configureCellDisplayWithCardInfo(cardInfo:nodeConstructionQueue:) ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.configureCellDisplayWithCardInfo(cardInfo, nodeConstructionQueue: nodeConstructionQueue)</span></code></pre></td></tr></table></div></figure>


<p>cell将会创建一个新的Node构造操作并将其添加到ViewControler的操作队列里并发运行。记住在cell出队时就会创建一个新的Node层次结构。这并不理想，但足够好。如果你要缓存Node的重用，看看ASRangeController 吧</p>

<p>OK，编译运行，你讲看到和之前一样的效果，但现在布局和渲染都没在主线程执行了，牛！我打赌你从来没有想过你看到这一天你所做的事情，这就是AsyncDisplayKit的威力。你可以将更多不需要再主线程操作从主线程中移除，这将给主线程更多机会处理和用户的交互，让你的App摸起来如黄油般顺滑</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>淡入Cell</h2>

<p>在这个就简短的章节，你将会学到:</p>

<ul>
<li>用自定义的Display Layer子类来支持Node</li>
<li>触发Node Layer的隐式动画</li>
</ul>


<p>这将会确保你的移除爆米花特效并最终带来良好的淡入动画</p>

<p>创建一个新的Layer子类.</p>

<p>菜单 File\New\File… ，选择 iOS\Source\Cocoa Touch Class 并单击Next.命名类为AnimatedContentsDisplayLayer并使其作为_ASDisplayLayer子类。选择 Swift语言并单击Next.最后保存并打开AnimatedContentsDisplayLayer.swift .</p>

<p>现在添加如下方法到类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func actionForKey(event: String!) -&gt; CAAction! {
</span><span class='line'>  if let action = super.actionForKey(event) {
</span><span class='line'>    return action
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  if event == "contents" && contents == nil {
</span><span class='line'>    let transition = CATransition()
</span><span class='line'>    transition.duration = 0.6
</span><span class='line'>    transition.type = kCATransitionFade
</span><span class='line'>    return transition
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Layer有一个contents属性，它告诉系统为这个Layer绘制什么，AsyncDisplayKit通过在后台渲染contents并最后在主线程设置contents</p>

<p>这个代码将会添加一个过渡动画，这样contents就会淡入到View中，你可以在Apple的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html">Core Animation Prgramming Guide</a>找到更多关于隐式Layer动画</p>

<p>打开 RainforestCardCell.swift。在nodeConstructionOperationWithCardInfo(cardInfo:image:) 里，在Container Node Creation Section开头，改动如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// REPLACE THIS LINE...
</span><span class='line'>// let containerNode = ASDisplayNode()
</span><span class='line'>// ...WITH THIS LINE:
</span><span class='line'>let containerNode = ASDisplayNode(layerClass: AnimatedContentsDisplayLayer.self)</span></code></pre></td></tr></table></div></figure>


<p>这会告诉容器Node使用AnimatedContentsDisplayLayer实例作为其支持Layer,因此自动带来淡入效果</p>

<blockquote><p><em>注意</em>
只有_ASDisplayLayer的子类才能被异步地绘制</p></blockquote>

<p>编译运行，你讲看到容器Node会在其绘制好之后淡入.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0023.png" alt="logo" /></p>

<h2>完整工程</h2>

<p><a href="https://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Layers-Finished-7.3.zip">完整工程</a>请在这里下载!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过一个Demo详解UIStackView]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-%5B%3F%5D-ge-demoxiang-jie-uistackview/"/>
    <updated>2016-04-04T19:48:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-[?]-ge-demoxiang-jie-uistackview</id>
    <content type="html"><![CDATA[<p><a href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/">在上一个章节</a>我们已经介绍了什么是UIStackView了，其实它更类似于Android开发中的LinerLayer排版技术。</p>

<p>这一章节，我们通过一个完整的例子来讲解UIStackView的用法</p>

<!--more-->


<h2>开始</h2>

<p>下下载这个<a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip">开始工程</a>,下载完毕后，用Iphone6 模拟器运行起来，你将会看到一个度假旅游的列表</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/01-table-view-is-now-correct_750x1334-281x500.png" alt="logo" />
点击第一行cell,咋看，这个视图没有什么问题，但是你仔细观察，就会发现有几个问题:</p>

<ol>
<li>看视图的下面的那一排按钮，它们中间都有一定间隙规则布局，但是它们并没有适配整个屏幕的布局，看着挺丑的，临时转换屏幕landscape orientation,通过 <code>Command-left</code></li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt="logo" /></p>

<ol>
<li>在详情页面，点击hidden按钮，它成功地隐藏了文字，但是下面的内容并没有顶上去，中间一片空白
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/03-hide-weather-issue_750x1334-281x500.png" alt="logo" /></li>
</ol>


<p>现在你已经有几点好的建议去提升app的体验，现在让我们开始切入这个工程</p>

<p>打开Main.storyboard然后找到 <code>Spot Info View Controller</code>,这里有一些颜色在stackView中。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/04-colorful-scene-in-storyboard_504x636-396x500.png" alt="logo" /></p>

<p>这些标签和按钮已经有几种不同颜色的背景色，但是在运行时他们的背景色就是透明的，在这个storyboard中，他们仅仅是为了帮助你展示stackView是怎么改变属性影响嵌套的子视图</p>

<p>你不需要做这些，但是从另一个观点来说你实际上喜欢去看看这些背景色当运行程序的时候，你能临时做些改变在SpotInfoViewController的viewDidLoad()中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Clear background colors from labels and buttons
</span><span class='line'>for view in backgroundColoredViews {
</span><span class='line'>  view.backgroundColor = UIColor.clearColor()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，其它标签都有占位符文字说明，他们仅仅是为了让你区分哪些是和后台连接的。哪些是描述什么内容的。例如<code>&lt;whyVisitLabel&gt;</code>是连接</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@IBOutlet weak var whyVisitLabel: UILabel!</span></code></pre></td></tr></table></div></figure>


<p>另外一个需要注意的是在这个storyboard中不是默认的 600 x 600,当你使用SizeClass的时候。</p>

<p>SizeClass总是可用的，但是初始化Navigation Controller 默认是总是iPhone 4-inch在模拟器下，这个是容易的在storyboard中，这个模拟器在启动的时候是不受影响的，这个视图将会动态适应不同的设备。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/05-simulated-metrics-iphone-4-inch_639x173.png" alt="logo" /></p>

<h2>你的第一个StackView</h2>

<p>第一件事是你将通过一个stackView修复最下面一排按钮的间距，一个stackView能描述在不不同轴向的布局（横向坐标和纵向坐标），其中之一就是子视图之间的距离设置。</p>

<p>幸运的是，修改已经存在的View在一个stackView中并不复杂，选中 <code>Spot Info View Controller</code>底部的所有按钮</p>

<p>检查这三个按钮是不是都选择上了，打开左边的控件面板查看，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/08-verify-button-selection_360x90.png" alt="logo" /></p>

<p>一旦选中了，在storyboard的右下角点击new Stack button
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/09-stack_button_outlined_148x52.png" alt="logo" /></p>

<p>这个按钮将会变成嵌入式的在stackView中</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/10-bottom-row-is-now-in-stack-view_640x100.png" alt="logo" /></p>

<p>这些按钮看起来不是平滑的，稍后我们将会修复</p>

<p>当这个stackView开始嵌套这些按钮的时候，我们将要添加自动布局给这个stackView</p>

<p>当你嵌套一个视图在一个stackView中，这个视图的任何约束都会被移除，例如，在嵌套到stackView之钱，在最前面的那个按钮<code>Submit Rating</code>有个垂直距离的约束和<code>Rating:</code>label之间:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/11-prior-constraint_420x90.png" alt="logo" /></p>

<p>点击<code>Submit Rating</code>按钮去看看是否还有这个约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/12-no-more-constraints_400x80.png" alt="logo" /></p>

<p>为了给stackView添加约束，首先你必须选中它，一个简单的方式去选择这个stackView在outline View:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" />
另外一种方式是按住 shift&amp;Right-click 在你想选择的视图上，或者按钮 <code>control</code>+<code>shift</code>+<code>左键点击</code>在你想要选择的视图上，你将会看到一个菜单视图，供你选择。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt="logo" /></p>

<p>现在，点击pin按钮在自动布局的工具条上  去 添加约束。</p>

<p>首先检查Constrain to margins，然后添加下载的约束:</p>

<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 0
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/17-bottom-stack-view-constraints_264x364.png" alt="logo" /></p>

<p>现在，这个stackVeiw是正确的尺寸，但是它有一点拉伸第一个按钮，因为它要去利用多余的空间。</p>

<p>stackView有个<code>distribution</code>属性来决定子视图的布局，当前，它是fill,这意味着包含的子视图都会完全填充stackview剩下的空间，为了修补这个，这个stackView将要展开其中的一个子视图去填补这个多余的空间</p>

<p>然而，你并不期望这个按钮完全填充stackView，你想让他们占用相同的空间。</p>

<p>选中这个stackView,然后修改它的属性<code>Distribution</code>从<code>Fill</code>到<code>Equal Spacing:</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/19-change-distribution-to-equal-spacing_640x148.png" alt="logo" /></p>

<p>现在编译运行，点击这个cell.旋转屏幕，你将会看到底部的按钮平分在屏幕的底部，是不是很酷呢!
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt="logo" /></p>

<p>如果不使用stackView来解决这个问题，你不得不使用sapce views，在没两个按钮之间，你的加入等比宽度的约束。很是麻烦。
它看起来像是下面这样，这中间的space View看起来有点灰色</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/21-alternate-solution-1_346x76.png" alt="logo" /></p>

<p>这个问题还是不是很大在一个storyboard中，但是很多视图都是动态的，这就不是一个简单的任务了，在运行时去增加一个按钮或者隐藏一个按钮，因为需要去调节视图和约束之间的关系。</p>

<p>为了在一个stack view中隐藏一个视图，你不得不设置子视图的hidden属性为true.现在你将要修复之前说过的那个问题，就是当点击 hidden之后，文字消失，下面的多余空间要顶上去。</p>

<h2>转换Sections</h2>

<p>你将要转换所有的section用stack view中，这将要确保你容易的完成你的任务，下一步你将要转换 rating section.</p>

<h3>Rating section</h3>

<p>定位到你刚才的页面，然后选择<code>RATING</code>标签和 星星的视图：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/22-select-rating-label-and-stars-label_640x74.png" alt="logo" />
然后点击 stack按钮让其嵌套在一个stackView中。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/23-after-clicking-stack-button_640x74.png" alt="logo" />
 现在，点击PIN按钮，添加下面三个属性:</p>

<pre><code class="`"> Top: 20, Leading: 0, Bottom: 20
</code></pre>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/24-add-second-stack-view-constraints_264x171.png" alt="logo" /></p>

<p> 现在切换到<code>Attributes inspector</code>，设置 spacing为8:
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/25-set-spacing-to-8_259x87.png" alt="logo" /></p>

<p> 这时，你看到视图上的两个控件之间已经有些间距了，
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/26-stars-label-weirdly-stretched_640x85.png" alt="logo" />
 有时候，xcode可能提示你stackview的位置是不正确的，但是这些警告将会消失，当你更新其它控件的时候，你通常可以忽略他们。</p>

<p>为了证明这个，改变 <code>Alignment</code>从<code>Fill</code>到<code>Top</code>然后再改为Fill,你将会看到这个stars 标签变成正确的位置了。</p>

<p>编译运行你的app,一切看起来还是和从前一样.</p>

<h2>取消嵌套一个Stack View</h2>

<p>在你深入学习之前，去进行一些"急救"训练，有时，你会发现你的视图上有一个你不再需要的stackview,或许你为了练习而导致的事故。</p>

<p>幸运的是，这里有容易的方式去移除一个嵌套的view从stack view中。</p>

<p>首先，你最好选择你想要删除的stack view,按住<code>Option</code>键，然后点击 <code>stack</code>按钮，点击 <code>Unembed</code>菜单就可以了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/28-how-to-unembed_186x71.png" alt="logo" /></p>

<h2>你的第一个垂直Stack view</h2>

<p>现在，你将要创建一个垂直的stack view,选中<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/29-select-why-visit-labels_640x90.png" alt="logo" />
Xcode将会正确的推断出这个视图将会需要一个垂直的stack view,点击<code>Stack</code>按钮去嵌套它们到一个stack view中。</p>

<p>当stack view添加成功之后，嵌套的视图的约束将会给删除，当前的这个stack view没有任何约束，所以它会适配子视图中最大尺寸的。</p>

<p>当这个stack view选中的时候，点击 Pin按钮，设置如下属性:
Top, Leading and Trailing 都为0</p>

<p>然后，点击dropdown在右下角，然后选择<code>WEATHER (current distance = 20):</code></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/31-dont-select-nearest-neighbor-constraint_463x417.png" alt="logo" /></p>

<p>最后，添加这4个约束，你将会看到如下结果：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/32-why-visit-stack-view-stretched_640x90.png" alt="logo" />
现在你有两个一个展开的stackview,它的右边界是定位到了视图的右边界，然而，这下面的标签依然是同样宽的，你将要修复它通过stack view的<code>alignment</code>属性</p>

<h2>Alignment属性</h2>

<p>这个alignment属性决定了stack view在其轴向上的布局方式，可能是Fill,Leading,Center和Trailing.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/33-horizontal-and-vertical-alignment_594x171.png" alt="logo" /></p>

<p>在垂直的stackview中，选择不同的属性，将会看到不同的布局:</p>

<p>Fill:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/34-alignment-fill_640x64.png" alt="logo" /></p>

<p>Leading:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/35-alignment-leading_640x64.png" alt="logo" /></p>

<p>Center:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/36-alignment-center_640x64.png" alt="lgo" /></p>

<p>Trailing:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/37-alignment-trailing_640x64.png" alt="lgo" /></p>

<p>当你测试完每个属性值后，最后设置成Fill</p>

<p>编译运行程序看起来是OK的，特别需要指出的是，<code>Fill</code>意味着你想要所有的视图都是完全占用空间在其轴向上，这将引起<code>WHY VISIT</code>标签去展开它到右边缘。</p>

<p>但是如果你只想下面的label张开到右边缘，此时该怎么做呢?</p>

<h2>转换"what to see"模块</h2>

<p>这个转换和上面的那个很相似，介绍如下:</p>

<ol>
<li>首先，选择<code>WHAT TO SEE</code>标签和<code>&lt;whatToSeeLabel&gt;</code></li>
<li>点击<code>Stack</code>按钮</li>
<li>点击<code>Pin</code>按钮</li>
<li>设置<code>margins</code>约束，添加下面4个约束</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<ol>
<li>设置stack view的Alignment为FIll</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/39-after-what-to-see-section_640x308.png" alt="logo" />
编译运行你的工程，验证页面是不是看起来和之前一样。</p>

<p>剩下就是这个<code>weather</code>模块了</p>

<h2>转换weather模块</h2>

<p>这个weather模块比其他几个稍微复杂一些，因为它包含了一个hidden按钮</p>

<p>一种方法是你将会创建一个最近的stacview通过嵌套<code>WEATHER</code>标签和<code>Hide</code>按钮在一个水平的stackview中，然后嵌套水平的stackview和<code>&lt;weatherInfoLabel&gt;</code>到一个垂直的stackview中。</p>

<p>看起来你像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/40-weather-stack-in-stack_640x92.png" alt="lgo" /></p>

<p>点击<code>Stack</code>按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/43-weather-click-stack-button_640x92.png" alt="logo" /></p>

<p>然后点击 Pin按钮，设置margin约束,设置如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<p>设置 stack view的Alignment为Fill
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/44-weather-alignment-fill_640x92.png" alt="logo" /></p>

<p>你需要一个在hide按钮和<code>WEATHER</code>标签的右边加一个约束，因为<code>WEATHER</code>标签被加到了stack view中，它的所有约束都被自动去掉了.</p>

<p>然后，你希望底部的<code>&lt;weatherInfoLabel&gt;</code>去填充整个stack view.</p>

<p>你可以完成这个通过把<code>WEATHER</code>嵌套进一个垂直的stack view中，记住垂直stackview可以设置alignment为 .Leading,假如stack view是拉伸的超出了它固有的边界，它包含的子视图将会到达它的边界。</p>

<p>选择<code>WEATHER</code>标签通过document outline，或者通过<code>Control-Shift-click</code>方法:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/45-select-just-the-weather-label_640x92.png" alt="logo" /></p>

<p>点击 stack按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/46-weather-in-horizontal-stack_640x92.png" alt="lgo" /></p>

<p>设置Alignment为Leading,然后确保axis是垂直方向:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/47-vertical-and-leading_640x92.png" alt="log" /></p>

<p>完美！你已经完成了外部的stackview平铺，在嵌套的stackView中去填充它的宽度，但是内部的stackview允许这个标签去保持它原有的宽度。</p>

<p>编译运行，为什么hide按钮现在飘到上面去了呢？
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/48-hide-label-incorrect-position_750x573-419x320.png" alt="dlo" /></p>

<p>它是因为当你嵌套<code>WEATHER</code>标签到一个stackview中时，它的所有和hide按钮相关的约束都被移除掉了。</p>

<p>现在你需要给hide按钮和<code>WEATHER</code>标签之间增加新的约束,按住<code>control-drag</code>从Hide按钮拖向<code>WEATHER</code>标签:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/49-drag-to-weather-label_380x94.png" alt="logo" /></p>

<p>添加两个约束:</p>

<ol>
<li>Horizontal Spacing</li>
<li>Baseline</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/50-add-multiple-constraints_380x224.png" alt="logo" />
编译运行，这个Hide按钮看起来正常了。</p>

<p>现在所有的模块都是在唯一的stackview中了，你把他们全部都嵌套进了stackview中。</p>

<h2>设置第一级Stack view</h2>

<p>点击 <code>command</code> 然后选择所有的5个顶级的stackview在 outline view中
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/52-select-all-stack-views-in-outline_640x260.png" alt="log" /></p>

<p>然后点击stack按钮：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/53-stack-all-the-views_640x185.png" alt="lgo" /></p>

<p>点击Pin按钮，设置约束属性:
全部都设置成0.然后设置Spacing为20, Alignment为Fill,你的storyboard看起来像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt="g" /></p>

<p>编译运行，此时你的 hide按钮又跑偏了，和之前设置的一样，需要把hide和<code>WEATHER</code>重新建立约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/56-add-constraints-to-button-again_380x223.png" alt="d" /></p>

<p>编译运行，此时hide按钮在正确的位置上了。</p>

<h2>重新布局视图</h2>

<p>现在所有的的模块都在顶级的stackview中，你现在可以更改<code>what to see</code>模块的位置，比如和<code>weather</code>模块的位置进行互换。</p>

<p>选择<code>middle stack view</code>从outline view然后拖拽它和weather的那个stackview进行互换，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/57-drag-and-drop-to-reposition-section_639x130.png" alt="log" /></p>

<p>此时，<code>weather</code>模块是第三个模块，但是这个 hide按钮不是在stackview中，它不会被移动。</p>

<p>选中 Hide按钮 :
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/58-hide-button-not-moved_640x130.png" alt="logo" />
然后点击<code>Resolve Auto Layout Issues</code>在自动布局的菜单上点击 update frame:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/59-resolve-auto-layout-issues_356x269.png" alt="logo" /></p>

<h2>Size class based configuration</h2>

<p>最后，你能把你注意力集中到之前的任务清单上，在加载模式中，垂直空间是昂贵的，所以你想让stackview中的模块靠近些，为了做到这些，你将要使用size classes去设置顶部stackview的空间从20修改成10.</p>

<p>选中顶部的stackview然后点击小小的<code>+</code>号，设置spacing:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/61-select-plus-button_260x120.png" alt="log" /></p>

<p>选择 Any Width > Compact Height:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/62-anywidth-compact-height_403x108.png" alt="lgo" /></p>

<p>然后设置Spacing 为10,在 new wAny hC文本框中:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/63-set-spacing-to-10_260x160.png" alt="lgo" /></p>

<h2>动画</h2>

<p>打开SpotInfoViewController.swift文件，然后找到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code>方法</p>

<p>你将要替换这一行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>weatherInfoLabel.hidden = shouldHideWeatherInfo</span></code></pre></td></tr></table></div></figure>


<p>改成如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if animated {
</span><span class='line'>  UIView.animateWithDuration(0.3) {
</span><span class='line'>    self.weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>  }
</span><span class='line'>} else {
</span><span class='line'>  weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，点击<code>hide</code>和<code>show</code>按钮，会不会感觉出来有点动画效果呢?</p>

<p>在stackview中增加动画效果也是很容易的，比如hidden, alignment, distribution, spacing，甚至axis。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip">完整工程</a></p>

<p>希望能够帮到你~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIStackView介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/"/>
    <updated>2016-04-04T15:47:37+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao</id>
    <content type="html"><![CDATA[<p>UIStackView类提供了一个高效的接口用于平铺一行或一列的视图组合.Stack视图使你的依靠自动布局的能力，创建用户接口使得可以动态的调整设备的朝向，屏幕尺寸以及任何可用范围内的变化。Stack视图管理着所有它的 arrageedSubviews属性中视图的布局，这些视图根据它们在arrangedSubviews数组中的顺序沿着stack视图的轴向排列，精确的布局变量根据Stack视图的 axixs,distribution,allignment,spcing,和其它属性决定。</p>

<!--more-->


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/130054395519774.png" alt="logo" /></p>

<p>使用 Stack视图，打开一个你希望编辑的storyboard,从对象库中拖出一个Horizontal Stack View或者Vertical Stack View,并放置到你希望的位置上，下一步，将控件或视图拖拽到stack中，如果需要你可以继续添加视图或者控件给指定的statck.Interface buider将根据stack内容自动调节尺寸，你可以通过修改尚需经面板中stack视图的属性调整statck的外观.</p>

<h2>Stack视图与自动布局</h2>

<p>Stack视图使用自动布局来定位和控制其管理的视图的尺寸，stack视图沿着它的轴向拼凑第一个和最后一个被管理的视图，使其便捷平齐。对一个月水平stack视图，这意味着第一个被管理的视图的左边界是与stack的左边界对齐的，并且最后一个被管理的视图右边界与stack右边界是平齐的。对于垂直stack,上边界和下边界格式对齐的。如果你设置了stack视图的 <code>layoutMarginsRelativeArrangement</code>为YES,stack视图将使用相关的边距与其内容对齐，而不是边界。</p>

<p>对于除去<code>UIStackViewDistributionFillEqually</code>分布以外的分布方式，stack视图使用被管理视图的<code>intrinsicContentSize</code>属性来计算沿着stack轴向的视图尺寸，<code>UIStackViewDistributionFillEqually</code>分布将调节所有被管理视图的在stack轴向上拥有相同尺寸，以填充stack视图。如果可能，stack视图将拉伸所有被管理的视图，来匹配其在stack轴向上最长的原有尺寸。</p>

<p>对于除去<code>UIStackViewAlignmentFill</code>对齐以外的对齐方式，stack视图使用其管理的视图的<code>intrinsicContentSize</code>属性来计算视图垂直于stack轴向的尺寸。<code>UIStackViewAlignmentFill</code>重新调节了所有其管理的视图，使这些视图填充stack视图垂直于其轴向空间。如果可能，stack视图将拉伸所有管理的视图来匹配其垂直于stack轴向的最大固有尺寸。</p>

<h2>定位和调整Stack视图尺寸</h2>

<p>当stack视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位stack视图，通常情况下，这意味着需要皮凑至少两个边界相邻的stack来定义它的位置，没有额外约束的情况下，系统会为stack视图计算一个尺寸来适应其内容:</p>

<ul>
<li>沿着stack视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和</li>
<li>垂直于stack视图轴向，其适应尺寸等于其管理的视图中最大视图的尺寸</li>
<li>如果stack视图的<code>layoutMarginsRelativeArrangement</code>为YES,stack视图的适应尺寸会包括边距空间</li>
</ul>


<p>你可以提供额外的约束来具体说明stack视图的高度，宽度或者两者兼有，在这些情况下，stack视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据stack视图的属性获得。可以通过查看<code>UIStackViewDistribution</code>和<code>UIStackViewAlignment</code>枚举，已获得一个完整的stack视图。</p>

<p>你也可以根据stack视图的第一条或最后一条基线定位它，而不是使用顶部，底部或者中心Y值，类似于stack视图的适应尺寸，这些基线都是基于stack视图的内容计算得到的</p>

<ul>
<li><p>一个水平的stack视图调用 <code>viewForFirstBaselineLayout</code>方法或者 <code>viewForLastBaselineLayout</code>方法时返回它最高的视图。如果最高的视图也是一个stack视图，那么其返回的将是在嵌套的stack视图上调用<code>viewForFirstBaselineLayout</code>方法或者<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
<li><p>一个垂直的stack视图当调用 <code>viewForFirstBaselineLayout</code>方法时返回的是其管理的第一个视图，当调用<code>viewForLastBaselineLayout</code>方法时返回的是其管理的最后一个视图。如果这两个视图之一也是stack视图，那么其返回的将是在嵌套的stack视图上对应调用<code>viewForFirstBaselineLayout</code>方法或<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
</ul>


<blockquote><p><em>注意</em>
基线对齐方式只作用于那些高度匹配其原本内容高度的视图，如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。</p></blockquote>

<h2>通过Stack视图布局</h2>

<p>这有一些通用方法用于stack视图。这个清单是要高亮一些有用的实例来显示 stack视图的灵活性，目前这还不是一个完整的清单。</p>

<ul>
<li>只是定义位置. 你可以通过固定两个与其父视图相邻的边界来定义stack视图的位置。在这里，stack视图的尺寸将根据其管理的视图在两个维度上自由扩展。</li>
</ul>


<p>举个例子，在Figure 1中，stack视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基准线。这对于相对于其本身左对齐的stack视图内容是有效的。</p>

<p>Figure1定义位置
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" /></p>

<ul>
<li>定义沿着 stack视图轴向的尺寸。这里，你固定了沿着stack视图轴向相对于其父视图的两个边界，定义了stack视图沿着其轴向的尺寸。你将需要固定其它边界中的一个来定义stack视图的位置。stack视图将沿着其轴向改变尺寸和位置来填充定义的空间:然而，未固定的边界将根据其管理的最大视图的尺寸自动移动。</li>
</ul>


<p>举例Figure 2,stack视图的左，上，右边界都已经相对于其父视图固定了。使用<code>UIStackViewDistributionFill</code>分布是的其内容重设尺寸来填充它的高度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。</p>

<p>Figure2定义沿着stack视图轴向的尺寸</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/140059516762099.png" alt="logo" /></p>

<ul>
<li>定义垂直于stack视图轴向的尺寸。这类似于上一个实例，但是你固定了垂直于stack视图轴向的连个边界和沿着轴向的一个边界。这使得stack视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了
<code>UIStackViewDistributionFillEqually</code>分布，被管理的视图将跟根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其stack视图的对齐模式在其定义的范围内平铺。</li>
</ul>


<p>举例，Figure3展示了一个包含了四个标签和一个按钮的垂直stack视图。这个stack视图使用了8个点的间隙和<code>UIStackViewAlignmentCenter</code>对齐方式。stack视图的高度将根据stack内部元素的增减而增大或回缩。</p>

<p>FIgure3.定义垂直于stack视图轴向的尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140110013482874.png" alt="logo" /></p>

<ul>
<li>同时定义stack视图的位置和尺寸。这里你固定了stack视图的所有四个边界。stack视图将在提供的范围之内平铺其内容，举例，Figure4展示了一个所有四个边界都相对于其父视图固定的垂直stack视图。通过使用<code>UIStackViewAlignmentCenter</code>对齐方式和<code>UIStackViewDistributionFill</code>分布方式，stack视图确保其内容将水平和垂直居中填充屏幕，然后，获得想要的布局需要两个额外的步骤，默认情况下，stack视图会垂直拉伸标签而不是图片，要缩放图片控件，就要降低其内容紧凑优先级到低于标签，额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit.增加一个图片视图月stack视图间相等约束将有助于确保图片将被缩放来填充可用范围。</li>
</ul>


<p>Figure 4.同时定义stack视图的位置和尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140122324105787.png" alt="logog" /></p>

<h2>管理stack视图的展现</h2>

<p>UistackView是UIview的非渲染型子类。它没提供其自由的任何用户接口，相反地，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如backgroundCOlor)在stack视图上是无效的。类似的，你无法重写layerClass,drawRect等方法。</p>

<p>这里有一系列的属性来定义stack视图如何平铺其内容。</p>

<ul>
<li>axis(轴向)属性决定了stack的朝向，只有垂直和水平</li>
<li>distributin(分布)属性决定了其管理的视图在沿着其轴向上的布局</li>
<li>alignment(对齐)属性决定了其管理的视图在垂直于其轴向上的布局</li>
<li>spacing(空隙)属性决定了其管理的视图间的最小间隙</li>
<li>baselineRelativeArragement 属性决定了其视图间的垂直间隙是否根据基线测量得到</li>
<li>layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距</li>
</ul>


<p>通常情况下，你会使用一个stack视图来布局小数量的视图，你可以通过在其他stack视图上嵌套多个stack视图的方式创建更加复杂的视图层次结构。举例：Figure5展示乐意个包含两个水平stack视图的垂直stack视图。每一个水平stack视图各包含一个标签和一个文本框.</p>

<p>Figure 5.Stack 视图的嵌套
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140146204108925.png" alt="logo" /></p>

<p>你也可以通过增加被管理的视图的额外约束来完备的吊接一个被管理视图的展现，举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度，或者你可以定义一个长宽比。当平铺其内容时，stack视图将使用这些约束。举例来说，在Figure4中，当图片被压缩时，图片视图的一个长宽比约束被强行赋予了一个长宽比数。</p>

<blockquote><p><strong>注意</strong>
当给一个stack视图内的视图增加约束时要特别注意避免传入冲突，作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容的尺寸，那么你可以安全的在这个维度上增加约束</p></blockquote>

<h2>维护其惯例的视图与子视图之间的统一性</h2>

<p>Stack视图确保它的arragedSubveiws属性将一直是其 subviews属性的子集合。明确的说，stack视图强制实施了以下规定:</p>

<ul>
<li>无论何时stack视图增加了一个视图到它的arrangedSubviews数组，其也将把这个视图作为子视图增加，如果还未增加的话。</li>
<li>无论何时一个子视图从stack视图中移除，那么stack视图也将从从arrangedSubviews数组中移除.</li>
<li>从arrangedSubviews移除一个视图并不会将其作为姿势图移除。stack视图将不再管理改视图的尺寸和位置，但是该视图扔将是视图结构的一部分，并且当其可见的狂下仍会被渲染到屏幕上。</li>
</ul>


<p>当arrangedSubviews数组一直包含着subviews数组的自己和，这些数组间的顺序仍然是独立的。</p>

<ul>
<li>arrangedSubviews数组的顺序定义了展现在stack中的视图的顺序。对于水平stack视图，这些视图将以阅读顺序平铺，即最小索引的视图在较大索引视图的左侧。对于垂直stack视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。</li>
<li>subviews数组中的顺序定义了子视图在z轴上的顺序。如果视图重叠，有较小索引的子视图将出现在有家多音的子视图后方。</li>
</ul>


<h2>动态改变stack视图内容</h2>

<p>当视图被加入，移除或插入arrangedSubviews数组时，或当一个被管理的子视图的hidden属性改变时，stack视图都会自动更新它的布局。</p>

<p>Oc代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>firstView.hidden = YES;</span></code></pre></td></tr></table></div></figure>


<p>swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>firstView.hidden = true</span></code></pre></td></tr></table></div></figure>


<p>stack视图也会自动响应其任何属性的改变。举例，你可以更新stack视图的axis属性来动态改变朝向</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if (self.stackView.axis == UILayoutConstraintAxisHorizontal) {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisVertical;
</span><span class='line'>}else {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisHorizontal;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if stackView.axis == .Horizontal {
</span><span class='line'>    stackView.axis = .Vertical
</span><span class='line'>}else {
</span><span class='line'>    stackView.axis = .Horizontal
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于被管理的子视图的hidden属性的变化和stack视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画的方式展现。</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>[UIView animateWithDuration:0.25 animations:^{
</span><span class='line'>    UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>    firstView.hidden = YES;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>UIView.animateWithDuration(0.25) { () -&gt; Void in
</span><span class='line'>    let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>    firstView.hidden = true}</span></code></pre></td></tr></table></div></figure>


<h2>常用方法</h2>

<h3>创建Stack视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- initWithArrangedSubviews:  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>管理安排的子视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- addArrangedSubview: (New in iOS 9.0)
</span><span class='line'>  arrangedSubviews Property (New in iOS 9.0)
</span><span class='line'>- insertArrangedSubview:atIndex: (New in iOS 9.0)
</span><span class='line'>- removeArrangedSubview: (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>设置布局</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alignment Property  (New in iOS 9.0)
</span><span class='line'>axis Property  (New in iOS 9.0)
</span><span class='line'>baselineRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>distribution Property  (New in iOS 9.0)
</span><span class='line'>layoutMarginsRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>spacing Property  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>常量</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIStackViewDistribution
</span><span class='line'>UIStackViewAlignment</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解RunLoop]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/"/>
    <updated>2016-03-29T17:29:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loop() {
</span><span class='line'>    initialize();
</span><span class='line'>    do {
</span><span class='line'>        var message = get_next_message();
</span><span class='line'>        process_message(message);
</span><span class='line'>    } while (message != quit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
</span><span class='line'>static CFMutableDictionaryRef loopsDic;
</span><span class='line'>/// 访问 loopsDic 时的锁
</span><span class='line'>static CFSpinLock_t loopsLock;
</span><span class='line'>  
</span><span class='line'>/// 获取一个 pthread 对应的 RunLoop。
</span><span class='line'>CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
</span><span class='line'>    OSSpinLockLock(&loopsLock);
</span><span class='line'>     
</span><span class='line'>    if (!loopsDic) {
</span><span class='line'>        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
</span><span class='line'>        loopsDic = CFDictionaryCreateMutable();
</span><span class='line'>        CFRunLoopRef mainLoop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    /// 直接从 Dictionary 里获取。
</span><span class='line'>    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
</span><span class='line'>     
</span><span class='line'>    if (!loop) {
</span><span class='line'>        /// 取不到时，创建一个
</span><span class='line'>        loop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, thread, loop);
</span><span class='line'>        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
</span><span class='line'>        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    OSSpinLockUnLock(&loopsLock);
</span><span class='line'>    return loop;
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetMain() {
</span><span class='line'>    return _CFRunLoopGet(pthread_main_thread_np());
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetCurrent() {
</span><span class='line'>    return _CFRunLoopGet(pthread_self());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
</span><span class='line'>    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
</span><span class='line'>    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
</span><span class='line'>    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
</span><span class='line'>    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
</span><span class='line'>    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
</span><span class='line'>    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __CFRunLoopMode {
</span><span class='line'>    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
</span><span class='line'>    CFMutableSetRef _sources0;    // Set
</span><span class='line'>    CFMutableSetRef _sources1;    // Set
</span><span class='line'>    CFMutableArrayRef _observers; // Array
</span><span class='line'>    CFMutableArrayRef _timers;    // Array
</span><span class='line'>    ...
</span><span class='line'>};
</span><span class='line'>  
</span><span class='line'>struct __CFRunLoop {
</span><span class='line'>    CFMutableSetRef _commonModes;     // Set
</span><span class='line'>    CFMutableSetRef _commonModeItems; // Set
</span><span class='line'>    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
</span><span class='line'>    CFMutableSetRef _modes;           // Set
</span><span class='line'>    ...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
</span><span class='line'>CFRunLoopRunInMode(CFStringRef modeName, ...);</span></code></pre></td></tr></table></div></figure>


<p>Mode暴露的管理Mode Item的有下面几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</span><span class='line'>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoop {
</span><span class='line'>    current mode = kCFRunLoopDefaultMode
</span><span class='line'>    common modes = {
</span><span class='line'>        UITrackingRunLoopMode
</span><span class='line'>        kCFRunLoopDefaultMode
</span><span class='line'>    }
</span><span class='line'>  
</span><span class='line'>    common mode items = {
</span><span class='line'>  
</span><span class='line'>        // source0 (manual)
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = _UIApplicationHandleEventQueue}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventSignalCallback }}
</span><span class='line'>        CFRunLoopSource {order = 0, {
</span><span class='line'>            callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>  
</span><span class='line'>        // source1 (mach port)
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 17923}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 12039}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 16647}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 2407,
</span><span class='line'>            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1c03,
</span><span class='line'>            callout = __IOHIDEventSystemClientAvailabilityCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1b03,
</span><span class='line'>            callout = __IOHIDEventSystemClientQueueCallback}}
</span><span class='line'>        CFRunLoopSource {order = 1, {port = 1903,
</span><span class='line'>            callout = __IOMIGMachPortPortCallback}}
</span><span class='line'>  
</span><span class='line'>        // Ovserver
</span><span class='line'>        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
</span><span class='line'>            callout = _UIGestureRecognizerUpdateObserver}
</span><span class='line'>        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _afterCACommitHandler}
</span><span class='line'>        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>  
</span><span class='line'>        // Timer
</span><span class='line'>        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
</span><span class='line'>            next fire date = 453098071 (-4421.76019 @ 96223387169499),
</span><span class='line'>            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
</span><span class='line'>    },
</span><span class='line'>  
</span><span class='line'>    modes ＝ {
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = 0, {
</span><span class='line'>                    callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = {
</span><span class='line'>                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
</span><span class='line'>                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>            )},
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventSignalCallback}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventCallback}}
</span><span class='line'>            },
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>         
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = (null),
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    /// 1. 通知Observers，即将进入RunLoop
</span><span class='line'>    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
</span><span class='line'>    do {
</span><span class='line'>  
</span><span class='line'>        /// 2. 通知 Observers: 即将触发 Timer 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
</span><span class='line'>        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 4. 触发 Source0 (非基于port的) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 6. 通知Observers，即将进入休眠
</span><span class='line'>        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 7. sleep to wait msg.
</span><span class='line'>        mach_msg() -&gt; mach_msg_trap();
</span><span class='line'>         
</span><span class='line'>  
</span><span class='line'>        /// 8. 通知Observers，线程被唤醒
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被Timer唤醒的，回调Timer
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
</span><span class='line'>        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>    } while (...);
</span><span class='line'>  
</span><span class='line'>    /// 10. 通知Observers，即将退出RunLoop
</span><span class='line'>    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFSocket
</span><span class='line'>CFNetwork       -&gt;ASIHttpRequest
</span><span class='line'>NSURLConnection -&gt;AFNetworking
</span><span class='line'>NSURLSession    -&gt;AFNetworking2, Alamofire</span></code></pre></td></tr></table></div></figure>


<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        [[NSThread currentThread] setName:@"AFNetworking"];
</span><span class='line'>        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
</span><span class='line'>        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
</span><span class='line'>        [runLoop run];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>+ (NSThread *)networkRequestThread {
</span><span class='line'>    static NSThread *_networkRequestThread = nil;
</span><span class='line'>    static dispatch_once_t oncePredicate;
</span><span class='line'>    dispatch_once(&oncePredicate, ^{
</span><span class='line'>        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
</span><span class='line'>        [_networkRequestThread start];
</span><span class='line'>    });
</span><span class='line'>    return _networkRequestThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start {
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    if ([self isCancelled]) {
</span><span class='line'>        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    } else if ([self isReady]) {
</span><span class='line'>        self.state = AFOperationExecutingState;
</span><span class='line'>        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    }
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUrlSession详解]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie/"/>
    <updated>2016-03-27T18:48:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie</id>
    <content type="html"><![CDATA[<p>NSUrlSession是NSUrlConnection的替代品。</p>

<p>NSUrlConennection指的是一组构成 Foundation框架中URL加载系统的相互关联的组件:NSURLRequest,NSUrlResponse,NSURlProtocol等,在协商发送一个请求到服务器的过程中，该服务器可发出验证质询，这可以由共享的cookie，证书存储（credential storage）或通过连接委托自动处理。必要的时候，为了无缝地改变装载行为，传出请求也可以被注册的NSURLProtocol对象截获.</p>

<!--more-->


<p>不管怎样，考虑到NSURLConnection作为一个网络基础架构，成千上万的Cocoa和Cocoa Touch应用程序从中获益，它已经表现得相当好。但是，这些年来，iPhone和iPad新兴的用例，特别是有一些已经向NSURLConnection的几个核心设想提出了挑战，对其重构已经迫在眉睫。</p>

<p>在2013年的WWDC上，Apple揭开了NSURLConnection继任者的面纱：NSURLSession.</p>

<p>与NSUrlConnection类似，除了同名类 NSUrlsession,NSUrlSession指的是一组相互依赖的类，NSURlSession包括与之前相同的组件，例如NSUrlRequest,NSURLCatch等等。
　　</p>

<h2>NSURlconenction 与 NSSession的不同</h2>

<p>　　与NSUrlConnection相比，NSUrlSession最直接的改善就是提供了配置每个回话的缓存，协议，cookie和证书策略(credential policies),甚至跨应用程序共享它们的能力。这使得框架的网络基础架构和部分应用程序独立工作，而不会相互干扰，每一个NSUrlSession对象都是根据一个NSURlSessionConfiguration初始化的，
　　
　　</p>

<p>该NSURlSessionConfiguration指定了上面提到的策略，一级一系列为了提高移动设备性能而专门添加的新选项。</p>

<p>NSUrlSession的另一个重要组成部分就是会话任务，它负责处理数据的加载，以及客户端与服务器之间的文件和数据的上传和下载。</p>

<h2>NSURLSession简介</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="logo" /></p>

<p>NSURLsession关键对象负责接收和发送http请求，创建NSURlSessionConfiguration,这里有三种方式:</p>

<ul>
<li><code>defaultSessionConfiguration</code>创建一个默认的配置文件，用户可以存储缓存，创建证书和缓存cookie等</li>
<li><code>ephemeralSessionConfiguration</code>和默认配置文件很相似，除了它可以在内存中存储之外，它更像是一个私有的session</li>
<li><code>backgroundSessionConfiguration</code>这个配置文件支持上传和下载任务在后台。当程序挂起或者被终止之后任务可以继续执行。</li>
</ul>


<p><code>NSURLSessionConfiguration</code>依然可以让你配置session的属性，比如设置超时时间，缓存策略和http请求头等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration">这里</a>有完整的配置文档。</p>

<p><code>NSURLSessionTask</code>是一个抽象的任务符号,一个session创建一个任务，它不仅可以请求数据，还可以上传和下载。</p>

<p>这里有三种类型的任务：</p>

<ul>
<li><code>NSURLSessionDataTask</code>：用这个任务可以发送http请求，从而从服务器得到返回的数据</li>
<li><code>NSURLSessionUploadTask</code>：用这个任务可以从本地硬盘上往服务器上传文件，一般是HTTP post请求或者PUT请求.</li>
<li><code>NSURLSessionDownloadTask</code>:用这个任务可以从远程服务器上下载文件</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="logo" /></p>

<p>你可以挂起，回滚和取消任务，<code>NSURLSessionDownloadTask</code>还有一个特性就是支持断点下载。</p>

<p>一般来讲, NSURLSession 有两种方式返回数据：</p>

<ol>
<li>利用completion handler,当任务完成之后，不管是成功返回还是产生错误；</li>
<li>还有一种就是利用NSSession的代理，依然可以捕获到返回的数据;</li>
</ol>


<h2>编写实例Demo</h2>

<p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip">启动工程在这里下载</a>,</p>

<p>开始做一个 在Itunes搜索歌曲，通过<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">Itunes API</a>下载歌曲的这么个小工程，支持暂停，下载功能。</p>

<p>下完工程，运行效果如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt="itunes" /></p>

<h3>开始编写代码</h3>

<p>你可以添加代码去查询itunes中的歌曲，通过查找 Itunes search Api.</p>

<p>在<code>SearchViewController.swift</code>文件中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
</span><span class='line'>// 2
</span><span class='line'>var dataTask: NSURLSessionDataTask?</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做了如下工作:</p>

<ol>
<li>用默认的配置文件创建NSURLSession</li>
<li>你定义了一个<code>NSURLSessionDataTask</code>变量，用它发送http请求，这个任务将会被重复初始化和重复利用在用户创建一个新查询的时候</li>
</ol>


<p>现在，替换<code>searchBarSearchButtonClicked(_:)</code>里面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func searchBarSearchButtonClicked(searchBar: UISearchBar) {
</span><span class='line'>  dismissKeyboard()
</span><span class='line'> 
</span><span class='line'>  if !searchBar.text!.isEmpty {
</span><span class='line'>    // 1
</span><span class='line'>    if dataTask != nil {
</span><span class='line'>      dataTask?.cancel()
</span><span class='line'>    }
</span><span class='line'>    // 2
</span><span class='line'>    UIApplication.sharedApplication().networkActivityIndicatorVisible = true
</span><span class='line'>    // 3
</span><span class='line'>    let expectedCharSet = NSCharacterSet.URLQueryAllowedCharacterSet()
</span><span class='line'>    let searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!
</span><span class='line'>    // 4
</span><span class='line'>    let url = NSURL(string: "https://itunes.apple.com/search?media=music&entity=song&term=\(searchTerm)")
</span><span class='line'>    // 5
</span><span class='line'>    dataTask = defaultSession.dataTaskWithURL(url!) {
</span><span class='line'>      data, response, error in
</span><span class='line'>      // 6
</span><span class='line'>      dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>        UIApplication.sharedApplication().networkActivityIndicatorVisible = false
</span><span class='line'>      }
</span><span class='line'>      // 7
</span><span class='line'>      if let error = error {
</span><span class='line'>        print(error.localizedDescription)
</span><span class='line'>      } else if let httpResponse = response as? NSHTTPURLResponse {
</span><span class='line'>        if httpResponse.statusCode == 200 {
</span><span class='line'>          self.updateSearchResults(data)
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    // 8
</span><span class='line'>    dataTask?.resume()
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>运行后代码如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160401-1.png" alt="logo" /></p>

<p>如果出现错误<code>An SSL error has occurred and a secure connection to the server cannot be made.</code></p>

<p>请在info.plist中配置，在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为 YES</p>

<p>上面的代码步骤意义如下:</p>

<ol>
<li>检查用户每一次查询，dataTask是否已经初始化，如果没有，则取消该任务</li>
<li>设置的状态栏上的转子运行起来，证明数据正在请求当中</li>
<li>当用户输入查询参数之前，调用 请求字符串的<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>,确保是一个正确的URL.　(这个 text 的类型是 String ，常用于搜索功能，在  URL 中包含被搜的关键字，如果不处理搜中文或者带空格的英文会直接崩溃);</li>
<li>下一步创建一个NSURL用上面的（安全的）字符串，使用GET请求去调用Itunes Search API</li>
<li>从创建的Session中，你初始化<code>NSURLSessionDataTask</code>去处理http请求，这个<code>NSURLSessionDataTask</code>任务使用completion handler （回调函数）去响应服务器返回的数据</li>
<li>异步调用主线程，在主线程上隐藏网络请求的转子</li>
<li>如果http请求是成功的，你可以调用<code>updateSearchResults(_:)</code>来刷新表格数据，返回数据是NSData类型的，需要在updateSearchResults方法中进行处理</li>
<li>所有任务默认是挂起状态，需要你调用 <code>resume()</code>去启动任务</li>
</ol>


<h2>下载</h2>

<p>看着搜索到的歌曲，感觉页面不错，但是如果我们能够通过点击 download,然后把歌曲下载到本地是不是更爽呢?下一步让我实现这个功能点.</p>

<p>用多线程实现下载是容易的。首先你要创建一个新的文件命名为 <code>Download.swift</code>. 打开这个文件，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Download: NSObject {
</span><span class='line'> 
</span><span class='line'>  var url: String
</span><span class='line'>  var isDownloading = false
</span><span class='line'>  var progress: Float = 0.0
</span><span class='line'> 
</span><span class='line'>  var downloadTask: NSURLSessionDownloadTask?
</span><span class='line'>  var resumeData: NSData?
</span><span class='line'> 
</span><span class='line'>  init(url: String) {
</span><span class='line'>    self.url = url
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>属性说明如下:</p>

<ul>
<li>URL:下载文件的url地址，它也扮演着唯一的标识符在下载过程中</li>
<li>isDownloading:是否正在下载或暂停</li>
<li>progress : 下载的进度,[0-1]</li>
<li>downloadTask: NSURLSessionDownloadTask下载任务</li>
<li>resumeData:当你暂停一个下载任务时，它负责存储此时的数据量；如果后台服务器支持的话，当用户再次点击继续下载，它会从这里开始继续下载这个文件，俗称 断点下载</li>
</ul>


<p>切换到 <code>SearchViewController.swift</code>，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var activeDownloads = [String: Download]()</span></code></pre></td></tr></table></div></figure>


<h2>创建下载任务</h2>

<p>准备工作做得差不多了，现在你只需实现下载，首先你要创建一个session去实现下载任务.</p>

<p>在 <code>SearchViewController.swift</code>文件中，在<code>viewDidLoad():</code>之前添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var downloadsSession: NSURLSession = {
</span><span class='line'>  let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span><span class='line'>  let session = NSURLSession(configuration: configuration, delegate: self, delegateQueue: nil)
</span><span class='line'>  return session
</span><span class='line'>}()</span></code></pre></td></tr></table></div></figure>


<p>这里初始化了一个session,用默认的配置文件，去处理所有的下载任务，你也可以指定delegate,这将会使你收到 <code>NSURLSession</code>的代理调用，这个是很有用的，它能有效的跟踪下载任务下载的进度和是否下载完成等。</p>

<p>设置代理的队列是nil,会促使session创建一个操作队列，默认的去调用代理方法和回调方法.</p>

<p>在创建<code>downloadsSession</code>属性的时候，我们加了<code>lazy</code>特性，这会让你延迟加载这个session直到你需要它的时候，更重要的是，它会通过<code>self</code>作为代理参数去初始化，假如<code>self</code>还没有初始化。</p>

<p>在<code>SearchViewController.swift</code>文件中，找到空的<code>NSURLSessionDownloadDelegate</code>并且扩展如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDownloadDelegate {
</span><span class='line'>  func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>    print("Finished downloading.")
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>NSURLSessionDownloadDelegate</code>定义了代理方法你需要去实现，在你使用 NSURLSession 下载任务的时候，这个唯一的不是可选的代理方法是 <code>URLSession(_:downloadTask:didFinishDownloadingToURL:),</code>,当下载完成的时候，将会执行这个代理方法，打印简答的一句话.</p>

<p>在<code>SearchViewController.swift</code>文件中，替换<code>startDownload(_:)</code>这个方法的代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func startDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl, url =  NSURL(string: urlString) {
</span><span class='line'>    // 1
</span><span class='line'>    let download = Download(url: urlString)
</span><span class='line'>    // 2
</span><span class='line'>    download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>    // 3
</span><span class='line'>    download.downloadTask!.resume()
</span><span class='line'>    // 4
</span><span class='line'>    download.isDownloading = true
</span><span class='line'>    // 5
</span><span class='line'>    activeDownloads[download.url] = download
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你点击 <code>Download</code>按钮的时候，你将会调用<code>startDownload(_:)</code>函数去执行下载命令，上面的代码执行的步骤如下:</p>

<ol>
<li>你用URL去初始化一个DownLoad对象</li>
<li>使用上面的NSURL和downloadsSession去初始化<code>NSURLSessionDownloadTask</code></li>
<li>调用resume()去启动一个下载任务</li>
<li>设置下载标识 为true</li>
<li>最后，你把下载的URL作为key,download对象作为值放到一个字典中</li>
</ol>


<p>编译运行你的项目，查询出来的歌曲中，点击 Download按钮，你将会看到一个消息打印在控制台。
<code>Finished downloading.</code></p>

<h2>保存&amp;播放</h2>

<p>当下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>提供了一个URL存储临时文件路径，你的工作就是移动它到你程序的沙盒当中，在这个方法返回之前。当然，这个过程当中你需要删除全局字典中正在下载的download对象，并且更新表格.</p>

<p>你需要添加一个Helper方法简化这个操作，在<code>SearchViewController.swift</code>中，添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func trackIndexForDownloadTask(downloadTask: NSURLSessionDownloadTask) -&gt; Int? {
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    for (index, track) in searchResults.enumerate() {
</span><span class='line'>      if url == track.previewUrl! {
</span><span class='line'>        return index
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法仅仅返回 当前的URL在 searchResults集合中的索引，下一步，替换 URLSession(_:downloadTask:didFinishDownloadingToURL:) 中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>  // 1
</span><span class='line'>  if let originalURL = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>    destinationURL = localFilePathForUrl(originalURL) {
</span><span class='line'> 
</span><span class='line'>    print(destinationURL)
</span><span class='line'> 
</span><span class='line'>    // 2
</span><span class='line'>    let fileManager = NSFileManager.defaultManager()
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.removeItemAtURL(destinationURL)
</span><span class='line'>    } catch {
</span><span class='line'>      // Non-fatal: file probably doesn't exist
</span><span class='line'>    }
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.copyItemAtURL(location, toURL: destinationURL)
</span><span class='line'>    } catch let error as NSError {
</span><span class='line'>      print("Could not copy file to disk: \(error.localizedDescription)")
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // 3
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    activeDownloads[url] = nil
</span><span class='line'>    // 4
</span><span class='line'>    if let trackIndex = trackIndexForDownloadTask(downloadTask) {
</span><span class='line'>      dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>        self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: trackIndex, inSection: 0)], withRowAnimation: .None)
</span><span class='line'>      })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的事情如下:</p>

<ol>
<li>定义了两个变量，<code>originalURL</code>请求路径的url,<code>destinationURL</code>变量则是通过<code>localFilePathForUrl(_:)</code>方法生成的，该方法会获取当前程序的沙盒路径再追加 传递的URL的最后一个后缀(/)的路径作为返回的参数。作为目标文件夹的路径</li>
<li>使用NSFileManager,在开始拷贝文件之前，先删除目标文件夹下的文件，如果存在的话。然后进行拷贝从本地拷贝到目标文件夹</li>
<li>删除download从全局的download字典中</li>
<li>最后刷新表格对应的哪一行</li>
</ol>


<p>编译运行你的工程，点击搜索然后选中一行进行下载，当下载完成时候，在控制台会打印一行信息,下载的目标路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file:///Users/Andrew/Library/Developer/CoreSimulator/Devices/875165C2-FA55-4884-96AE-A7C8E3223C12/data/Containers/Data/Application/52B47648-04A2-4C26-8BCF-F41D2C76CA21/Documents/mzm.gyadmzom.aac.p.m4a</span></code></pre></td></tr></table></div></figure>


<p>这时下载按钮将会消失，再次点击表格的对应的那行，将会弹出一个 MPMoviePlayerViewController,开始播放音频.</p>

<h2>监视下载进度</h2>

<p>当然，现在你还没有监视下载的进度条，为了提高用户体验，你将要改变你的App去监听下载的进度在每个cell中。</p>

<p>在SearchViewController.swift文件中,找到 <code>NSURLSessionDownloadDelegate</code>的扩展，然后添加如下的代理方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
</span><span class='line'> 
</span><span class='line'>    // 1
</span><span class='line'>    if let downloadUrl = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>      download = activeDownloads[downloadUrl] {
</span><span class='line'>      // 2
</span><span class='line'>      download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
</span><span class='line'>      // 3
</span><span class='line'>      let totalSize = NSByteCountFormatter.stringFromByteCount(totalBytesExpectedToWrite, countStyle: NSByteCountFormatterCountStyle.Binary)
</span><span class='line'>      // 4
</span><span class='line'>      if let trackIndex = trackIndexForDownloadTask(downloadTask), let trackCell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: trackIndex, inSection: 0)) as? TrackCell {
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          trackCell.progressView.progress = download.progress
</span><span class='line'>          trackCell.progressLabel.text =  String(format: "%.1f%% of %@",  download.progress * 100, totalSize)
</span><span class='line'>        })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过这个代理方法做的工作如下:</p>

<ol>
<li>使用提供的 downloadTask 找到URL属性，然后从全局激活的下载字典中查找 DownLoad对象</li>
<li>这个方法将会返回总的字节数和已经写入的字节数，你可以利用这个两个值算出当前的下载进度并且实时更新进度条。</li>
<li>NSByteCountFormatter 将会把字节数转化成人类能够看懂的文件大小，有将会使用这个字符串去显示下载的文件大小和百分比</li>
<li>最后，你将要定位到这个Cell,在主线程中更新进度条和显示的百分比</li>
</ol>


<p>下一步，你将要配置这个cell属性去显示进度条</p>

<p>找到下面的代码在 <code>tableView(_:cellForRowAtIndexPath:):</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let downloaded = localFileExistsForTrack(track)</span></code></pre></td></tr></table></div></figure>


<p>添加如下代码在这行的上面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var showDownloadControls = false
</span><span class='line'>if let download = activeDownloads[track.previewUrl!] {
</span><span class='line'>  showDownloadControls = true
</span><span class='line'> 
</span><span class='line'>  cell.progressView.progress = download.progress
</span><span class='line'>  cell.progressLabel.text = (download.isDownloading) ? "Downloading..." : "Paused"
</span><span class='line'>}
</span><span class='line'>cell.progressView.hidden = !showDownloadControls
</span><span class='line'>cell.progressLabel.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>为了跟踪正在下载的歌曲，你将要设置 showDownloadControls为true,否则，你将要设置为false.你将要显示这进度条和文字。</p>

<p>为了暂停任务，显示"Paused"状态，否则，显示 “Downloading&hellip;.”
最后，替换这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded</span></code></pre></td></tr></table></div></figure>


<p>使用下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded || showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>到这，你可以告诉表格是否隐藏下载按钮。</p>

<p>编译运行你的工程，点击下载按钮，你将要看到一个进度条和下载的进度，以及下载的百分比。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-17-at-11.02.03-pm-480x78.png" alt="logo" /></p>

<p>OK,你做到了!😀</p>

<h2>暂停 恢复  取消下载任务</h2>

<p>假如我需要暂停一个任务，或者取消任务？此时该怎么做呢？</p>

<p>在这个章节，你将要实现暂停，恢复，取消任务操作。</p>

<p>你将要开始编写代码，通过允许用户去取消一个正在激活的任务
替换 <code>cancelDownload(_:)</code> 使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func cancelDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      download.downloadTask?.cancel()
</span><span class='line'>      activeDownloads[urlString] = nil
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了取消任务，你可以从全局激活的字典中取出Download对象，然后调用它的 cancel() 方法，执行取消命令，然后在全局字典中移除它</p>

<p>暂停任务和取消任务非常类似，不同点在于当你暂停一个任务的时候，会产生恢复数据，它包含了足够多的信息去恢复下载数据，当然后台服务器必须要支持这个特性才能完全实现断点下载功能.</p>

<blockquote><p><strong>注意</strong>
你能恢复一个下载任务在一定的控制条件下，例如，从你第一下请求下载开始，这个下载资源就不能再改变了。想要更详细的控制条件，请参考苹果的 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDownloadTask_class/index.html#//apple_ref/occ/instm/NSURLSessionDownloadTask/cancelByProducingResumeData:">官方文档</a></p></blockquote>

<p>现在，替换 <code>pauseDownload(_:)</code>使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func pauseDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if(download.isDownloading) {
</span><span class='line'>        download.downloadTask?.cancelByProducingResumeData { data in
</span><span class='line'>          if data != nil {
</span><span class='line'>            download.resumeData = data
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>        download.isDownloading = false
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个关键字是不同的 cancelByProducingResumeData(_:) 替代了 cancel(),你检索这个恢复的数据从这个方法cancelByProducingResumeData提供的回调函数中，并且把恢复的数据保存到Download的resumeData属性中。并且设置isDownloading=false</p>

<p>下面替换<code>resumeDownload(_:)</code>用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func resumeDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if let resumeData = download.resumeData {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      } else if let url = NSURL(string: download.url) {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户恢复一个下载任务时，你检查下当前的Download对象 恢复数据的属性是否有值，如果有值，你将会创建一个新的下载任务通过 <code>downloadTaskWithResumeData(_:)</code>和一个恢复数据的参数，启动<code>resume()</code>恢复数据的命令;如果这个 恢复数据的属性是空的或者其他一些原因，你将要用URL创建一个新的下载任务，启动它.</p>

<p>在上面的案例中，你设置这个isDownloading为true,表明任务正在进行.</p>

<p>还有一件事件要做就是设置这三个函数的工作属性，你需要在cell中显示 或者隐藏 <code>暂停</code>，<code>取消</code>和<code>继续下载</code>按钮。</p>

<p>找到 <code>tableView(_:cellForRowAtIndexPath:)</code>然后找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let download = activeDownloads[track.previewUrl!] {</span></code></pre></td></tr></table></div></figure>


<p>然后添加下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let title = (download.isDownloading) ? "Pause" : "Resume"
</span><span class='line'>cell.pauseButton.setTitle(title, forState: UIControlState.Normal)</span></code></pre></td></tr></table></div></figure>


<p>暂停和继续下载按钮共用一个按钮。</p>

<p>下一步，添加下面的代码在 <code>tableView(_:cellForRowAtIndexPath:)</code>结尾:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.pauseButton.hidden = !showDownloadControls
</span><span class='line'>cell.cancelButton.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>当下载任务激活的时候，这里仅仅把按钮显示出来。</p>

<p>编译运行你的工程，下载几个歌曲试试，你可以暂停，继续下载，取消 下载任务。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="logo" /></p>

<h2>支持后台下载</h2>

<p>你的App现在看来已经很不错了，但是还有一个问题，是否支持后台任务下载:当你的程序进入后台模式或者因为别的原因意外终止了，后台任务是否能继续下载?</p>

<p>假如你的App不再运行了，那它怎么能继续工作呢？这儿有一个守护进程在App运行之外，去管理后台任务下载；它发送一个适当的代理方法通知给app让其任务下载继续，当这个app正在下载的时候突然退出，这个任务将要继续下载。</p>

<p>当任务完成的时候，这个守护进程将要重新加载在后台模式中，这个重新加载app将要重新连接这同样的session.收到相关的完成的代理消息并且执行一些要求的动作，比如持久化下载的文件到硬盘上等。</p>

<blockquote><p><em>注意</em>
如果你强制退出app通过app switche，这个系统将要取消所有后台下载的任务，并且不会再视图重启这个app</p></blockquote>

<p>仍然在SearchViewController.swift这个文件中，在初始化 <code>downloadsSession</code>的地方，找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span></code></pre></td></tr></table></div></figure>


<p>替换成下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("bgSessionConfiguration")</span></code></pre></td></tr></table></div></figure>


<p>替换默认的session配置文件，指定一个特殊的后台session配置文件，注意你设置了唯一的ID为这个session,这会允许你引用并且重新连接同样的后台session.</p>

<p>下一步，在 viewDidLoad()中，增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_ = self.downloadsSession</span></code></pre></td></tr></table></div></figure>


<p>调用懒加载属性<code>downloadsSession</code>,确保应用程序确实创建了一个后台session 的SearchViewController的实例。</p>

<p>当一个后台任务完成的时候，这个App不再运行，这个app将会重新运行到后台进程中，你需要去处理你的app的一些代理方法.</p>

<p>切换到 AppDelegate.swift,添加下面的代码在类的顶部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var backgroundSessionCompletionHandler: (() -&gt; Void)?</span></code></pre></td></tr></table></div></figure>


<p>下一步，添加如下代码在AppDelegate.swift:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) {
</span><span class='line'>  backgroundSessionCompletionHandler = completionHandler
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>提供一个completionHandler作为一个变量在你的App代理方法中，等会会用到。</p>

<p>application(_:handleEventsForBackgroundURLSession:)会唤醒这个App处理完成这个后台任务，你需要去处理两个事情：</p>

<ul>
<li>首先，通过代理方法用这个App去重新连接这个后台session,一旦你创建并且每次使用后台session时，SearchViewController就会被实例化，你已经重新连接了.</li>
<li>第二，你需要去捕获完成的回调方法，在完成的回调函数中，更新你的UI,然后告诉系统你的App已经工作完毕使用后台任务的session.</li>
</ul>


<p>但是什么时候你将会调用完成的回调函数呢？
<code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>将会是一个好的选择，它是NSURLSessionDelegate的一个代理方法，当所有的任务在后台session中完成的时候。</p>

<p>实现下面的扩展在<code>SearchViewController.swift</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDelegate {
</span><span class='line'> 
</span><span class='line'>  func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
</span><span class='line'>    if let appDelegate = UIApplication.sharedApplication().delegate as? AppDelegate {
</span><span class='line'>      if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
</span><span class='line'>        appDelegate.backgroundSessionCompletionHandler = nil
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          completionHandler()
</span><span class='line'>        })
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码仅仅抓取了在APPDelegate中存储的回调函数，并且在主线中调用它.</p>

<p>编译运行你的工程，开始几个下载之后迅速按在home键，使得下载任务进入后台，等几十秒你的下载任务将会完成，然后双击home,关闭当前程序。</p>

<p>下载任务将会完成并且他们将会更新显示状态。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt="logo" /></p>

<p>OK，这个demo已经完备了。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程从 <a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip">这里</a></p>

<p>更多资源</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/">苹果的官方文档</a></li>
<li><a href="https://github.com/Alamofire/Alamofire">AlamoFire</a>是Swift中非常流行的第三方框架，可以学习一下.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue简单介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao/"/>
    <updated>2016-03-26T08:11:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao</id>
    <content type="html"><![CDATA[<p>在iOS中有两种方式来实现多线程:NSOperation和GCD.
其中GCD是基于C的底层的API,而NSOperation则是GCD实现的Object-c的API,随让NSOPeration是基于GCD实现的，但是并不意味着它是一个GCD的重复版本，相反，我们可以用NSOperation轻易的实现一些GCD要写大量代码的事情，因此，NSOperation是被推荐使用的.</p>

<!--more-->


<h2>为什么优先使用NSOperationQuere,而不是GCD</h2>

<p>你可能写过这样的网络请求的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(_Queue, ^{  
</span><span class='line'>    //请求数据 
</span><span class='line'>    NSData *data = [NSData dataWithContentURL:[NSURL URLWithString:@"http://domain.com/a.png"]]; 
</span><span class='line'>    dispatch_async(dispatch_get_main_queue(), ^{ 
</span><span class='line'>        [self refreshViews:data];
</span><span class='line'>     });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>这段代码是可以正常工作的，但是有一个很大的缺点，就是<em>这个任务是无法取消的</em></p>

<p><code>dataWithContentURL:</code>是同步拉取数据，它会一直阻塞主线程，直到所有的数据返回之后；这个期间，并发队列就需要为其它任务新建线程，这样可能导致性能下降问题。因此我们不推荐这种写法来从网络上拉取数据。</p>

<p>操作队列是有GCD提供的一个队列模型的Coco对象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了更加方便的功能。NSOperation相对GCD来说有以下优点:</p>

<ul>
<li>提供了GCD中不那么容易复制的有用特性</li>
<li>可以很方便的取消一个NSOperation的执行</li>
<li>可以容易的添加任务的依赖关系</li>
<li>提供了任务的状态:isExecting,isFinished
*</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue就是一个线程队列，可以吧 <code>NSOperation</code>加入到队列中，可以取消或者执行完队列中所有的 <code>NSOperation</code>,我们可以通过<code>maxConcurrentOperationCount</code>属性来控制并发任务的数量，当设置为1时，就是一个串行队列。</p>

<h2>NSOperation</h2>

<p>它是创建线程的对象，系统已经默认提供了<code>NSBlockOperaton</code>和<code>NSInvocationOperation</code>.你也可以实现自己的子类，通过重写
<code>main</code>或者<code>start</code>方法来自定义nsoperation</p>

<p>使用<code>main</code>方法非常简单，不需要管理一些状态属性,当main方法返回的时候，这个operation就执行结束了，所以一般用来执行同步任务。</p>

<p>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么重写<code>start</code>方法，但是注意，在这种情况下，你必须手动的管理操作的状态，只有发送isFinished的KVO消息时，才认为是operaiton结束。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>@implementation YourOperation
</span><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = YES;
</span><span class='line'>    // 任务代码 ...
</span><span class='line'>}
</span><span class='line'>- (void)finish //异步回调
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = NO;
</span><span class='line'>    self.isFinished = YES;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><em>当实现了<code>start</code>方法时，默认就会执行start方法，而不执行main方法</em>，为了让操作队列捕获到做的改变，需要将状态的属性配合KVO的方式实现，如果你不使用它们默认的sette来进行设置的话，就需要在合适的时候手动发送KVO消息。</p>

<p>需要手动管理的状态有:</p>

<ol>
<li>isExecuting  代表任务正在进行中</li>
<li>isFinished   代表任务已经执行完成</li>
<li>isCanceled  代表任务已经取消</li>
</ol>


<p>手动发送KVo消息，通知状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self willChangeValueForKey:@"isCancelled"];
</span><span class='line'>_isCancelled = YES;
</span><span class='line'>[self didChangeValueForKey:@"isCancelled"];</span></code></pre></td></tr></table></div></figure>


<p>为了能使用队列所提供的取消功能，你需要在长时间操作中不时地检查isCanceled属性，比如在一个长的循环中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)main
</span><span class='line'>{
</span><span class='line'>    while (notDone && !self.isCancelled) {
</span><span class='line'>        // 任务处理
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>简单使用</h2>

<p>NSOperaiton和NSOperationQueue实现多线程的步骤:</p>

<ol>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装放到一条新线程中执行</li>
</ol>


<p>NSOperation是个抽象类，并不具备封装操作的能力，必须实现它的子类。</p>

<h3>NSInvocationOperation子类</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建操作对象，封装要执行的任务
</span><span class='line'>//NSInvocationOperation   封装操作
</span><span class='line'>    NSInvocationOperation *operation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];
</span><span class='line'>    
</span><span class='line'>    //执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>一旦执行操作，就会调用target的test方法</p>

<p>操作对象默认在主线程中执行，只有添加到列队中才会开启新的线程，即默认情况下，如果操作没有放到队列queue中，都是同步执行，只有将NSoperation放到一个NSOperationQueue中，才会异步执行.</p>

<h2>NSBlockOoperaiton</h2>

<p>创建对象和添加操作:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>    NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        //......
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //添加操作
</span><span class='line'>    [operation addExecutionBlock:^{
</span><span class='line'>        //....
</span><span class='line'>    }];</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>     NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>    
</span><span class='line'>     //添加操作
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation1------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>         NSLog(@"NSBlockOperation2------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     //开启执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>只要NSBlockOperation封装的操作数>1，就会异步操作。</p>

<h2>NSOperationQueue</h2>

<p>NSOperationQueue可以调用start方法来执行任务，但默认是同步执行的。
如果将NSOperation添加到NSOperationQueue中，系统就会自动异步执行NSOPeration中的操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "YYViewController.h"
</span><span class='line'>
</span><span class='line'>@interface YYViewController ()
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation YYViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    //创建NSInvocationOperation对象，封装操作
</span><span class='line'>    NSInvocationOperation *operation1=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test1) object:nil];
</span><span class='line'>    NSInvocationOperation *operation2=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test2) object:nil];
</span><span class='line'>    //创建对象，封装操作
</span><span class='line'>    NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--1----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    [operation3 addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--2----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //创建NSOperationQueue
</span><span class='line'>    NSOperationQueue * queue=[[NSOperationQueue alloc]init];
</span><span class='line'>    //把操作添加到队列中
</span><span class='line'>    [queue addOperation:operation1];
</span><span class='line'>    [queue addOperation:operation2];
</span><span class='line'>    [queue addOperation:operation3];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test1
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test1--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test2
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test2--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>系统自动将NSOperationqueue中的NSOPeration对象取出，将其封装的操作放到一条新的线程中执行，
上面的代码一共有4个任务，operation1和operation2分别有一个任务，operation3有两个任务，一共4个任务，开启了4条线程。</p>

<p>这些任务是并行执行的。</p>

<blockquote><p><strong>提示</strong>
队列的取出时有顺序的，与打印结果并不矛盾，这就好比赛跑，起跑的顺序是A,B,C，但是到达终点的顺序就不一样是 A B  C了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-泛型]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing/"/>
    <updated>2016-03-24T10:11:56+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing</id>
    <content type="html"><![CDATA[<p>泛型代码可以让你编写使用自定义需求以及任意类型的灵活可冲中的函数和类型，它可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>

<!--more-->


<p>泛型是swift的强大特性之一，许多swift标准库是通过泛型代码构建的。事实上，泛型的使用贯穿饿了正本语言手册，只是你可能没有发现而已。例如,swift的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可以创建一个<code>String</code>数组，甚至可以是任意其它Swift类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>

<h2>泛型所解决的问题</h2>

<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个<code>Int</code>值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数使用输入输出函数(<code>inout</code>)来交换<code>a</code>和<code>b</code>的值。</p>

<p><code>swapTwoInts(_:_:)</code>函数交换<code>b</code>的原始值到<code>a</code>,并交换<code>a</code>的原始值到<code>b</code>,你可以调用这个函数交换两个<code>Int</code>变量的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// 打印 “someInt is now 107, and anotherInt is now 3”</span></code></pre></td></tr></table></div></figure>


<p>诚然，<code>swapTwoInts(_:_:)</code>函数挺有用，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>值或者<code>Double</code>值，就不能不写更多的函数，例如<code>swapTwoStrings(_:_:)</code>和<code>swapTwoDoubles(_:_:)</code>,如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoStrings(inout a: String, inout _ b: String) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func swapTwoDoubles(inout a: Double, inout _ b: Double) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可能注意到<code>swapTwoInts(_:_:) 和 swapTwoDoubles(_:_:)</code>,的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 int,String,Double.</p>

<p>在实际的应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p>

<blockquote><p><em>注意</em>
在上面的三个函数中，<code>a</code>和<code>b</code>类型相同，如果<code>a</code>和<code>b</code>类型不同，那他们俩就不能交换值。Swift是类型安全的语言，所以不会允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互换值。视图这样做将导致编译错误。</p></blockquote>

<h2>泛型函数</h2>

<p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面三个函数的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoValues&lt;T&gt;(inout a:T,inout _ b:T){
</span><span class='line'> let temporaryA=a;
</span><span class='line'> a=b;
</span><span class='line'> b= temporaryA;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>swapTwoValues(_:_:)</code>的函数主体和<code>swapTwoInts(_:_:)</code>函数是一样的。他们只在第一行有所不同，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int)
</span><span class='line'>func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)</span></code></pre></td></tr></table></div></figure>


<p>这个函数的泛型版本使用了占位类型名(在这里用字母<code>T</code>来表示)来代替实际的类型名(例如<code>Int</code>,<code>String</code>或者<code>Double</code>).占位类型名没有指明<code>T</code>必须是什么类型，但是它指明了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>,而不论<code>T</code>代表什么类型，只有<code>swapTwoValues(_:_:)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型。</p>

<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名(T),而且使用尖括号括起来的(<code>&lt;T&gt;</code>).这个尖括号告诉Swift那个<code>T</code>是<code>swapTwoValues(_:_:)</code>函数定义的一个占位类型名，因此swift不会去查找名为<code>T</code>的实际类型。</p>

<p>swapTwoValues(<em>:</em>:) 函数现在可以像 swapTwoInts(<em>:</em>:) 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code>函数调用时，<code>T</code>所代表的类型都会由传入的值的类型判断出来.</p>

<p>在下面的两个例子中，<code>T</code>分别代表<code>Int</code>和<code>String</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoValues(&someInt, &anotherInt)
</span><span class='line'>// someInt is now 107, and anotherInt is now 3
</span><span class='line'>
</span><span class='line'>var someString = "hello"
</span><span class='line'>var anotherString = "world"
</span><span class='line'>swapTwoValues(&someString, &anotherString)
</span><span class='line'>// someString is now "world", and anotherString is now "hello"</span></code></pre></td></tr></table></div></figure>


<h2>类型参数</h2>

<p>在上面的<code>swapTwoValues(_:_:)</code>例子中，占位类型<code>T</code>是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来(<T>).</p>

<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型，或者作为函数的返回类型，还可以用作函数主题中的注释类型。在这些情况下，类型参数在函数调用时被实际类型所代替。</p>

<h2>命名类型参数</h2>

<p>在大多数情况下，类型参数具有一个描述性名字，例如<code>Dictionary&lt;Key,Value&gt;</code>中的key和value,以及<code>Array&lt;Element&gt;</code>中的<code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当他们之间的关系没有意义时，通常使用单一的字母来命名，例如<code>T</code>,<code>U</code>,<code>V</code>，正如上面演示的<code>swapTwoValues(_:_:)</code>函数中的<code>T</code>一样.</p>

<h2>泛型类型</h2>

<p>除了泛型函数，Swift还允许你定义泛型类型。这些自定义类，结构体和枚举可以适用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>

<p>这部分内容将向你展示如何编写一个名为<code>stack</code>（栈）的泛型集合类型。栈是一系列值的有序集合，如<code>Array</code>类型，但它比Swift的array类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素，称为入栈。同样滴，栈也只能从末端移除元素。</p>

<p>下面展示了一个如何编写一个非泛型版本的栈，在这种情况下是<code>Int</code>型的栈.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStack {
</span><span class='line'>    var items=[Int]()
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个结构体在栈中使用一个名为<code>items</code>的<code>array</code>属性来存储值。<code>Stack</code>提供了两个方法:<code>push(_:)</code>和<code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为<code>mutating</code>，因为他们需要修改结构体的<code>items</code>数组。</p>

<p>上面的<code>IntStack</code>结构体只能用于Int类型，不过可以定义一个泛型的<code>Stack</code>结构体，从而能够处理任意类型的值。</p>

<p>下面是相同代码的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;Element&gt; {
</span><span class='line'>    var items=[Element]();
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Element){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Element{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，<code>Stack</code>基本上和<code>IntStack</code>相同，只是占位类型参数<code>Element</code>代替了实际的<code>Int</code>类型。这种类型参数包裹在一对尖括号里(<code>&lt;Element&gt;</code>)，紧跟在结构体名后面、</p>

<p><code>Element</code>为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体定义中通过<code>Element</code>来引用。在这种情况下，<code>Element</code>在如下三个地方被用作占位符:</p>

<ul>
<li>创建 items 属性，使用<code>Element</code>类型的空数组进行初始化</li>
<li>执行<code>psh(_:)</code>方法的单一参数<code>item</code>的类型必须是<code>Element</code>类型</li>
<li>指定<code>pop()</code>方法的返回值类型必须是<code>Element</code>类型.</li>
</ul>


<p>由于<code>stack</code>是泛型类型，因此可以用来创建Swift中任意有效类型的栈，如同<code>Array</code>和<code>Dictionary</code>.</p>

<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例。例如，要创建一个<code>String</code>类型的栈，可以写成<code>Stack&lt;String&gt;</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'>stackOfStrings.push("cuatro")
</span><span class='line'>// 栈中现在有 4 个字符串</span></code></pre></td></tr></table></div></figure>


<p>移除并返回栈顶部的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let fromTheTop = stackOfStrings.pop()
</span><span class='line'>// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></code></pre></td></tr></table></div></figure>


<h2>扩展一个泛型类型</h2>

<p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型的参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<p>下面的例子扩展了泛型类型<code>Stack</code>，为其添加了一个名为<code>topItem</code>的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Stack{
</span><span class='line'>    var topItem:Element?{
</span><span class='line'>        return items.isEmpty ? nil:items[items.count];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>topItem</code>属性会返回一个<code>Element</code>类型的可选值。当栈为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>items</code>数组中的最后一个元素.</p>

<p>注意，这个扩展并没有定义一个类型参数列表。相反地，<code>Stack</code>类型已有的类型参数名<code>Element</code>，被用在扩展中表示计算型属性<code>topItem</code>的可选类型，<code>topItem</code>现在可以用来访问任意<code>Stack</code>实例的顶端元素而不是移除它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let topItem = stackOfStrings.topItem {
</span><span class='line'>    print("The top item on the stack is \(topItem).")
</span><span class='line'>}
</span><span class='line'>// 打印 “The top item on the stack is tres.”</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>类型约束</h2>

<p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须集成自特定类，或者符合一个特定的协议或者协议组合。</p>

<p>例如,Swift的<code>Dictionary</code>类型对字典的键的类型做了限制，在字典的描述中，字典的键必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希的，是为了便于检查字典是否已经包含了某个特定键的值。如无此要求，Dictionary将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中指定键的值。</p>

<p>这个要求强制加上了一个类型约束作用域<code>Dictionary</code>的键类型上，其键类型必须符合<code>Hashable</code>协议，这是swift标准库中定义的一个特定协议。所有的swfit基本类型(String,Int,Double)默认都是可哈希的。</p>

<p>当你创建自定义反省类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的。</p>

<h2>类型约束语法</h2>

<p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分割，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
</span><span class='line'>    // 这里是泛型函数的函数体部分
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的这个函数有两个类型参数。第一个类型是参数<code>T</code>,有一个要求<code>T</code>必须是<code>SomeClass</code>自雷的类型约束；第二个类型参数<code>U</code>,有一个要求<code>U</code>必须符合<code>someProtocol</code>协议的类型约束.</p>

<h2>类型约束实践</h2>

<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数的功能在<code>String</code>值的数组中查找指定<code>String</code>值的索引。弱查找到匹配的字符串，<code>findStringIndex(_:_:)</code>函数返回该字符串在数组中的索引值，反之则返回<code>nil</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findStringIndex(array: [String], _ valueToFind: String) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数可以用于查找字符串数组中的某个字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
</span><span class='line'>if let foundIndex = findStringIndex(strings, "llama") {
</span><span class='line'>    print("The index of llama is \(foundIndex)")
</span><span class='line'>}
</span><span class='line'>// 打印 “The index of llama is 2”</span></code></pre></td></tr></table></div></figure>


<p>如果只能查找字符串在数组中的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex(_:_:)</code>,用占位类型<code>T</code>代替<code>String</code>类型。</p>

<p>下面展示了<code>findStringIndex(_:_:)</code>函数的泛型版本<code>findIndex(_:_:)</code>.请注意这个函数仍然返回<code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到一个可选值。需要提醒的是，这个函数无法通过编译，原因例子后面说明:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>func findIndex&lt;T&gt;(array:[T], valueToField:T)-&gt;Int?{
</span><span class='line'>    for (index, value)in array.enumerate(){
</span><span class='line'>        if value == valueToField{
</span><span class='line'>            return index;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即<code>if vlaue == valueToField</code>。不是所有的Swift类型都可以用等号(==)进行比较。例如，如果你创建一个你自己的类活结构体表示一个复杂的数据模型，那么Swift无法猜到对于这个类或者结构体而言 “相等”意味着什么。正因为如此，这部分代码无法保证适用于每个可能的类型<code>T</code>,当你试图编译这部分代码的时候会出现相应的错误。</p>

<p>不过所有的这些并不会让我们无从下手。Swift标准库中定义了一个<code>Equatable</code>协议，该协议要求任何符合该协议的类型必须实现等式符号(==),从而对符合该协议的类型的任意两个值进行比较。所有的Swift标准类型自动支持Equatable协议。</p>

<p>任何<code>Equatable</code>类型都可以安全地使用在<code>findIndex(_:_:)</code>函数中，因为其保证支持等式操作符。为了说明事实，当你定义一个函数时，你可以定义一个<code>Equatable</code>类型约束作为类型参数定义的一部分:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>findIndex(_:_:)</code>中的这个单一类型参数协作<code>T:Equatable</code>，也就意味着<code>任何符合Equatable</code>协议的<code>T</code>类型。</p>

<p>findIndex函数现在可以成功编译了。并且可以作用于任何符合<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
</span><span class='line'>// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中
</span><span class='line'>let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
</span><span class='line'>// stringIndex 类型为 Int?，其值为 2</span></code></pre></td></tr></table></div></figure>


<h2>关联类型</h2>

<p>下面例子定义了一个<code>Container</code>协议，该协议定义了关联类型<code>ItemType</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Container{
</span><span class='line'>   typealias ItemType
</span><span class='line'>    mutating func append(item:ItemType)
</span><span class='line'>    
</span><span class='line'>    var count:Int{get}
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;ItemType{get}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><code>Container</code>协议定义了三个任何采纳协议的类型必须提供的功能：</p>

<ul>
<li>必须可以通过<code>append</code>方法添加一个新元素到容器里。</li>
<li>必须可以通过<code>count</code>属性获取容易中元素的数量，并返回一个Int</li>
<li>必须可以通过接受<code>Int</code>索引值的下标检索到每一个元素</li>
</ul>


<p>这个协议没有指定容易中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳<code>Container</code>协议的类型必须是提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>

<p>任何采纳<code>Container</code>协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素类型。</p>

<p>为了定义这三个条件，<code>Container</code>协议需要在不知道容易中元素具体类型的情况下引用这种类型。</p>

<p><code>Container</code>协议声明了一个关联类型<code>ItemType</code>，协作<code>typealias Itemtype</code>.这个协议无法定义<code>ItemType</code>是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code>别名提供了一种方式来引用<code>Container</code>中元素的类型，并将之用于<code>append</code>方法和下标，从而保证任何<code>Container</code>的预期行为都能够被执行。</p>

<p>下面采用复合<code>Container</code>协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStackContainer:Container {
</span><span class='line'>    var items:[Int]
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>     items.append(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //Container协议的实现部分
</span><span class='line'>    typealias ItemType=Int
</span><span class='line'>    
</span><span class='line'>    mutating func append(item: ItemType) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var count:Int{
</span><span class='line'>      return items.count
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;Int{
</span><span class='line'>        return items[i];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>IntStackContainer</code>结构体实现了<code>Container</code>协议的三个要求，其原有功能也不会和这些要求冲突。</p>

<p>此外，<code>IntStackContainer</code>指定 ItemType为Int类型，即<code>typealias ItemType = Int</code>，从而将<code>Container</code>协议中抽象的<code>ItemType</code>类型转为具体的<code>Int</code>类型。</p>

<h2>通过扩展一个存在的类型来指定关联类型</h2>

<p>Swift的<code>Array</code>已经提供了<code>append(_:_:)</code>方法，一个<code>count</code>属性，以及一个接受<code>Int</code>型索引值的可用来检索数组元素的下标。这三个功能都符合<code>Container</code>协议的要求，也就意味着你可以扩展<code>Array</code>去符合<code>Container</code>协议，只需简单滴声明<code>Array</code>采纳该协议即可。你可以通过一个空扩展来实现这点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Array:Container{}</span></code></pre></td></tr></table></div></figure>


<p>如何上面的泛型<code>Stack</code>结构一样，array的<code>append(_:)</code>方法和下标确保了Swift可以推断出<code>ItemType</code>的类型，定义了这个扩展后，你可以将任意<code>Array</code>当做<code>Container</code>来使用</p>
]]></content>
  </entry>
  
</feed>
