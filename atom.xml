<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-12-02T07:34:25+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Carthage管理ios依赖]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/"/>
    <updated>2016-11-28T15:55:02+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/Carthage/Carthage.git">Carthage</a>官网已经针对cocopods和carthage进行了详细的说明：</p>

<!--more-->


<p>首先，cocoaPods会直接创建和修改项目的workspace配置，一切都是为了便捷，我们只需要修改pod文件并不需要过多的关心其它事情，CocoaPods创建的也是高度集成的项目。而Carthage的特点是灵活，耦合度不高，集成时不需要集成相应的project,不需要创建workspace,而仅仅需要依赖打包好的framework文件。</p>

<p>其次，CocoaPods相对来说功能要比Carthage多很多，在国内由于墙的原因，我们都改成了淘宝的源来更新CocoaPods,相信我，如果你不翻墙，很多东西不能用，更新不下来，版本错误等一系列原因会让你不得不放弃一起看起来非常好用的第三方库。而Carthage似乎只需要从github上下载项目即可，配置更是简单，使用的项目项目干干净净，所有的第三方库就像苹果原生的framework一样美好，从此你不再需要担心CocoaPods的库用不了，不用花大量时间去修复用CocoaPods打包时出现的各种问题了，如果你用过CocoaPods，当你开始使用Carthage的时候，你会爱上这个工具的。</p>

<h2>安装使用Carthage</h2>

<p>假如你的电脑上已经安装了Homebrew,打开终端，输入如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew update
</span><span class='line'>
</span><span class='line'>$ brew install carthage</span></code></pre></td></tr></table></div></figure>


<p>如果你不喜欢使用终端，也可以从网站<code>https://github.com/Carthage/Carthage/releases</code>下载最新版的Carthage.pkg来更新。</p>

<p>现在，你已经安装好了Carthage,接下来就是在你的项目中使用carthage了：</p>

<ol>
<li>通过终端进入到项目所在的文件夹</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/Path/Project</span></code></pre></td></tr></table></div></figure>


<p>后面的路径替换成你的项目所在的路径</p>

<ol>
<li>创建一个空的carthage文件：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim Cartfile</span></code></pre></td></tr></table></div></figure>


<p>此时在你的项目文件夹里会创建一个名为Cartfile的文件</p>

<ol>
<li>在Cartfile文件里输入</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>github "Alamofire/Alamofire" ~&gt; 3.0
</span><span class='line'>
</span><span class='line'>github "SwiftyJSON/SwiftyJSON"</span></code></pre></td></tr></table></div></figure>


<p>上面仅仅是举个栗子
，如果您是用命令行打开的，按下ESC,输入 :wq，保存关闭当前窗口</p>

<h3>版本的含义</h3>

<p>~> 3.0 表示使用版本3.0以上但是低于4.0的最新版本，如3.5，3.7&hellip;</p>

<p>== 3.0表示使用3.0版本</p>

<p><code>&gt;=</code> 3.0表示使用3.0或者更高的版本
如果你没有指明版本号，则会自动使用最新的版本</p>

<ol>
<li>在终端执行命令</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ carthage update --platform iOS</span></code></pre></td></tr></table></div></figure>


<p>carthage会为你下载和编译所需要的第三方库，当命令执行完毕，在你的项目文件夹中会创建一个名为Carthage的文件夹</p>

<p>在 ~/Carthage/Build/iOS里会出现xxx.framework文件已经为你创建好了</p>

<ol>
<li>现在打开你的项目，点击Project,选择target,点击<code>+</code>,将刚才生成的framework文件拖到<code>Linked frameworks and Binaries</code>里；</li>
</ol>


<p>同样也要把生成的framework拖到<code>Embedded Binaries</code>中</p>

<h2>开始使用</h2>

<p>如果你已经导入framework成功了，然后使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import Alamofire
</span><span class='line'>
</span><span class='line'>import SwiftyJSON</span></code></pre></td></tr></table></div></figure>


<p>Please enjoy it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP TCP 和HTTP]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http/"/>
    <updated>2016-11-22T10:04:46+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http</id>
    <content type="html"><![CDATA[<p>当app和服务器进行通信的额时候，大多数情况下，都是采用http协议。http最初是为web浏览器而定制的，如果在浏览器输入 <code>http://www.baidu.com</code>。浏览器就会通过http协议和baidu所对应的服务器进行通信。</p>

<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Application Layer -- e.g. HTTP
</span><span class='line'>----
</span><span class='line'>Transport Layer -- e.g. TCP
</span><span class='line'>----
</span><span class='line'>Internet Layer -- e.g. IP
</span><span class='line'>----
</span><span class='line'>Link Layer -- e.g. IEEE 802.2</span></code></pre></td></tr></table></div></figure>


<p>所谓的<a href="https://en.wikipedia.org/wiki/OSI_model">OSI(Open Systems Interconnnection),开放式系统互联</a>模型定义了七层结构。本文会关注应用层(application layer)传输层(transport layer)和网络层(internet layer),他们分别代表了典型的HTTP的应用的HTTP,TCP,以及IP.在ip之下的是数据连接和物理层级，比如像Ethernet的实现之类的东西</p>

<p>如上文所述，我们只关注应用层，传输层和网络层部分，更确切的说，着重探讨一种特殊的混合模式：基于IP的TCP,以及基于TCP实现的HTTP.这就是我们每天使用的app的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的HTTP问题产生的原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只是HTTP一种，HTTP之所以被广泛使用的原因是其非常稳定，易用，即便是防火墙一般也是允许HTTP协议穿透的。</p>

<p>接下来，我们从最低的一层谈起，说说IP网络协议。</p>

<h3>IP网络协议(IP_Internet Protocol)</h3>

<p>TCP/IP 中的Ip是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议(Internet Protocol)</a>的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP实现了分组交换网络，在协议下，机器被叫做主机(host)，IP协议明确了host之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制的数据，其中包含了发送源主机和目标主机的信息。IP网络负责源主机和目标主机之间的数据包传输。IP协议的特点是best effort(尽力服务，其目标是提供有效服务并尽力传输)。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包</p>

<p>IP网络中的主机都配有自己的地址，被称为IP地址。每个数据包中都包含了源主机和目标主机的IP地址，IP协议负责路径计算，即IP数据包在网络中的传输时，数据包所经过的灭一个主机几点都会读取数据包中的目标主机地址信息，以便选择朝着什么地方传输数据包</p>

<p>今天，绝大多数的数据包仍旧是IPv4的，每一个IPV4的地址的长度是32位的，常见采用dotted-decimal(点分十进制)表示法，具体形式如下：198.51.100.42</p>

<p>新的IPv6标准也正在逐渐推广中。它有更大的地址空间：长度为128位，这使得数据包在网络中传输中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，注入网络地址转换等问题也迎刃而解。IPv6的表示形式为:八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2>IP Header</h2>

<p>一个ip数据包通常包含header（报头信息）和payload（有效载荷）</p>

<p>payload中的内容即是要传输的真正信息，而header承载的是与传输数据有关的元数据(metadata)</p>

<h3>IPV4 Header</h3>

<p>ipv4的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IPv4 Header Format
</span><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |IHL        |DSCP            |ECN  |Total Length                                   |
</span><span class='line'> 4        32     |Identification                                |Flags   |Fragment Offset                       |
</span><span class='line'> 8        64     |Time To Live           |Protocol              |Header Checksum                                |
</span><span class='line'>12        96     |Source IP Address                                                                             |
</span><span class='line'>16       128     |Destination IP Address                                                                        |
</span><span class='line'>20       160     |Options (if IHL &gt; 5)                                                                          |</span></code></pre></td></tr></table></div></figure>


<p>header长度为20字节（不包含极少用到的可选信息）</p>

<p>header信息中最关键的是源和目标IP地址，除此之外，版本信息是4，代表ipv4.protocol(协议区)代表payload采用的传输协议。TCP的协议号是6.Total Length(总长度区)表明了header加payload整个数据包的大小</p>

<h3>Ipv6 Header</h3>

<p>ipv6的地址长度为128位，IPv6的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |Traffic Class         |Flow Label                                                 |
</span><span class='line'> 4        32     |Payload Length                                |Next Header            |Hop Limit              |
</span><span class='line'> 8        64     |Source Address                                                                                |
</span><span class='line'>12        96     |                                                                                              |
</span><span class='line'>16       128     |                                                                                              |
</span><span class='line'>20       160     |                                                                                              |
</span><span class='line'>24       192     |Destination Address                                                                           |
</span><span class='line'>28       224     |                                                                                              |
</span><span class='line'>32       256     |                                                                                              |
</span><span class='line'>36       288     |                                                                                              |</span></code></pre></td></tr></table></div></figure>


<p>Ipv6 header采用固定长度40字节。经过多年来对Ipv4使用的总结，如今Ipv6的header信息简化了很多。</p>

<p>除了源和目标地址这种必备信息外，IPv6提供专门的next header区域来指明紧跟header的数据是什么。也就是说，Ipv6允许在数据包中将header链接起来，每一个被链接的Ipv6 header 都会有一个next header 字段，直到到达实际的payload数据，比如说，当next header的值为6(TCP的协议号)时，数据包的其它信息就是tcp协议要传输的数据</p>

<h2>Fragmentation(数据分片)</h2>

<p>由于底部链路层对所传输的数据帧有最大长度限制，所以有时候IPV4需要对所传数据包进行分片。具体表现为，如果数据包尺寸超过了索要经过的数据链路层的最大传输限制，路由就会对数据包进行分片，当分片数据到达目标主机后，可以根据分片信息进行数据重组。当然，数据发送源有权决定路由是否启用对传输数据包进行分片，加入所传输的数据超过了输送限制，又禁止了路由分片，发送源会收到<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>的数据帧超长报告信息</p>

<p>在Ipv6中，如果数据包超限制，路由会直接丢弃数据包并且向发送源回传ICMP6的数据帧超长报告信息。源和目标两端会基于这个特性进行<a href="https://en.wikipedia.org/wiki/Path_MTU">路径MTU发现</a>，以此寻找两端之间最大传输单元所在的路由，找到MTU路由后，仅当上层数据包的最小payload确实超过了MTU,IPV6才会进行分片传输，对于IPV6下的tCp来说，这不会造成什么问题。</p>

<h2>TCP-传输控制协议(Transmission Control Protocol)</h2>

<p>TCP层位于IP层之上，是最受欢迎的因特网通讯协议之一，人们通常用TCP/IP来泛指整个因特网协议族。</p>

<p>刚刚提到，IP协议允许两个主机之间传送单一的数据包，为了保证对所传送数据包达到尽力服务的目的，最终的传输结果可能是数据包乱序，重复甚至丢包。</p>

<p>TCP是基于IP 层的协议。但是TCP是可靠地，有序的，有错误检查机制的基于字节流传输的协议。这样当两个设备上的应用通过TCP来传递数据的时候，总能够保证目标接收方收到的数据的顺序和内容与发送方所发出的是一致的。TCP做的这些事看起来很平常，但是比起IP层的粗犷处理方式已经是显著的进步了。</p>

<p>应用程序之间可以通过TCP建立链接，TCP建立的是双向连接，通信双方可以同时进行数据的传输。连接的双方都不需要操心数据是否分块，或者是否采用了尽力服务等。TCP会确保所传输的数据的正确性，即接受方收到的数据与发出方的数据一致。</p>

<p>HTTP是典型的TCP应用，用户浏览器(应用1)与web服务器(应用2)建立连接后，浏览器可以通过连接发送服务请求，web服务器可以通过同样的连接请求作出响应。</p>

<p>同一个host主机上可以有多个应用同时使用TCP协议。TCP用不同的端口来区分应用，作为连接的两端，发送源和接收目标分别拥有自己的IP地址和端口号，凭借这样一对IP地址和端口号，就可以唯一标识一个连接。</p>

<p>使用HTTPS的web服务器会监听443端口，浏览器作为发送源会启用一个临时端口结合自己的IP地址与目标服务器对应的端口和IP地址建立TCP连接。</p>

<p>TCP在IPv4和Ipv6上是无差别运行的。所以如果ipv4和protocol活IPv6的Next Header的协议号被设置为6，表示执行TCP协议。</p>

<h2>TCP Segments (TCP 报文段)</h2>

<p>主机之间传输的数据流一般会先被分块，再转为为TCP报文段，最终会生成IP数据包中的payload的载荷数据</p>

<p>每个TCP报文段都有header信息和对应的载荷payload.payload信息就是待传输的数据块。TCP报文段的header信息中主要包含的是源和目标端口号，至于说源和目标的IP地址信息则已经包含在IP header信息中了。</p>

<p>TCP的报文段header信息中还有报文序列号，确认号等其他一些用于管理连接的信息。</p>

<p>所谓序列号信息，其实就是为每个报文段分配的唯一编号，第一个报文段的序列号是随机的，比如1721092979，其后的每一个报文段的序列号都以此号为基础以此加1，1721092980，1721092981 等等。至于确认号，是目标端反馈给源的确认信息，通知源目前已经接到那些报文段了。由于TCP是双向的，所以数据和确认信息发送也都是双向的。</p>

<h2>TCP连接</h2>

<p>连接管理是TCP的核心功能之一，而且协议需要解决由于IP层采用不可靠传输引发的一系列复杂问题。下面会分别介绍TCP的连接简历，数据传输以及连接终止的详细过程。</p>

<p>TCP连接全过程的状态变化是复杂的，但是大多数情况下还是比较简单的。</p>

<h3>连接建立</h3>

<p>TCP连接都是简历在两个主机之间的。所以，每个连接建立过程中都存在两个角色：一端（例如web服务器）监听连接，另一端(例如应用)主动连接正在监听的一端(web服务器).服务器端的这种监听行为被称为passive open(被动打开)。客户端主动连接服务器的行为称为active open(主动打开)</p>

<p>TCP会通过三次握手来完成连接建立，具体过程是这样的：</p>

<ol>
<li>客户端首先向服务器端发送一个SYn包和一个随机序列号A</li>
<li>服务器端收到回回复客户端一个SYn_ACK包以及各一个确认号（用于确认收到SYN）A+1,同时再发送一个随机序列号B</li>
<li>客户端收到后会发送一个ACK包以及确认号（用于确认收到SYN-ACK）B+1和序列号A+1给服务端</li>
</ol>


<p>SYN是Synchronize sequence numbers（同步序列号）的缩写。两端在传递数据时，所传递的每个TCP报文段都有一个序列号。就是利用这种机制，TCP可以确保分块传输的数据包最终都已正确的个数和顺序抵达目标端。在正式传输开始之前，源和目标端需要同步确认第一个报文的序列号。</p>

<p>ACK 是acknowledgment(确认)的缩写。当某一端接到了报文包后，通过回传已报文序列号来确认接收到报文这件事。</p>

<p>运行如下语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -4 http://www.apple.com/contact/</span></code></pre></td></tr></table></div></figure>


<p>这是通过<code>curl</code>命令与www.apple.com 的 80端口创建一个TCPl连接</p>

<p>www.apple.com所在服务器23.63.125.15（注意，整个 IP 不是固定的）会监听80端口。我们自己的IP地址是<code>10.0.1.6</code>，启用的临时端口52181(这个端口是从可用端口中随机选择的)。利用tcpdump(1)输出的三次握手过程是这样的、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15
</span><span class='line'>18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0
</span><span class='line'>18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0
</span><span class='line'>18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里的信息量很大，下面要逐个分析一下：</p>

<p>最左边的是系统时间。当执行命令的时间是晚上18:31。后面的IP代表的是这些都是IP协议数据包。</p>

<p>接下来看这段10.0.1.6.52181 > 23.63.125.15.80，这一对是源和目标端的IP地址+端口。第一行和第三行是客户端发向服务端的信息，第二行是服务端发向客户端的。tcpdump会自动把端口号加到IP地址后头，比如 10.0.1.6.52181 表示 IP 地址为 10.0.1.6，端口号为 52181。</p>

<p><code>Flags</code>表示TCP报文段header信息中的一些缩写标识：<code>S</code>代表SYN,<code>.</code>代表ACK,<code>P</code>代表PUSH,F是FIN.还有一些其他的标识，这边就不罗列了。注意上面三行Flags中先是携带SYN,接着是SYN-ACK,最后是ACK,这就是三次握手确认的全过程。</p>

<p>另外，第一行中客户端发送了一个随机序列号1721092979（就是上文中所说的A）给服务器，第二行展示的是服务器回传给客户端的确认号<code>1721092980 (A+1)</code>和一个随机序列号 673593777 (B).最后在第三行，客户端将自己的确认号 673593778 (B+1) 发送给服务端.</p>

<h2>其他选项</h2>

<p>当然，在连接建立过程中还会配置一些其他信息。比如第一行中客户端发送的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol]</span></code></pre></td></tr></table></div></figure>


<p>还有第二行服务端发送的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1]</span></code></pre></td></tr></table></div></figure>


<p>其中<code>TS val / ecr</code>是TCP用来创建RTT 往返时间(round-trip time)的。TS val 是发送方的时间戳，ECR 是相应应答时间戳，通常情况下就是发送方收到的最后时间戳。TCP以RTT作为其拥塞控制算法 (congestion-control algorithms) 的依据</p>

<p>连接的两端都发送 sackOK.这样会启用选择性确认(Selective Acknowledagement)机制，使连接双方能够确认收到的字节返回。一般情况下，确认机制只是确认接受方已收到的数据的字节总数。</p>

<p><code>mss</code>选项声明了最大报文长度，表示接收端希望接收的单个报文的最大长度。wscale是窗口放大因子。</p>

<h2>数据传输</h2>

<p>一旦建立了连接，双方就可以互发数据了。发送端所发出的每个报文段都有一个序列号，这个序列号与当下已传送的字节总数有关。接收端会针对已接收的数据包向源端发送确认报文，确认信息同样是由报文header所携带的ACK</p>

<p>假设现在传送的信息是除最后一个报文5字节外，其它都是10字节。具体是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>host A sends segment with seq 10
</span><span class='line'>host A sends segment with seq 20
</span><span class='line'>host A sends segment with seq 30    host B sends segment with ack 10
</span><span class='line'>host A sends segment with seq 35    host B sends segment with ack 20
</span><span class='line'>                                    host B sends segment with ack 30
</span><span class='line'>                                    host B sends segment with ack 35</span></code></pre></td></tr></table></div></figure>


<p>整个机制是双向运转的，A主机会持续的发送数据包。B收到数据包后会向A发送确认信息。A发送数据包的过程不需要等待B的确认。</p>

<p>TCP将流量控制和其它一系列复杂机制结合起来进行拥塞控制。需要处理以下问题：针对丢失的报文采用重发机制，同时还需要动态的调整发送报文的频率。</p>

<p>流量控制的原则是发送方发送数据的速度不能比接收方处理数据的速度快。接收方，也就是所谓的接收窗口会告知发送方自身接收窗口数据缓冲区的大小。从上面tcpdump的输出看，窗口大小是 <code>win 65535</code>,<code>wscale</code>（窗口放大因子）是4.这些数字的意思是说：<code>10.0.1.6</code>主机的接收窗口大小是4＊64 kB = 256 kB,<code>23.63.125.15</code>主机的<code>win</code>是<code>14480</code>,<code>wscale</code>是1，接收窗口约为14kb.总之，不管哪一方作为数据接收方，都会向对方通报自己的接收窗口的大小。</p>

<p>拥塞控制要更负责一些，所有拥塞控制的目标都是要计算出当前网络中数据传输的最佳速率。所谓最佳速率就是要达到一种微妙的平衡。一方面，是希望速度越快越好，另一方面，速度快意味着数据传输多，这样处理性能会打打打折甚至崩溃。而这种超负荷崩溃是分组交换网络的固有特点。当负载过大，数据包之间会产生拥塞，直接导致丢包率急速上升。</p>

<p>拥塞控制还需要充分考虑对流量的影响。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部IP协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估RTT往返时间，然后基于RTT去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致TCP需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP连接往往会是短暂而低效的。在简历连接的初期，TCP协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况作出实时的合理的评估。</p>

<p>之前展示了客户单和服务端之间交换的三段报文，再看看关于连接的其它信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.150955 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [P.], seq 1721092980:1721093065, ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 85
</span><span class='line'>18:31:29.161213 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], ack 1721093065, win 7240, options [nop,nop,TS val 1433256633 ecr 743929773], length 0</span></code></pre></td></tr></table></div></figure>


<p>客户端<code>10.0.1.6</code>发送的第一段报文长度是85 bytes(http请求)。由于在上一个报文发送后没有收到来自服务端的信息，所以ACK确认号值不变。</p>

<p>服务端 <code>23.63.125.15</code>只是对接收客户端的数据进行确认回复，没有向客户端发送数据，所以length为0，由于当前连接是采用选择性确认，所以序列号和确认好之间的字节长度从1721092980到1721093065，也就是85 bytes.接收方发送的ACK确认号是1721093065,这代表目前已接收的数据确认累计到1721093065字节了。至于说为什么数字会如此之大，这要说道初次握手时发出的随机数，数字的范围和那个初始数字是相关的。</p>

<p>这种模式会一直持续到全部数据传送完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.189335 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673593778:673595226, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190280 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673595226:673596674, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190350 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673596674, win 8101, options [nop,nop,TS val 743929811 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190597 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673596674:673598122, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190601 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673598122:673599570, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190614 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673599570:673601018, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190616 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673601018:673602466, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190617 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673602466:673603914, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190619 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673603914:673605362, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190621 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673605362:673606810, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190679 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673599570, win 8011, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190683 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673602466, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190688 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190703 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190743 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673606810, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190870 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673606810:673608258, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.198582 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [P.], seq 673608258:673608401, ack 1721093065, win 7240, options [nop,nop,TS val 1433256670 ecr 743929811], length 143
</span><span class='line'>18:31:29.198672 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608401, win 8183, options [nop,nop,TS val 743929819 ecr 1433256660], length </span></code></pre></td></tr></table></div></figure>


<h2>终止连接</h2>

<p>最终连接会终止(或结束)，连接的每一端都会发送FIN标识给另一端来声明结束传输，接着另一端会对收到的FIN进行通知，当连接两端均发送完各自FIN和做出相应的确认后，连接将会彻底关闭：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.199029 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [F.], seq 1721093065, ack 673608401, win 8192, options [nop,nop,TS val 743929819 ecr 1433256660], length 0
</span><span class='line'>18:31:29.208416 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [F.], seq 673608401, ack 1721093066, win 7240, options [nop,nop,TS val 1433256680 ecr 743929819], length 0
</span><span class='line'>18:31:29.208493 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608402, win 8192, options [nop,nop,TS val 743929828 ecr 1433256680], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里值得注意的是第二行，<code>23.63.125.15</code>发送了FIN，同时在这个报文信息中还对第一行中的另一端发送的FIN予以ACK(以.代表)确认。</p>

<h2>HTTP-超文本传输协议（Hypertext Transfer Protocol）</h2>

<p>1989年，Tim Berners lee 在<a href="https://en.wikipedia.org/wiki/CERN">CERN</a>担任软件咨询师的时候，开发了一套程序，奠定了万维网的基础。HyperText Transform Protocol（超文本转移协议，即HTTP）,是用于从WWW服务器传输超文件到本地浏览器的传送协议。<a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 定义了今天普通使用的一个版本:HTTP 1.1</p>

<h3>请求与响应</h3>

<p>HTTP采用简单的请求和响应机制，在safari输入<code>http://www.apple.com</code>时，会向www.apple.com所在的服务器发送一个http请求。服务器会在对请求作出一个响应，将请求结果信息返回给Safari.</p>

<p>每一个请求都有一个对应的响应信息。请求和响应遵从同样的格式，第一行是请求行或者响应状态行，接下来是header信息，header信息之后会有一个空行。空行之后是body请求信息体</p>

<h3>一个简答请求</h3>

<p>当safari加载html页面<a href="http://www.objc.io/about.html">http://www.objc.io/about.html</a>的时候，先是发送HTTP请求到<code>www.objc.io</code>,请求的内容是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /about.html HTTP/1.1
</span><span class='line'>Host: www.objc.io
</span><span class='line'>Accept-Encoding: gzip, deflate
</span><span class='line'>Connection: keep-alive
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.74.9 (KHTML, like Gecko) Version/7.0.2 Safari/537.74.9
</span><span class='line'>Referer: http://www.objc.io/
</span><span class='line'>DNT: 1
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>第一样是请求行，它包含三部分信息：动作，资源信息，还有HTTP的版本</p>

<p>本例中，动作是GET,所谓动作也就是常说的HTTP请求方法， 资源信息表明所请求的资源。例子中的资源信息是 /about.html,这表示我们想get服务器的在/about.html位置中的文档。当前HTTP版本是HTTP/1.1</p>

<p>接下来10行是HTTP header信息。跟着是一行空行。例子中请求没有body信息。</p>

<p>header的作用是向服务器传递一些额外的辅助信息，它的内容比较宽泛，维基百科中又<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">常用HTTP header关键字</a>信息的清单。例子中的header信息:<code>Host: www.objc.io</code>表示告诉服务器，本次请求的服务器名称是什么。这样可以让同一个服务器处理针对多个域名的请求。</p>

<p>下面是一些常见的header信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>服务器可能具备返回多种媒体类型的能力，Accept表示safari希望接收的媒体格式类型，text/html是胡亮媒体，也被称为MIME类型或者是内容类型(Content-TYpes).<code>q=0.9</code>表示Safari对给定媒体类型的优先级要求。Accept_Lanaguage 代表Safari希望接收的自然语言清单。这回要求服务器尽可能的根据清单要求去匹配相应的语言。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept-Encoding: gzip, deflate</span></code></pre></td></tr></table></div></figure>


<p>通过这个header,Safari告诉服务器可以对响应boday做压缩处理，如果header信息中没有设置压缩标识，那么服务器就必须返回没有压缩过的信息。压缩可以大大减少数据的传输量，在文本信息(比如HTML)中尤为明显。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"</span></code></pre></td></tr></table></div></figure>


<p>这两行信息表明Safari已经对请求结果做过缓存，如果服务器上的请求内容在2月10号以后发生过变化或者是etag与<code>a54907f38b306fe3ae4f32c003ddd507</code>不匹配，这就表示请求结果与当前缓存信息不一致，需要服务器返回最新的请求结果。</p>

<p>user-agent 是告知服务器当前发送请求的客户端类型。</p>

<h3>一个简单响应</h3>

<p>作为上面的请求的响应，服务器的返回是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 304 Not Modified
</span><span class='line'>Connection: keep-alive
</span><span class='line'>Date: Mon, 03 Mar 2014 21:09:45 GMT
</span><span class='line'>Cache-Control: max-age=3600
</span><span class='line'>ETag: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Last-Modified: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>Age: 6
</span><span class='line'>X-Cache: Hit from cloudfront
</span><span class='line'>Via: 1.1 eb67cb25620df959ba21a943fbc49ef6.cloudfront.net (CloudFront)
</span><span class='line'>X-Amz-Cf-Id: dDSBgR86EKBemW6el-pBI9kAnuYJEaPQYEqGmBnilD12CbixCuZYVQ==</span></code></pre></td></tr></table></div></figure>


<p>第一行是状态航，它包括HTTP版本，状态码(204)和状态信息</p>

<p>HTTP定义了一系列状态码，他们各有用途，本利中的304表示所请求的信息自上次访问以来没有变化</p>

<p>响应中没有包含body信息。也就说服务器通知客户端：你的版本已经是最新的了，可以直接使用当前缓存信息</p>

<h3>关闭缓存</h3>

<p>用curl 发送一个请求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% curl http://www.apple.com/hotnews/ &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p><code>curl</code>没有使用本地缓存，整个请求会是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /hotnews/ HTTP/1.1
</span><span class='line'>User-Agent: curl/7.30.0
</span><span class='line'>Host: www.apple.com
</span><span class='line'>Accept: */*</span></code></pre></td></tr></table></div></figure>


<p>这个请求与之前Safari发的请求很类似，但是curl请求的header信息中没有<code>If-None-Match</code>,所以服务器必须将请求结果返回。</p>

<p>此处<code>curl</code>头信息中声明的<code>Accept: */*</code>表示可以接收任何媒体类型。</p>

<p>来自www.apple.com的响应：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 200 OK
</span><span class='line'>Server: Apache
</span><span class='line'>Content-Type: text/html; charset=UTF-8
</span><span class='line'>Cache-Control: max-age=424
</span><span class='line'>Expires: Mon, 03 Mar 2014 21:57:55 GMT
</span><span class='line'>Date: Mon, 03 Mar 2014 21:50:51 GMT
</span><span class='line'>Content-Length: 12342
</span><span class='line'>Connection: keep-alive
</span><span class='line'>
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US"&gt;
</span><span class='line'>&lt;head&gt;
</span><span class='line'>    &lt;meta charset="utf-8" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>后面还会有一些，现在收到的响应里body中包含了HTML文档信息</p>

<p>Apple服务器响应的状态码是200,这是标准的表示HTTP请求成功的状态码。</p>

<p>服务器同时还告知响应媒体类型是 <code>text/html</code>;字符集<code>charset=utf-t</code>；内容长度：<code>Content-length:12342</code>,还代表了body信息的大小</p>

<h2>HTTPS-安全的HTTP</h2>

<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>(安全传输层协议，TLS)是一种基于TCP的加密协议，它支持两件事情：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于TLS的HTTP请求就是HTTPS</p>

<p>用https去替代http,在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。</p>

<h3>TLS 1.2</h3>

<p>如果服务器支持的话，你应该讲<code>TLSMinmumSupportedProtocol</code>设置为<code>kTLSProtocol12</code>,以要求使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2"><code>TLS1.2</code></a>版本，这能有效的防御<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a></p>

<h2>证书锁定(Certificate Pinning)</h2>

<p>如果不确定数据接收方的身份，那么即便对所传输数据进行加密也没什么意义。服务器的证书可以表明服务器的身份，只允许好持有某个特定证书的一方建立连接，就是<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">证书锁定</a></p>

<p>如果一个客户端通过TLS和服务器建立连接，操作系统会验证服务器证书的有效性。当然，有很多手段可以绕开这个校验，最直接的是在iOS设备上安装证书并且将其设置为可信的，这种情况下，实施<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">中间人攻击</a>也不是什么难事。</p>

<p>可以使用证书锁定来规避这种风险。当监理TLS连接后，应立即检查服务器的证书，不仅要验证证书的有效性，还需要确定证书和其持有者是否匹配。考到应用和服务器需要同时升级证书的要求，这种方式比较适合应用在访问自家服务器的情况下。</p>

<p>为了实现证书锁定，在建立连接的过程中需要对服务器进行信任检查，每当通过NSURLSession创建了连接，<code>NSUrlSession</code>的代理就会收到一个
<code>-URLSession:didReceiveChallenge:completionHandler:</code>的调用。传递的参数<code>NSURLAuthenticationChallenge</code>有一个属性<code>protectionSpace</code>，它是<code>NSURLProtectionSpace</code>的实例，它有一个<code>serverTrust</code>属性。</p>

<p><code>serverTrust</code>是一个<code>SecTrustRef</code>对象，<code>Security</code>框架提供了很多方法用于验证<code>SecTrustRef</code>。<code>AFNetworking</code>项目中的<code>AFSecurityPolicy</code>就是一个不错的使用。一如既往的提醒大家，如果要自己构建全验证相关的代码，请一定要认真做好代码审查，千万不要再出现诸如<code>goto fail</code>这类bug</p>

<h2>综合讨论</h2>

<p>现在大家多IP，TCP，和http的工作原理有了一定的了解了。下面说说还可以做些什么</p>

<h3>有效地使用连接</h3>

<p>TCP连接容易在两个时点出现问题：初始设置，以及通过连接传输的最后一部分报文</p>

<h3>建立连接</h3>

<p>连接设置可能会非常耗时，正如前文所说，TCPj建立连接的过程中需要进行三次握手，这个过程中本身没有太多的数据需要传递，但是，对于移动网络来说，从手机端向服务器端发送一个数据包普遍需要250ms,也就是四分之一秒。推及到三次握手，也就是说在还没有传送任何数据之前，光建立连接就花费了750ms</p>

<p>https的情况更夸张，由于Https是基于TLS的http,而http又基于TCP,TCP连接就要执行三次握手，然后到了TLS层还会再握手三次，估算一下，建立一个HTTPS连接的耗时只要是创建一个https连接的两倍。如果RTT时间是500ms(假设单程250ms)，HTTPS建立连接累计总耗时1.5秒</p>

<p>不管建立连接后传递多少数据，建立连接本身都太过耗时了。</p>

<p>另一个影响TCP连接的因素是传送大规模的数据。如果要在网络情况未知的条件下传送报文，TCP需要侦测当前网络的能力。换句话说，TCP得花费一定的事件去计算此网络最佳传输速率。上文提到过，TCP需要逐步调整以便找到最佳速度。这种算法成为<a href="https://en.wikipedia.org/wiki/Slow-start">慢启动</a>。还有一点值得注意，慢启动策略在那些数据链路层传输质量较差的网络环境中的表现更差，无线网络就是典型的例子</p>

<h3>结束连接</h3>

<p>另一个问题主要存在于数据传输的最后阶段。每当客户端发起HTTP请求某些资源的时候，服务器会持续的向客户端发送TCP报文数据，客户端收到数据后会给服务器反馈ACK报文数据，客户端收到数据后会给服务器反馈ACK确认信息。假如某个报文在传输过程中发生丢包，那么服务器也就不会收到该包的确认ACK.一旦服务器发现现有数据包没有ACK反馈，就会触发快速重传。</p>

<p>每当某个数据包丢失，数据接收方在收到下个数据包后发出的确认ACK与所接收的前一个数据包的确认ACK相同。那么数据发送方自然就会收到重复的ACK.除了报文丢失，还有很多网络状况会导致重复ACK的问题。一般情况下，如果数据发送方连续收到3个重复的ACK就会立即进行快速重发</p>

<p>这所导致的问题将发生在数据传输的收尾阶段。如果发送方完成数据发送，接受方自然会停止发送ACK确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包丢失问题的（以为不会收到三个相同的确认ACK,所以不能界定传输丢包），在常规的网络环境下，四个数据包相当于5.7kb的数据规模。总之，在这最后的5.7kb的传输过程中，快速重发机制是无效的。针对这种情况，TCP会启用其它机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>

<h3>长连接和管线化</h3>

<p>HTTP有两种策略来解决这些问题，最简单的是<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP持久连接(persistent connection)</a>，也被称为长连接。具体就是,每当HTTP完成一组请求-响应后，还会继续复用相同的TCP连接。而HTTPS会复用同样的TLS连接：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>第二部就是利用了<a href="https://en.wikipedia.org/wiki/Http_pipelining">HTTP管线</a>处理，即允许客户端利用同样的连接并行发送多个请求，也就是说无需等待上一个请求的响应完成可以发下一个请求。这表示能同时处理请求和响应，请求处理的顺序采用先进先出的原则，响应结果会按照请求发出的顺序依次返回给客户端</p>

<p>稍微简化一下，看起来会是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>client sends HTTP request 4 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>                            &lt;- server sends HTTP response 4
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>注意，服务器发出的响应是实时的，不会等到接收完全请求才处理。</p>

<p>可以利用这个特点来提升TCP的效率，只需要在简建立连接初始阶段执行握手，而后一直复用同样的连接。这样TCP就可以最大限度的利用带宽，此种情况下，拥塞控制也会随之提升。因为快速重复机制无法处理的最末四个报文丢失情况只会发生在使用本地连接的最后一个请求-响应中，而不是像之前那样每一个请求-响应都需要建立自己的连接，每个连接中都可能出现最后四个报文丢失的问题。</p>

<p>HTTP管线化对高网络延迟连接的通讯性能提升尤为显著，在你的iPhone没有通过wifi访问网络的时候，此类网络连接就属于高延迟范畴。实际上，有调差显示，在移动网络环境下，<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>的通讯性能并不优于HTTP管线。</p>

<p><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>指明，在与同一个服务器通讯的时候，如果启用了http管线，建议启用两个连接。按照说明所述，这样能获得最优的响应效率，能最大限度避免拥塞，增加更多的连接也不会再对性能有什么明显改善。</p>

<p>遗憾的是，还有相当多的服务器不支持管线话，由于这个原因，HTTP管线在<code>NSURlSession</code>中默认是关闭的，如果想要开启HTTP管线，需要将<code>NSURLSessionConfiguration</code>中的<code>HTTPShouldUsePipelining</code>设置为YES.另外，建议服务器最好还是支持管线化</p>

<h3>超时处理</h3>

<p>我们都有在网络不太好的情况下使用app的经历，很多app大概15s左右就会结束请求并且反馈一个超时信息，这种设计其实是很不好有的。应该给用户一个他们理解的友好提示，比如：“你好，现在网络状态不太好，你需要多等一会”。但是即便网络状况良好，只要连接还在，TCP都会保证将请求发出去并且会一直等待响应的返回，只是时间长短问题。</p>

<p>从另一个角度来说，在较慢的网络中，请求-响应的RTT时间可能会有17秒。如果15秒就决定终止请求，就算用户有足够的耐心，他们也没积水等到想要的操作结果，反过来，如果我们给出用户响应的提示信息，而他们又刚好愿意多等一会，用户可能会更喜欢使用这样的应用。</p>

<p>一直以来都有一种误解，用重发请求来解决上面的问题，注意，这不是问题的关键，因为TCP有自己的重复机制。</p>

<p>正确的处理方式应该是：没放发起一个请求的时候，同时启动一个10秒计时器，如果请求在10秒之内返回，就把计时器关掉。如果超过10秒，可以给用户一个提示：“网络不好请稍后”。我建议再给用户一个取消按钮，让他们可以自行选择等待还是取消请求，当然提示信息的具体内容和是否配备取消按钮，这个可以视各app的情况去决定。总而言之，开发者最好不要直接替用户做决定，比如直接终止他们的请求。</p>

<p>只要连接双方的IP地址是不变的，可用的，连接就一定是活跃的。如果把iPhone从wifi连接切换到3G网络，这样连接就会变得不可用，因为的IP地址发生了变化，基于原IP地址创建的路由自然是失效的。</p>

<h2>缓存</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveSwift入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men/"/>
    <updated>2016-11-16T10:29:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men</id>
    <content type="html"><![CDATA[<h2>Signal</h2>

<p>一个signal类型的实例，代表了一个有时序的并且可以被观察(类似订阅)的事件流。</p>

<p>信号通常被用来表示正在进行中的事件流，比如通知，用户输入等。用户（或者只要能造成事件的东西）产生的事件发送或者被接受，事件就被传递到信号上，并且被推送(push-Driven)到任何观察者哪里，并且所有观察者都是同时收到这些事件。</p>

<p>如果你想访问一系列的事件，就必须观察一个信号，观察一个信号并不会触发任何副作用，可以这样理解。信号是由生产者生产和推动的，消费者（观察者）是不会对事件的生命周期有任何影响。在观察一个信号时，发送了什么事件，只能对这个事件操作，因为信号是由时序的，不能随机的访问其他事件。</p>

<p>信号可以通过原函数去操作，比如filter,map,reduce,也可以同时操作多个信号如zip,这些原函数只在nextEvents生效（也就是对complete,failure等不生效）</p>

<p>在一个信号的生命周期里，可以发送无数次的NextEvents事件，直到他们被终结，类似compleye,Failed,InterRupper.终止事件没有数据值，所以他们必须被单独处理。</p>

<h2>Subscription</h2>

<p>一个信号通常被用来表示正在进行中的事件流，有时候他们被叫做热信号，这意味着订阅者可以错过一些在它订阅前发送的事件。订阅一个信号不会触发任何副作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>20
</span><span class='line'>21
</span><span class='line'>22
</span><span class='line'>23
</span><span class='line'>24
</span><span class='line'>25
</span><span class='line'>26
</span><span class='line'>27
</span><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    // Signal.pipe is a way to manually control a signal. the returned observer can be used to send values to the signal
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nonerror&gt;.pipe()
</span><span class='line'>    let subscriber1 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to the signal")
</span><span class='line'>    print("\(observer)")
</span><span class='line'>    signal.observe(subscriber1)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    // subscriber1 will receive the value
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    print("Subscriber 2 subscribes to the signal")
</span><span class='line'>    // Notice how nothing happens at this moment, i.e. subscriber2 does not receive the previously sent value
</span><span class='line'>    signal.observe(subscriber2)
</span><span class='line'>    print("Send value `20` on the signal")
</span><span class='line'>    // Notice that now, subscriber1 and subscriber2 will receive the value
</span><span class='line'>    observer.sendNext(20)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to the signal
</span><span class='line'>Observer&lt;int, nonerror&gt;(action: (Function))
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber 1 received 10
</span><span class='line'>Subscriber 2 subscribes to the signal
</span><span class='line'>Send value `20` on the signal
</span><span class='line'>Subscriber 1 received 20
</span><span class='line'>Subscriber 2 received 20&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>因为Swift有泛型的存在，这样的话我们可以把Signal当做任何数据类型的容器，而不是像OC中利用上帝类型Id，更加方便传递数据</p>

<p>首先我们通过Signal.pipe()创建了一个信号和一个观察者。</p>

<p>奇怪的是，在RACOC部分中，我们很少主动创建观察者，我们通常直接订阅信号就可以。</p>

<p>在Swift中，通过pipe创建的信号是个热信号，类似于OC中的RACSubject系列，在RACSubject继承自RACSiganl又继承RACStream，RACStream是一个Monad,它可以代表数据和数据的一系列的操作如map,flatterMap,bind</p>

<p>RACSubject又遵守了RACSubscriber协议，这个协议定义了可以发送数据的操作。</p>

<p>所以RACSubject即是一个信号，又是一个观察者。</p>

<p>在Swift部分的实现中，Signal并没有实现发送数据的方法。所以它需要一个内部的Observer去发送数据。所以它被pipe直接返回。</p>

<p>在外部我们需要自己实例化一个Observer观察者。去订阅事件。</p>

<p>可能在你查看Pipe的实现的时候并不好理解。把尾随闭包补全相对好理解点。</p>

<p>做个总结：</p>

<ul>
<li>RACOC中：RACSubject = RACSignal + RACSubscriper，在订阅的时候，订阅者被放在了RACSubject内部存放，我们只需要去关注订阅的block实现即可。</li>
<li>RACSwift中:Signal 仅仅就是一个信号，所以需要一个内部观察者去充当发送数据的工具。外部的订阅需要自己手动实例观察者</li>
<li>热信号：由于pipe方法返回的是热信号，所以一个订阅者会错过在订阅之前发送的事件
*</li>
</ul>


<h3>empty</h3>

<p>空信号直接发送一个interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptySignal = Signal&lt;int, nonerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, nonerror&gt;(
</span><span class='line'>    failed: { _ in print("error not called") },
</span><span class='line'>    completed: { print("completed not called") },
</span><span class='line'>    interrupted: { print("interrupted called") },
</span><span class='line'>    next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptySignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>interrupted called&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Never</h3>

<p>一个Never信号不会发送任何事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverSignal = Signal&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        interrupted: { print("interrupted not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverSignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>uniqueValues唯一值</h3>

<p>仅从集合中发送一次相同事件&ndash;类似与arrayQueue变成了Setqueue</p>

<p>注意：这会造成被发送的值被保留下来，用于以后发送的时候来检查是否重复，你可以编写一个函数来过滤重复值，这样可以减少内存消耗。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>scopedExample("`uniqueValues`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let uniqueSignal = signal.uniqueValues()
</span><span class='line'>    uniqueSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(5)
</span><span class='line'>}
</span><span class='line'>--- `uniqueValues` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2
</span><span class='line'>Subscriber received 3
</span><span class='line'>Subscriber received 4
</span><span class='line'>Subscriber received 5&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每一个发送的值转换成新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let mappedSignal = signal.map { $0 * 2 }
</span><span class='line'>    mappedSignal.observe(subscriber)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber received 20&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error值变成新的error值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>        let userInfo = [NSLocalizedDescriptionKey: "??"]
</span><span class='line'>        let code = error.code + 10000
</span><span class='line'>        let mappedError = NSError(domain: "com.reactivecocoa.errordomain", code: code, userInfo: userInfo)
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nserror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, nserror&gt;(failed: { print("Subscriber received error: \($0)") } )
</span><span class='line'>    let mappedErrorSignal = signal.mapError { (error:NSError) -&gt; NSError in
</span><span class='line'>        return mappedError
</span><span class='line'>    }
</span><span class='line'>    mappedErrorSignal.observe(subscriber)
</span><span class='line'>    print("Send error `NSError(domain: \"com.reactivecocoa.errordomain\", code: 4815, userInfo: nil)` on the signal")
</span><span class='line'>    observer.sendFailed(NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil))
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Send error `NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil)` on the signal
</span><span class='line'>Subscriber received error: Error Domain=com.reactivecocoa.errordomain Code=14815 "??" UserInfo={NSLocalizedDescription=??}&lt;/int, nserror&gt;&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>用于过滤一些值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    // subscriber will only receive events with values greater than 12
</span><span class='line'>    let filteredSignal = signal.filter { $0 &gt; 12 ? true : false }
</span><span class='line'>    filteredSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    observer.sendNext(11)
</span><span class='line'>    observer.sendNext(12)
</span><span class='line'>    observer.sendNext(13)
</span><span class='line'>    observer.sendNext(14)
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>Subscriber received 13
</span><span class='line'>Subscriber received 14&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>在发送的值为可选类型中：如果有值，把值解包，如果是nil丢弃掉</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int?, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int?` and observer is of type `Int`, given we're unwrapping
</span><span class='line'>    // non-`nil` values
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let ignoreNilSignal = signal.ignoreNil()
</span><span class='line'>    ignoreNilSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(nil)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 3&lt;/int, noerror&gt;&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num)只取前num此值得信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let takeSignal = signal.take(2)
</span><span class='line'>    takeSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect</h3>

<p>在发送complete事件之后，观察者会收到一个由之前事件组成的数组</p>

<p>注意：如果在发送complete事件的时候，没有任何事件发送，观察者会收到一个空的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int` and observer is of type `[Int]` given we're "collecting"
</span><span class='line'>    // `Int` values for the lifetime of the signal
</span><span class='line'>    let subscriber = Observer&lt;[Int], NoError&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let collectSignal = signal.collect()
</span><span class='line'>    collectSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendCompleted()
</span><span class='line'>}
</span><span class='line'>--- `collect` ---
</span><span class='line'>Subscriber received [1, 2, 3, 4]&lt;/int, noerror&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h2>SignalProducer</h2>

<p>一个信号发生器，是SignalProducer类型的实例，它可以创建信号(signals)并施加副作用（side effects）</p>

<p>信号发生器用来表示操作或者任务，比如网络请求，每一次对它的调用start()将会生成一个新的潜在操作，并允许调用者观察它的结果，还有一个startWithSignal()方法，会给出产生的信号，允许在必要的情况下监听多次。</p>

<p>根据start()方法的动作方式，被同一个信号发生器生成的信号可能会有不同的事件顺序或版本，甚至事件流完全不一样！和普通的信号不同，在观察者连接上之前，信号发生器不会开始工作（也就没有事件会生成），并且在每一个新的监听器连接上时其工作都会重新开始一个单独的工作流。</p>

<p>启动一个信号发生器会返回一个销毁器(disposable)，它可用来打断或取消被生成信号的工作</p>

<p>和信号一样，信号生成器可以通过map,filter等原函数操作，使用lift方法，所有信号的原函数可以被提升成为以信号生成器为对象的操作，除此以外，还有一些用来控制何时与如何启动信号生成器的原函数，比如times.</p>

<p>通过lift函数可以让热信号转变为冷信号。</p>

<h3>Subscription</h3>

<p>一个信号生成器代表了一种可以在需要的时候才被启动的操作（不像signal是自启动的），这种信号是冷信号，在刚开始这个信号的状态也为冷（未激活），既然是冷信号，那么就意味着这一个观察者不会错过任何被信号生成器发出的值。</p>

<p>补充：像signal是创建的时候状态为cold(理解为未激活)，被订阅时状态为hot(理解为激活)</p>

<p>但是冷信号和热信号与状态为冷热是两个不同的概念，冷信号会带来副作用，热信号不会</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    let producer = SignalProducer&lt;int, noerror&gt; { observer, _ in
</span><span class='line'>        print("New subscription, starting operation")
</span><span class='line'>        observer.sendNext(1)
</span><span class='line'>        observer.sendNext(2)
</span><span class='line'>    }
</span><span class='line'>    let subscriber1 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to producer")
</span><span class='line'>    producer.start(subscriber1)
</span><span class='line'>    print("Subscriber 2 subscribes to producer")
</span><span class='line'>    // Notice, how the producer will start the work again
</span><span class='line'>    producer.start(subscriber2)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 1 received 1
</span><span class='line'>Subscriber 1 received 2
</span><span class='line'>Subscriber 2 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 2 received 1
</span><span class='line'>Subscriber 2 received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>像不像是RACDynamicSignal的创建方式，这不过不同与Sinal的是，这里的发送信号的观察者是在内部通过Signal.pipe()生成的，不需要外部创建。</p>

<p>SignalProduce是冷信号，任何一个订阅者/观察者都不会错过任何事件</p>

<p>start方类似Signal的 signal.observe()方法，只不过Signal的方法只有一个作用，就是关联一个观察者，而SignalProduce的start方法还多了一个激活信号的功能</p>

<h3>Empty</h3>

<p>一个会立即调用complete事件的信号生成器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `empty`
</span><span class='line'> A producer for a Signal that will immediately complete without sending
</span><span class='line'> any values.
</span><span class='line'> */
</span><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptyProducer = SignalProducer&lt;int, noerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed called") },
</span><span class='line'>        interrupted: { print("interrupted called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptyProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>Signal调用的是interrup方法，暂时不知道为什么，可能是为了区分语义吧，Signal是有时序的，SignalProduce是没有时序的。</p>

<h3>Never</h3>

<p>一个什么都不会发送的信号器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `never`
</span><span class='line'> A producer for a Signal that never sends any events to its observers.
</span><span class='line'> */
</span><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverProducer = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>buffer</h3>

<p>创建一个事件队列可以回放已经发送的事件</p>

<p>当一个值被发送的时候，它会被放进缓冲区内，如果缓冲区已经溢出，就会丢弃旧的值</p>

<p>这些被缓存的值将会被保留，直到这个信号被终结，当一个信号启动的时候，如果队列里没有任何值，所有被发送的新值都会被自动转发到观察者那里，直到管着着收到一个终止事件。</p>

<p>当一个终止事件被发送到队列中，观察者不会再收到任何值，并且这个事件不会被计算buffer的缓冲区大小，所以没有缓存的值都会被丢弃。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`buffer`") {
</span><span class='line'>    let (producer, observer) = SignalProducer&lt;int, noerror&gt;.buffer(2)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    var values: [Int] = []
</span><span class='line'>    producer.start { event in
</span><span class='line'>        switch event {
</span><span class='line'>        case let .Next(value):
</span><span class='line'>            values.append(value)
</span><span class='line'>        default:
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print(values)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    print(values)
</span><span class='line'>    let subscriber = Observer&lt;int,noerror&gt;(next:{ bufferdValue in
</span><span class='line'>        print("\(bufferdValue)")
</span><span class='line'>    })
</span><span class='line'>    producer.start(subscriber)
</span><span class='line'>}
</span><span class='line'>--- `buffer` ---
</span><span class='line'>[2, 3]
</span><span class='line'>[2, 3, 4]
</span><span class='line'>3
</span><span class='line'>4&lt;/int,noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithSignal</h3>

<p>通过Producer返回一个Signal,当闭包调用时返回signal开始发送事件</p>

<p>闭包返回一个Disponsable，可以用来中断Signal或者完成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithSignal`") {
</span><span class='line'>    var started = false
</span><span class='line'>    var value: Int?
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .on(next: {
</span><span class='line'>            value = $0
</span><span class='line'>        })
</span><span class='line'>        .startWithSignal { signal, disposable in
</span><span class='line'>            print(signal)
</span><span class='line'>            print(value) // nil
</span><span class='line'>        }
</span><span class='line'>    print(value)
</span><span class='line'>}
</span><span class='line'>--- `startWithSignal` ---
</span><span class='line'>ReactiveCocoa.Signal&lt;swift.int, result.noerror&gt;
</span><span class='line'>nil
</span><span class='line'>Optional(42)&lt;/swift.int, result.noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithNext</h3>

<p>通过信号生成器创建一个信号，并且给这个信号内部直接构建一个观察者，在指定的闭包中会直接订阅next事件。</p>

<p>返回一个Disposable,可以中断这个信号，中断之后这个闭包不会再被调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithNext`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithNext` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个订阅只能接受next事件</p>

<h3>startWithCompleted</h3>

<p>同startWithNext，只不过只能接受complete事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithCompleted`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithCompleted {
</span><span class='line'>            print("completed called")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithCompleted` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithFailed</h3>

<p>同startWithNext， 只不过只能接受Failer事件事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithFailed`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "example", code: 42, userInfo: nil))
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithFailed` ---
</span><span class='line'>Error Domain=example Code=42 "(null)"&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithInterrupted</h3>

<p>同startWithNext,只不过只能接受interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithInterrupted`") {
</span><span class='line'>    let disposable = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>        .startWithInterrupted {
</span><span class='line'>            print("interrupted called")
</span><span class='line'>        }
</span><span class='line'>    disposable.dispose()
</span><span class='line'>}
</span><span class='line'>--- `startWithInterrupted` ---
</span><span class='line'>interrupted called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>lift</h3>

<p>这个相对难理解点，大致类似于RAC_OC部分中的bind函数，monad中bind函数</p>

<p>可以理解为所有的原函数都是通过lift去实现的，借用中间信号来实现一系列的信号变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`lift`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    let transform: Signal&lt;int, noerror&gt; -&gt; Signal&lt;int, noerror&gt; = { signal in
</span><span class='line'>        counter = 42
</span><span class='line'>        return signal
</span><span class='line'>    }
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 0)
</span><span class='line'>        .lift(transform)
</span><span class='line'>        .startWithNext { _ in
</span><span class='line'>            print(counter)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `lift` ---
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每个值都转换为新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 1)
</span><span class='line'>        .map { $0 + 41 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error转换为新的error</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "mapError", code: 42, userInfo: nil))
</span><span class='line'>        .mapError { Error.Example($0.description) }
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Example("Error Domain=mapError Code=42 \"(null)\"")&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>过滤不符合条件的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .filter { $0 &gt; 3}
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num) 只取前几次的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .take(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>1
</span><span class='line'>2&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>observeOn</h3>

<p>在指定调度器上分发事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `observeOn`
</span><span class='line'> Forwards all events onto the given scheduler, instead of whichever
</span><span class='line'> scheduler they originally arrived upon.
</span><span class='line'> */
</span><span class='line'>scopedExample("`observeOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let completion = { print("is main thread? \(NSThread.currentThread().isMainThread)") }
</span><span class='line'>    if #available(OSX 10.10, *) {
</span><span class='line'>    baseProducer
</span><span class='line'>        .observeOn(QueueScheduler(qos: QOS_CLASS_DEFAULT, name: "test"))
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>    }
</span><span class='line'>    baseProducer
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>}
</span><span class='line'>--- `observeOn` ---
</span><span class='line'>is main thread? true&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h2>collect</h2>

<p>在发送完成的时候将一系列的值聚合为一个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect()`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect()` ---
</span><span class='line'>[1, 2, 3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(count:)</h3>

<p>在发送数据的时候（不需要发送complete）的时候将一系列的值聚合为数组，数组的长度为count,如果有很多数据，将会返回多个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(count:)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>        observer.sendNext(5)
</span><span class='line'>//            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect(count: 2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(count:)` ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(predicate:) matching values inclusively</h3>

<p>通过谓词将一系列的值聚合为一个数组，注意在发送complete时候，如果前面只剩下一个值，就不需要聚合（因为没有其它元素和最后一个元素聚合），直接返回一个只有一个元素的数组。如果没有数据则返回一个空数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values inclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>//            observer.sendNext(1)
</span><span class='line'>//            observer.sendNext(2)
</span><span class='line'>//            observer.sendNext(3)
</span><span class='line'>//            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values in values.reduce(0, combine: +) == 3 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values inclusively ---
</span><span class='line'>[]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>尝试打开注释看看会有什么结果</p>

<h3>collect(predicate:) matching values exclusively</h3>

<p>和上一个不同的是，如果谓词成功就把之前的聚合在一起，可以理解为把成功的界限当做分隔符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values exclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendNext(5)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values, next in next == 3 || next == 5  }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values exclusively ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4] // 3满足了条件所以被分开
</span><span class='line'>[5] // 5也是&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>combineLatestWith</h3>

<p>将第一个信号生成器的values和被聚合信号生成器的最后一个值聚合为一个元组</p>

<p>新产生的信号生成器不会发送任何值，只是转发，任何一个原来的信号被中断，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combineLatestWith`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let producer2 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>    producer1
</span><span class='line'>        .combineLatestWith(producer2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combineLatestWith` ---
</span><span class='line'>(1, 2)
</span><span class='line'>(2, 2)
</span><span class='line'>(3, 2)
</span><span class='line'>(4, 2)&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skip</h3>

<p>skip（num），跳过num此发送的事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skip`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    producer1
</span><span class='line'>        .skip(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skip` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>materialize</h3>

<p>将被发送的值(value)编程Event,允许他们被修改。还句话说，允许他们被修改，把一个值变成一个Monad</p>

<p>当收到一个complete或者Failure事件，这个新的信号生成器，会发送事件并且结束。当收到一个interrupted事件，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`materialize`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .materialize()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `materialize` ---
</span><span class='line'>NEXT 1
</span><span class='line'>NEXT 2
</span><span class='line'>NEXT 3
</span><span class='line'>NEXT 4
</span><span class='line'>COMPLETED
</span><span class='line'>// 注意 value  如果不做materialize就是Int类型</span></code></pre></td></tr></table></div></figure>


<h3>sampleOn</h3>

<p>当sampler（被操作的信号生成器）发送任何事件的时候，都转发原来信号生成器的最后一个值</p>

<p>如果当一个sampler启动时，当前的值没有被观察者，没有任何事情发生</p>

<p>新产生的信号生成器从源信号生成器哪里发送数据，如果两个信号生成器任何一个complete或者interrupt,新产生的都会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `sampleOn`
</span><span class='line'> Forwards the latest value from `self` whenever `sampler` sends a Next
</span><span class='line'> event.
</span><span class='line'> If `sampler` fires before a value has been observed on `self`, nothing
</span><span class='line'> happens.
</span><span class='line'> Returns a producer that will send values from `self`, sampled (possibly
</span><span class='line'> multiple times) by `sampler`, then complete once both input producers have
</span><span class='line'> completed, or interrupt if either input producer is interrupted.
</span><span class='line'> */
</span><span class='line'>scopedExample("`sampleOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let sampledOnProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>        .map { _ in () }
</span><span class='line'>    let newProduce = baseProducer
</span><span class='line'>        .sampleOn(sampledOnProducer)
</span><span class='line'>      newProduce  .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `sampleOn` ---
</span><span class='line'>4
</span><span class='line'>4&lt;/int, noerror&gt;&lt;/int, noerror&gt;
</span><span class='line'>sampler发送的2次值都被变换成baseProduce 的comlete前的最后一个值</span></code></pre></td></tr></table></div></figure>


<h3>combinePrevious</h3>

<p>向前合并，没法送一个值就结合历史发送数据的最后一个构造成一个新的元组返回。在第一个发送时由于没有历史数据，所以combinePrevious传递了一个默认值。当做第一次的合并。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combinePrevious`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .combinePrevious(42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combinePrevious` ---
</span><span class='line'>(42, 1) // 第一次没有历史记录默认值是42
</span><span class='line'>(1, 2) // 第二次默认记录是1
</span><span class='line'>(2, 3)
</span><span class='line'>(3, 4)&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>scan</h3>

<p>类似reduce,将值聚合为一个新的值，每次聚合都保留结果作为下次的默认值，首次需给出默认值</p>

<p>每次聚合都会发送这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`scan`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .scan(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `scan` ---
</span><span class='line'>1
</span><span class='line'>3
</span><span class='line'>6
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>reduce</h3>

<p>和scan类似，区别为reduce只发送聚合后的值并且立即结束</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`reduce`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .reduce(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `reduce` ---
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skipRepeats</h3>

<p>跳过表达式里返回true的值，第一个值不会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipRepeats` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>4
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<h3>skipWhile</h3>

<p>对每个值都去做判断，知道返回false,之前的值会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipWhile` ---
</span><span class='line'>1  // 到1 返回false  之前的值被忽略掉
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeUntilReplacement</h3>

<p>在被替换的信号发生器发送信号之后，发送被替换的信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeUntilReplacement`") {
</span><span class='line'>    let (replacementSignal, incomingReplacementObserver) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt; { incomingObserver, _ in
</span><span class='line'>        incomingObserver.sendNext(1)
</span><span class='line'>        incomingObserver.sendNext(2)
</span><span class='line'>        incomingObserver.sendNext(3)
</span><span class='line'>// 下面被替换的信号生成器发送了事件，之后就不再发送baseProducer的事件了
</span><span class='line'>// 相当于被替换了
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>        incomingObserver.sendNext(4)
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>    }
</span><span class='line'>    let producer = baseProducer.takeUntilReplacement(replacementSignal)
</span><span class='line'>    producer.startWithNext { value in
</span><span class='line'>        print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `takeUntilReplacement` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>42
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeLast</h3>

<p>在发送complete事件后只取count此数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeLast`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .takeLast(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>只取了2次数据
</span><span class='line'>--- `takeLast` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>如果发送的事件是可选类型，解包这些可选类型，并且丢弃nil值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    SignalProducer&lt;int?, noerror&gt;(values: [ nil, 1, 2, nil, 3, 4, nil ])
</span><span class='line'>        .ignoreNil()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>zipWith</h3>

<p>压缩信号生成器，只有再两个信号都有数据发送之后，新的信号生成器才会发送数据</p>

<p>新的数据被组合为元组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`zipWith`") {
</span><span class='line'>    let baseProducer = SignalProducer(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let zippedProducer = SignalProducer(values: [ 42, 43 ])
</span><span class='line'>    baseProducer
</span><span class='line'>        .zipWith(zippedProducer)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `zipWith` ---
</span><span class='line'>(1, 42)
</span><span class='line'>(2, 43)</span></code></pre></td></tr></table></div></figure>


<p>后面应为第二个没有数据了，所以不会再聚合了</p>

<h3>times</h3>

<p>time(count)重复发送count数据，每次重复必须上次发送完成事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`times`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    SignalProducer&lt;(), NoError&gt; { observer, disposable in
</span><span class='line'>            counter += 1
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .times(42)
</span><span class='line'>        .start()
</span><span class='line'>    print(counter)
</span><span class='line'>}
</span><span class='line'>--- `times` ---
</span><span class='line'>42</span></code></pre></td></tr></table></div></figure>


<h3>retry</h3>

<p>如果收到失败事件重试retry(count)次</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`retry`") {
</span><span class='line'>    var tries = 0
</span><span class='line'>    SignalProducer&lt;int, nserror&gt; { observer, disposable in
</span><span class='line'>            if tries == 0 {
</span><span class='line'>                tries += 1
</span><span class='line'>                observer.sendFailed(NSError(domain: "retry", code: 0, userInfo: nil))
</span><span class='line'>            } else {
</span><span class='line'>                observer.sendNext(42)
</span><span class='line'>                observer.sendCompleted()
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        .retry(1)
</span><span class='line'>        .startWithResult { result in
</span><span class='line'>            print(result)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `retry` ---
</span><span class='line'>.Success(42)&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<p>当第一个信号发送complete时，第二个信号被替换成信号发送线路上，如果有任何失败事件，后面的就替换失败。</p>

<p>第一个信号发送的所有事件都会被忽略</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160726/1469505056118233.png" alt="1" /></p>

<h3>flatMap</h3>

<p>将收到的每个事件都映射为新的Product,然后摊平，如果原来的producer发送失败，新产生也得立即失败</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMap(.Latest)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .flatMap(.Latest) { SignalProducer(value: $0 + 3) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMap(.Latest)` ---
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>flatMapError</h3>

<p>把收到的failer事件映射为新的Producer,并且摊平它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "flatMapError", code: 42, userInfo: nil))
</span><span class='line'>        .flatMapError { SignalProducer&lt;int, noerror&gt;(value: $0.code) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMapError` ---</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Package Manager入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men/"/>
    <updated>2016-11-11T14:09:18+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men</id>
    <content type="html"><![CDATA[<p>大部分语言都有官方的代码分配解决方案，幸好苹果也在开发替代<a href="https://cocoapods.org/">Cocoapods</a>和<a href="https://github.com/Carthage/Carthage">Carthage</a>的管理工具，<a href="https://swift.org/package-manager/#conceptual-overview">Swift Package Manager</a>(Swift包管理器，下面我们简称SPM)就是一个用来管理Swift代码的分配的官方工具，它为Swift编译系统集成了自动进行下载，编译和连接依赖的过程</p>

<p>目前，SPM还处于早起阶段，现在仅仅支持OS X和linux系统，尚不支持Ios,watchOS以及tvOS平台，但未来很大希望会支持上述平台。</p>

<h2>概念概述</h2>

<p>在swift中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外那些部分是代码是可以被访问控制的。</p>

<p>一个程序可以将它所有代码聚合到一个模块中，也可以将它作为依赖关系导入到其他模块，除了少量系统提供的模块，像OS X中的Darwin或者 Linux中的Glibc等大多数依赖需要代码被下载或者内置才能被使用。</p>

<p>当你将编写额解决待定问题的代码独立成一个模块时，这段代码可以在其他情况下呗重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的app或者一个天气的app里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p>

<p>一个包由Swift源文件和一个清单文件组成，这个清单文件称为<code>Package.swift</code>,定义包或者它的内容使用<code>PackageDescription</code>模块。</p>

<p>一个包邮一个或者多个目标，每个目标制定一个铲平并且可能声明一个后者多个依赖。</p>

<p>一个目标可能构建一个库或者一个可执行文件作为其产品。库是包含可以被其它Swift代码导入的模块。可执行文件是一段可以被操作系统运行的程序</p>

<p>目标依赖是指保重代码必须添加的模块。依赖由包资源的绝对或者相对URL和一些可以被使用的包的版本要求所组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成一个依赖的相关图。包管理器下载和编译所需要满足整个依赖相关图的一切。</p>

<h2>开源Swift入门</h2>

<ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85Swift">下载和安装Swift</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8REPL">使用REPL</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">使用编译系统</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95%E5%99%A8">使用LLDB调试器</a></li>
</ul>


<p>关于使用REPL和LLDB调试器的内容具体可以参阅官方文档<a href="https://swift.org/getting-started/#using-the-repl">使用REPL</a>和<a href="https://swift.org/getting-started/#using-the-lldb-debugger">使用LLDB调试器</a></p>

<h2><a name = "下载和安装Swift"></a>下载和安装Swift</h2>

<p>刚开始下载和安装swift需要下载并安装编译器和其它必备组件，进入到 <a href="https://swift.org/download/#releases">https://swift.org/download/#releases</a>按目标平台的说明进行。</p>

<p>下载完成后，点击按步骤安装就可以</p>

<p>在OS X上下载工具链的默认地址是:<code>/Library/Developer/Toolchains</code>.接着，我们可以输入以下命令导出编译路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>首先需要安装clang:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install clang</span></code></pre></td></tr></table></div></figure>


<p>如果你在Linux上安装的Swift工具链在系统根目录以外的目录，你需要使用你安装Swift的实际路径来运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/path/to/Swift/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>导出路径之后，你可以通过输入 swift 命令并传入 &ndash;version 标志来校验你是否运行了 Swift 的预期版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift --version
</span><span class='line'>Apple Swift version 3.0-dev (LLVM ..., Clang ..., Swift ...)</span></code></pre></td></tr></table></div></figure>


<p>在版本号的后缀 -dev 用来表明它是一个开发的编译，而不是一个发布的版本</p>

<h2><a name = "使用REPL"></a>使用REPL</h2>

<h2><a name = "使用编译系统"></a>使用编译系统</h2>

<p>Swift编译系统为编译库，可执行文件和不同工程之间共享代码提供了基本的约定。</p>

<p>创建一个新的Swift包，首先创建并进入到一个新的目录命令为Hello:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Hello
</span><span class='line'>$ cd Hello</span></code></pre></td></tr></table></div></figure>


<p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件，如果清单文件为空，那包管理器将会使用常规默认的方式来编译包，创建一个空的清空文件使用命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch Package.swift</span></code></pre></td></tr></table></div></figure>


<p>当使用默认方式时，包管理器预计将包含在Source/子目录下的所有源代码。创建方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Sources</span></code></pre></td></tr></table></div></figure>


<h3>编译可执行文件</h3>

<p>默认方式下，目录中包含一个文件称为<code>main.swift</code>将会将文件编译成与包名称相同的二进制可执行文件。</p>

<p>在这个例子中，包将生成一个可以输出<code>hello world</code>的可执行文件为 <em>hello</em></p>

<p>在<em>Source/</em>目录下创建一个命名为<code>main.swift</code>的文件，并使用你喜欢的任意一种编译器输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print("Hello, world!")</span></code></pre></td></tr></table></div></figure>


<p>返回到 Hello 目录中，通过运行 swift build 命令来编译包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build</span></code></pre></td></tr></table></div></figure>


<p>当命令完成之后，编译产品将会出现在 .build 目录中。通过如下命令运行 Hello 程序:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ .build/debug/Hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<p>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code>然后直接用<code>print(_:)</code>替换执行调用的内容。</p>

<h3>多了源文件协作</h3>

<p>在<code>Sources/</code>目录下创建一个新文件命名为<code>Greeter.swift</code>然后输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(name: String) {
</span><span class='line'>  print("Hello, \(name)!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>sayHello(_:)</code>方法带一个单一的字符串参数，然后在前面打印一个"hello",后面跟着函数参数单词"World".</p>

<p>现在打开<code>main.swift</code>，然后替换原来的内容为下面代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if Process.arguments.count != 2 {
</span><span class='line'>    print("Usage: hello NAME")
</span><span class='line'>} else {
</span><span class='line'>    let name = Process.arguments[1]
</span><span class='line'>    sayHello(name)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>跟之前的硬编码不同，<code>main.swift</code>现在从命令行参数中读取。替代之前直接调用<code>print(_:)</code>，<code>main.swift</code>现在调用<code>sayHello(_:)</code>方法，因为这个方法是<code>Hello</code>模块的一部分，所以不需要使用到<code>import</code>语句。</p>

<p>运行<code>swift build</code>并尝试<code>Hello</code>的新版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/Hello 'whoami'</span></code></pre></td></tr></table></div></figure>


<p>目前为止，你已经能够运用开源Swift来运行一些你想要的程序了。接下来我们就可以进入正题开始入手SPM.</p>

<h3>快速入门实例</h3>

<p>在本章节中，我们简单地学会了编译一个"`Hello world"程序。</p>

<p>为了了解SPM究竟能做什么，我们来看一下下面这个由4个独立的包组成的例子:</p>

<ul>
<li><a href="https://github.com/marklin2012/O2PlayingCard.git">O2PlayingCard</a>-定义了O2PlayingCard ， O2Suit ， O2Rank ， 3个类型</li>
<li><a href="https://github.com/marklin2012/O2FisherYates.git">O2FisherYates</a>-定义了 shuffle() 和 shuffleInPlace() 方法实现的扩展</li>
<li><a href="https://github.com/marklin2012/O2DeckOfPlayingCards.git">O2DeckOfPlayingCards</a>-定义了一个 O2Deck 类型对 O2PlayingCard 值得数据进行洗牌和抽牌。</li>
<li><a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer</a>-定义了一个用来创建 O2DeckOfPlayingCards 进行洗牌和抽出前10个卡片的可执行文件。</li>
</ul>


<p>你可以从<a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer from GitHub </a>编译并运行完整例子，然后运行如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd O2Dealer
</span><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/O2Dealer</span></code></pre></td></tr></table></div></figure>


<h3>创建一个库包</h3>

<p>我们将从创建一个代表一副标准的52张扑克牌的模块开始。 O2PlayingCard 模块定义了 由 O2Suit 枚举值（Clubs, Diamonds, Hearts, spades）和 O2Rank 枚举值（Ace, Two, Three, …, Jack, Queen, King）组成的 O2PlayingCard 类。各个类的核心代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum O2Rank : Int {
</span><span class='line'>    case Ace = 1
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public enum O2Suit: String {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public struct O2PlayingCard {
</span><span class='line'>    let rank: O2Rank
</span><span class='line'>    let suit: O2Suit
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，一个包包括位于Source/的源文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2PlayingCard
</span><span class='line'>├── Sources
</span><span class='line'>│   ├── O2PlayingCard.swift
</span><span class='line'>│   ├── O2Rank.swift
</span><span class='line'>│   └── O2Suit.swift
</span><span class='line'>└── Package.swift</span></code></pre></td></tr></table></div></figure>


<p>由于<code>O2PlayingCard</code>模块并不会生成可执行文件，这里应该成为库。库表示被编译成一个可以被其它包导入的模块的包，默认情况下，库模块公开所有位于<code>Sources/</code>目录下的源代码中声明的公共类型的方法。</p>

<p>运行 swift build 开始启动 Swift 编译的过程。如果一切进行顺利，将会在 .build/debug 目录下生成 O2PlayingCard.build 目录。</p>

<p>接下来，我们在<code>Package.swift</code>文件中定义包名，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>  name: "O2PlayingCard"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>然后我们只要将<code>O2PlayingCard</code>提交到Github上，并且给他发布一个Release版本即可完成该库包，这里可以自己手动添加一个<code>.gitignore</code>文件，忽略掉<code>/.build</code>，因为我们的包是不需要包括生成的编译结果的内容的。</p>

<h2>使用编译配置语句</h2>

<p>下一个即将编译的模块是<code>O2FisherYates</code>.跟之前<code>O2PlayingCard</code>有所不同，该模块没有定义新的类，取而代之的是该模块拓展了一个已经存在的特殊的<code>CollectionType</code>和<code>MutableCollectionType</code>接口协议，用来添加<code>shuffle()</code>方法和对应的<code>shuffleInPlace()</code>方法。</p>

<p>在 OS X 中，系统模块是 Darwin , 提供的函数是 arc4random_uniform(_:) 。在 Linux 中， 系统模块是 Glibc ， 提供的函数是 random() ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if os(Linux)
</span><span class='line'>  import Glibc
</span><span class='line'>#else
</span><span class='line'>  import Darwin.C
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>public extension Collection {
</span><span class='line'>  func shuffle() -&gt; [Generator.Element] {
</span><span class='line'>    var array = Array(self)
</span><span class='line'>    array.shuffleInPlace()
</span><span class='line'>    
</span><span class='line'>    return array
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public extension MutableCollection where Index == Int {
</span><span class='line'>  mutating func shuffleInPlace() {
</span><span class='line'>    guard count &gt; 1 else { return }
</span><span class='line'>    v 
</span><span class='line'>    for i in 0..&lt;count - 1 {
</span><span class='line'>      #if os(Linux)
</span><span class='line'>        let j = Int(random() % (count - i)) + i
</span><span class='line'>      #else
</span><span class='line'>        let j = Int(arc4random_uniform(UInt32(count - i))) + i
</span><span class='line'>      #endif
</span><span class='line'>      guard i != j else { continue }
</span><span class='line'>      swap(&self[i], &self[j])
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的步骤和前面的类似，编译通过后上传到GitHub,发布Release版本。</p>

<h3>导入依赖</h3>

<p><code>O2DeckOfPlayingCards</code>包把前两个包聚合到一起：它定义了一个<code>O2PlayingCard</code>数组中使用<code>O2FisherYates</code>的<code>shuffle()</code>方法的Deck类型。</p>

<p>为了使用 O2FisherYates 和 O2PlayingCards 模块， O2DeckOfPlayingCards 包必须在 Package.Swift 清单中将上述模块声明为依赖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>    name: "O2DeckOfPlayingCards",
</span><span class='line'>    dependencies: [
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2PlayingCard.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2FisherYates.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>    ]
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>每个依赖都需要指定一个源URL和版本号，源URL是指允许当前用户解析到对应的Git仓库。版本号遵循 <a href="http://semver.org/lang/zh-CN/">语义化版本号 2.0.0</a> 的约定,用来决定检出或者使用哪个Git标签版本来建立依赖。对于<code>FisherYates</code>和<code>PlayingCard</code>这两个依赖来说， 最新的将要被使用的主版本号为1.</p>

<p>当你运行<code>swift build</code>命令时，包管理器将会下载所有的依赖，并将它们编译成静态库，再把它们链接到包模块中。这样将会使<code>O2DeckOfPlayingCards</code>可以访问依赖import语句的模块的公共成员</p>

<p>你可以看到这些资源被下载到你工程根目录的 Packages 目录下，并且会生成编译产品在你工程根目录的 .build 目录下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2DeckOfPlayingcards
</span><span class='line'>├── .build
</span><span class='line'>│   └── debug
</span><span class='line'>│       ├── O2DeckOfPlayingCards.build
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftdoc
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftmodule
</span><span class='line'>│       ├── O2FisherYates.build
</span><span class='line'>│       ├── O2FisherYates.swiftdoc
</span><span class='line'>│       ├── O2FisherYates.swiftmodule
</span><span class='line'>│       ├── O2PlayingCard.build
</span><span class='line'>│       ├── O2PlayingCard.swiftdoc
</span><span class='line'>│       └── O2PlayingCard.swiftmodule
</span><span class='line'>└── Packages
</span><span class='line'>    └── O2FisherYates-1.0.0
</span><span class='line'>    │   ├── Package.swift
</span><span class='line'>    │   ├── README.md
</span><span class='line'>    │   └── Sources
</span><span class='line'>    └── O2Playingcard-1.0.1
</span><span class='line'>        ├── Package.swift
</span><span class='line'>        ├── README.md
</span><span class='line'>        └── Sources</span></code></pre></td></tr></table></div></figure>


<p><code>Package</code>目录包含了被复制的包依赖的所有仓库，这样将使你能修改源代码并直接推送这些修改到它们的源，而不需要再对每个包在单独进行复制。</p>

<p>Swift是一门先进的语言，SPM的社区也在不断地完善中。在swift开源之后，我们很容可以看到它的潜力，看来掌握这门语言必将是一个大趋势。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的热修复]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong/"/>
    <updated>2016-11-07T16:46:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong</id>
    <content type="html"><![CDATA[<h2>背景需求</h2>

<h3>为什么我们需要热修复</h3>

<ul>
<li>工作中容易犯错，bug难以避免</li>
<li>开发和测试人力有限</li>
<li>苹果AppStore审核周期太长，一旦出现严重bug难以快速上线新版本</li>
</ul>


<h2>JSPatch简介</h2>

<p>JSPatch诞生于2015年5月，最初是腾讯广研高级ios开发@bang的人格项目。它能够使用JavaScripit调用Objective-C的原声接口，从而动态植入代码来替换旧代码，以实现修复线上bug.</p>

<h2>JSPatch与wax对比</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3d1af75ebfe7de01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最关键的是JSpath可实现方法粒度的线上代码替换，能修复一切代码引起的bug.而Wax无法实现。</p>

<h2>JSPatch实现原理</h2>

<h3>基础原理</h3>

<p>Objective-C是动态语言，具有运行时特性，该特性可通过类名称和方法名的字符换获取该类和该方法，并实例化调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class class = NSClassFromString(“UIViewController");
</span><span class='line'>id viewController = [[class alloc] init];  
</span><span class='line'>SEL selector = NSSelectorFromString(“viewDidLoad");
</span><span class='line'>[viewController performSelector:selector];</span></code></pre></td></tr></table></div></figure>


<p>也可以替换某个类的方法为新的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void newViewDidLoad(id slf, SEL sel) {}
</span><span class='line'>class_replaceMethod(class, selector, newViewDidLoad, @"");</span></code></pre></td></tr></table></div></figure>


<p>还可以注册一个类，为类添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
</span><span class='line'>objc_registerClassPair(cls);
</span><span class='line'>class_addMethod(cls, selector, implement, typedesc);</span></code></pre></td></tr></table></div></figure>


<h3>JavaScript调用</h3>

<p>我们可以用JavaScript对象定义一个Objective-C类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  __isCls: 1,
</span><span class='line'>  __clsName: "UIView"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在OC执行JS脚本前，通过正则把所有方法调用都改成__c()函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView.alloc().init()
</span><span class='line'>-&gt;
</span><span class='line'>UIView.__c('alloc')().__c('init')()</span></code></pre></td></tr></table></div></figure>


<p>给JS对象基类Object的prototype加上c成员，这样所有对象都可以调用到c,根据当前对象类型判断进行不同操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Object.prototype.__c = function(methodName) {
</span><span class='line'>  if (!this.__obj && !this.__clsName) return this[methodName].bind(this);
</span><span class='line'>  var self = this
</span><span class='line'>  return function(){
</span><span class='line'>    var args = Array.prototype.slice.call(arguments)
</span><span class='line'>    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>互传消息</h2>

<p>JS和OC是通过JavaScriptCore互传消息的。OC端在启动JSPatch引擎会创建一个JSContext实例，JSContext是js代码的执行环境，可以给JSContext添加方法。JS通过调用JSContext定义的方法把数据传给OC,OC通过返回值传回给JS.调用这种方法，它的参数/返回值 javaScripotCore都会自动转换，OC里的NSArray,NSdictionary
,NSString,NSNumber,NSBlock会分别转为JS端的数组/对象/字符串/数字/函数类型  对于一个自定义ID对象，JavaScriptCore会把这个自定义对象的指针传给JS,这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象声明周期的管理，如果JS有变量引用时，这个OC对象引用计数就加1，JS变量的引用释放了就减一，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>

<h2>方法替换</h2>

<ol>
<li>把UIViewContrller的 <code>-viewWillAppear:</code>方法通过<code>class_replaceMethod()</code>接口指向<code>_objc_msgForward</code>,这是一个全局IMP,OC调用方法不存在时都会转发到这个IMP上，这里直接把方法替换成这个IMP,这样调用这个方法时就会走到<code>-forwardInvocation:</code></li>
<li>为UIViewController添加<code>-ORIGviewWillAppear:</code>和<code>-_JPviewWillAppear:</code>两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数</li>
<li>改写UIViewController的<code>-forwardInvocation:</code>方法为自定义实现。一旦OC里调用UIViewController的<code>-viewWillAppear:</code>方法，经过上面的处理会把这个调用转发到<code>forwardInvocation:</code>，这时已经组装好了一个NSInvocation,包含了这个调用的参数。在这里把参数从NSInvocation反解出来，待着参数调用删除新增加的方法<code>-JPviewWillAppear:</code>,在这个新方法里获取到参数传给JS,调用JS的实现函数，整个调用过程就结束了，整个过程图示如下：</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-d079409a185f394c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最后一个问题，我们把UIViewController的<code>-forwardInvocation:</code>方法的实现给替换掉了，如果程序里挣得有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现了做个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程</p>

<h2>JSPatch代码示例</h2>

<p>jspatch在oc上的调用十分简单</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
</span><span class='line'>[JPEngine startEngine]; 
</span><span class='line'>NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; 
</span><span class='line'>NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; 
</span><span class='line'>[JPEngine evaluateScript:script];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>一个JavaScript修复Objective-C的bug的示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation JPTableViewController
</span><span class='line'>
</span><span class='line'>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
</span><span class='line'>  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
</span><span class='line'>  [self.navigationController pushViewController:ctrl];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上述代码中取数组元素出可能会超出数组范围导致crash.如果在项目里引用了JSPatch,就可以发JS脚本修复这个bug:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defineClass("JPTableViewController", {
</span><span class='line'>  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
</span><span class='line'>    var row = indexPath.row()
</span><span class='line'>    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
</span><span class='line'>      var content = self.dataArr()[row];
</span><span class='line'>      var ctrl = JPViewController.alloc().initWithContent(content);
</span><span class='line'>      self.navigationController().pushViewController(ctrl);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}, {})</span></code></pre></td></tr></table></div></figure>


<h2>热修复的解决方案</h2>

<ol>
<li><p>版本更新策略</p></li>
<li><p>考虑到下一个提交的App版本已经修复了上一个版本的bug,所以不同的App版本对应的补丁肯定也不同，同一个App版本下，可以出现递增的补丁版本</p></li>
<li>补丁为全量更新，即最新的版本补丁包括旧版的补丁的内容，更新后新版补丁覆盖旧版补丁</li>
<li>补丁分为可选补丁和必选补丁，必选补丁用于重大bug的修复，如果不更新必须补丁则App无法继续使用。如下图2中，补丁版本v1234对应各自版本的用户，补丁v3为必须更新，补丁v1,v2,v4为可选补丁，则v1,v2必须更新到v4才可使用；而v3的哟过户可先使用，同事后台静默更新到v4</li>
</ol>


<h2>安全策略</h2>

<p>安全问题在于JS脚本可能被中间人攻击替换代码。可采取一下三种方法</p>

<ol>
<li>对称加密： 如zip的加密压缩，Aes等加密算法。优点是简单，缺点是安全性低，易被破解。若客户端被反编译，密码字段泄露，则完全破解。</li>
<li><a href="HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82">HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82</a></li>
<li>RSA校验：安全性高，部署简单</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-14723080a9823ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>详细校验步骤如下：</p>

<ol>
<li>服务器计算出脚本文件的MD5值，作为这个文件的数字签名</li>
<li>服务器通过私钥加密算出的MD5值，得到一个加密后的md5值</li>
<li>把脚本文件和加密后的md5值一起发给客户端</li>
<li>客户端拿到加密后的md5值，通过保存在客户端的公钥解密</li>
<li>客户端计算脚本文件的md5值</li>
<li>对比第 4/5 步的两个md5值(分别是客户端和服务器端计算出来的MD5值)，若相等则通过校验</li>
</ol>


<h2>客户端策略</h2>

<p>客户端具体策略如下图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3f5d0d89e0b3833d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<ol>
<li>用户打开App时，同步进行本地补丁的加载</li>
<li>用户打开App时，后台进程发起异步网络请求，获取服务器中当前App版本所对应的最新补丁版本和必须的补丁版本</li>
<li>获取补丁版本的请求回来后，跟本地的补丁版本进行对比</li>
<li>如果本地补丁版本小于必须版本，则提示用户，展示下载补丁界面，进行进程同步的补丁下载。下载完成后重新加载App和最新补丁，再进入App</li>
<li>如果本地补丁版本不小于必须版本，但小于最新版本，则进入App,不影响用户操作。同时进行后台进程异步静默下载，下载后补丁保存在本地，下次App启动时再加载最新补丁。</li>
<li>如果版本为最新，则进入App</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中常见的面试题二]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/"/>
    <updated>2016-11-04T20:22:42+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er</id>
    <content type="html"><![CDATA[<h2>如何进行真机调试</h2>

<ol>
<li>首先需要钥匙串创建一个钥匙(key)</li>
<li>将钥匙串上传到官网，获取ios Development证书</li>
<li>创建APP Id即我们应用程序中的BundleId</li>
<li>添加Device ID 即 UDID;</li>
<li>通过勾选前面所创建的证书：App ID, Deveice id</li>
<li>生成mobileProvision文件</li>
<li>先决条件：申请开发者账号 99美刀</li>
</ol>


<!--more-->


<h2>APP发布上架流程</h2>

<ol>
<li>登录苹果开发者网站</li>
<li>下载安装发布证书</li>
<li>选择发布证书，使用Archive编译发布包，用Xcode将代码上传到服务器</li>
<li>等待审核</li>
<li>生成ipa->菜单栏->Product->Archive</li>
</ol>


<h2>如何发送通知</h2>

<ul>
<li>一种是Apple自己提供的通知服务（APNS服务器），一种是用第三方推送机制</li>
<li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器请求deviceToken,并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用</li>
<li>推送信息内容，总容量不超过256个字节</li>
<li>iOSSDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示</li>
</ul>


<p>优点：不论应用是否开启，都会发送到手机端</p>

<p>缺点：消息推送机制是苹果服务器端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；</p>

<ul>
<li>第三方推送机制,普遍使用Socket机制来实现，几乎可以达到即时发送到目标用户手机端，适用于即时通讯类应用。</li>
</ul>


<p>优点：实时的，取决于心跳包的节凑</p>

<p>缺点：IOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用</p>

<h2>网络七层协议</h2>

<ul>
<li>应用层：

<ol>
<li>用户接口，应用程序</li>
<li>Application典型设备:网关；</li>
<li>典型协议，标准和应用：TELNET,FTP,HTTP</li>
</ol>
</li>
<li>表示层：

<ol>
<li>数据表示，压缩和加密presentation</li>
<li>典型设备:网关</li>
<li>典型协议，标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG</li>
<li>表示层相当于一个东西的表示，表示的一些协议，比如图片，声音和视频MPEG</li>
</ol>
</li>
<li>会话层：

<ol>
<li>会话的建立和结束；</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</li>
</ol>
</li>
<li>传输层：

<ol>
<li>主要功能：端到端控制Transport;</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：TCP，UDP，spx</li>
</ol>
</li>
<li>网络层：

<ol>
<li>主要功能：路由，寻址Network</li>
<li>典型设备:路由器</li>
<li>典型协议，标准和应用：IP,IPX,APPLETALK,ICMP</li>
</ol>
</li>
<li><p>数据链路层：</p>

<ol>
<li>主要功能：保证无差错的疏忽链路 data link;</li>
<li>典型设备：交换机，网桥，网卡</li>
<li>典型协议，标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li>
</ol>
</li>
<li>物理层：

<ol>
<li>主要功能：传输比特流Physical</li>
<li>典型设备：集线器，中继器</li>
<li>典型协议，标准和应用：V.35、EIA/TIA-232.</li>
</ol>
</li>
</ul>


<h2>对NSUserDefualts的理解</h2>

<ul>
<li>NSUserDefaults：系统提供的一种存储数据的方式，主要用户保存少量的数据，默认存储到library下的Preferences文件夹</li>
</ul>


<h2>LayoutSubViews在什么时候被调用</h2>

<p>当View本身的frame改变时，会调用这个方法</p>

<h2>单例模式理解与使用</h2>

<ul>
<li>单例模式是一种常用的设计模式，单利模式是一个类在系统中只有一个实例对象。通过全局的一个入口点对这个实例对象进行访问</li>
<li>iOS中单例模式的实现方式一般分为两种：非ARC和ARC+GCD</li>
</ul>


<h2>对沙盒的理解</h2>

<ul>
<li><p>每个ios应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，及时在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录，苹果对沙盒有几条限制：</p></li>
<li><p>应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序沙盒</p></li>
<li>应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中</li>
<li>苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；</li>
<li>沙盒目录里有三个文件夹：Documents——存储应用程序的数据文件，存储用户数据或其他定期备份的信息；Library下有两个文件夹，Caches存储应用程序再次启动所需的信息，
Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；
temp存放临时文件即应用程序再次启动不需要的文件</li>
</ul>


<h2>对瀑布流的理解</h2>

<ul>
<li>首先图片的宽度都是一样的

<ol>
<li>将图片等比例压缩，让图片不变形</li>
<li>计算图片最低应该摆放的位置，那一列低就放在哪</li>
<li>进行最优排列，在ScrollView的基础上添加两个tableView,然后将之前所计算的scrollView的高度通过tableView展示出来</li>
</ol>
</li>
<li>如何使用两个TableView产生联动：将两个TableView的滚动事件禁止掉，最外层的ScrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableview.</li>
</ul>


<h2>ViewController 的loadView,viewDidLoad,viewDidUnload 分别是在什么时候调用的？</h2>

<ul>
<li>viewDidLoad在View从nib文件初始化时调用，loadView在controller的View为nil时调用</li>
<li>此方法在编程实现view时调用，View控制器默认会注册memory warning notification,当view controller的任何View没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release，如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。</li>
</ul>


<h2>@synthesize、@dynamic的理解</h2>

<ul>
<li>@synthesize 是系统自动生成getter和setter属性声明；@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明</li>
<li>@dynamic是开发者自己提供相应的属性声明，@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter,对于读写属性需要提供setter和getter,查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。</li>
</ul>


<p>主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行动态生成子类属性</p>

<h2>Frame和bounds有什么不同？</h2>

<ul>
<li>frame指的是：该View在父view坐标系统中的位置和大小（参照点是父亲的坐标系统）</li>
<li>bounds指的是：该View在本身坐标系统中的位置和大小（参照点是本身坐标系统）</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-3.png" alt="1" /></p>

<h2>iOS中的响应者链的工作原理</h2>

<ul>
<li>每一个应用有一个响应者链，我们的视图结构是一个N叉树（一个视图可以有多个子视图，一个子视图同一时刻只有一个父亲视图），而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点</li>
<li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追溯出一条链，那么对于这个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶子节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发</li>
</ul>


<h2>Property属性的修饰符的作用</h2>

<ul>
<li>getter=getName、setter=setName：设置setter与getter的方法名；</li>
<li>readwrite,readonly:设置可供访问的级别</li>
<li>assign:方法直接赋值，不进行任何retain操作，为了解决原类型与循环引用问题</li>
<li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序</li>
<li>copy:其setter方法进行copy操作，与retain 处理流程一样，先对旧值release,再copy出新的对象，retaincount为1,这是为了减少对上下文的依赖而引入的机制</li>
<li>nonatomic:非原子性访问，不加同步，多线程并发访问会提供性能。注意，如果不加此属性，则默认是两个访问方法都是原子型事务访问</li>
</ul>


<h2>对Run Loop的理解</h2>

<ul>
<li>RUNLOOP，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程，主线程执行完即时任务时会继续等待接收事件而不退出，非主线程同城来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li>
<li>每一个线程都有其对应的RunLoop,只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动</li>
<li>在一个单独的线程中，如果需要在处理完某个人物后不退出，继续等待接收事件，则需要启用RunLoop</li>
<li>NSRunLoop提供了一个添加NStimer的方法，可以指定Mode,如果要让任何情况下都回调，则需要设置Mode为Common模式</li>
<li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载方式，如果我们没有东东调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop,也就不会去加载，更不会创建</li>
</ul>


<h2>XIB与Storyboards的优缺点</h2>

<p>优点:</p>

<ul>
<li><p>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类</p></li>
<li><p>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。</p></li>
</ul>


<p><em>缺点:</em></p>

<ul>
<li>XIB:需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li>
<li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li>
</ul>


<h2>队列和多线程的使用原理</h2>

<p>在iOS中队列分为以下几种：</p>

<ul>
<li>串行队列：队列中的任务只会顺序执行</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("...", DISPATCH_QUEUE_SERIAL);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>并行队列：对垒中的任务通常会并发执行：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("......",DISPATCH_QUEUE_CONCURRENT);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>全局队列：是系统的，直接拿过来(get)用就可以，与并行队列类似：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>主队列：每一个应用程序对应唯一主队列，直接GET就行，在多线程开发中，使用祝队列更新UI：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_get_main_queue();
</span></code></pre></td></tr></table></div></figure>


<p>如图：
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/1771779-da221054beb5cbb4.png" alt="1" />
 </p>

<h2>内存的使用和优化的注意事项</h2>

<ul>
<li>重用问题：如UITableViewCells,UICollectionViewCells, UITableViewHeaderFooterViews设置正确的reuseIdentifier,充分重用；</li>
<li>尽量把views设置为不透明，当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能</li>
<li>不要使用太复杂的XIB/StroyBoard;载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用，那些相比纯代码写的延迟加载，性能及内存就差了很多</li>
<li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出搞笑代码的基础，比如，数组：有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。存储键值对，用键来查找比较快。集合：无需的一组值，用值来查找很快，插入/删除很快；</li>
<li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li>
<li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载</li>
<li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储</li>
<li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉。重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建</li>
<li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li>
<li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li>
</ul>


<h2>UIViewController的完整生命周期</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[ViewController initWithNibName:bundle:]；
</span><span class='line'>-[ViewController init]；
</span><span class='line'>-[ViewController loadView]；
</span><span class='line'>-[ViewController viewDidLoad]；
</span><span class='line'>-[ViewController viewWillDisappear:]；
</span><span class='line'>-[ViewController viewWillAppear:]；
</span><span class='line'>-[ViewController viewDidAppear:]；
</span><span class='line'>-[ViewController viewDidDisappear:]；</span></code></pre></td></tr></table></div></figure>


<h2>UIImageView添加圆角</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>imgView.layer.cornerRadius = 10;// 这一行代码是很消耗性能的imgView.clipsToBounds = YES;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><em>这是离屏渲染（off-screen-rendering），消耗性能的</em></li>
<li>扩展:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIImage *)imageWithCornerRadius:(CGFloat)radius {
</span><span class='line'>CGRect rect = (CGRect){0.f, 0.f, self.size};
</span><span class='line'>
</span><span class='line'>UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale);CGContextAddPath(UIGraphicsGetCurrentContext(),
</span><span class='line'> [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);CGContextClip(UIGraphicsGetCurrentContext());
</span><span class='line'>
</span><span class='line'>[self drawInRect:rect];
</span><span class='line'>UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
</span><span class='line'>UIGraphicsEndImageContext();
</span><span class='line'>
</span><span class='line'>return image;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中常见的面试题及答案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/"/>
    <updated>2016-11-03T17:50:01+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an</id>
    <content type="html"><![CDATA[<h2>ios中深拷贝和浅拷贝</h2>

<p>在ios开发中，经常涉及到深拷贝和浅拷贝的问题，针对深拷贝和浅拷贝，为了方便大家的理解，专门总结如下:</p>

<!--more-->


<ul>
<li>理解1</li>
</ul>


<p>浅拷贝是拷贝操作后，并没有进行真正的复制，而是另一个指针也指向了同一个地址。深拷贝，拷贝操作后，是真正的复制了一份，另一个指针指向了拷贝后的地址。如下图：A代表原有的指针，B代表拷贝的指针。（图一为浅拷贝，图二为深拷贝）</p>

<p><img src="http://img.blog.csdn.net/20141218004439540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="1" /></p>

<p><img src="http://img.blog.csdn.net/20141218004554327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="2" /></p>

<p>从上图中可以看到，浅拷贝（浅复制）中如果其中A指针改变了所指向的地址的内容，那么B指针也指向了被修改的内容，如果有些地方用到B指针，即便A指向的内容发生变化，也不希望B收到影响，则需要用深拷贝，真正复制一份A指向的内容，B指向复制后的值，这样即使A指向的内容变化了，B也不会产生影响。好比：浅复制好比你的影子，你完蛋，你的影子也完蛋。深复制好比你和你的克隆人，你完蛋，你的克隆人依然活着。</p>

<ul>
<li>理解2</li>
</ul>


<p>深拷贝和浅拷贝的本质是地址相同，就是浅拷贝，地址不同就是深拷贝。</p>

<p>iOS开发过程中，大体上会区分为对象和容器两个概念，对象的copy是浅拷贝，mutableCopy是深拷贝。容器也参照如上方法，但是需要记住，容器的包含对象的拷贝,无论使用copy,还是mutableCopy都将是浅拷贝，想要实现对象的深拷贝，必须自己提供拷贝的方法。</p>

<ul>
<li>理解3</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
</span><span class='line'> NSMutableArray *array1=[array copy];        
</span><span class='line'>[array1 addObject:@"three"];  </span></code></pre></td></tr></table></div></figure>


<p>//这段代码是错误的，array1通过copy进行的是浅拷贝，即并没有真正复制array，而是也指向了array,此时array是不可变数组，无法进行新数据的添加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
</span><span class='line'>NSMutableArray *array2=[array mutableCopy];        
</span><span class='line'>[array2 addObject:@"three"];  </span></code></pre></td></tr></table></div></figure>


<p>这段代码是正确的，array2通过mutableCopy进行的是深拷贝，即把array真正复制了一份，并且复制后，变味了NSMutableArray,此时array2是可变数组，可以添加数据</p>

<blockquote><p>注意点:<em>(1)</em> 当使用mutableCopy时，不管源对象是否可变，副本是可变的，并且实现真正意义上的拷贝。当我们使用copy一个可变对象时，副本对象是不可变的。</p>

<p><em>(2)</em>要想实现对象的自定义拷贝，必须实现NSCopying,NSMutableCopying协议，实现该协议的copyWithZone方法和mutableCopyWithZone方法。深拷贝和浅拷贝的区别就在于copyWithZone方法的实现。</p></blockquote>

<h2>NSString属性什么时候用copy,什么时候用Strong?</h2>

<p>我们定义一个类，并且为其声明两个字符串属性，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface TestStringClass ()
</span><span class='line'>@property (nonatomic, strong) NSString *strongString;
</span><span class='line'>@property (nonatomic, copy) NSString *copyedString;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上面的代码声明了两个字符串属性，其中一个内存特性是strong,一个是copy.下面我们来看看它们的区别。</p>

<p>首先，我们用一个不可变字符串来为这两个属性赋值,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)test {
</span><span class='line'>    NSString *string = [NSString stringWithFormat:@"abc"];
</span><span class='line'>    self.strongString = string;
</span><span class='line'>    self.copyedString = string;
</span><span class='line'>    NSLog(@"origin string: %p, %p", string, &string);
</span><span class='line'>    NSLog(@"strong string: %p, %p", _strongString, &_strongString);
</span><span class='line'>    NSLog(@"copy string: %p, %p", _copyedString, &_copyedString);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>输出结果为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>origin string: 0x7fe441592e20, 0x7fff57519a48
</span><span class='line'>strong string: 0x7fe441592e20, 0x7fe44159e1f8
</span><span class='line'>copy string: 0x7fe441592e20, 0x7fe44159e200</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，这种情况下，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string执行的地址，如果我们换做MRC环境，打印string的引用计数的话，会看到其引用计数是3,即String操作和copy做做都使原字符串对象的引用计数值+1.</p>

<p>接下来，我们把string由不可变改为可变对象，看看会是什么结果，即将下面这一句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *string = [NSString stringWithFormat:@"abc"];</span></code></pre></td></tr></table></div></figure>


<p>改成:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableString *string = [NSMutableString stringWithFormat:@"abc"];</span></code></pre></td></tr></table></div></figure>


<p>其输出结果为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>origin string: 0x7ff5f2e33c90, 0x7fff59937a48
</span><span class='line'>strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8
</span><span class='line'>copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</span></code></pre></td></tr></table></div></figure>


<p>可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让<em>copyedString对象指向这个字符串，在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而</em>copyedString的引用计数是1</p>

<p>此时，我们如果去修改string字符串的话，可以看到：因为<em>strongString和string都是指向同一个对象，所以</em>strongString的值会跟随者改变（需要注意的是，此时 <em>strongString 的类型实际上是NSmutableString,而不是NSString）而</em>copyedString指向的是另一个对象，所以并不会改变。</p>

<h3>结论</h3>

<p>由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的StrongString指针指向一个可变字符串是OK的。</p>

<p>而上面的例子可以看得出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是Strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>

<p>当源字符串是NSMUtableSring时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生了一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString,而不是NSMutableString,因此其实不可变的。</p>

<p>这里还有一个性能问题，即在源字符串是NSMutableString,strong是单纯的增加对象的引用计数，而copy操作是智行了一次深拷贝，所以性能上会有所差异，而如果源字符串是NSString时，则没有这个问题。</p>

<h2>OC的理解和特性</h2>

<ul>
<li>OC 作为一门面向对象的语言，自然具有面向对象的语言特性：封装，继承，多台，它既有静态语言的特性（如C++），又有动态语言的效率（动态绑定，动态加载）。总体来讲，OC确实是一门不错的编程语言</li>
<li><p>OC具有相当多的动态特性，表现为三个方面：动态类型（Dynamic typing）,动态绑定(Dynamic binding)和动态加载(Dynamic loading).动态-必须运行时（run time）才会做的事情</p></li>
<li><p>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单说就是id类型，事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者</p></li>
<li>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对对那个的属性和响应消息也被完全确定。</li>
<li>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retain设备上加载@2x的图片，而在老一些的普通苹果设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类</li>
</ul>


<h2>简述内存管理的基本原则</h2>

<ul>
<li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建活引用一个对象的时候，需要向它发送alloc,copy,retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制(MRC)</li>
<li>目前：ios5之后引用自动管理机制-自动引用计数（ARC），管理机制和手动机制一样，只是不再需要调用retain,release,autorelease,它编译时的特性，当你使用arc时，在适当位置插入release和 autorelease;它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针比那两指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动设置为nil</li>
<li>如果使用alloc,copy(mutableCopy)或者retain一个对象时，你就有义务向它发送一条release或者autorelease消息，其它方法创建的对象，不需要由你来管理内存。</li>
<li>向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池子中每个对象发送一条release消息，以此来释放对象</li>
<li>向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法，释放该对象和对象本身所拥有的实例。</li>
</ul>


<h2>其它注意事项</h2>

<ul>
<li>如果一个对象有一个<em>Strong类型的指针指向着，找个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil.如果一个指针被指向nil,那么它原来指向的对象就被释放了，当一个视图控制器被释放时，它内部的全部指针会被指向nil.&ldquo;不管是全局变量还是局部变量用</em>Strong描述就行&rdquo;</li>
<li>局部变量：出了作用域，指针会被设置为nil</li>
<li>方法内部创建对象，外部使用需要添加_autorelease</li>
<li>连线的时候，用_weak描述</li>
<li>代理使用unsafe_unretained就相当于assign</li>
<li>block中为了避免循环引用问题，使用_weak描述</li>
<li>声明属性时，不要以new开头，如果非要以new开头命名属性的名字，需要自己定制get方法名，如</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(getter=theString) NSString * newString;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果要使用自动释放池，用@autoreleasepool{}</li>
<li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成Core Foundation中的变量需要交换管理权</li>
<li>在非ARC工程中采用ARC去编译某些类:<code>-fobjc-arc</code></li>
<li>在ARC工程下采用非ARC去比哪一某些类:<code>-fno-fobjc-arc</code></li>
</ul>


<h2>如何理解MVC设计模式</h2>

<p>mvc是一种架构模式，M表示Model，V表示视图View,C表示控制器Controller:
* Model负责存储，定义，操作数据
* View用来展示数据，和用户进行交互
* Controller是Model和View的协调者，Controller把MOdel中的数据拿过来给View用，Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，Model也要与Controller进行通信，这个时候要用Notification和KVO,这个方式就像一个广播一样，Model刚发送信号，Contrller设置坚挺接受信号，当有数据更新时就发信号给Controller,Model和View不能直接进行通信，这样会违背MVC设计模式</p>

<h2>如何理解MVVM设计模式</h2>

<ul>
<li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其它业务逻辑处理极好的地方，说白了，就是把原来ViewCOntroller层的业务逻辑和页面逻辑等剥离出来放到ViewModel层</li>
<li>View层，就是ViewController层，它的任务就是从ViewModel层获取数据，然后显示</li>
</ul>


<h2>Objective-C 中是否支持垃圾回收机制？</h2>

<ul>
<li>OC是支持垃圾回收机制的,但是Apple的移动终端中，是不支持GC的，Mac桌面系统开发中是支持的。</li>
<li>移动端开发是支持ARC的，ARC是在ios5之后推出的新技术，它与GC机制是不同的，我们在编写代码时，不需要想对象发送release或者autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release消息，ARC的特点是自动引用计数简化了内存管理的难度</li>
</ul>


<h2>ARC下Assign和weak的区别</h2>

<p>weak比assign对了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值nil,这个再向weak修饰的属性发送消息就不会导致野指针操作crash.</p>

<p>在arc模式下编程时，指针变量一定要用weak修饰，只有基本数据类型和结构体需要用assign，例如delegate,一定要用weak修饰。</p>

<ul>
<li>区别：如果用weak声明的变量在栈中就会自动清空，赋值为nil，如果用assign声明的变量在栈中可能不会自动赋值为nil,就会造成野指针错误</li>
</ul>


<h2>协议的基本概念和协议中方法默认什么类型</h2>

<p>OC中的协议是一个方法列表。它的特点是可以被任何类使用（实现），但它并不是类，自身不会实现这样方法，而是有其它人来实现协议，经常用来实现委托对象，如果一个类采用了一个协议，那么它必须实现协议中必须需要实现的方法，在协议中的方法默认是必须实现的（@required）,添加关键字@optional,表明一旦采用该协议，这些可选的方法是可以不实现的</p>

<h2>简述类目Category的有点和缺点</h2>

<h3>优点</h3>

<ul>
<li>不需要通过增加子类而增加现有类的行为或方法，且类目中的方法与原始类方法基本没有区别：</li>
<li>通过类目可以将庞大的一个类的方法进行划分，从而便于代码的日后的维护，更新及提高代码的阅读性</li>
</ul>


<h3>缺点</h3>

<ul>
<li>无法向类目中添加实例变量，如果需要添加实例变量，只能通过定义子类的方式</li>
<li>类目中的方法与原始类以及父类方法相比具有更高优先级，如果覆盖弗雷的方法，可能导致super消息的断裂，因此，最好不要覆盖原始类中的方法。</li>
</ul>


<h2>循环引用产生额原因，以及解决方法</h2>

<ul>
<li>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减去1.对象A的销毁依赖于对象B的销毁，同事对象B销毁也依赖于对象A的销毁，从而形成了循环引用，此时，即使外界没有任何指针访问它，它也无法释放。
<img src="http://devstorepic.qiniudn.com/FvDA-QQdrUBpndLKOmJgy6-vqM0F" alt="2" /></li>
</ul>


<p>对个对象之间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：</p>

<p><img src="http://devstorepic.qiniudn.com/Fk4cV48OjN9tUl-lDiU_ap5WWGUl" alt="1" /></p>

<h3>解决方法</h3>

<ul>
<li>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，让对象回收</li>
<li>使用weak声明</li>
</ul>


<h2>键路径(keyPath),键值编码(KVC),键值观察(KVO)</h2>

<h3>键路径</h3>

<ul>
<li>在一个给定的实体中，同一个属性的所有值具有相同的数据类型</li>
<li>键-值编码技术用于进行这样的查找-它是一种间接访问对象属性的机制。键路径是一个由点做分隔符组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于前面的性质</li>
<li><p>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相关对象的特定属性</p>

<h3>键值编码KVC</h3></li>
<li><p>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取的方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</p></li>
<li>KVC的缺点：一旦使用KVC，你的编译器无法检查出错误，即不会对设置的键，键路径进行错误检查，且执行效率要地域合成存取器方法和自定的setter和getter方法，因为使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量

<h3>键值观察KVO</h3></li>
<li>键值观察机制是一种能使的对象获取到其他对象属性变化的通知，极大的简化了代码</li>
<li>实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到，因此，KVC是KVO的基础</li>
</ul>


<h3>Demo</h3>

<p>比如我自定义一个Button</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO 
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { 
</span><span class='line'>     if ([keyPath isEqualToString:@"highlighted"] ) { 
</span><span class='line'>      [self setNeedsDisplay]; } 
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和KVC机制的道理是一样的。</p>

<h3>KVC机制通过key找到value的原理</h3>

<ul>
<li>当通过KVC调用对象时，比如：<code>[self valueForKey:@”someKey”]</code>,程序会自动视图通过下面几种不同的方式解析这个调用。</li>
<li>首先查找对象是否带有somekey这个方法，如果没找到，会继续查找对象是否带有somekey这个实例变量，如果还没有找到，程序会继续视图调用<code>-(id) valueForUndefinedKey:</code>这个方法，如果这个方法还是没有被实现的话，程序会抛出一个<code>NSUndefinedKeyException</code>错误</li>
<li>补充：KVC在查找方法的时候，不仅会超照somekey这个方法，还会查找getsomeKey这个方法，前面加一个get,或者<em>someKey以</em>getsomeKey这几种形式，同时，查找实例变量的时候也会不仅仅查找somekey这个变量，也会查找_someKey这个变量是否存在</li>
<li>设计<code>valueForUndefinedKey</code>方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li>
</ul>


<h2>在Objective-C中如何实现KVO</h2>

<ul>
<li>注册观察者（注意：观察者和被观察者不会被保留也不会被释放）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 
</span><span class='line'>options:(NSKeyValueObservingOptions)options 
</span><span class='line'>context:(void *)context;
</span><span class='line'>
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath 
</span><span class='line'>ofObject:(id)object change:(NSDictionary *)change   context:(void *)context;
</span><span class='line'>
</span><span class='line'>- (void)removeObserver:(NSObject *)observer 
</span><span class='line'>forKeyPath:(NSString *)keyPath;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>KVO 中谁要监听谁注册，然后响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性都是通过NSString来查找，编译器不会检错和补位，全部取决于自己</li>
</ul>


<h2>代理的作用</h2>

<ul>
<li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性</li>
<li>改变或传递控制链，允许一个类在某些特定时刻通知到其他类，而不需要获取到哪些类的指针，可以减少框架的复杂度</li>
<li>另外一点，代理可以理解为java中回调监听机制的一种类似</li>
<li>代理的属性常常是assign的原因：防止循环引用，以至于对象无法得到正确的释放</li>
</ul>


<h2>NSNotification、Block、Delegate和KVO的区别</h2>

<ul>
<li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知</li>
<li>效率：Delegate比NSNotification高</li>
<li>Delegate和Block一般是一对一的通信</li>
<li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信</li>
<li>Block:Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate;</li>
</ul>


<h2>Objective-C中可修改和不可修改类型</h2>

<ul>
<li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改</li>
<li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不变的，而后者可以添加修改等，可以动态申请的内存空间</li>
</ul>


<h2>当我们调用一个静态方法时，需要对对象进行release吗？</h2>

<p>不需要，静态方法（类方法）创建一个对象时，对象已被放入自动释放池。在自定释放池被释放时，很有可能被销毁</p>

<h2>当我们释放我们的对象时，为什么需要调用[super dealloc]方法，它的位置又是如何的呢？</h2>

<ul>
<li>因为子类的某些实例是继承自父类的，因此需要调用<code>[super dealloc]</code>方法，来释放父类拥有的实例，其实也就是子类本身的，一般来说我们优先释放子类拥有的实例，最后释放父类所拥有的实例</li>
</ul>


<h2>对谓词的认识</h2>

<ul>
<li>Cocoa中提供乐意一个<code>NSPredicate</code>类，该类主要用于指定过滤器的条件，每一个对象通过谓词进行筛选，判断条件是否匹配</li>
</ul>


<h2>static，self，super关键字的作用</h2>

<ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配了一次，因此其值在下次调用时扔维持上次的值</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li>
<li>在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明</li>
<li>在类中的static成员变量属于整个类所拥有过，对类的所有对象只有一份拷贝</li>
<li>self：当前消息的接受者</li>
<li>super：向父类发送消息</li>
</ul>


<h2>include与#import的区别、#import 与@class 的区别</h2>

<ul>
<li>include和#import其效果相同，都是查询勒种定义的行为</li>
<li>import不会引起交叉编译，确保头文件只会被导入一次</li>
<li>@class的表明，只定义了类的名称，而具体类的行为是未知的，一般用于.h文件</li>
<li>@class比#import编译效率更高</li>
<li>此外@class和#import的主要区别在于解决引用死锁的问题</li>
</ul>


<h2>@public、@protected、@private @ fileprivate, open 它们的含义与作用</h2>

<ul>
<li>@public:对象的实例变量的作用域在任意地方都可以被访问</li>
<li>@protected:对象的实例变量作用域在本类和子类都可以被访问到</li>
<li>@private：实例变量的作用域只能在本类中访问</li>
</ul>


<h3>fileprivate</h3>

<p>在原有的swift中的private其实并不是真正的私有，如果一个变量定义为private,在同一个文件中的其他类依然是可以访问到的。这个场景在使用extension的时候很明显</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class User {
</span><span class='line'>    private var name = "private"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension User{
</span><span class='line'>    var accessPrivate: String {
</span><span class='line'>        return name
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样带来了两个问题：</p>

<ul>
<li>当我们标记为private时，意思为真的私有还是文件内共享呢？</li>
<li>当我们如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件内，否则可能同文件里其它的代码访问到</li>
</ul>


<p>由此，在swift3中，新增加了一个<code>fileprivate</code>来显示表明，这个元素的访问权限为文件内私有，过去的private对应现在的fileprivate,现在private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问到</p>

<h3>open</h3>

<p>open则是弥补public语义上的不足。
现在public有两层含义:</p>

<ul>
<li>这个元素可以在其他作用域被访问</li>
<li>这个元素可以在其他作用域被继承或者ovrride</li>
</ul>


<p>继承是一件危险的事情，尤其对于一个framework或者module的设计者而言，在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者ovrride都是可控制的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改，这个对应的就是final.</p>

<p>final的问题在于标记之后，在任何地方都不能被ovrride,而对于lib的设计者而言，希望得到的是在module内可以ovrride,在被import到其他地方后其他用户使用的时候不能被ovrride.</p>

<p>这就是<code>open</code>产生的初衷，通过open和public标记区别一个元素在其他module中是只能被访问还是可以被ovrride.</p>

<p>例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// ModuleA:
</span><span class='line'>
</span><span class='line'>// 这个类在ModuleA的范围外是不能被继承的，只能被访问
</span><span class='line'>public class NonSubclassableParentClass {
</span><span class='line'>
</span><span class='line'>    public func foo() {}
</span><span class='line'>
</span><span class='line'>    // 这是错误的写法，因为class已经不能被继承，
</span><span class='line'>    // 所以他的方法的访问权限不能大于类的访问权限
</span><span class='line'>    open func bar() {}
</span><span class='line'>
</span><span class='line'>    // final的含义保持不变
</span><span class='line'>    public final func baz() {}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 在ModuleA的范围外可以被继承
</span><span class='line'>open class SubclassableParentClass {
</span><span class='line'>    // 这个属性在ModuleA的范围外不能被override
</span><span class='line'>    public var size : Int
</span><span class='line'>
</span><span class='line'>    // 这个方法在ModuleA的范围外不能被override
</span><span class='line'>    public func foo() {}
</span><span class='line'>
</span><span class='line'>    // 这个方法在任何地方都可以被override
</span><span class='line'>    open func bar() {}
</span><span class='line'>
</span><span class='line'>    ///final的含义保持不变
</span><span class='line'>    public final func baz() {}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/// final的含义保持不变
</span><span class='line'>public final class FinalClass { }
</span><span class='line'>/// ModuleB:
</span><span class='line'>
</span><span class='line'>import ModuleA
</span><span class='line'>
</span><span class='line'>// 这个写法是错误的，编译会失败
</span><span class='line'>// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承
</span><span class='line'>class SubclassA : NonSubclassableParentClass { }
</span><span class='line'>
</span><span class='line'>// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.
</span><span class='line'>class SubclassB : SubclassableParentClass {
</span><span class='line'>
</span><span class='line'>    // 这样写也会编译失败
</span><span class='line'>    // 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'.
</span><span class='line'>    override func foo() { }
</span><span class='line'>
</span><span class='line'>    // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写
</span><span class='line'>    // 这里不需要再声明为open，因为这个类是internal的
</span><span class='line'>    override func bar() { }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassC : SubclassableParentClass {
</span><span class='line'>    // 这种写法会编译失败，因为这个类已经标记为open
</span><span class='line'>    // 这个方法override是一个open的方法，则也需要表明访问权限
</span><span class='line'>    override func bar() { } 
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassD : SubclassableParentClass {
</span><span class='line'>    // 正确的写法，方法也需要标记为open
</span><span class='line'>    open override func bar() { }    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassE : SubclassableParentClass {
</span><span class='line'>    // 也可以显式的指出这个方法不能在被override
</span><span class='line'>    public final override func bar() { }    
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>现在的访问权限则依次为:open,public,internal,fileprivate,private.</p>

<h2>iOS开发中数据持久性有哪几种？</h2>

<p>数据存储的核心都是写文件</p>

<ul>
<li>属性列表：只有NSString,NSArray,NSdictionary,NSdata可以writeToFile;存储依旧是plist文件，plist文件可以存储7种数据类型：array,dictionary,string,bool,data,date,number</li>
<li>对象序列化（对象归档）:对象序列化通过序列化的形式，键值关系存储到本地，转化为二进制刘，通过runtime实现自动化归档/解档，实现NSCoding协议必须实现的两个方法:</li>
<li>编码(对象序列化):把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData,可以存储到本地</li>
<li>解码:(对象反序列化)把二进制数据转化为本来的类型</li>
<li>SqlLite数据库：大量有规律的数据使用数据库</li>
<li>CoreData:通过管理对象进行增删改查操作。它不是一个数据库，不仅可以使用SqlLite数据库来保持数据，也可以使用其他方式来存储数据，如:XML</li>
</ul>


<h3><em>CoreData介绍</em></h3>

<ul>
<li>CoreData是面向对象的API，COreData是ios中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础</li>
<li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理，对象关系管理和持久化等方面相关的问题</li>
<li>大多数情况下，我们引用CoreData作为持久化数据的解决方法，并利用它作为持久护士数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转为数据，保存到SQL中，然后将保存后的数据还原成OC对象</li>
</ul>


<h3><em>CoreData的特征:</em></h3>

<ul>
<li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量</li>
<li>将对象数据存储在SQLite数据已获得性能优化</li>
<li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删改查</li>
<li>管理 undo/redo操作</li>
<li>检查托管对象的属性值是否正确</li>
</ul>


<h3><em>CoreData的6个成员对象</em></h3>

<ol>
<li>NSManageObject：被管理的数据记录Managed Object Model是描述应用程序数据模型，这个模型包含实体(Entity),特性(Property)，读取请求(Fetch Request)等</li>
<li>NSManageObjectContext：管理对象的上下文，持久化存储模型对象，参与数据对象进行各种操作的全过程，并检测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI</li>
<li>NSPersistentStoreCoordinator：连接数据库的Persistent Store Coordinator,相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集</li>
<li>NSManagedObjectModel：被管理的数据模型，数据结构</li>
<li>NSFetchRequest：数据请求</li>
<li>NSEntityDescription：表格实体结构，还需知道. xcdatamodel文件编译后为<code>.momd</code>或者<code>.mom</code>文件。</li>
</ol>


<h3>Core Data 的功能</h3>

<ul>
<li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系</li>
<li>自动验证属性值</li>
<li>支持跟踪修改和撤销操作</li>
<li>关系维护，CoreData管理数据的关系传播，包括维护对象之间的一致性</li>
<li>在内存上和界面上分组，过滤，组织数据</li>
<li>自动支持对象存储在外部数据仓库的功能</li>
<li>创建复杂请求：无需动手写SQL语句，在获取请求(Fetch request)中关联 NSPredicate,NSPredicated支持基本功能，想关子查询和其它高级的sql特性。它支持正确的Unicode编码，区域感知查询，排序和正则表达式</li>
<li>延迟操作：CoreData使用懒加载方式减少内存负载，还支持部分实体化延迟加载和复制队形的数据共享机制</li>
<li>合并策略：COreData内置版本跟踪和乐观锁来支持多用户写入冲突的解决，其中，乐观锁就是对局冲突进行检测，若冲突就返回冲突的信息</li>
<li>数据迁移：CoreData的Schema Migration工具尅简化对应数据库结构变化的任务，在某些情况下允许你执行高效率的数据库原地迁移工作</li>
<li>可选择针对程序Controller层的集成，来支持UI的显示同步core data在iphone os之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS上我们用Cocoa提供的绑定机制来完成的</li>
</ul>


<h2>对象可以被Copy的条件</h2>

<p>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝分为不可变拷贝和可变拷贝，</p>

<ul>
<li>NSCopying协议方法为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)copyWithZone:(NSZone *)zone {
</span><span class='line'> MyObject *copy = [[[self class] allocWithZone: zone] init]; copy.username = [self.username copyWithZone:zone]; return copy;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>在某个方法中 self.name = <em>name，name = </em>name 它 们有区别吗,为什么?</h2>

<ul>
<li>前者是存在内存管理的setter方法赋值，它会对_name对象进行保留或者拷贝操作</li>
<li>后者是普通赋值</li>
<li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写setter方法来执行某些额外的工作，比如说，外部传一个模型过来，那么我会直接重写setter方法，当模型传来时，也就意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI</li>
</ul>


<h2>解释self=[super init]方法</h2>

<ul>
<li>容错处理，当父类初始化失败，会返回一个nil,表示初始化事变，由于继承的关系，子类是需要拥有父类的实例和行为，因此，我们必须先初始化父类，然后再初始化子类</li>
</ul>


<h2>定义属性时,什么时候用 assign、retain、copy 以及它们的之间的区别</h2>

<ul>
<li>assign:普工赋值，一般常用于基本数据类型，常见委托设计模式，一次来防止循环引用（我们成为弱引用）</li>
<li>retain:保留计数，获得到了对象的所有权，引用计数在原有的基础上加1</li>
<li>copy:一般认为，是在内存中重新开辟了一个新的内存空间，用来存储新的对象，和原来的对象是两个不同的地址，引用计数分别1.当时当copy对象为不可变对象时，那么copy的作用相当于retain,因此，这样可以节约内存空间</li>
</ul>


<h3>堆和栈的区别</h3>

<ul>
<li>栈区(stack)由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等，栈是由低地址扩展的数据结构，是以一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的</li>
<li>堆区（heap）：一般是由程序员分配释放，弱程序员不释放，程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活</li>
<li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使的程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不能有一个内存块从栈中间弹出</li>
<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配是由alloc函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现</li>
<li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆是C/C++函数库提供的，它的机制是很复杂的</li>
<li>全局区(静态区)(static):全局变量和静态变量的存储是放在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放</li>
<li>文字常量区：常量字符串就是存放在这里的额，程序结束后由系统释放</li>
<li>程序代码区：存放函数体的二进制代码</li>
</ul>


<h2>怎样使用performSelector传入3个以上的参数，其中一个为结构体</h2>

<ul>
<li>因为系统提供的performSelector的API中，并没有提供三个参数，因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型，我们只能通过对象放入结构作为属性来传过去了。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (id)performSelector:(SEL)aSelector; 
</span><span class='line'> - (id)performSelector:(SEL)aSelector withObject:(id)object; 
</span><span class='line'> - (id)performSelector:(SEL)aSelector withObject:
</span><span class='line'>    (id)object1 withObject:(id)object2;</span></code></pre></td></tr></table></div></figure>


<p>具体实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct HYBStruct {
</span><span class='line'>int a;
</span><span class='line'>int b;
</span><span class='line'>} *my_struct;
</span><span class='line'>@interface HYBObject : NSObject
</span><span class='line'>@property (nonatomic, assign) my_struct arg3;
</span><span class='line'>@property (nonatomic, copy)  NSString *arg1;
</span><span class='line'>@property (nonatomic, copy) NSString *arg2;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>@implementation HYBObject
</span><span class='line'>
</span><span class='line'>// 在堆上分配的内存，我们要手动释放掉- (void)dealloc {
</span><span class='line'>free(self.arg3);
</span><span class='line'>
</span><span class='line'>}@end</span></code></pre></td></tr></table></div></figure>


<p>测试:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my_struct str = (my_struct)(malloc(sizeof(my_struct)));
</span><span class='line'>str-&gt;a = 1;
</span><span class='line'>str-&gt;b = 2;
</span><span class='line'>HYBObject *obj = [[HYBObject alloc] init];
</span><span class='line'>obj.arg1 = @"arg1";
</span><span class='line'>obj.arg2 = @"arg2";
</span><span class='line'>obj.arg3 = str; 
</span><span class='line'>[self performSelector:@selector(call:) withObject:obj]; 
</span><span class='line'>// 在回调时得到正确的数据的- (void)call:(HYBObject *)obj { NSLog(@"%d %d", obj.arg3-&gt;a, obj.arg3-&gt;b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>UITableViewCell有个UIlabel,显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</h2>

<p>这是否刷新取决于timer加入到run loop中的mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView 滑动时切换到该Mode</li>
<li>UIInitializationRunLoopMode：run loop启动时，会切换到该Mode</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）:Mode集合苹果公开提供的Mode有两个：</li>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
<li>在编程中，如果我们把一个NStimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候，ScrollView滚动的过程中会因为mode的切换，而导致NSTimer将不再被调度，当我们滚动的时候，也希望不调度，那就应该使用该模式。
但是，我们希望在滚动的时候，定时器也要回调，那就应该使用common mode</li>
</ul>


<h2>对于单元格重用的理解</h2>

<ul>
<li>当cell滑动屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外划入屏幕内部时，从重用队列中找看有没有可重用的单元格，若有，就直接用，没有就重新创建一个</li>
</ul>


<h2>解决Cell重用的问题</h2>

<ul>
<li>UITableview通过重用单元格来达到节省内存的额目的，通过为每个单元格制定一个重用标识（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的Id，对于简单的表格，一个标识符就够了</li>
<li>如一个TableView中又10个单元格，但屏幕最多显示4个，实际上iPHone只为其分配了4个单元格的内存，没有分配10个，当关东单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的格式为屏幕最大显示数，当有新的cell进入屏幕时，会随你调用已经滚出屏幕的cell所占的内存，这就是cell的重用</li>
<li>对于多变的自定义cell,这种重用机制会导致内容出错，为解决这种出错的方法，把原来的</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString]
</span><span class='line'>修改为：UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];</span></code></pre></td></tr></table></div></figure>


<p>这样就解决掉cell重用机制导致的问题，但是数据量多的情况，会有性能问题</p>

<h2>有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？</h2>

<p>对于这4个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务a */ });
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务b */ });
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务c */ }); 
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务d */ }); 
</span><span class='line'>dispatch_group_notify(group,dispatch_get_main_queue(), ^{ // 在a、b、c、d异步执行完成后，会回调这里});
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当然，我们还可以使用非常老套的方法来处理，通过4个变量来标识a,b,c,d四个人物是否完成，然后在runloop中让其等待，当完成时才退出runloop.但是这样做会让后面的代码得不到执行，直到Runloop执行完成</li>
<li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。</li>
</ul>


<h2>使用block有什么好处？使用NSTimer写出一个使用block显示（在UIlabel上）秒表的代码</h2>

<ul>
<li>代码紧凑，传值，回调都很方便，省去了写代理的很多代码</li>
<li>NSTimer封装成block</li>
<li>实现方法:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0
</span><span class='line'>                              repeats:YES
</span><span class='line'>                             callback:^() {
</span><span class='line'>  weakSelf.secondsLabel.text = ...
</span><span class='line'>}
</span><span class='line'>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]</span></code></pre></td></tr></table></div></figure>


<h2>线程和进程的区别和联系？</h2>

<ul>
<li>一个程序至少要有进程，一个进程至少要有一个线程</li>
<li>进程：资源分配的最小独立单元，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程：进程下的一个分支，是进程的实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一点在运行中不可少的资源（程序计数器，一组寄存器，栈）但是它可与同属一个进程的其他线程共享进程所拥有的全部资源</li>
<li>进程和线程的主要差别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于这个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源比较大，效率要差一些</li>
<li>但对于一些要求同事进行并且又要共享某些变量的并发造作，只能用线程，不能用进程</li>
</ul>


<h2>多线程编程</h2>

<ul>
<li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中，线程同步：多个线程同事访问一个数据会出问题，NSlock,线程同步块，@synchronized(self){}。</li>
<li>NSOperationQueue操作队列（不需要考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation, BSBlockOperation，自定义Operaton.创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到队列中时，默认会调用main方法。</li>
<li>GCD（<code>Grand Central Dispatch</code>）宏大的中央调度，串行队列，并发队列，主线程队列</li>
<li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个</li>
<li>串行和并行：串行是多个任务按照一定的顺序执行，并行是多个任务同事执行</li>
<li>代码是在分线程执行，在主线程刷新UI</li>
</ul>


<h3>多线程编程是防止主线程堵塞，增加运行效率的最佳方法</h3>

<ul>
<li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法</li>
<li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个想成管理器可以并行运行的线程数量等</li>
<li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径</li>
<li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力</li>
</ul>


<h2>定时器与线程的区别：</h2>

<ul>
<li>定时器：可以执行多次，默认在主线程中</li>
<li>线程：只能执行一次</li>
</ul>


<h2>Apple设备尺寸和编程尺寸</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-0.png" alt="1" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-1.png" alt="2" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-2.png" alt="3" /></p>

<h2>TCP和UPD的区别和联系</h2>

<ul>
<li>TCP为传输控制层协议，为面向连接，可靠地，点到点的通信</li>
<li>UPD为用户数据报协议，非连接的不可靠的点到多点的通信</li>
<li>TCP侧重可靠传输，UPD侧重于快速传输</li>
</ul>


<h2>TCP连接的三次握手</h2>

<ul>
<li>第一次握手：客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN,同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK,此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态</li>
</ul>


<h2>Scoket连接和HTTP连接的区别:</h2>

<ul>
<li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Scoket是对TCP/IP协议的封装，scoket本身并不是协议，而是一个调用接口(API)，通过Socket,我们才能使用TCP/IP协议</li>
<li>HTTP连接:短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPHone主要类NSURLSession</li>
<li>Socket连接：长连接，客户端跟服务器端直接使用Scoket进行连接，没有规定连接后断开，因此客户端和服务器保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8k</li>
</ul>


<h2>http协议的特点，关于http请求Get和Post的区别</h2>

<p>Get和post的区别：</p>

<ul>
<li>HTTP超文本传输协议，是短链接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开，Http是一个属于应用层面面向对象的协议，http有两类报文：请求报文和响应报文</li>
<li>http请求报文：一个http请求报文由请求行，请求头部，空行和请求数据4部分组成</li>
<li>http响应报文：由三部分组成：状态航，消息报头，响应正文</li>
<li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有的参数都拼接在地址后面），不适合传输大量数据，长度有限制，为1024个字节</li>
<li>Post请求：参数在请求数据区放着，相对Get更安全，并且数据大小没有限制，把提交的数据放置在HTTP包的包体中</li>
<li>GET提交的数据会在地址栏显示出来，而Post请求，地址栏不会改变</li>
</ul>


<p><em>传输数据的大小 ：</em>
* Get提交时，传输数据就会受到URL长度限制，Post由于不是通过URL传值，理论上不受限制</p>

<p><em>安全性：</em></p>

<ul>
<li>Post的安全性要比Get的安全性高；</li>
<li>通过Get提交数据，用户名和密码将明文出现在URL上，比如登录界面有可能被浏览器缓存</li>
<li>HTTPS：安全超文本传输协议(Secure Hypertext Transfer Protocol),它是一个安全通信通道，基于http 开发，用于客户计算机和服务器之间交换信息，使用安全套接字(SSI)进行信息交换，即HTTP的安全版</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义UICollectionViewLayout]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/"/>
    <updated>2016-10-28T14:34:50+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout</id>
    <content type="html"><![CDATA[<p>UICollectionView，自从ios6之后就被引入到开发中，现在已经变成了最流程的UI元素之一，它最吸引人的特性就是将数据和布局进行分离，依靠分离的数据元素去处理布局，这个布局对象是决定占位元素和视图的元素。</p>

<!--more-->


<p>你可能已经习惯了默认的flow layout布局，它是一个默认实现的被UIKit,它是由基本的表格布局组成的。当然你也可以自定义布局，你可以按照自己的喜好来对视图进行重排。自定义布局是非常强大和灵活的。</p>

<p>通过本章，你将学会如何自定义的布局，怎么去计算layout Attributes,怎么去处理动态的cell。</p>

<h2>Getting Started</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Pinterest-starterproject.zip">Download the started project</a>，下载后打开</p>

<p>编译运行，效果如图：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_starter_project.png" alt="1" /></p>

<h2>创建自定义的布局类</h2>

<p>你第一步就是创建一个自定义的布局类，UICollectionView有一个抽象类是<code>UIcollectionViewLayout</code>,它定义了你的Collection View 的每个cell的属性集合-<code>UICollectionViewLayoutAttributes</code>，它包含了你的CollectionView中每个item的属性，比如frame,透明度等</p>

<p>创建一个类继承自<code>UICollectionViewLayout</code>,确保选中的是swift语言，然后创建。</p>

<p>下一步，在你的storyboard中配置下你的自定义布局对象类。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_select_collection_view.png" alt="1" /></p>

<p>然后打开<code>Attributes Inspector</code>面板，选中<code>Custom</code>，在下一个<code>class</code>框中选中你刚才创建的新类<code>PinterestLayout</code>：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_change_layout.png" alt="1" /></p>

<p>好了，编译运行：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_empty_collection.png" alt="3" /></p>

<p>why?</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/meme-nopictures.jpg" alt="1" /></p>

<p>不要慌张！因为你还没有在自定义布局类中写入方法，所以这里什么都不显示。</p>

<h2>核心布局对象</h2>

<p>让我们先看看Collection View的布局调用流程，当Collection View 需要显示一些布局信息的时候，它会询问layout object 去提供一些防范去实现。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/layout-lifecycle.png" alt="1" /></p>

<p>你自定义的布局必须实现如下方法:</p>

<ul>
<li><code>prepareLayout()</code>，在cell将要进入屏幕的时候，这个方法将会被调用，这是一个机会当你去准备展示和计算CollectionView size和坐标的地方</li>
<li><code>collectionViewContentSize()</code>：在这个方法中，你将会返回CollectionView的高度和宽度-不仅仅是可视的内容，Collection View 将会用这些信息去配置ScrollView的内容尺寸</li>
<li><code>layoutAttributesForElementsInRect(_:):</code>在这个方法中，你需要返回所有的嵌套在矩形区域中的布局属性，你将要返回一个包含<code>UICollectionViewLayoutAttributes</code>属性的集合</li>
</ul>


<p>ok，现在你知道需要去实现什么方法了-但是如何去计算attributes？</p>

<h2>计算布局属性</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UICollectionView 新特性]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/"/>
    <updated>2016-10-24T10:35:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing</id>
    <content type="html"><![CDATA[<p>关于ios 10 UIcolelctionView的新特性，主要还是体现在如下三个方面</p>

<ol>
<li>顺滑的滑动体验</li>
<li>针对self=sizing的改进</li>
<li>Interactive recording重排</li>
</ol>


<!--more-->


<p>这个功能在iOS9的时候介绍过了，苹果在iOS10的API里面大大增强了这一个功能</p>

<h2>目录</h2>

<h3><a href="#1">UICollectionViewCell顺滑的滑动体验</a></h3>

<h3><a href="#2">UICollectionViewCell的预加载</a></h3>

<h3><a href="#3">UITableViewCell的预加载</a></h3>

<h3><a href="#4">针对self-sizing的改进</a></h3>

<h3><a href="#5">Interactive Recordering</a></h3>

<h3><a href="#6">UIRefreshControl的改进</a></h3>

<h2><a name="1"></a>UICollectionViewCell顺滑的滑动体验</h2>

<p>众所周知，iOS设备已良好的用户体验赢得了广大的用户群，iOS系统在用户点击屏幕会立即做出响应。而且很大一部分的操作是来自用户的滑动操作，所以滑动的顺滑性是使用用户沉浸在App中享受的必要条件，接下来我们就谈谈iOS10中增加了那些新特性。</p>

<p>我们先来看一下之前UIcollectionView的体验，假设我们每个cell都是简单的蓝色，实际开发app中，cell会比较复杂，我们先生成100cell.当用户滑动不是很快的时候，还感觉不出来卡顿，当用户大幅度滑动，整个UIcollectionView的卡顿就很明显了。如果整个cell的dataSource又是从网络加载的，那就更加卡顿了，如果如下图</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784344928825.gif" alt="1" /></p>

<p>如果这种app上架，用户使用过后，很可能就直接给1星评价了，但是为什么会造成这种问题呢？我们来分析一下，我们模拟一下系统是如果处理重用机制的，效果如下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784355209022.gif" alt="2" /></p>

<p>在上图中，我们可以看出，当cell准备进入屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了。而且更重要的是，在屏幕外面等待加载的cell是整整一行！这一行的cell都已经加载完数据。这是UICollectionView在用户大幅度滑动时卡顿的根本原因。用专业术语来说就是掉帧</p>

<p>接下来我们来详细说说掉帧的问题</p>

<p>当今的用户是很挑剔的，用户需要一个很顺滑的体验，只要有一点卡顿，很可能一言不合就卸载app了。要想用户感觉不到卡顿，那么我们的app就必须达到每秒60帧，用数学换算一下就是每帧16毫秒就必须刷新一次。</p>

<p>我们用图标来分析一下掉帧的问题，下面会出现两种不同的帧</p>

<ul>
<li>第一种情况，下图是当用户轻微的上下小幅度滑动，这个时候每个cell的加载压力都不打，ios针对这种情况，已经做了很好的优化了，所以用户感觉不到任何卡顿，这种情况下不会掉帧，用户也希望能使用如此顺滑的app</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784433822879.jpg" alt="1" /></p>

<ul>
<li>第二种情况，当用户大幅度滑动，每个cell加载的压力很大， 也许需要网络请求，也许需要读取数据库，而且每次都加载一行cell出来，这样每个cell的加载时间都增加了，加载一行的总时间也就大大增加了，如下图所示，这样，不仅仅当前帧在加载cell，总的时间还会挤压到下一帧的时间里面去。这种情况下，用户就感觉到卡顿了。</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784459878847.jpg" alt="2" /></p>

<p>我们换种方式在说明一下2种情况下掉帧的情况。我们用下图的标准来衡量一下上面2中情况。下图分为2部分，上面红色的区域，就是表示掉帧的区域，因为高于16ms。红色和绿色区域的分界线就在16ms处，Y轴我们表示的是CPU在主线程中花费的时间，X轴表示对额就是在用户滑动中发生的刷新事件。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784491910972.jpg" alt="1" /></p>

<p>针对上述掉帧的情况，绘制出实验数据，如下图，值得我们关注的是，曲线是很曲折的，非常的不平滑，当用户大幅度滑动的时候，峰值超过了16 ms ，当用户慢速滑动的时候，帧率又能保持在比较顺滑的区域，处于绿色区域内的cell加载压力都是很小的。这就是时而掉帧时而顺滑的场景。这种场景下，用户体验是很糟糕的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784519648239.jpg" alt="2" /></p>

<p>那怎么解决这个问题呢？我们来看下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784547235875.jpg" alt="2" /></p>

<p>上图中的曲线我们看着就很平缓了，而且这种情况也不会出现掉帧的情况了，每个滑动中的时间都能达到60帧了，这是怎样做到的呢？因为把每个cell的加载事件都评分了，每个cell不会再出现很忙和很闲的两个极端，这样我们就取消了之前的波峰和波谷。从而让该曲线达到了近乎水平的直线。</p>

<p>如何让每个cell都分摊加载任务的压力？这就要谈到新的cell的生命周期了。</p>

<p>先来看看老的UICollectionViewCell的声明周期，当用户滑动屏幕，屏幕外有一个cell准备加载显示进来。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784605179969.jpg" alt="1" />
这个时候我们把这个cell从reuse队列里面拿出来，然后调用<code>prepareForReuse</code>方法。这个方法就给了cell时间，用来重置cell,重置转台，刷新cell,加载新数据。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784613342397.jpg" alt="2" /></p>

<p>再滑动，我们就会调用<code>cellForItemAtIndexPath</code>方法了，这个方法里面就是我们开发者自定义的填充cell的方式了。这里会填充data model,然后赋值给cell,再把cell返回给iOS系统。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784643684182.jpg" alt="1" /></p>

<p>当cell马上要进入屏幕的时候，就会调用willDisplayCell的方法，这个方法给了我们app最后一次机会，为cell进入屏幕做最后的准备工作。执行完willDisplayCell之后，cell就进入屏幕了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784674667370.jpg" alt="2" /></p>

<p>当cell完全离开屏幕之后，就会调用<code>didEndDisplayingCell</code>方法，以上就是在iOS10之前的整个UICollectionViewCell的生命周期。</p>

<p>接下来我们看看iOS10 的UICollectionViewCell的生命周期是怎么样的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784919171617.jpg" alt="1" /></p>

<p>这里还是和iOS9一样的。当用户滑动UICollectionView的时候，需要一个cell,我们就从reuse队列中拿出一个cell，并调用<code>prepareForReuse</code>方法，注意调用这个方法的时间，当cell还没有进入屏幕的时候，就已经提前调用这个方法了。注意对比和iOS9的区别，iOS9是在cell上边缘马上进入屏幕的时候才调用方法， 而这里，cell整个生命周期都被提前了，提前到cell还在设备外面的时候。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784950618167.jpg" alt="2" /></p>

<p>这里还是和之前一样，在<code>cellForItemAtIndexPath</code>中创建cell，填充数据，刷新状态等操作，注意，这里的生命周期也比iOS9提前了。</p>

<p>用户继续滑动，这个时候就有不同了。</p>

<p>这个时候我们并不去调用<code>willDisplayCell</code>方法了，这里遵循的原则是，何时去显示，何时再去调用<code>willDisplayCell</code>.</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785001420508.jpg" alt="1" /></p>

<p>当cell要马上就需要显示的时候，我们再调用<code>willDisplayCell</code>方法。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785009176155.jpg" alt="2" /></p>

<p>当整个cell要从UICollectionView的可见区域消失的时候，这个时候回调用<code>didEndDisplayingCell</code>方法，接下来发生的事情和iOS9一样，cell会进入重用队列中。</p>

<p>如果用户想要显示某个cell,在iOS9中，cell只能从重用队列里面取出，再次走一遍生命周期，并调用<code>cellForItemAtIndexPath</code>去创建或者生成一个cell.</p>

<p>在iOS10当中，系统会把cell保持一段时间，在iOS中，如果用户把cell滑出屏幕后，如果突然又想回来，这个时候cell并不需要再走一遍生命周期了，只需要直接调用<code>willDisplayCell</code>就可以了。cell就又会重新出现在屏幕中了。这就是iOS10的整个UICollectionView的生命周期</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785140434098.jpg" alt="1" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785147242971.jpg" alt="2" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785156440182.jpg" alt="3" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785162269537.jpg" alt="4" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785168247905.jpg" alt="5" /></p>

<p>上面说的iOS10里面的场景同样适用于多列的情况，这时我们每次只加载一个cell,而不是每次加载一行的cell.当第一个cell准备好之后再叫第二个cell准备。当2个cell都准本号之后，接着我们再调用<code>willDisplayCell</code>给每个cell,发送完这个消息之后，cell就会出现在屏幕上了。</p>

<p>这虽然看起来是一个很小的改动，但是这小小的改动就提升了很多用户体验</p>

<p>让我们来看看上述的改动对滑动的影响！</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785199429168.gif">1</a></p>

<p>滑动比iOS9流畅很多，这里可以看到整个过程都很平缓，不卡顿。</p>

<p>还是和iOS9一样，我们来模拟一下系统是如果加载cell的情况。</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785382812684.gif">2</a></p>

<p>我们可以很明显的的看到，iOS系统是一个一个的加载cell的，一个cell加载完之后再去加载下一个cell,这里和iOS9的有很大的不同，ios9是记载整整一行的cell</p>

<p>这是因为我们用了新的UICollectionViewCell的生命周期，整个App完全没有加一行代码，现在iOS10是丝滑般的体验，是在是太棒了。</p>

<h2><a name = "2"></a>UICollectionViewCell的Pre-Fetching预加载</h2>

<p>当我们编译iOS10的APP的时候，这个Pre-Fetching默认是enable的。当然，如果有一些原因导致你必须用到iOS10之前的老的生命周期，你只需要给collectioView加入新的<code>isPrefetchingEnabled</code>属性即可。如果你不想用到<code>Pre-Fetching</code>，那么把这个属性变成false即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>collectionView.isPrefetchingEnabled = false</span></code></pre></td></tr></table></div></figure>


<p>为了最佳实践一下这个新特性，我们先改变一下我们加载cell的方式，我们把很重的读取数据的操作，所有内容的创建都放到<code>cellForItemAtIndexPath</code>方法里面去完成。保证我们在<code>willDisplayCell</code>和<code>didEndDisplayCell</code>这两个方法里面基本不做其他事情。最后，保证<code>cellForItemAtIndexPath</code>加载的cell都不是从重用队列里面拿出来的。</p>

<p>如果这个时候你用ios10编译出你的app,那么非常顺滑的用户体验就会自动的优化出来</p>

<p>UICollectionView的流畅滑动解决了，那么在UICollectionViewCell在加载的时候所花费的时候，怎么解决呢？</p>

<p>UICollectionViewCell加载的时候取决于DataMOdel,DataMOdel很可能回去加载图片，来自于网络或者来自于本地的数据库，这些操作大多数都是异步操作，为了使data加载更快，iOS10引入了新的Apil来解决这个问题。</p>

<p>UICollectionView有两个小伙伴，那就是dataSource和delegate,在iOS10中，将会迎来第三个小伙伴，这个小伙伴就是<code>prefetchDataSource</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol UICollectionViewDataSourcePrefetching {
</span><span class='line'>    func collectionView(_ collectionView: UICollectionView,
</span><span class='line'>                        prefetchItemsAt indexPaths: [NSIndexPath])
</span><span class='line'>    optional func collectionView(_ collectionView: UICollectionView,
</span><span class='line'>                                 cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])
</span><span class='line'>}
</span><span class='line'>class UICollectionView : UIScrollView {
</span><span class='line'>    weak var prefetchDataSource: UICollectionViewDataSourcePrefetching?
</span><span class='line'>    var isPrefetchingEnabled: Bool
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个协议连只有一个必须要实现的方法-<code>ColletionView prefetchItemsAt indexPaths</code>，这个方法会在<code>prefetchDataSource</code>里面被调用，用来给你异步的预加载数据的。indexPaths数组是有序的，就是接下来item接收数据的顺序，让我们model异步处理数据更加方便。</p>

<p>在这个协议里面患有第二个方法<code>CollectionView cancelPrefetcingForItemsAt indexPaths</code>，不过这个方法是可选的，我们可以利用这个方法来处理在滑动中取消或者降低提前加载数据的优先级。</p>

<p>值得说明的是，新增加的这个小伙伴<code>prefetchDataSource</code>，并不能取代原来的读取数据的方法，这个预加载仅仅只是辅助加载数据，并不能删除原来我们读取数据的方法。</p>

<p>至此，我们来看看从文章开始到现在，UICollectionView的性能提升了多少，我们还是用掉帧的方法来看看UICollectionView的性能。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785413182613.jpg" alt="1" /></p>

<p>上面是iOS9 UICollectionView的性能，很明显的看见，波峰波谷很明显，并且还掉了8帧，有明显的卡顿现象。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785449871270.jpg" alt="2" />
上图是iOS10 UICollectionView的性能，我们可以明显的看到，经过ios10的优化，整个曲线很明显的平缓了一些，没有极端的波峰掉帧现象。但是依旧存在少量的波峰快到了16ms分界线了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785482131029.jpg" alt="1" /></p>

<p>上图是iOS10 + pre-Fetching Api之后的性能，已经优化的效果很明显了，整条曲线基本上都水平了。近乎完美，但是还是能发现有个别波峰特别高，波峰特别高的地方就是那个cell加载压力大， 时间花的比较长导致的。接下来我们继续优化！</p>

<p>先来总结一下使用Pre-Fetching API 需要注意的地方。</p>

<ul>
<li>在我们使用Pre-Fetching API的时候，我们一定要保证整个预加载过程都放在后台线程中进行。合理使用GCD和NSOperationQueue处理好多线程</li>
<li>请切记，Pre-Fetching API 是一种自适应的技术，何为自适应技术呢？当我们滑动速度很慢的时候，在这种“安静”的时期，Pre-Fetching API会默默的再后台预加载数据，但是一旦我们快速滑动，我们需要频繁的刷新，我们不会去执行pre-fetching API</li>
<li>最后，用<code>cancelPrefetchingAPI</code>去迎合用户的滑动动作的变换，比如说用户在快速滑动发现了有趣的感兴趣的事情，这个时候停下来，甚至快速反向滑动了，或者点击了事件，进去看详情了，这些时刻我们都应该开启<code>cancelPrefetchingAPI</code></li>
</ul>


<p>综合所述，Pre-Fetching API对于提高UICOllectionView的性能提升是很有帮助的，而且并不需要加入太多的代码，加入少量的代码就可以获得巨大的额性能提升！</p>

<h2><a name="3"></a>UITableViewCell的Pre-Fetching预加载</h2>

<p>在iOS10中，UITableViewCell也跟着UICollectionView一起得到了性能的提升，一样拥有了Pre-Fetching API</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol UITableViewDataSourcePrefetching {
</span><span class='line'>    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [NSIndexPath])
</span><span class='line'>    optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:
</span><span class='line'>                            [NSIndexPath])
</span><span class='line'>}
</span><span class='line'>class UITableView : UIScrollView {
</span><span class='line'>    weak var prefetchDataSource: UITableViewDataSourcePrefetching?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里和上面的UICollectionView一样，会调用<code>TableView prefetchRowsAt indexPaths</code>方法，indexPaths还是一个有序数字，顺序就是列表上可见的顺序，第二个可选的API还是<code>TableView cancelPrefetchingForRowsAt indexPaths</code>，和之前的提到的一样，也是用来取消预加载的，性能的提升和UIcollectionView一样的，对于UITableView 的性能提升很大！</p>

<h2><a name="4"></a>针对self-sizing的改进</h2>

<p>self-sizing API 第一次被引入是在ios8中，然而现在在iOS10中得到了一些改进。</p>

<p>在UICollectionView中有个固定的类，叫UICollectionViewFlowlayout,iOS已经在这个类中完全支持了self-sizing.为了能开启这一特性，需要我们开发者为一些不能为0的 CGSize的cell设置一下estimated item size.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout.estimatedItemSize = CGSize(width:50,height:50)</span></code></pre></td></tr></table></div></figure>


<p>这会告诉UICOllectionView我们想要开启动态计算内容的布局。</p>

<p>至今，我们有三种方法来动态的布局：</p>

<ul>
<li>第一种方法是使用autolayout，当我们合理的加入约束，当cell加载的时候，就会根据内容动态的加载布局</li>
<li>第二种方法，如果你不想使用autolayout的方法，想更加手动的控制它，那么我们就需要重写sizeThatFits()方法</li>
<li>第三种方法，终极的方法是重写<code>preferredLayoutAttributesFittingAttributes()</code>方法，在这个方法里面不仅仅可以提供size的信息，更可以得到alpha和transform的信息。</li>
</ul>


<p>所以想指定cell的大小，就可以用上面的三个方法之一</p>

<p>但是实际的操作中，我们可以发现，有时候设置一个合适的estimated item size，对于我们来说是很困难的事情，如果flow layout可以用数学的方法动态的计算布局，而不是根据我们给的size去布局，那回事很酷的事情。</p>

<p>iOS10中就引入了新的API来解决上述问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize</span></code></pre></td></tr></table></div></figure>


<p>对于开发者，我们需要做的事情，仅仅就是设置好flow layout,然后给<code>estimatedItemSize</code>设定一个新的常数，最后<code>UICollectionViewFlowLayout</code>就会自动计算高度了。</p>

<p>系统会自动计算好所有的布局，包括已经定下来的size的cell,并且还会动态的给出接下来的cell的大小的预测。</p>

<p>接下来看2个例子就可以很明显看出iOS10针对self-sizing的改进了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785547586106.gif" alt="1" />
上图可以看到，iOS 9的布局是针对单个cell计算的，当改变了单个cell,其它的cell依旧没有变化，还是需要重新计算</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785653922069.gif" alt="2" /></p>

<p>这里例子就可以很明显的看出差别了，当我们改变了第一个cell的size之后，系统会自动计算出所有的cell的size，并且每一行，每一个section的size都会被动态的计算出来，并且刷新界面！</p>

<p>以上就是iOS 10 针对 self-sizing的改进。</p>

<h2><a name="5"></a>Interactive Reordering</h2>

<p>谈到重新排列，这是我们就需要类比一下UITableview了，UICollectioNView重新排列就如同UITableview把cell上下移动，只不过UITableView的重新排列是针对垂直方向的。</p>

<p>在IOS 9 中，引入了UICollectionView的Interactive Reordering，在今年的iOS 10中，又加入了新的API</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785697559422.gif" alt="1" /></p>

<p>在上图中，我们可以看到，我们即使任意拖动cell,整个界面也会重新排列，并且我们改变了cell的大小，整个UICollectionView也会重新动态的布局。</p>

<p>我们先来看看iOS 9 里面的API</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UICollectionView : UIScrollView {
</span><span class='line'>    func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&gt; Bool
</span><span class='line'>    func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint)
</span><span class='line'>    func endInteractiveMovement()
</span><span class='line'>    func cancelInteractiveMovement()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>要想开启interactive movement,我们就需要调用<code>beginInteractiveMovementForItem()</code>方法，其中indexPath代表了我们将要移动的cell.接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作，这时我们就需要调用<code>updateInteractiveMovementTargetPosition()</code>方法，我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用<code>endInteractiveMovement()</code>方法。UICollectionView就会放下cell,处理完整个layout，此时你也可以重新刷新model或者处理数据model.如果中间突然手势取消了，那么这个时候就应该调用<code>cancelInteractiveMovement()</code>方法，如果我们重新把cell对应一圈之后有放回原位了，其实就是取消了移动，那这个时候就应该在<code>cancelInteractiveMovement()</code>方法里面不用取刷新data Source.</p>

<p>在iOS10中，如果你使用UICollectionViewController,那么这个重排对于你来说更加简单、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UICollectionViewController : UIViewController {
</span><span class='line'>    var installsStandardGestureForInteractiveMovement: Bool
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你只需要把installsStandardGestureForInteractiveMovement这个属性设置为true就可以了。CollectionViewController会自动为你加入手势，并且自定为你调用上面的方法。</p>

<p>以上就是去年ios 9 为我们增加的API</p>

<p>今年的ios 10 新加入的API是在iOS9的基础上增加了翻页的功能。</p>

<p>UICollectionView继承自UIScrollView,所以只需要你做的是把 isPagingEnable设置为true，即可开启分页的功能。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>collectionView.isPagingEnabled = true</span></code></pre></td></tr></table></div></figure>


<p>开启分页之前:
<img src="http://cc.cocimg.com/api/uploads/20160706/1467785741500789.gif" alt="1" /></p>

<p>开启分页之后就长这样子:</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785759631412.gif" alt="2" /></p>

<p>每次移动一次就会以页为单位的翻页、</p>

<h2><a name="6"></a>UIRefreshControl的改进</h2>

<p>UIRefreshControl现在可以直接在CollectionView里面使用了，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController.因为现在RefreshCOntrol成为了ScrollView的一个属性了。</p>

<p>UIRefreshControl的使用方法很简单，就三步:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let refreshControl = UIRefreshControl()
</span><span class='line'>refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)),
</span><span class='line'>                         for: .valueChanged)
</span><span class='line'>collectionView.refreshControl = refreshControl</span></code></pre></td></tr></table></div></figure>


<p>先创建一个refreshCOntroler,再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性就可以了。</p>

<h2>Summary</h2>

<ul>
<li>UICollectionview cell Pre-fetching预加载的机制</li>
<li>UICollectionView And UITableView prefetch DataSource新增的API</li>
<li>针对self-sizing cell改进</li>
<li>Interactive recordering 重排</li>
</ul>


<p>最后，原来有些地方用到 AsyncDispatchKit优化的UICollectioView速度的，现在可以考虑不用第三方库了，系统自带的方法可以解决一般性的卡顿问题了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UserNotifications]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications/"/>
    <updated>2016-10-17T09:53:08+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications</id>
    <content type="html"><![CDATA[<p>ios10以前杂乱的和通知相关的API都被统一了，现在开发者可以使用独立的UserNotificaitons.framework来集中管理和使用iOS系统中通知的功能。在此基础上，Apple还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知UI等一系列功能。</p>

<!--more-->


<p>对于开发者来说，想比较于之前版本，iOS10提供了一套非常易用通知处理接口，是SDK的一次重大重构，而之前的绝大部分通知相关API都已经被标为弃用(deprecated)</p>

<p>您可以在WWDC16的 <a href="https://developer.apple.com/videos/play/wwdc2016/707/">introducaion to Notifications</a>和<a href="https://developer.apple.com/videos/play/wwdc2016/708/">Advanced Notifications</a>这两个Session中找到详细信息；另外也不要忘了参考<a href="https://developer.apple.com/reference/usernotifications">UserNotifications官方文档</a></p>

<h2>UserNOtifications框架解析</h2>

<h3>基本流程</h3>

<p>iOS10中通知相关的操作遵循下面的流程:</p>

<p><code>审核和注册</code>-><code>创建和发起</code>-><code>展示和处理</code></p>

<p>首先你需要向用户请求推送权限，然后发送通知。对于发送出的通知，如果你的应用位于后台或者没有运行的话，系统将通过用户允许的方法（弹窗，横幅，或者是在通知中心）进行展示。如果你的应用已经位于前台正在运行，你可以自行决定要不要显示这个通知。最后，如果你希望用户点击通知能有打开应用以外的额外功能的话，你也需要进行处理。</p>

<h2>权限申请</h2>

<p>iOS8之前，本地推送和远程推送（Remote Notificaiton）是区分对待的，应用只需要在进行远程推送是获取用户同意。iOS8对这一行为进行了规范，因为无论是本地推送还是远程推送，其实在用户看来表现是一致的，都是打断用户的行为。因此从iOS8开始，这两种通知都需要申请权限。ios10里进一步消除了本地通知和推送通知的区别。向用户申请通知权限非常简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {
</span><span class='line'>    granted, error in
</span><span class='line'>    if granted {
</span><span class='line'>        // 用户允许进行通知
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，在使用UN开头的API的时候，不要忘记导入<code>UserNotifications</code>框架：</p>

<p><code>import UserNotifications</code></p>

<p>第一次调用这个方法时，会弹出一个系统弹窗.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-0.png" alt="1" /></p>

<p>要注意的是，一旦用户拒绝了这个请求，再次调用该方法时也不会进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知，而这往往是不可能的。因此，在合适的是偶弹出请求窗，在请求权限前预先进行说明，而不是直接粗暴地在启动的时候就进行弹窗，会是更明智的选择。</p>

<h2>远程推送</h2>

<p>一旦用户同意后，你就可以再应用中发送本地通知了。不过如果你通过服务器发送远程通知的话，还需要多一个获取用户token的操作，你的服务器可以使用这个token将用向Apple push Notification的服务器提交请求，然后APNS通过token识别设备和应用，将通知推给用户。</p>

<p>提交token请求和获得token的回调是现在"唯一"不在新框架中的API,我们使用<code>UIApplication</code>的<code>registerForRemoteNotifications</code>来注册远程通知，在<code>AppDelegate</code>的<code>application(_:didRegisterForRemoteNotificationsWithDeviceToken)</code>中获取用户token:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 向 APNs 请求 token：
</span><span class='line'>UIApplication.shared.registerForRemoteNotifications()
</span><span class='line'>
</span><span class='line'>// AppDelegate.swift
</span><span class='line'> func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
</span><span class='line'>    let tokenString = deviceToken.hexString
</span><span class='line'>    print("Get Push token: \(tokenString)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>获取得到的<code>deviceToken</code>是一个<code>Data</code>类型，为了方便使用和传递，我们一般会选择将它转换为一个字符串。swift3中可以使用下面的<code>data</code>扩展来构造适合传递给Apple的字符串：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Data {
</span><span class='line'>    var hexString: String {
</span><span class='line'>        return withUnsafeBytes {(bytes: UnsafePointer&lt;UInt8&gt;) -&gt; String in
</span><span class='line'>            let buffer = UnsafeBufferPointer(start: bytes, count: count)
</span><span class='line'>            return buffer.map {String(format: "%02hhx", $0)}.reduce("", { $0 + $1 })
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>权限设置</h3>

<p>用户可以再系统设置中修改你的应用的通知权限，除了打开和关闭全部通知权限外，用户也可以限制你的应用智能进行某种形式的通知显示，比如值允许横幅而不允许弹窗及通知中心显示灯。一般来说你不应该对用户的选择进行干涉，但是如果你的应用确实需要某种特定场景的推送的话，你可以对当前用户进行的设置进行检查:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UNUserNotificationCenter.current().getNotificationSettings {
</span><span class='line'>    settings in 
</span><span class='line'>    print(settings.authorizationStatus) // .authorized | .denied | .notDetermined
</span><span class='line'>    print(settings.badgeSetting) // .enabled | .disabled | .notSupported
</span><span class='line'>    // etc...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>发送通知</h2>

<p>UserNOtifications中对通知进行了统一。我们通过通知的内容（<code>UNNotificaitonsContent</code>）,发送的时机<code>UNNotifiationTrigger</code>以及一个发送通知的<code>String</code>类型的标识符，来生成一个<code>UNNotificationRequest</code>类型的发送请求。最后，我们将这个请求添加到<code>UNUserNotificationCenter.current()</code>中，就可以等待通知到达了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1. 创建通知内容
</span><span class='line'>let content = UNMutableNotificationContent()
</span><span class='line'>content.title = "Time Interval Notification"
</span><span class='line'>content.body = "My first notification"
</span><span class='line'>
</span><span class='line'>// 2. 创建发送触发
</span><span class='line'>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
</span><span class='line'>
</span><span class='line'>// 3. 发送请求标识符
</span><span class='line'>let requestIdentifier = "com.onevcat.usernotification.myFirstNotification"
</span><span class='line'>
</span><span class='line'>// 4. 创建一个发送请求
</span><span class='line'>let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)
</span><span class='line'>
</span><span class='line'>// 将请求添加到发送中心
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error == nil {
</span><span class='line'>        print("Time Interval Notification scheduled: \(requestIdentifier)")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>iOS10中通知不仅支持简单的一行文字，你还可以添加<code>title</code>和 <code>subtitle</code>,来用粗体字的形式强调通知的目的。对于远程推送，iOS10之前一般只含有消息的推送；payload是这样的：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":"Test",
</span><span class='line'>    "sound":"default",
</span><span class='line'>    "badge":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果我们想要加入<code>title</code>和<code>subtitle</code>的话，则需要将<code>alert</code>从字符串换为字典，新的payload是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"I am title",
</span><span class='line'>      "subtitle":"I am subtitle",
</span><span class='line'>      "body":"I am body"
</span><span class='line'>    },
</span><span class='line'>    "sound":"default",
</span><span class='line'>    "badge":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好消息是，后一种字典的方法其实在iOS8.2的时候就已经存在了，虽然当时<code>title</code>只是用在Apple Watch上的，但是设置好<code>body</code>的话在iOS上还是可以显示的，所以针对iOS10添加标题时是可以保证向前兼容的。</p>

<p>另外，如果要进行本地化对应，在设置这些内容文本时，本地可以使用<code>String.localizedUserNotificationString(forKey: "your_key", arguments: [])</code>的方式来从<code>Localizable.strings</code>文件中取出本地化字符串，而远程推送的话，也可以再payload的alert中使用<code>loc-key</code>或者<code>title-loc-key</code>来进行指定</p>

<ol>
<li><p>触发器是只对本地通知而言的，远程推送的通知的话默认会在收到后立即显示。现在<code>UserNotifications</code>框架中提供了三种触发器，分别是：在一定时间后触发<code>UNTimeIntervalNotificationTrigger</code>,在某月某日某时触发<code>UNCalendarNotificationTrigger</code>,以及在用户进入或者离开某个区域时触发<code>UNLocationNotificationTrigger</code></p></li>
<li><p>请求标识符可以用来区分不同的通知请求，在将一个通知请求提交后，通过特定的API我们能够使用这个标识符来取消或者更新这个通知。我们将在稍后提到具体方法</p></li>
<li><p>在新版本的通知框架中，Apple借用了一部分网络请求的概念，我们组织并发送一个通知请求，然后将这个请求提交给<code>UNUserNotificationCenter</code>进行处理。我们会在delegate中接收到这个通知请求对应的responst,另外我们也有机会再应用的extension中对request进行处理</p></li>
</ol>


<p>在提交请求后，我们锁屏或者将应用切到后台，并等待设定的时间后，就能看到我们的通知出现在通知中心或者屏幕横幅了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-1.png" alt="1" /></p>

<h2>取消和更新</h2>

<p>在创建通知请求时，我们已经制定了标识符。这个标识符可以用来管理通知，在iOS10之前，我们很难取消掉某一个特定的通知，也不能主动移除或者更新已经展示的通知。</p>

<p>iOS10中，UserNotifications框架提供了一系列管理通知的API,你可以做到:</p>

<ul>
<li>取消还未展示的通知</li>
<li>更新还未展示的通知</li>
<li>移除已经展示过的通知</li>
<li>更新已经展示过的通知</li>
</ul>


<p>其中关键就是创建请求时使用同样的标识符：</p>

<p>比如，从通知中心移除一个展示过得通知：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
</span><span class='line'>let identifier = "com.onevcat.usernotification.notificationWillBeRemovedAfterDisplayed"
</span><span class='line'>let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
</span><span class='line'>
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error != nil {
</span><span class='line'>        print("Notification request added: \(identifier)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>delay(4) {
</span><span class='line'>    print("Notification request removed: \(identifier)")
</span><span class='line'>    UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [identifier])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>类似的，我们可以使用<code>removePendingNotificationRequests</code>，来取消还未展示的通知请求。对于更新通知，不论是否已经展示，都和一开始添加请求时一样，再次将请求提交给<code>UNUserNotificationCenter</code>即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// let request: UNNotificationRequest = ...
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error != nil {
</span><span class='line'>        print("Notification request added: \(identifier)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>delay(2) {
</span><span class='line'>    let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
</span><span class='line'>
</span><span class='line'>    // Add new request with the same identifier to update a notification.
</span><span class='line'>    let newRequest = UNNotificationRequest(identifier: identifier, content:newContent, trigger: newTrigger)
</span><span class='line'>    UNUserNotificationCenter.current().add(newRequest) { error in
</span><span class='line'>        if error != nil {
</span><span class='line'>            print("Notification request updated: \(identifier)")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>远程推送可以进行通知的更新，在使用Provider API向APNS提交请求时，在HTTP2的header中<code>apns-collapse-id</code>key的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新</p>

<h2>处理通知</h2>

<h3>应用内展示通知</h3>

<p>现在系统可以在应用处于后台或者退出的时候向用户展示通知了。不过，当应用处于前台时，收到的通知是无法进行展示的。如果我们希望在应用内也能显示通知的话，需要额外的工作。</p>

<p><code>UNUserNotificationCenterDelegate</code>提供了两个方法，分别对应如何在应用内展示通知，和收到通知响应时要如何处理的工作。我们可以实现这个借口中的对应方法来在应用内展示通知：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NotificationHandler: NSObject, UNUserNotificationCenterDelegate {
</span><span class='line'>    func userNotificationCenter(_ center: UNUserNotificationCenter, 
</span><span class='line'>                       willPresent notification: UNNotification, 
</span><span class='line'>                       withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) 
</span><span class='line'>    {
</span><span class='line'>        completionHandler([.alert, .sound])
</span><span class='line'>
</span><span class='line'>        // 如果不想显示某个通知，可以直接用空 options 调用 completionHandler:
</span><span class='line'>        // completionHandler([])
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>实现后，将<code>NotificationHandler</code>的实例赋值给<code>UNUserNotificationCenter</code>的<code>delegate</code>属性就可以了。没有特殊理由的话，AppDelegate的<code>application(_:didFinishLaunchingWithOptions:)</code>就是一个不错的选择：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AppDelegate: UIResponder, UIApplicationDelegate {
</span><span class='line'>    let notificationHandler = NotificationHandler()
</span><span class='line'>    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
</span><span class='line'>        UNUserNotificationCenter.current().delegate = notificationHandler
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>对通知进行响应</h2>

<p><code>UNUserNotificationCenterDelegate</code>中还有一个方法,<code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>这个代理方法会在用户与你推送的通知进行交互时被调用，包括用户通过通知打开了你的应用，或者点击或者触发了某个Action。因为涉及到打开应用的行为，所以事先了这个方法的delegate必须在<code>applicationDidFinishLaunching:</code>返回前就完成设置，这也是我们之前推荐将<code>NotificationHandler</code>今早进行赋值的理由。</p>

<p>一个最简单的事先自然什么也不错，直接告诉系统你已经完成了所有工作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>    completionHandler()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在该方法里，我们将获取到这个推送请求对应的response,<code>UNNotificationResponse</code>是一个几乎包括了通知的所有信息的对象，从中我们可以再次获取到<code>userInfo</code>中的信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>    if let name = response.notification.request.content.userInfo["name"] as? String {
</span><span class='line'>        print("I know it's you! \(name)")
</span><span class='line'>    }
</span><span class='line'>    completionHandler()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更好的消息是，远程推送的payload内的内容也会出现在这个<code>userInfo</code>中，这样一来，不论是本地推送还是远程推送，处理的路径得到了统一。通过<code>userInfo</code>的内容来决定页面跳转或者是进行其他操作，都会有很大空间。</p>

<h2>Actionable通知发送和处理</h2>

<h3>注册Category</h3>

<p>iOS8和9中Apple引入了可以交互的通知，这是通过将一簇action放到了一个category中，将这个category进行注册，最后在发送通知时将通知的category设置为要使用的category来实现的。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-2.png" alt="1" /></p>

<p>注册一个category非常容易：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private func registerNotificationCategory() {
</span><span class='line'>    let saySomethingCategory: UNNotificationCategory = {
</span><span class='line'>        // 1
</span><span class='line'>        let inputAction = UNTextInputNotificationAction(
</span><span class='line'>            identifier: "action.input",
</span><span class='line'>            title: "Input",
</span><span class='line'>            options: [.foreground],
</span><span class='line'>            textInputButtonTitle: "Send",
</span><span class='line'>            textInputPlaceholder: "What do you want to say...")
</span><span class='line'>
</span><span class='line'>        // 2
</span><span class='line'>        let goodbyeAction = UNNotificationAction(
</span><span class='line'>            identifier: "action.goodbye",
</span><span class='line'>            title: "Goodbye",
</span><span class='line'>            options: [.foreground])
</span><span class='line'>
</span><span class='line'>        let cancelAction = UNNotificationAction(
</span><span class='line'>            identifier: "action.cancel",
</span><span class='line'>            title: "Cancel",
</span><span class='line'>            options: [.destructive])
</span><span class='line'>
</span><span class='line'>        // 3
</span><span class='line'>        return UNNotificationCategory(identifier:"saySomethingCategory", actions: [inputAction, goodbyeAction, cancelAction], intentIdentifiers: [], options: [.customDismissAction])
</span><span class='line'>    }()
</span><span class='line'>
</span><span class='line'>    UNUserNotificationCenter.current().setNotificationCategories([saySomethingCategory])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>UNTextInputNotificationAction</code>代表一个输入文本的action,你可以自定义框的按钮title和placeholder,你稍后会使用<code>identifier</code>来对action进行区分。</li>
<li>普通的<code>UNNotificationAction</code>对应标准的按钮</li>
<li>为category指定一个<code>identifier</code>,我们将在实际发送通知的时候用这个标识符进行设置，这样系统就知道对应哪个category了。</li>
</ol>


<p>当然，不要忘了在程序启动时调用这个方法进行注册</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
</span><span class='line'>    registerNotificationCategory()
</span><span class='line'>    UNUserNotificationCenter.current().delegate = notificationHandler
</span><span class='line'>    return true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>发送一个带有action的通知</h3>

<p>在完成category注册后，发送一个actionable通知就非常简单了，只需要在创建<code>UNNotificationContent</code>时把<code>categoryIdentifier</code>设置为需要的categoryId即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>content.categoryIdentifier = "saySomethingCategory"</span></code></pre></td></tr></table></div></figure>


<p>尝试展示这个通知，在下拉或者使用3D touch展开通知后，就可以看到对应的action了：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-3.png" alt="1" /></p>

<p>远程推送也可以使用category,只需要在payload中添加<code>category</code>字段，并指定预先定义的category id 就可以了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":"Please say something",
</span><span class='line'>    "category":"saySomething"
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>处理actionable通知</h3>

<p>和普通的通知并无二致力，actionable通知也会走到<code>didReceive</code>的delegate方法，我们通过request中包含的<code>categoryIdentifier</code>和response里的<code>actionIdentifier</code>就可以轻易判定是那个通知的那个操作被执行了。对于<code>UNTextInputNotificationAction</code>触发的response,直接将它转换为一个<code>UNTextInputNotificationResponse</code>，就可以拿到其中的用户输入了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>
</span><span class='line'>    if let category = UserNotificationCategoryType(rawValue: response.notification.request.content.categoryIdentifier) {
</span><span class='line'>        switch category {
</span><span class='line'>        case .saySomething:
</span><span class='line'>            handleSaySomthing(response: response)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    completionHandler()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private func handleSaySomthing(response: UNNotificationResponse) {
</span><span class='line'>    let text: String
</span><span class='line'>
</span><span class='line'>    if let actionType = SaySomethingCategoryAction(rawValue: response.actionIdentifier) {
</span><span class='line'>        switch actionType {
</span><span class='line'>        case .input: text = (response as! UNTextInputNotificationResponse).userText
</span><span class='line'>        case .goodbye: text = "Goodbye"
</span><span class='line'>        case .none: text = ""
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>        // Only tap or clear. (You will not receive this callback when user clear your notification unless you set .customDismissAction as the option of category)
</span><span class='line'>        text = ""
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if !text.isEmpty {
</span><span class='line'>        UIAlertController.showConfirmAlertFromTopViewController(message: "You just said \(text)")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码先判断通知响应是否属于<code>saySomething</code>，然后从用户输入或者是选择中提取字符串，并且弹出一个alert作为响应结果。当然，更多请苦情下我们会发送一个网络请求，或者是根据用户操作更新一些UI等。</p>

<h2>Notificiaton Extension</h2>

<p>iOS10中添加了很多extention,作为应用与系统整合的入口。与通知相关的extension有两个：Service Extension和Content Extension.前者可以让我们有机会在收到远程推送的通知后，展示之前对通知内容进行修改：后者可以用来自定义通知视图的样式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-extensions.png" alt="1" /></p>

<h3>截取并修改通知内容</h3>

<p><code>NotificationService</code>的模板已经为我们进行了基本的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NotificationService: UNNotificationServiceExtension {
</span><span class='line'>
</span><span class='line'>    var contentHandler: ((UNNotificationContent) -&gt; Void)?
</span><span class='line'>    var bestAttemptContent: UNMutableNotificationContent?
</span><span class='line'>
</span><span class='line'>    // 1
</span><span class='line'>    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {
</span><span class='line'>        self.contentHandler = contentHandler
</span><span class='line'>        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
</span><span class='line'>
</span><span class='line'>        if let bestAttemptContent = bestAttemptContent {
</span><span class='line'>            if request.identifier == "mutableContent" {
</span><span class='line'>                bestAttemptContent.body = "\(bestAttemptContent.body), Andrew"
</span><span class='line'>            }
</span><span class='line'>            contentHandler(bestAttemptContent)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 2
</span><span class='line'>    override func serviceExtensionTimeWillExpire() {
</span><span class='line'>        // Called just before the extension will be terminated by the system.
</span><span class='line'>        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
</span><span class='line'>        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
</span><span class='line'>            contentHandler(bestAttemptContent)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>didReceive:</code>方法中有一个等待发送的通知请求，我们通过修改这个请求中的content内容，然后在限制的时间内将修改后的内容调用通过<code>contentHandler</code>返还给系统，就可以显示这个修改过得通知了</li>
<li>在一定时间内没有调用<code>contentHandler</code>的话，系统会调用这个方法，来告诉你大限已到。你可以选择什么都不做，这样的话系统将当做什么都没发生，简单地显示原来的通知，可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用<code>contentHandler</code>来显示一个变更"中途"的通知</li>
</ol>


<p>Service Extentsion现在只对远程推送的通知起效，你可以在推送payload中增加一个<code>mutable-content</code>的值为1的项来启用内容修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"Greetings",
</span><span class='line'>      "body":"Long time no see"
</span><span class='line'>    },
</span><span class='line'>    "mutable-content":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个payload的推送得到的结果就是推送的内容+“Andrew”</p>

<p>使用在本机截取推送并替换内容的方式，可以完成端到端(end-to-end)的推送加密。你在服务器推送payload中加入加密过得文本，在客户端接到通知后使用预先定义或者获取过得秘钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>

<h2>在通知中展示图片/视频</h2>

<p>相比于旧版本的通知，iOS10中另一个亮眼功能室多媒体的推送，开发者现在可以在通知中嵌入图片或者视频，这极大丰富了推送内容的可读性和趣味性。</p>

<p>为本地通知添加多媒体内容十分简单，只需要通过本地磁盘上的文件URL创建一个<code>UNNotificationAttachment</code>对象，然后将这个对象放到数组中赋值给<code>content</code>的<code>attachments</code>属性就行了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let content = UNMutableNotificationContent()
</span><span class='line'>content.title = "Image Notification"
</span><span class='line'>content.body = "Show me an image!"
</span><span class='line'>
</span><span class='line'>if let imageURL = Bundle.main.url(forResource: "image", withExtension: "jpg"),
</span><span class='line'>   let attachment = try? UNNotificationAttachment(identifier: "imageAttachment", url: imageURL, options: nil)
</span><span class='line'>{
</span><span class='line'>    content.attachments = [attachment]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在显示时，横幅或者弹窗将附带设置的图片，使用3D Touch pop通知或者下拉通知显示详细内容时，图片也会被放大显示：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-4.png" alt="2" /></p>

<p>除了图片之外，通知还支持音频以及视频。你可以将MP3或者MP4这样的文件提供给系统来在通知中进行展示和播放，不过，这些文件都有尺寸的限制，比如图片不能超过5MB,视频不能超过50MB,不过对于一般的能在通知中展示的内容来说，这个尺寸应该是绰绰有余了。关于支持的文件格式和尺寸，可以在文档中进行确认。在创建<code>UNNotificationAttachment</code>时，如果遇到了不支持的格式，SDK也会抛出错误。</p>

<p>通过远程推送的方式，你也可以显示图片等多媒体内容，这要借助于上一节所提到的通过<code>Notification Service Extension</code>来修改涂松通知内容的技术。一般做法是，我们在推送payload中指定需要加载的图片资源地址，这个地址可以是应用bundle内已经存在的资源，也可以是网络的资源。不过因为在创建<code>UNNotificationAttachment</code>时偶们只能使用本地资源，所以如果多媒体还不在本地的话，我们需要先将其下载到本地，在完成<code>UNNotificationAttachment</code>创建后，我们就可以和本地通知一样，将它设置给<code>attachments</code>属性，然后调用<code>contentHandler</code>了。</p>

<p>简单的实例 payload如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"Image Notification",
</span><span class='line'>      "body":"Show me an image from web!"
</span><span class='line'>    },
</span><span class='line'>    "mutable-content":1
</span><span class='line'>  },
</span><span class='line'>  "image": "https://onevcat.com/assets/images/background-cover.jpg"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>mutable-content</code>表示偶们会在接收到通知时对内容进行更改，<code>image</code>指明了目标图片的地址。</p>

<p>在<code>NotificationService</code>里，加入如下代码来下载图片，并将其保存到磁盘缓存中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {
</span><span class='line'>    let task = URLSession.shared.dataTask(with: url, completionHandler: {
</span><span class='line'>        data, res, error in
</span><span class='line'>
</span><span class='line'>        var localURL: URL? = nil
</span><span class='line'>
</span><span class='line'>        if let data = data {
</span><span class='line'>            let ext = (url.absoluteString as NSString).pathExtension
</span><span class='line'>            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)
</span><span class='line'>            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)
</span><span class='line'>
</span><span class='line'>            if let _ = try? data.write(to: url) {
</span><span class='line'>                localURL = url
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        handler(localURL)
</span><span class='line'>    })
</span><span class='line'>
</span><span class='line'>    task.resume()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后再<code>didReceive:</code>中，接收到这类通知时提取图片地址，下载，并生成attachment,进行通知展示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let imageURLString = bestAttemptContent.userInfo["image"] as? String,
</span><span class='line'>   let URL = URL(string: imageURLString)
</span><span class='line'>{
</span><span class='line'>    downloadAndSave(url: URL) { localURL in
</span><span class='line'>        if let localURL = localURL {
</span><span class='line'>            do {
</span><span class='line'>                let attachment = try UNNotificationAttachment(identifier: "image_downloaded", url: localURL, options: nil)
</span><span class='line'>                bestAttemptContent.attachments = [attachment]
</span><span class='line'>            } catch {
</span><span class='line'>                print(error)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        contentHandler(bestAttemptContent)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于在通知中展示图案品或者视频，有几点想补充说明：</p>

<ol>
<li><code>UNNotificationContent</code>的<code>attachments</code>虽然是一个数组，但是系统只会展示第一个attachmen对象的内容。不过你依然可以发送多个<code>attachments</code>,然后再要展示的时候再重新安排他们的顺序，以显示最符合情景的图片或者视频。另外，你也可能会在自定义通知展示UI时用到多个<code>attachment</code>,我们接下来一节中会看到一个相关的例子。</li>
<li>在当前iOS10中，<code>serviceExtensionTimeWillExpire</code>被条用之前，你有30秒时间来处理和更改通知内容，对于一般的图片来说，这个时间是足够的，但是如果你推送的体积较大的视频内容，用户又恰巧在糟糕的网络环境的话，很有可能无法及时下载完成。</li>
<li>如果你想在远程推送来的通知中显示应用bundle内的资源的话，要注意extension的bundle和app main bundle并不是一回事，你可以选择将图片资源放到extension bundle中，也可以选择放在main bundle里，总之，你需要保证能够获取到正确的，并且你具有读取权限的url</li>
<li>系统在创建<code>attachement</code>时会根据提供的url后缀确定文件类型，如果没有后缀，或者后缀无法不正确的话，你可以在创建时通过<code>UNNotificationAttachmentOptionsTypeHintKey</code>来<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachmentoptionstypehintkey">指定资源类型</a></li>
<li>如果使用的图片和视频文件不在你的bundle内部，它们将被移动到系统的负责通知的文件夹下，然后当同志被移除后删除。如果媒体文件在bundle内部，它们将被负责到通知文件夹下。每个应用能使用的媒体文件大小总和是有限制，超过限制后创建<code>attachment</code>时将抛出异常。可能的所有错误可以再<code>UNError</code>中找到</li>
<li>你可以访问一个已经创建的<code>attachment</code>的内容，但是要注意权限问题，可以使用<code>startAccessingSecurityScopedResource</code>来暂时获取以创建的<code>attachment</code>的访问权限。比如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let content = notification.request.content
</span><span class='line'>if let attachment = content.attachments.first {  
</span><span class='line'>    if attachment.url.startAccessingSecurityScopedResource() {  
</span><span class='line'>        eventImage.image = UIImage(contentsOfFile: attachment.url.path!)  
</span><span class='line'>        attachment.url.stopAccessingSecurityScopedResource()  
</span><span class='line'>    }  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h2>自定义通知视图样式</h2>

<p>ioS10 SDK 新加的另一个<code>Content Extension</code>可以用来自定义通知的详细页面的视图，新建一个<code>Notification Content Extension</code>,Xcode为我们准备的模板中包含了一个实现了<code>UNNotificationContentExtension</code>的<code>UIViewController</code>子类。这个extension中有个一必须实现的方法<code>didReceive(_:)</code>,在系统需要显示自定义样式的通知详情视图时，这个方法将被调用，你需要在其中配置你的UI.而UI本身可以通过这个extension中的<code>MainInterface.storyboard</code>来进行定义。自定义UI的通知是和通知category绑定的，我们需要在<code>extension</code>的info.plist里指定这个通知样式所对应的category标识符：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-content-info.png" alt="1" /></p>

<p>系统在接收到通知后会先查找有没有能够处理这类通知的content extension,如果存在，那么就交给extensionl来进行处理，另外，在构建UI时，我们可以通过Info.plist控制通知详细视图的尺寸，以及是否显示原始的通知。关于Content Extension中的info.plist的key,可以在<a href="https://developer.apple.com/reference/usernotificationsui/unnotificationcontentextension">这个文档</a>中找到详细信息。</p>

<p>虽然我们可以使用包括按钮在内的各种UI，但是系统不允许我们队这些UI进行交互，点击通知视图UI本身会将我们导航到应用中，不过我们可以通过action的方式来对自定义UI进行更新。<code>UNNotificationContentExtension</code>为我们提供了一个可选方法<code>didReceive(_:completionHandler:)</code>，它会在用户选择了某个action时被调用，你有机会在这里更新通知的UI，如果有UI更新，那么在方法的<code>completionHandler</code>中，开发者可以选择传递<code>. doNotDismiss</code>来保持通知继续呗显示。如果没有继续显示的必要，可以选择<code>. dismissAndForwardAction</code>或者<code>. dismiss</code>，前者将把通知的action继续传递给应用的<code>UNUserNotificationCenterDelegate</code>中的<code>userNotificationCenter(:didReceive:withCompletionHandler)</code>，而后者将直接解散这个通知</p>

<p>如果你的自定义UI包含视频等，你还可以实现<code>UNNotificationContentExtension</code>里的<code>media</code>开头的一系列属性，它将为你提供一些视频播放的控件和相关方法。</p>

<h2>总结</h2>

<p>iOS10 SDk中对通知这块进行了IOS系统发布以来最大的一次重构，很多"老朋友"都被标记为了 deprecated:</p>

<h2>iOS10中被标记弃用的API</h2>

<ul>
<li>UILocalNotification</li>
<li>UIMutableUserNotificationAction</li>
<li>UIMutableUserNotificationCategory</li>
<li>UIUserNotificationAction</li>
<li>UIUserNotificationCategory</li>
<li>UIUserNotificationSettings</li>
<li>handleActionWithIdentifier:forLocalNotification:</li>
<li>handleActionWithIdentifier:forRemoteNotification:</li>
<li>didReceiveLocalNotification:withCompletion:</li>
<li>didReceiveRemoteNotification:withCompletion:</li>
</ul>


<p>等一系列在<code>UIKIT</code>中的发送和处理通知的类型及方法</p>

<p>相比较于iOS早期时代的API,新的APi展现了高度的模块化和统一特性，易用性也非常好，是一套更加先进的API,如果有可能，特别是如果你的应用是重度依赖通知特性的话，直接从iOS10开始可以让你充分使用在新同志体系的各种特性。</p>

<p>虽然原来的API都被标为弃用了，但是如果需要支持iOS10之前系统的话，你还是需要使用原来的API,我们可以使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if #available(iOS 10.0, *) {
</span><span class='line'>    // Use UserNotification
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>的方式来对iOS10进行新通知的适配，并让iOS10的用户享受到新通知带来的便利特性，然后在将来版本升级到只支持iOS10以上时再移除掉所有被启用的代码。对于优化和梳理通知相关代码来说，新API对代码设计和祖上上带来的好处足以弥补适配上的麻烦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配iOS10]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10/"/>
    <updated>2016-10-10T11:03:06+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10</id>
    <content type="html"><![CDATA[<h2>UICOllecitonViewCell的优化</h2>

<p>在ios10之前，UIcollectionView上面如果有大量的Cell,当用户活动很快的时候，整个UIcollectionView有很卡顿，为什么会造成这样的问题，这里涉及到iOS系统的重用机制，当cell准备加载进到屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了，也就是整整一行cell都已经加载完毕，这就是造成卡顿的主要原因，专业术语叫掉帧</p>

<!--more-->


<p>iOS10之前的UIcollectionViewCell的生命周期是这样的:</p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这个方法里面，可以重置cell的状态，加载新的数据</li>
<li>继续欢动，就会调用cellForItemAtIndexPath方法，在这个方法里面给cell赋值模型，然后返回给系统</li>
<li>当cell马上进去屏幕的时候，就会调用willDispalyCell方法，在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作</li>
<li>执行完willDisplayCell方法后，cell就进去屏幕了，当cell完全离开屏幕之后，会调用didEndDisplayingCell方法</li>
</ol>


<p><em>ios 10 UIcollectionViewCell的生命周期是这样的</em></p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这里当cell还没有进去屏幕的时候，就已经提前调用这个方法了，对比之前的区别就是cell的上边缘拿上进去屏幕的时候就会调用该方法，而ios10提前到cell还在屏幕外面的时候就调用</li>
<li>在cellForItemAtIndexPath中创建cell,填充数据，刷新状态等操作，相比之前也提前了</li>
<li>用户继续滑动的话，当cell马上就需要显示的时候我们再调用willDisplayCell方法，原则就是：何时需要显示，何时再去调用willDisplayCell方法</li>
<li>当cell完全离开屏幕以后，会调用didEndDispalyingCell方法，跟之前一样，cell会进入重用队列</li>
</ol>


<p>在ios10之前，cell只能从重用队列里面取出，再走一遍生命周期，并调用cellForItemAtIndexPath创建或者生成一个cell.</p>

<p>在ios10中，系统cell会保存一段时间，也就是说当用户把cell滑出屏幕以后，如果又滑动回来，cell不用再走一遍生命周期了，只需要调用willDisplayCell方法就可以重现出现在屏幕中了。</p>

<h2>ios10新增加的Pre-Fetching预加载</h2>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时间，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时候，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray *)indexPaths NS_AVAILABLE_IOS(10_0);
</span><span class='line'>
</span><span class='line'>- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray *)indexPaths  NS_AVAILABLE_IOS(10_0);</span></code></pre></td></tr></table></div></figure>


<p>在CollectionView prefetchItemAt indexPaths这个方法是异步预加载数据的，当中的indexPaths数组是有序的，就是Item接收数据的顺序：
ColletionView cancelPrefetchingForItemsAt indexPaths这个方法是可选的，可以用来处理在滑动中取消或者降低提前加载数据的优先级。
这个协议并不能代替之前读取数据的方法，仅仅是辅助加载数据</p>

<h2>UIRefreshControl的使用</h2>

<p>在iOS10中，UIRefreshControl 可以直接在UIcollectionView和UITableView中使用，并且脱离了UITableViewController，现在RefreshControl是UIScrollView的一个属性。</p>

<p>使用方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIRefreshControl *refreshControl = [[UIRefreshControl alloc] init];
</span><span class='line'>  [refreshControl addTarget:self action:@selector(loadData) forControlEvents:UIControlEventValueChanged];
</span><span class='line'>    collectionView.refreshControl = refreshControl;</span></code></pre></td></tr></table></div></figure>


<h2>关于ATS的问题</h2>

<p>WWDC2015提出的ATS(App Transport Security)是Apple在推进网络通讯安全的一个重要的方式，在iOS9中，默认情况下非HTTPS的网络访问是被禁止的。当然，因为这样的推进影响面非常广，作为缓冲，我们可以在info.plist中添加<code>NSAppTransportSecurity</code>字典并且将<code>NSAllowsArbitraryLoads</code>设置为<code>YES</code>来禁用ATS.相信大家已经对这个非常熟悉了。</p>

<p>不过在WWDC2016中，Apple表示将继续在ios10和macOS 10.12里收紧对普通http的访问限制。从2017年一月一日起，所有的提交的app默认是不允许使用<code>NSAllowsArbitraryLoads</code>来绕过ATS限制的，也就是说，我们最好保证app的所有的网络请求都是HTTPS加密的，否则可能会在应用审核时遇到麻烦。</p>

<ol>
<li>默认情况下你的app可以访问加密足够强（TLS v1.2以上，AES-128和SHA-2）的HTTPS内容，这对所有的网络请求都有效，包括<code>NSURLSession</code>,<code>UIWebview</code>以及<code>WkWebView</code>等</li>
<li>你依然可以添加<code>NSAllowsArbitraryLoads</code>为<code>YES</code>来禁用ATS,不过如果你这么做的话，需要在提交app时进行说明，为什么需要访问非HTTPS的内容，一般来说，可能类似浏览器类的app比较容易能通过</li>
<li>相比于使用<code>NSAllowsArbitraryLoads</code>将全部HTTP内容放开，选择使用<code>NSExceptionDomains</code>来针对特定的域名开放HTTP应该要相对容易过审核。“需要访问的域名是第三方服务器,他们没有进行HTTPS对应”，会是审核时的一个可选理由，但是这应该只需要针对特定域名，而非全面开放，如果访问的是自己的服务器的话，可能这个理由会无法通过</li>
<li>对于网页浏览和视频播放的行为，iOS10中新加入了<code>NSAllowsArbitraryLoadsInWebContent</code>键，通过将它设置为<code>YES</code>，可以让你的app中的<code>WKWebView</code>和使用<code>AVFoundation</code>播放的在线视频不受ATS的限制。这也应该是绝大多数使用了相关特性的app的选择。但是坏消息是这个键在ios9中并不会起到作用</li>
</ol>


<p>总结：对于API请求，基本上必须使用HTTPS的，特别是如果你们自己可以管理服务器的话，可能需要后端的同学尽快升级到HTTPS.如果你的app只支持iOS10,并且有用户可以自由输入网址进行浏览的功能，或者是在线视频音频播放功能的话，简单地加入<code>NSAllowsArbitraryLoadsInWebContent</code>并且将组件换成<code>WKWebKit</code>或者<code>AVFoundation</code>就可以了。如果你还需要支持ios9,并且需要访问网页和视频的话，可能只能开启<code>NSAllowsArbitraryLoads</code>然后提交的时候进行说明，并且看Apple审核员的脸色决定让不让通过了。除了<code>WKWebKit</code>以外，另外一个访问网页的选择是使用<code>SFSafariViewController</code>。因为其实<code>SFSafariViewController</code>就是一个独立于App的Safari进程，所以它完全不受ATS限制</p>

<p>另外，当<code>NSAllowsArbitraryLoads</code>和<code>NSAllowsArbitraryLoadsInWebContent</code>同时存在时，根据系统不同，表现的行为也会不一样，简单说，ios9只看<code>NSAllowsArbitraryLoads</code>,而ios10会先看<code>NSAllowsArbitraryLoadsInWebContent</code>.在ios10中，要是<code>NSAllowsArbitraryLoadsInWebContent</code>存在的话，就忽略掉<code>NSAllowsArbitraryLoads</code>,如果它不存在，则遵循<code>NSAllowsArbitraryLoads</code>的设定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IOS中的内存分配]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei/"/>
    <updated>2016-10-09T17:16:16+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/09/ioszhong-de-nei-cun-fen-pei</id>
    <content type="html"><![CDATA[<p>内存分配可以分为5个区</p>

<h2>栈区（stack）</h2>

<p>这个一般由编译器操作，或者说是系统管理，会存一些局部变量，这些系统都会帮我们自动实现，无需我们干预，所以大量的局部变量，深递归，函数循环调用都可以耗尽栈内存而程序崩溃</p>

<h2>堆区（heap）</h2>

<p>一般由程序员管理，比如alloc申请内存，free释放内存，我们创建的对象也都放在这里</p>

<h2>全局区(静态区 static)</h2>

<p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。</p>

<h2>常量区</h2>

<p>常量字符串就是放在这里的，还有const常量</p>

<h2>代码区</h2>

<p>存放代码，app程序会拷贝到这里，程序不是在</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1475976705224479.png" alt="1" /></p>

<p>图中各个区并不连续</p>

<p>当一个app启动后，代码区，常量区，全局区地址已经固定，因此指向这些区的指针不会为空而产生崩溃性的错误，而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入和弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[升级Xcode8后注意的问题]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/09/sheng-ji-xcode8hou-zhu-yi-de-wen-ti/"/>
    <updated>2016-10-09T16:37:48+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/09/sheng-ji-xcode8hou-zhu-yi-de-wen-ti</id>
    <content type="html"><![CDATA[<p>现在已经可以从AppStore升级到Xcode8的正式版了，但是升级之后会有一些莫名其妙的问题，再次总结如下：</p>

<h2>杂乱无章的Bug日志</h2>

<!--more-->


<p>更新xcode8后，新建立工程，都会打印一堆莫名其妙看不懂的log,比如：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161009-0.png" alt="1" /></p>

<p>屏蔽的方法如下:</p>

<p>xcode8里边的 <code>Edit Scheme-&gt;Run-&gt;Arguments,</code>在Environment Variables里边添加 <code>OS_ACTIVITY_MODE ＝ Disable</code></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/707724-e81adf182229475f.png" alt="1" /></p>

<h2>权限及相关设置</h2>

<p>我们需要打开info.plist文件添加相应权限的说明，否则程序在iOS10上会出现崩溃，具体如下图</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/707724-d118ca12029c78ab.png" alt="1" /></p>

<ul>
<li>麦克风权限 Privacy - Microphone Usage Description 是否允许此App使用你的麦克风？</li>
<li>相机权限： Privacy - Camera Usage Description 是否允许此App使用你的相机？</li>
<li>相册权限： Privacy - Photo Library Usage Description 是否允许此App访问你的媒体资料库？</li>
<li>通讯录权限： Privacy - Contacts Usage Description 是否允许此App访问你的通讯录？</li>
<li>蓝牙权限：Privacy - Bluetooth Peripheral Usage Description 是否许允此App使用蓝牙？</li>
<li>语音转文字权限：Privacy - Speech Recognition Usage Description 是否允许此App使用语音识别？</li>
<li>日历权限：Privacy - Calendars Usage Description 是否允许此App使用日历？</li>
<li>定位权限：Privacy - Location When In Use Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据</li>
<li>定位权限: Privacy - Location Always Usage Description 我们需要通过您的地理位置信息获取您周边的相关数据</li>
</ul>


<h2>字体变大，原有的frame需要适配</h2>

<p>程序内原有的2个字体的长度是24，现在2个子需要27宽度来显示</p>

<h2>推送</h2>

<p>如下图部分，不要忘记打开，所有的推送平台，不管是极光推送还是其它推送平台，要想收到推送，这个必须打开
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161009-1.png" alt="1" /></p>

<p>之后就可以收到推送了，iOS10推送的API也进行了更新，并且支持了语音，图片和自定义等功能</p>

<p>iOS10收到通知不再是在<code>[application: didReceiveRemoteNotification:]</code>方法去处理，iOS10推出新的代理方法，接受和处理各类通知(本地或者远程)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler { //应用在前台收到通知 NSLog(@"========%@", notification);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'> - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler { //点击通知进入应用 NSLog(@"response:%@", response);
</span><span class='line'>   }
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS推送]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/21/iostui-song/"/>
    <updated>2016-09-21T16:25:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/21/iostui-song</id>
    <content type="html"><![CDATA[<p>推送服务可以说是所有App的标配，不论是那种类型的App,推送都从很大程度上决定了App的打开率，使用率，存活率。因此熟知并掌握推送原理及方法,对每一个开发者来说都是必备技能，对每一个依赖App的公司都至关重要</p>

<p>从ios10新增的<code>UserNotifications Framework</code>可以发现，Apple整合了原有散乱的API,并且增加了很多强大的功能。以Apple官方的角度来看，也必然是相当重视推送服务对App的影响，以及对Apple生态圈长远发展的影响。</p>

<!--more-->


<h2>准备</h2>

<h3>Tip 1：推送通知（Push Notification）必须购买Apple开发者账号，并使用特定的推送证书</h3>

<ul>
<li>使用免费账号不能推送</li>
<li>如果我们使用的是第三方推送服务，比如 &lt;极光推送>,也必须购买开发者账号，因为所有的第三方都会将推送请求发至 <code>APNS</code>(Apple push Notification service，苹果推送通知服务)，所有的推送都是由Apns发送的</li>
<li>如果注册及正确的配置证书，参考这里<a href="http://docs.jiguang.cn/client/ios_tutorials/#ios_1">ios证书设置指南</a></li>
</ul>


<h2>原理</h2>

<h3>Tip2:推送通知本身是iOS系统的行为，所以在App没有运行的时候：</h3>

<ul>
<li>仍然能够推送及接收(通知中心通知，顶部横幅，刷新App右上角小圆点等都会由系统控制和展示)</li>
<li>收到推送时，是无法再App的代码中获取到通知内容的。因为沙盒机制，此时App的任何代码都不可能被执行</li>
</ul>


<h3>Tip3:手机向APNS注册推送服务</h3>

<ol>
<li>在代码中注册推送服务:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> #ifdef __IPHONE_8_0
</span><span class='line'> if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {
</span><span class='line'>     UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge| UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];
</span><span class='line'>     [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
</span><span class='line'> } else {
</span><span class='line'>     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
</span><span class='line'>     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
</span><span class='line'>}
</span><span class='line'> #else
</span><span class='line'>     UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
</span><span class='line'>     [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
</span><span class='line'> #endif</span></code></pre></td></tr></table></div></figure>


<ol>
<li>在第一次触发这段代码的时候，会有一个系统弹窗，询问你是否允许该App要给你推送信息。当你选择允许时，系统会打包App+手机唯一标识+证书信息 发送至Apns服务器注册推送服务，APNs系统会对该手机安装的该App是否有推送权限进行验证，所以必须要加入了Apple Device的手机，使用对应App的推送证书才能够成功注册。</li>
<li>如果注册成功，则可以在<code>AppDelegate.swift</code>的如下方法中获取到<code>deviceToken</code>,它是对该手机+该App组合的一个唯一标识，当使用远程推送时，只需将推送消息发给指定的<code>deviceToken</code>即可使推送消息传达给指定手机的指定App上。因此如果你使用第三方，就需要在这里将<code>deviceToken</code>传给第三方。（在ios9为了更好的保护用户隐私，会出现多次重复删除/安装App导致<code>deviceToken</code>不断变化的情况。有时会出现一条推送手机会受到2次的问题，属于iOS9系统问题）</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> -(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {  
</span><span class='line'>     [JPUSHService registerDeviceToken:deviceToken];//将 deviceToken 传给极光推送
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>如果以上步骤都成功，此时你能够获取到第三方提供的设备注册的id，能够获取到该id值，可以作为判断设备是否能够成功推送的标准，因此当你获取到该值时：</p></li>
<li><p>推送证书配置正确（你拥有了推送权限）</p></li>
<li>设备成功在Apns注册并返回了<code>deviceToken</code>（Apns能识别你的设备了）</li>
<li><p>返回的<code>deviceTOken</code>传给第三方，成功在第三方生成了唯一标识注册id（第三方能将你的设备信息传给APNS了）</p></li>
<li><p>综上，注册及接受推送必须使用真机，必须连网</p></li>
</ol>


<h3>Tip4:推送通知从服务端->App代码的过程</h3>

<ol>
<li>使用你们公司或第三方的服务端向APNs发送推送请求（请参考苹果APNS相关资料，或者使用第三方提供的Rest Api）</li>
<li>APNS接受并验证推送请求</li>
<li>APNS找到设备下发推送</li>
<li><p>手机收到推送通知，系统根据App状态进行处理：</p></li>
<li><p>前台收到：</p>

<ul>
<li>系统会将通知内容传到 <code>didReceiveRemoteNotification</code></li>
</ul>
</li>
<li><p>后台收到:</p>

<ul>
<li>如果开启了<code>Remote Notification</code>,系统将推送传到<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>,否则此时代码中收不到推送</li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
<li><p>退出收到:</p>

<ul>
<li>如果点击推送横幅/通知中心而启动App,系统将通知传到<code>didFinishLaunchingWithOptions</code></li>
<li>展示横幅，通知中心，声音，角标</li>
</ul>
</li>
</ol>


<h2>推送通知内容篇</h2>

<h3>Tip5:推送通知分为本地/远程 2种类型:</h3>

<ul>
<li>本地通知，可指定推送时间，在该时间准时弹出推送通知。</li>
<li><p>远程推送通知，分为普通推送/后台推送/静默推送3种类型。存在延迟问题（由于Tip1的第2点，APNS的不稳定及高峰时段的巨量请求所致）</p>

<ul>
<li><p>普通推送</p>

<ul>
<li>就是我们在手机上平时见到的推送通知</li>
<li>包括声音，横幅，角标，自定义字段</li>
<li><p>App:</p>

<ul>
<li>处于前台，不会显示横幅，可通过 <code>didReceiveRemoteNotification</code>（ios7 before）,<code>didReceiveRemoteNotification:fetchCompletionHandler:</code>(ios7 after)获取通知内容</li>
<li>处于后台，会展示横幅，无法获取通知内容</li>
<li>处于退出，会展示横幅，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击通知横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>
</li>
</ul>
</li>
<li>通知内容类似如下:</li>
</ul>


<pre><code class="``">  {
"_j_msgid" = 200806057;  // 第三方附带的 id，用于统计点击
aps =     {
  alert = "显示内容";
  badge = 1;  // App 角标，可推送 n、+n、-n 来实现角标的固定、增加、减少
  sound = default;  // 推送声音，默认系统三全音，如需使用自己的声音，需要将声音文件拖拽&amp;拷贝至 Xcode 工程目录任意位置，并在推送时指定其文件名
};
key1 = value1;  // 自定义字段，可设置多组，用于处理内部逻辑
key2 = value2;
}
</code></pre></li>
<li><p>后台推送</p>

<ul>
<li>各种显示效果跟普通推送完全一样</li>
<li>必须携带<code>content-available</code> = 1</li>
<li>必须携带 alter ,badge ,sound 至少一个字段</li>
<li>仅 ios7以后支持</li>
<li>必须在Xcode工程中 <code>TARGETS – Capabilities – Background Modes – Remote notifications</code>开启该功能，具体可参照 <a href="http://docs.jiguang.cn/client/ios_tutorials/#ios-7-background-remote-notification"> iOS 7 Background Remote Notification</a></li>
</ul>
</li>
</ul>


<h3>App</h3>

<ul>
<li>处于前台，可通过<code>didReceiveRemoteNotification</code>(iOS7 before) ，didReceiveRemoteNotification:fetchCompletionHandler: （iOS 7 after）获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中于普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下没执行一些代码，大概提供几分钟的时间，可以用来偷偷地刷新UI，切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
<li>点击图标启动，无法获取通知内容</li>
<li>点击推送横幅启动，在<code>didFinishLaunchingWithOptions</code>获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "_j_msgid" = 2090737306;
</span><span class='line'>  aps =     {
</span><span class='line'>    alert = "显示内容";
</span><span class='line'>    badge = 1;
</span><span class='line'>    "content-available" = 1;  // 必带字段
</span><span class='line'>    sound = default;
</span><span class='line'>  };
</span><span class='line'>  key1 = value1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>静默推送</h3>

<ul>
<li>没有任何展示效果</li>
<li>必须携带<code>"content-available" = 1</code>，因此静默必然是后台的</li>
<li>必须不携带 alert,badge,sound</li>
<li>可携带自定义字段</li>
</ul>


<p><em>App:</em></p>

<ul>
<li>处于前台，可以通过<code>didReceiveRemoteNotification</code>(iOS7 before),<code>didReceiveRemoteNotification:fetchCompletionHandler:</code> (ios 7 after)获取通知内容</li>
<li>处于后台，可通过<code>didReceiveRemoteNotification:fetchCompletion Handler:</code>获取通知内容，获取情况中与普通推送的唯一不同点，此时iOS系统允许开发者在App处于后台的情况下，执行一些代码，大概提供几分钟的时间，可以用来偷偷的刷新UI,切换页面，下载更新包等等操作</li>
<li>处于退出，无法获取通知内容</li>
</ul>


<p><em>通知内容类似如下:</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "_j_msgid" = 3938587719;
</span><span class='line'>    aps =     {
</span><span class='line'>        alert = "";
</span><span class='line'>        "content-available" = 1;  // 必带字段
</span><span class='line'>    };
</span><span class='line'>    key1 = value1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>推送目标篇</h2>

<p>别名，标签，RegistrationID均是第三方提供的用于更方便地指定推送目标的功能</p>

<h3>Tip6:推送根据目标的不同可以分为:</h3>

<ul>
<li>广播

<ul>
<li>无差别发送给所有用户</li>
</ul>
</li>
<li><p>别名alias推送</p>

<ul>
<li>第三方提供的功能</li>
<li>一个手机的一款App只能设置一个 alias(可修改)</li>
<li>建议对每一个用户都取不同的别名，以此来确定唯一的用户</li>
<li>推送时可指定多个alias来发送同一内容</li>
<li>仅指定alias的用户能够收到推送</li>
</ul>
</li>
<li><p>标签tag推送</p>

<ul>
<li>第三方提供的功能</li>
<li>可以设置多个，可增加，清空</li>
<li>用于指定多样的属性，如 『1000』+『daily』+『discount』 可用于表示月消费超过 1k、喜欢购买日用品、偏好折扣商品的用户</li>
<li>如果要删除，需要在上次设置时，将设置的tags保存至<code>NSUserDefaults</code>，本次剔除不需要的tag后，再重新设置</li>
<li>推送时可指定多个tag来发同一个内容</li>
<li>手机如果设置了推送指定的多个 tag 中任一个tag，都能够收到推送消息。如指定 『1000』+『globe』+『original』 （千元级消费者、全球购、原价），那么设置了 『100』+『globe』+『discount』（百元级消费者、全球购、折扣价）的用户可以收到该推送消息。</li>
</ul>
</li>
<li><p>Registration ID 推送</p>

<ul>
<li>第三方提供的功能</li>
<li>在Tip 3的第三步时将<code>deviceToken</code>提供给第三方之后，其服务器会自动生成的指向该手机的唯一id</li>
<li>可在推送时指定多个id来下发消息</li>
<li>可用于对核心用户，旗舰用户的精准推送</li>
</ul>
</li>
</ul>


<h2>应用消息篇</h2>

<h3>Tip 7:应用内消息和推送通知的区别，消息:</h3>

<ul>
<li>不需要Apple推送证书</li>
<li>由第三方服务器下发，而不是APNS</li>
<li>相比通知，更快速，几乎没有延迟，可用于IM消息的即使传达</li>
<li>能够长时间保留离线消息，可获取所有历史消息内容</li>
<li>通过长连接技术下发消息，因此：

<ul>
<li>手机必须启动并与第三方服务器简历连接</li>
<li>如果手机启动立刻切换到后台，很可能连接没有建立</li>
<li>手机必须处于前台才能收到消息</li>
<li>手机从后台切回前台，会自动重新简历连接，并收到离线消息</li>
</ul>
</li>
<li>没有任何展示（横幅，通知中心，角标，声音），因此可以：

<ul>
<li>完全自定义字段实现UI效果</li>
<li>完全在静默的情况下处理App内部逻辑</li>
<li>使用一些App Store审核不会通过的功能，在审核时关闭功能，上架后通过接收消息，开启相关功能</li>
</ul>
</li>
</ul>


<h2>组合大招</h2>

<h3>Tip 8:tags的组合技巧</h3>

<ul>
<li>见 Tip5 - 标签tag 推送</li>
<li>可以再服务器端来统计分析用户行为，然后将指定的tags发送至手机，手机接收后再为用户打上对应的tags</li>
</ul>


<h3>Tip 9:通知 + 消息的组合技巧</h3>

<ul>
<li>首先来看通知和消息的特性对比</li>
</ul>


<table>
<thead>
<tr>
<th>XX </th>
<th>  通知  </th>
<th>             消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>送达时间 </td>
<td> 可能存在几秒延迟  </td>
<td> 几乎没延迟</td>
</tr>
<tr>
<td>获取时机  </td>
<td> 处于前台或后台 能获取内容</td>
<td>仅处于前台能获取内容</td>
</tr>
<tr>
<td>离线内容</td>
<td> 保留一段时间，过期会抛弃，无法查询历史内容</td>
<td>始终保留，可查询全部历史内容</td>
</tr>
<tr>
<td>系统展示</td>
<td>会展示（静默推送或App处于前台不展示）</td>
<td>不展示</td>
</tr>
</tbody>
</table>


<p><em>由于各自的特性都存在差异，因此二者结合使用使得App推送性能最大化的必然选择：</em></p>

<ul>
<li>情景一</li>
</ul>


<p>QQ/微信聊天，会同时下发一组通知+消息，如果用户没有启动QQ,虽有延迟但必须能够先收到通知，在收到通知的提醒之后，用户打开App,此时收到了离线消息，即使更新UI，与好友即使地发送/接收消息，（在收到通知后，断网，然后启动APP，你会发现此时手机里并不会显示刚刚通知的内容，因为它是依靠拉取消息来刷新页面的，而不是不够稳定的通知）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组合与继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng/"/>
    <updated>2016-09-10T08:45:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-yu-ji-cheng</id>
    <content type="html"><![CDATA[<h2>何时使用子类</h2>

<p>首先，我们讨论几种使用子类比较合适的场景。如果你要写一个自定义布局的UITableViewCell,那就创建一个子类。这同样适用于几乎每个视图。一旦你开始布局，把这块代码放入子类就更合理一些，不管代码得到了更好的封装，你也能得到一个可在工程之间重用的组件。</p>

<!--more-->


<p>假设你的代码是针对多平台多版本的，并且你需要针对每个平台每个版本写一些代码。这时候更合理的做法可能是创建一个<code>OBJDevice</code>类，让一些子类如 <code>OBJIPhoneDevice</code>和<code>OBJIPadDevice</code>,甚至更深层次的子类如<code>OBJIPhone5Device</code>来继承，并让这些子类重写特定的方法，例如，你的<code>OBJDevice</code>类可能包含了函数<code>applyRoundedCornersToView:withRadius</code>,它有一个默认的实现，但是也能被特定的子类重写。</p>

<p>另一个子类可能很有用的场景是模型对象（model object）.绝大多数情况下，我的模型对象继承自一个实现了 <code>isEqual:</code>,<code>hash</code>,<code>copyWithzone:</code>,和<code>description</code>等方法的类。这些方法只被实现一次，并且迭代循环遍历所有属性，所以极不容易出错。（如果你也想找这样的一个基类，可以考虑使用<a href="https://github.com/mantle/mantle">Mantle</a>,它就是这么做的，并且做的更多）</p>

<h2>何时不适用子类</h2>

<p>在以往工作过得很多工程中，我见过很多继承层次很深的子类。当我也这么干的时候，总会感到内疚。除非继承的层次非常浅，否则你会很快发现它的局限性。</p>

<p>幸运的是，如果你发现自己正在使用深层次的继承，还有很多替代的方案可选。在下面的章节中，我们会逐个进行更详细的描述。如果你的子类只是使用相同的接口，协议会是非常好的替代方案。如果你知道某个对象需要大量的修改，你可能会使用代理来动态改变和配置它。当你想给已有的对象增加一些简单功能时，类别可能是个选择。当你有一堆重写了相同方法的子类时，你可以使用配置对象来代替。最后，当你想重用某些功能时，组合多个对象而不是扩展它们可能会更好。</p>

<h1>替代方案</h1>

<h2>协议(Protocols)</h2>

<p>很多时候，使用子类的原因是你想保证某个对象可以响应某些消息。假设在app中你有一个播放器对象，它可以播放视频。现在你想添加对YouTube的支持，使用相同的接口，但是具体实现不同。你可以像这样用子类来实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Player : NSObject
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class YouTubePlayer : Player
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>事实上可能这两个类并没有太多共用的代码，它们只不过具有相同的接口。如果这样的话，使用协议可能会是更好的昂奋。可以这样用协议来写你的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol VideoPlayer &lt;NSObject&gt;
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class Player : NSObject &lt;VideoPlayer&gt;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class YouTubePlayer : NSObject &lt;VideoPlayer&gt;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这样，<code>YouTubePlayer</code>类就不必知道<code>Player</code>类内部实现了</p>

<h2>替代方案:代理(delegate)</h2>

<p>再一次假设你有一个像上面例子中的<code>Player</code>类，现在，你想在开始播放的时候在某个地方执行一个自定的函数。这么做相对容易一些：创建一个自定义的子类，重写<code>play</code>方法，调用<code>[super play]</code>，然后开始做你自定义的工作。这么做是一种方法，另外一种方法是，改动你的<code>Player</code>对象，然后给它设置一个代理。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@class Player;
</span><span class='line'>
</span><span class='line'>@protocol PlayerDelegate
</span><span class='line'>
</span><span class='line'>- (void)playerDidStartPlaying:(Player *)player;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@class Player : NSObject
</span><span class='line'>
</span><span class='line'>@property (nonatomic,weak) id&lt;PlayerDelegate&gt; delegate;
</span><span class='line'>
</span><span class='line'>- (void)play;
</span><span class='line'>- (void)pause;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>现在，在播放器的<code>play</code>方法里，就可以给代理发<code>playerDidStartPlaying :</code>消息了。这个<code>Player</code>类的任何使用者都可以仅仅实现这个代理协议，而不用继承该类，<code>Player</code>类也能够保持通用性。这是个强大有效的技术，苹果在自己的框架里大量地使用它。你想想像<code>UITextField</code>这样的类，还有<code>NSLayoutManager</code>。有时候你还会想把几个不同的方法打包分组到几个单独的协议里，比如<code>UITableView</code>,它不仅有个一个代理(delegate),还有一个数据源(dataSource)</p>

<h2>替代方案：类别(Categories)</h2>

<p>有时候，你可能会想给你一个对象增加一点点额外的功能，比如你想给NSArray增加一个方法<code>arrayByRemovingFirstObject</code>.不用子类，你可以把这个函数放到一个类别里。像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface NSArray (OBJExtras)
</span><span class='line'>
</span><span class='line'>- (void)obj_arrayByRemovingFirstObject;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在用类别扩展一个不是你自己的类的时候，在方法前欠佳前缀是个比较好的习惯做法。如果不这么做，有可能别人也用类别对此类添加了相同名字的函数。那时候程序的行为可能跟你想要的并不一样，未预期的事情可能会发生。</p>

<p>使用类别还有一个另外一个风险，那就是，到最后你可能会使用一大堆的类别，连你自己都会失去对代码全局的认识。假如那样的话，创建自定义的类可能更简单一些。</p>

<h2>替代方案:配置对象(Configuration Objects)</h2>

<p>在我经常犯的错误中，其中一条就是：使用一个含有几个抽象方法的类并让很多子类来重写某个方法。假如，在一个幻灯片应用里，你有一个主题类<code>Theme</code>,它含有几个属性，比如<code>backgroundColor</code>和<code>Font</code>，还有一些在一张幻灯片上如何布局的逻辑函数</p>

<p>然后，对每种主题，你都创建一个<code>Theme</code>的子类，重写某个函数(例如 <code>setup</code>)并且配置其属性。直接使用父类对此做不了什么事。在这种情况下，你可以使用配置对象来让代码更简单些。你可以把共有的逻辑（比如 幻灯片布局）放在<code>Theme</code>类中，把属性的配置放到比较简单的对象中，这些对象中只包含有这些属性。</p>

<p>例如，类<code>ThemeConfiguration</code>具有<code>backgroundColor</code>和<code>font</code>属性，而类<code>Theme</code>在其初始化函数中获取一个配置类<code>ThemeConfiguration</code>的值</p>

<h2>替代方案:组合</h2>

<p>组合是代替子类化的最强大有效的方案。如果你想重用已有代码而不像共享同样的接口，组合就是你的首选武器，例如，假设你要设计一个缓存类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface OBJCache : NSObject
</span><span class='line'>
</span><span class='line'>- (void)cacheValue:(id)value forKey:(NSString *)key;
</span><span class='line'>- (void)removeCachedValueForKey:(NSString *)key;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>简单点的做法是直接继承<code>NSDictionary</code>，通过调用字典的函数来实现上面的两个方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface OBJCache : NSDictionary</span></code></pre></td></tr></table></div></figure>


<p>但是这么做有几个弊端，它本来是应该被详细实现的，但只是通过字典来实现，现在，在任何需要一个<code>NSDictionary</code>参数的时候，你可以直接提供一个<code>OBJCache</code>值。但如果你想把它转为其它完全不同的东西，你就可能需要重构很多代码了。</p>

<p>更好的方式是，将这个字典存在一个私有属性(或者实例变量)中，对外仅仅暴露这两个<code>cache</code>方法。现在，当你有了更深入想法的时候，你可以在灵活地修改其实现，而该类的使用者们不用进行重构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[组合继承]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/09/10/zu-he-ji-cheng/"/>
    <updated>2016-09-10T08:45:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/09/10/zu-he-ji-cheng</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[View-Layer协作]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo/"/>
    <updated>2016-07-19T13:44:10+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/view-layerxie-zuo</id>
    <content type="html"><![CDATA[<p>在ios中，所有的View都是由一个底层的layer来驱动的。View和它的layer之间有着紧密的联系，View其实直接从layer对象中获取了绝大多数它所需要的数据。在ios中也有一些单独的layer,比如<code>AVCaptureVideoPreviewLayer</code>和<code>CAShapeLayer</code>，它们不需要附加到view上就可以在屏幕上显示内容。两种情况下都是layer起决定作用。当然了，附加到view上的layer和单独的layer在行为上还是稍有不同的。</p>

<!--more-->


<p>基本上你改变一个单独的layer的任何属性的时候，都会触发一个从旧值过渡到新值的简单动画（就是所谓的动画<code>animatable</code>）。然而，如果你改变的是view中layer的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有layer,但是当layer附加在view上时，它的默认的隐式动画的layer行为就不起作用了。</p>

<blockquote><p><em>注意</em>
animatable 几乎所有的层的属性都是隐性可动画的。你可以在文档中看到它们的简介是以'animatable'结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，设置也囊括了像isHidden和doubleSides这样的布尔值。像paths这样的属性也是animatable的。但是它不支持隐式动画。</p></blockquote>

<p>在 Core Animation 编程指南的"How to Animate Layer-Backed Views"中，对为什么会这样做出了一个解释:</p>

<blockquote><p>UIView默认情况下进制了layer动画，但是在animation block中又重新启用了它们</p></blockquote>

<p>这正是我们所看到的额行为，当一个属性在动画block之外被改变时，没有动画，但是当属性在动画block内改变时，就带上了动画。对于这是如何发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了view和layer之间是如何协同工作和被精心设计的。</p>

<p>无论何时一个可动画的layer属性改变时，layer都会寻找并运行何时的'Action'来实行这个改变。在core Animation的专业术语中就把这样的动画统称为动作(Action,或者CAAction)</p>

<blockquote><p>CAAction:从技术上来说，这是一个接口，并可以用来做各种事情，但是实际上，某种程度上你可以只把它理解为用来处理动画</p></blockquote>

<p>layer将像文档中缩写的那样去寻找动作，整个过程分为5个步骤。第一步中的view和layer中交互的部分是最有意思的：</p>

<p>layer通过向它的代理发送 <code>actionForLayer:forKey:</code>消息来询问提供一个对应属性变化的action.delegate可以通过返回以下三者之一来进行响应:</p>

<ol>
<li>它可以返回一个动作对象，这种情况下layer将使用这个动作</li>
<li>它可以返回一个nil,这样layer就会到其他地方继续寻找</li>
<li>它可以返回一个NShull对象，告诉layer这里不需要执行一个动作，搜索也会就此停止</li>
</ol>


<p>而让这一切变得有趣的是，当layer在背后支持一个view的时候，view就是它的delegate;</p>

<blockquote><p>在ios中，如果layer与一个UIview对象关联时，这个属性必须被设置为持有这个layer的那个view</p></blockquote>

<p>理解这些之后，前一分钟解释起来还复杂无比的现象瞬间就易如反掌了；属性改变时layer会向View请求一个动作，而一般情况下view将返回一个NSNull,只有当属性改变发生在动画block中时，view才会返回实际的动作。哈，但是请别轻信我的这些话，你可以非常容易地验证到底是不是这样。只要对一个一般来说可以动画的layer属性向view询问动作就可以了，比如对于'position':</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLog(@"outside animation block: %@",
</span><span class='line'>      [myView actionForLayer:myView.layer forKey:@"position"]);
</span><span class='line'>
</span><span class='line'>[UIView animateWithDuration:0.3 animations:^{
</span><span class='line'>    NSLog(@"inside animation block: %@",
</span><span class='line'>          [myView actionForLayer:myView.layer forKey:@"position"]);
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>运行上面的代码，可以看到在block外view返回的是NSNull对象，而在block中时返回的是一个CABasicAnimation.很优雅，对吧?值得注意的是打印出的 NSNull 是带着一对尖括号的 (&ldquo;<null>&rdquo;)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号((null))：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>outside animation block: &lt;null&gt;
</span><span class='line'>inside animation block: &lt;CABasicAnimation: 0x8c2ff10&gt;</span></code></pre></td></tr></table></div></figure>


<p>对于view中的layer来说，对动作的搜索只会到第一步为止。对于单独的layer来说，剩余的4个步骤可以在 <a href="https://developer.apple.com/library/mac/documentation/graphicsimaging/reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instm/CALayer/actionForKey:">CALayer</a>actionForKey: 文档中找到。</p>

<h2>从UIKit中学习</h2>

<p>我很确定我们都会同意UIview动画是一组非常优秀的API,它简洁明确，实际上，它使用了Core Animation来执行动画，这给了我们一个绝佳的积水来深入研究UIKit是如何使用Core Animation的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴.</p>

<p>当属性在动画block中改变时，view将向layer返回一个基本的动画，然后动画通过通常的addAnimation:forKey:方法将添加到layer中，就像显示地添加动画那样。再一次，别直接相信我，让我们实践检验一下</p>

<p>归功于UIview的layerClass 类方法，View和layer之间的交互很容易被观测到。通过这个方法我们可以在为View创建layer时为其指定要使用的类。通过子类一个UIView,以及用这个方法返回一个自定义的layer类，我们就可以重写layer子类中的 <code>addAnimaiton:ForKey:</code>并输出一些东西来验证它是佛确实被调用。唯一要记住的是我们需要调用super方法，不然的话我们就把要观测的行为完全改变了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface DRInspectionLayer : CALayer
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRInspectionLayer
</span><span class='line'>- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key
</span><span class='line'>{
</span><span class='line'>    NSLog(@"adding animation: %@", [anim debugDescription]);
</span><span class='line'>    [super addAnimation:anim forKey:key];
</span><span class='line'>}
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>@interface DRInspectionView : UIView
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRInspectionView
</span><span class='line'>+ (Class)layerClass
</span><span class='line'>{
</span><span class='line'>    return [DRInspectionLayer class];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>通过输出动画的debug信息，我们不仅可以验证它确实如逾期一样被调用了，还可以看到动画是如何组织构建的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;CABasicAnimation:0x8c73680; 
</span><span class='line'>    delegate = &lt;UIViewAnimationState: 0x8e91fa0&gt;;
</span><span class='line'>    fillMode = both; 
</span><span class='line'>    timingFunction = easeInEaseOut; 
</span><span class='line'>    duration = 0.3; 
</span><span class='line'>    fromValue = NSPoint: {5, 5}; 
</span><span class='line'>    keyPath = position
</span><span class='line'>&gt;</span></code></pre></td></tr></table></div></figure>


<p>当动画被添加到layer时，属性的新值还没有被改变。在构建动画时，只有fromValue(也就是当前值)被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说的行为应该是:</p>

<blockquote><p>只有FromValue不是nil时，在fromvalue和属性当前显示层的值之间进行插值</p></blockquote>

<p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到layer上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *fadeIn = [CABasicAnimation animationWithKeyPath:@"opacity"];
</span><span class='line'>fadeIn.duration  = 0.75;
</span><span class='line'>fadeIn.fromValue = @0;
</span><span class='line'>
</span><span class='line'>myLayer.opacity = 1.0; // 更改 model 的值 ...
</span><span class='line'>// ... 然后添加动画对象
</span><span class='line'>[myLayer addAnimation:fadeIn forKey:@"fade in slowly"];</span></code></pre></td></tr></table></div></figure>


<p>这很简洁，你也不需要再动画被移除的时候做什么额外的操作，如果动画是在一段延迟后才开始的话，你可以使用backward填充模式(或者'both'填充模式)，就像UIKit所创建的动画那样</p>

<p>可能你看见上面输出中的动画的delegate了，想知道这个类是用来做什么的呢？我们可以来看看 <a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump出来的头文件</a>,它主要用来维护动画的一些状态(持续时间，延时，重复次数等等)，它还负责对一个栈做push和pop,这是为了在多个动画block嵌套时能够获取正确的动画状态。这些都是事先细节，除非你想要写一套自己的基于block的动画API,否则可能你不会用到它们</p>

<p>然后真正有意思的是这个delegate事先了 animationDidStart: 和 animationDidStop:finished: 并将信息传给了它自己的delegate</p>

<blockquote><p>这里不太容易理解，加以说明:从上面的头文件可以看出，作为CAAnimation的delegate的私有类UIViewAnimationState中还有个<code>_delegate</code>成员，并且<code>animationDidStart</code>和<code>animationDidStop:finished:</code>也是典型的delegate的实现方法.</p></blockquote>

<p>通过打印这个delegate的delegate,我们可以发现它也是一个私有类：<code>UIViewAnimationBlockDelegate</code>。同样进行<a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的delegate回调并且进行相应的block.如果我们使用自己的Core Animation代码，并且选阿泽block而不是delegate做回调的话，添加这个是很容易的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface DRAnimationBlockDelegate : NSObject
</span><span class='line'>
</span><span class='line'>@property (copy) void(^start)(void);
</span><span class='line'>@property (copy) void(^stop)(BOOL);
</span><span class='line'>
</span><span class='line'>+(instancetype)animationDelegateWithBeginning:(void(^)(void))beginning
</span><span class='line'>                                   completion:(void(^)(BOOL finished))completion;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation DRAnimationBlockDelegate
</span><span class='line'>
</span><span class='line'>+ (instancetype)animationDelegateWithBeginning:(void (^)(void))beginning
</span><span class='line'>                                    completion:(void (^)(BOOL))completion
</span><span class='line'>{
</span><span class='line'>    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];
</span><span class='line'>    result.start = beginning;
</span><span class='line'>    result.stop  = completion;
</span><span class='line'>    return result;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animationDidStart:(CAAnimation *)anim
</span><span class='line'>{
</span><span class='line'>    if (self.start) {
</span><span class='line'>        self.start();
</span><span class='line'>    }
</span><span class='line'>    self.start = nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
</span><span class='line'>{
</span><span class='line'>    if (self.stop) {
</span><span class='line'>        self.stop(flag);
</span><span class='line'>    }
</span><span class='line'>    self.stop = nil;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>虽然是我的个人喜好，但是我觉得像这样的基于block的回调风格可能会比实现一个delegate回调更适合你的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^{
</span><span class='line'>    NSLog(@"beginning to fade in");
</span><span class='line'>} completion:^(BOOL finished) {
</span><span class='line'>    NSLog(@"did fade %@", finished ? @"to the end" : @"but was cancelled");
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h2>自定义基于block的动画APIS</h2>

<p>一旦你知道了<code>actionForKey:</code>的原理之后，UIview就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于block的动画Apis。我所设计的动画将通过block中用一个很激进的时间曲线来做动画，以吸引用户对该View的注意，之后做一个缓慢的动画回到原始状态。你可以把它看做一种类似pop的行为。与一般使用<code>UIViewAnimationOptionAutoreverse</code>的动画block不同，因为动画设计和概念上的需要，我自己实现了将model值改变回原始值的过程。自定义的动画API的使用方法就像这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[UIView DR_popAnimationWithDuration:0.7
</span><span class='line'>                             animations:^{
</span><span class='line'>                                 myView.transform = CGAffineTransformMakeRotation(M_PI_2);
</span><span class='line'>                                }];</span></code></pre></td></tr></table></div></figure>


<p>当我们完成后，效果是这样样子的(对四个不同的View为位置，尺寸，颜色和旋转进行动画)</p>

<p><img src="http://7xsn4e.com1.z0.glb.clouddn.com/2014-05-01-view-layer-synergy-custom-block-animations.gif" alt="1" /></p>

<p>要开始实现它，我们首先要做的是当一个layer属性变化时获取delegate的回调，因为我们无法实现预测layer要改变什么，所以我选择在一个UIView的category中的swizzle<code>actionForLayer:forKey:</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation UIView (DR_CustomBlockAnimations)
</span><span class='line'>
</span><span class='line'>+ (void)load
</span><span class='line'>{        
</span><span class='line'>    SEL originalSelector = @selector(actionForLayer:forKey:);
</span><span class='line'>    SEL extendedSelector = @selector(DR_actionForLayer:forKey:);
</span><span class='line'>
</span><span class='line'>    Method originalMethod = class_getInstanceMethod(self, originalSelector);
</span><span class='line'>    Method extendedMethod = class_getInstanceMethod(self, extendedSelector);
</span><span class='line'>
</span><span class='line'>    NSAssert(originalMethod, @"original method should exist");
</span><span class='line'>    NSAssert(extendedMethod, @"exchanged method should exist");
</span><span class='line'>
</span><span class='line'>    if(class_addMethod(self, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) {
</span><span class='line'>        class_replaceMethod(self, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
</span><span class='line'>    } else {
</span><span class='line'>        method_exchangeImplementations(originalMethod, extendedMethod);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了保证我们不破坏其他依赖于<code>actionForLayer:forKey:</code>的回调代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子莱索一个简单的Bool其实就够了，但是如果我们之后要写更多内容的话，上下文的话要灵活得多了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void *DR_currentAnimationContext = NULL;
</span><span class='line'>static void *DR_popAnimationContext     = &DR_popAnimationContext;
</span><span class='line'>
</span><span class='line'>- (id&lt;CAAction&gt;)DR_actionForLayer:(CALayer *)layer forKey:(NSString *)event
</span><span class='line'>{
</span><span class='line'>    if (DR_currentAnimationContext == DR_popAnimationContext) {
</span><span class='line'>        // 这里写我们自定义的代码...
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 调用原始方法
</span><span class='line'>    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在我们的实现中，我们要确保在执行动画block之前设置动画的上下文，并且在执行后恢复上下文：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
</span><span class='line'>                          animations:(void (^)(void))animations
</span><span class='line'> {
</span><span class='line'>     DR_currentAnimationContext = DR_popAnimationContext;
</span><span class='line'>     // 执行动画 (它将触发交换后的 delegate 方法)
</span><span class='line'>     animations();
</span><span class='line'>     /* 一会儿再添加 */
</span><span class='line'>     DR_currentAnimationContext = NULL;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>如果我们想要做的不过是添加一个从旧值向新值过渡的动画的话，我们可以直接在delegate的回调中来做。然后因为我们想要更精确的控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓</p>

<p>有意思的是，ios添加的一个基于block的动画API也遇到了同样了问题，使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每一个关键帧，在属性变化时，view返回nil,但是却存储下需要的状态。这样就能在所有关键帧block执行后创建一个<code>CAKeyframeAnimationz</code>对象。</p>

<p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么layer被更改了，什么key path的值被改变了，以及原来的值是什么:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> @interface DRSavedPopAnimationState : NSObject
</span><span class='line'>
</span><span class='line'> @property (strong) CALayer  *layer;
</span><span class='line'> @property (copy)   NSString *keyPath;
</span><span class='line'> @property (strong) id        oldValue;
</span><span class='line'>
</span><span class='line'> + (instancetype)savedStateWithLayer:(CALayer *)layer
</span><span class='line'>                             keyPath:(NSString *)keyPath;
</span><span class='line'>
</span><span class='line'> @end
</span><span class='line'>
</span><span class='line'> @implementation DRSavedPopAnimationState
</span><span class='line'>
</span><span class='line'> + (instancetype)savedStateWithLayer:(CALayer *)layer
</span><span class='line'>                             keyPath:(NSString *)keyPath
</span><span class='line'> {
</span><span class='line'>     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];
</span><span class='line'>     savedState.layer    = layer;
</span><span class='line'>     savedState.keyPath  = keyPath;
</span><span class='line'>     savedState.oldValue = [layer valueForKeyPath:keyPath];
</span><span class='line'>     return savedState;
</span><span class='line'> }
</span><span class='line'>
</span><span class='line'> @end</span></code></pre></td></tr></table></div></figure>


<p>接下来，在我们的交换后的delegate回调中，我们简单地讲被变更的属性的状态存入一个静态可变数组中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> if (DR_currentAnimationContext == DR_popAnimationContext) {
</span><span class='line'>       [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer
</span><span class='line'>                                                                                 keyPath:event]];
</span><span class='line'>
</span><span class='line'>       // 没有隐式的动画 (稍后添加)
</span><span class='line'>       return (id&lt;CAAction&gt;)[NSNull null];
</span><span class='line'>   }</span></code></pre></td></tr></table></div></figure>


<p>在动画block执行完毕后，所有的属性都被变更了，它们的状态也被保存了，现在，创建关键帧动画:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> + (void)DR_popAnimationWithDuration:(NSTimeInterval)duration
</span><span class='line'>                          animations:(void (^)(void))animations
</span><span class='line'> {
</span><span class='line'>     DR_currentAnimationContext = DR_popAnimationContext;
</span><span class='line'>
</span><span class='line'>     // 执行动画 (它将触发交换后的 delegate 方法)
</span><span class='line'>     animations();
</span><span class='line'>
</span><span class='line'>     [[self DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
</span><span class='line'>         DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;
</span><span class='line'>         CALayer *layer    = savedState.layer;
</span><span class='line'>         NSString *keyPath = savedState.keyPath;
</span><span class='line'>         id oldValue       = savedState.oldValue;
</span><span class='line'>         id newValue       = [layer valueForKeyPath:keyPath];
</span><span class='line'>
</span><span class='line'>         CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:keyPath];
</span><span class='line'>
</span><span class='line'>         CGFloat easing = 0.2;
</span><span class='line'>         CAMediaTimingFunction *easeIn  = [CAMediaTimingFunction functionWithControlPoints:1.0 :0.0 :(1.0-easing) :1.0];
</span><span class='line'>         CAMediaTimingFunction *easeOut = [CAMediaTimingFunction functionWithControlPoints:easing :0.0 :0.0 :1.0];
</span><span class='line'>
</span><span class='line'>         anim.duration = duration;
</span><span class='line'>         anim.keyTimes = @[@0, @(0.35), @1];
</span><span class='line'>         anim.values = @[oldValue, newValue, oldValue];
</span><span class='line'>         anim.timingFunctions = @[easeIn, easeOut];
</span><span class='line'>
</span><span class='line'>         // 不带动画地返回原来的值
</span><span class='line'>         [CATransaction begin];
</span><span class='line'>         [CATransaction setDisableActions:YES];
</span><span class='line'>         [layer setValue:oldValue forKeyPath:keyPath];
</span><span class='line'>         [CATransaction commit];
</span><span class='line'>
</span><span class='line'>         // 添加 "pop" 动画
</span><span class='line'>         [layer addAnimation:anim forKey:keyPath];
</span><span class='line'>
</span><span class='line'>     }];
</span><span class='line'>
</span><span class='line'>     // 扫除工作 (移除所有存储的状态)
</span><span class='line'>     [[self DR_savedPopAnimationStates] removeAllObjects];
</span><span class='line'>
</span><span class='line'>     DR_currentAnimationContext = nil;
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>注意老的model值被设置到了layer上，所以在当动画结束和移除后，model的值和persentation的值是相符合的。</p>

<p>创建像这样的你自己的API不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂UIview block动画的APis,特别是你已经在core Animation的舒适区的时候，这非常有助于你的提高。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 ViewController 容器转场]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang/"/>
    <updated>2016-07-19T10:02:19+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/19/zi-ding-yi-viewcontroller-rong-qi-zhuan-chang</id>
    <content type="html"><![CDATA[<p>我们在本文讨论navigation controller中的两个view controller之间的转场动画，但是这些做法在 tab bar controller或者任何你自己定义的view controller容器中也是通用的&hellip;</p>

<!--more-->


<p>尽管从技术角度来讲，使用ios7的api,你可以对自定义容器中的view controller做自定义转场，但是这不是能直接使用的，实现这种效果非常不容易。</p>

<p>请注意我正在讨论的自定义视图控制器容器都是UIViewController的直接子类，而不是UITabBarController或者UINavigationController的子类。</p>

<p>对于你自定义的继承与UIViewController的容器子类，并没有现成可用的Api允许一个任意的动画控制器将一个子视图控制器自动转场到另外一个，不管是可交互的转场还是不可交互式的转场。我甚至都觉得苹果根据不想支持这种方式。苹果支持下面的几种转场方式:</p>

<ul>
<li>Navigation Controller推入和推出页面</li>
<li>Tab bar Controller选择的改变</li>
<li>Model页面的展示和消失</li>
</ul>


<p>在本文中，我将向你展示如何自定义视图控制器容器，并且使其支持第三方的动画控制器</p>

<h2>预热准备</h2>

<p>看到这里，你可能对上文我们说到一些问题犯嘀咕，让我来告诉你答案吧:</p>

<p>为什么我们不直接继承UINavigationController或UITabBarController.并且使用它们提供的功能呢？</p>

<p>有些时候这是你不想要的。可能你想要一个非常特殊的外观或者行为，和这些类能够提供给你的差别非常大，因此你必须使用一些黑客式的手段去达到你想要的结果，同时还要担心系统框架的版本更新后这些黑客式的手段是否还仍然有效。或者，你就是想完全控制你的视图控制器容器，避免不得不支持一些特定的功能。</p>

<p>好吧，那么为什么不实用
<code>transitionFromViewController:toViewController:duration:options:animations:completion :</code>去实现呢?</p>

<p>这又是一个好问题，你可能想用这种方式去实现，但是或许你对代码的整洁性比较在意，想把这种转场相关的代码封装在内部。那么为什么不实用一个即存的，被良好验证的设计模式呢？这种设计模式可以非常方便的支持第三方的转场动画。</p>

<h2>介绍相关的API</h2>

<p>在我们开始写代码之前，让我们先花一分钟时间来简单看一下我们需要的组件吧。</p>

<p>ios7自定义视图控制器转场的API基本上都是以协议的方式提供的，这也使其可以非常灵活的使用，因为你可以很简单地讲它们插入到你的类中。最主要的五个组件如下：</p>

<ol>
<li>动画控制器(Animation Controllers)遵从UIViewControllerAnimatedTransitioning协议，并且负责实际执行动画。</li>
<li>交互控制器(Interaction Controllers)通过遵从UIViewControllerInteractiveTransitioning协议来控制可交互式的转场</li>
<li>转场代理(Transitioning Delegates)根据不同的转场类型方便的提供需要的动画控制器和交互控制器</li>
<li>转场上下文(Transitioning Contexts)定义了转场时需要的元数据，比如在转场过程中所参与的视图控制和视图相关属性。转场上下文对象遵从UIViewControllerContextTransitoning协议，并且这是由系统负责生成和提供的。</li>
<li>转场协调器(Transition Coordinators)可以在运行转场动画时，并行的运行其他动画。转场协调器遵从UIViewControllerTransitionCoorinator协议。</li>
</ol>


<p>正如你从其他的阅读材料中得知的那样，转场有不可交互式和可交互式两种方式。在本文红，我们将集中精力于不可交互的转场。这种转场是最简单的转场，也是我们学习的一个好的开始。这意味着我们需要处理上面提到的动画控制器(animation controllers)，转场代理(transioning delegates)和转场上下文(transionging contexts)</p>

<h2>示例工程</h2>

<p>通过三个阶段，我们将要实现一个简单自定义的视图控制器容器，它可以对子视图控制器提供自定义的转场动画的支持。</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions">这里</a>找到这三个阶段的Xcode工程的源代码</p>

<h3>阶段1:基础</h3>

<p>我们应用中的核心类是<code>ContainerViewController</code>，它持有一个UIViewController实例的数组，每个实例是一个普通的ChildViewController。容器视图控制器设置了一个带有可点击图标，并代表每个子视图控制器的私有的子视图:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-1.gif" alt="1" /></p>

<p>我们通过点击图标在不同的子视图控制器之间切换，在这一阶段，子视图控制器之间切换时是没有转场动画的。</p>

<p>你可以在这里查看<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-1">阶段1</a>的源代码</p>

<h3>阶段2：转场动画</h3>

<p>当我们添加转场动画时，我们想要使用一个遵从 UIViewControllerAnimatedTransitioning协议的动画控制器(animation controllers)。这个协议声明了三个方法，前面的2歌方法是必须实现的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
</span><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext;
</span><span class='line'>- (void)animationEnded:(BOOL)transitionCompleted;  </span></code></pre></td></tr></table></div></figure>


<p>通过这些方法，我们可以获得我们所需的所有东西。当我们的视图控制器容器准备执行动画时，我们可以从动画冬至器中获取动画的持续时间，并让其去执行真正的动画。当动画执行完毕后，如果动画控制器实现了可选的 <code>animationEnded:</code>方法，我们可以调用动画控制器中的 animationEnded: 方法。</p>

<p>但是，首先我们必须把一件事情搞清楚。正如你在上面的方法签名中看到的那样，上面两个必须实现的方法需要一个转场上下文参数，这是一个遵从 <code>UIViewControllerContextTransionging</code>协议的对象。通常情况下，当我们使用系统内建的类时，系统框架为我们创建了转场上下文对象，并把它传递给动画控制器。但是在我们这种情况下，我们需要自定义转场动画，所以我们需要承担系统框架的责任，自己去创建这个转场上下文对象。</p>

<p>这就是大量使用协议的方便之处。我们可以不用必须复写一个私有类，而复写私有类这种方法是明显不可行的。我们可以定义自己的类，并使其遵从文档中相应的协议就可以了。</p>

<p>尽管在UIViewControllerContextTransioning协议中声明了很多方法，而且他们都是必须要实现的，但是我们现在可以暂时忽略它们中的一些方法，因为我们现在仅仅支持不可交互的转场。</p>

<p>同UIKit类似，我们定义了私有类<code>NSObject &lt;UIViewControllerContextTransitioning&gt;</code>.在我们的特定例子汇总，这个私有类是 PrivateTransitionContext,它的初始化方法如下实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController goingRight:(BOOL)goingRight {
</span><span class='line'>    NSAssert ([fromViewController isViewLoaded] && fromViewController.view.superview, @"The fromViewController view must reside in the container view upon initializing the transition context.");
</span><span class='line'>
</span><span class='line'>    if ((self = [super init])) {
</span><span class='line'>        self.presentationStyle = UIModalPresentationCustom;
</span><span class='line'>        self.containerView = fromViewController.view.superview;
</span><span class='line'>        self.viewControllers = @{
</span><span class='line'>            UITransitionContextFromViewControllerKey:fromViewController,
</span><span class='line'>            UITransitionContextToViewControllerKey:toViewController,
</span><span class='line'>        };
</span><span class='line'>
</span><span class='line'>        CGFloat travelDistance = (goingRight ? -self.containerView.bounds.size.width : self.containerView.bounds.size.width);
</span><span class='line'>        self.disappearingFromRect = self.appearingToRect = self.containerView.bounds;
</span><span class='line'>        self.disappearingToRect = CGRectOffset (self.containerView.bounds, travelDistance, 0);
</span><span class='line'>        self.appearingFromRect = CGRectOffset (self.containerView.bounds, -travelDistance, 0);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们把视图的出现和消失时的状态记录了下来，比如初始状态和最终状态的frame.</p>

<p>请注意一点，我们的初始化方法需要我们提供我们是在向右切换还是向左切换。在我们的<code>ContainerViewController</code>中，按钮是一个接一个水平排列的，转场上下文通过设置每个frame来记录它们之间的位置关系。动画控制器或者说 animator,在生成动画时可以使用这些frame.</p>

<p>我们也可以通过另外的方式去获取这些信息，但是那样的话，就会使animator和<code>ContainerViewController</code>及其视图控制器耦合在一起了，这是不好的，我们并不想这样。animator应该只关心它自己以及传递给它的上下文，因为这样，在理想的情况下，animator可以在不同的上下文中得到复用。</p>

<p>在下一步实现我们自己的动画控制器时，我们应该时刻记住这一点，现在让我们来实现转场上下文吧。</p>

<p>使用Animator类的实例来做转场动画的核心代码如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[fromViewController willMoveToParentViewController:nil];
</span><span class='line'>[self addChildViewController:toViewController];
</span><span class='line'>
</span><span class='line'>Animator *animator = [[Animator alloc] init];
</span><span class='line'>
</span><span class='line'>NSUInteger fromIndex = [self.viewControllers indexOfObject:fromViewController];
</span><span class='line'>NSUInteger toIndex = [self.viewControllers indexOfObject:toViewController];
</span><span class='line'>PrivateTransitionContext *transitionContext = [[PrivateTransitionContext alloc] initWithFromViewController:fromViewController toViewController:toViewController goingRight:toIndex &gt; fromIndex];
</span><span class='line'>
</span><span class='line'>transitionContext.animated = YES;
</span><span class='line'>transitionContext.interactive = NO;
</span><span class='line'>transitionContext.completionBlock = ^(BOOL didComplete) {
</span><span class='line'>    [fromViewController.view removeFromSuperview];
</span><span class='line'>    [fromViewController removeFromParentViewController];
</span><span class='line'>    [toViewController didMoveToParentViewController:self];
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>[animator animateTransition:transitionContext];</span></code></pre></td></tr></table></div></figure>


<p>这其中的大部分是对视图控制器容器的操作，计算出我们是在向左切换还是向右切换，做动画的部分基本上只有3行代码：</p>

<ol>
<li>创建Animator</li>
<li>创建转场上下文</li>
<li>触发动画执行</li>
</ol>


<p>有了上面的代码，转场效果看起来如下图所示:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-2.gif" alt="2" /></p>

<p>非常酷，我们甚至没有写一行动画相关的代码</p>

<p>你可以在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-2">阶段2</a>标签下看到这部分代码的变化。</p>

<h3>阶段3：封装</h3>

<p>我想我们最后要做的一件事情是封装 ContainerViewController,使其能够:</p>

<ol>
<li>提供默认的转场动画</li>
<li>提供替换默认动画控制器的代理</li>
</ol>


<p>这意味着我们需要对Animator类的依赖移除，同时需要创建一个代理协议。</p>

<p>我们如下定义这个协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@protocol ContainerViewControllerDelegate &lt;NSObject&gt;
</span><span class='line'>@optional
</span><span class='line'>- (void)containerViewController:(ContainerViewController *)containerViewController didSelectViewController:(UIViewController *)viewController;
</span><span class='line'>- (id &lt;UIViewControllerAnimatedTransitioning&gt;)containerViewController:(ContainerViewController *)containerViewController animationControllerForTransitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><code>containerViewController:didSelectViewController:</code>方法使<code>ContainerViewController</code>可以很容易的集成与功能齐全的应用中。</p>

<p><code>containerViewController:animationControllerForTransitionFromViewController:toViewController:</code>方法挺有趣的，当然，你可以把它和下面的UIKit中的视图控制器容器的代理协议做对比:</p>

<ul>
<li>tabBarController:animationControllerForTransitionFromViewController:toViewController: (UITabBarControllerDelegate)</li>
<li>navigationController:animationControllerForOperation:fromViewController:toViewController: (UINavigationControllerDelegate)</li>
</ul>


<p>所有的这些方法都返回一个id<UIViewControllerAnimatedTransitioning>对象。与之前一直使用一个 Animator 对象不同，我们现在可以从我们的代理那里获取一个动画控制器:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>id&lt;UIViewControllerAnimatedTransitioning&gt;animator = nil;
</span><span class='line'>if ([self.delegate respondsToSelector:@selector (containerViewController:animationControllerForTransitionFromViewController:toViewController:)]) {
</span><span class='line'>    animator = [self.delegate containerViewController:self animationControllerForTransitionFromViewController:fromViewController toViewController:toViewController];
</span><span class='line'>}
</span><span class='line'>animator = (animator ?: [[PrivateAnimatedTransition alloc] init]);</span></code></pre></td></tr></table></div></figure>


<p>如果我们有代理并且它返回一个Animator,那么我们就使用这个 animator.否则，我们使用内部私有类PrivateAnimatedTransition 创建一个默认的 animator.接下来我们将实现 <code>PrivateAnimatedTransition</code>类。</p>

<p>尽管默认的动画和 Animator有一些不同，但是代码看起来惊人的相似，下面是完整的代码实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation PrivateAnimatedTransition
</span><span class='line'>
</span><span class='line'>static CGFloat const kChildViewPadding = 16;
</span><span class='line'>static CGFloat const kDamping = 0.75f;
</span><span class='line'>static CGFloat const kInitialSpringVelocity = 0.5f;
</span><span class='line'>
</span><span class='line'>- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
</span><span class='line'>    return 1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext {
</span><span class='line'>
</span><span class='line'>    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>
</span><span class='line'>    // When sliding the views horizontally, in and out, figure out whether we are going left or right.
</span><span class='line'>    BOOL goingRight = ([transitionContext initialFrameForViewController:toViewController].origin.x &lt; [transitionContext finalFrameForViewController:toViewController].origin.x);
</span><span class='line'>
</span><span class='line'>    CGFloat travelDistance = [transitionContext containerView].bounds.size.width + kChildViewPadding;
</span><span class='line'>    CGAffineTransform travel = CGAffineTransformMakeTranslation (goingRight ? travelDistance : -travelDistance, 0);
</span><span class='line'>
</span><span class='line'>    [[transitionContext containerView] addSubview:toViewController.view];
</span><span class='line'>    toViewController.view.alpha = 0;
</span><span class='line'>    toViewController.view.transform = CGAffineTransformInvert (travel);
</span><span class='line'>
</span><span class='line'>    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:kDamping initialSpringVelocity:kInitialSpringVelocity options:0x00 animations:^{
</span><span class='line'>        fromViewController.view.transform = travel;
</span><span class='line'>        fromViewController.view.alpha = 0;
</span><span class='line'>        toViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        toViewController.view.alpha = 1;
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
</span><span class='line'>    }];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>需要注意一点的是，上面的代码没有通过设置视图的frame 来反应它们之间的位置关系，但是代码仍然可以正常工作，只不过转场总是在同一个方向上。因此，这个类也可以被其它的代码库使用。</p>

<p>转场动画看起来像是这样:</p>

<p><img src="https://www.objccn.io/images/issues/issue-12/2014-05-01-custom-container-view-controller-transitions-stage-3.gif" alt="2" /></p>

<p>在<a href="https://github.com/objcio/issue-12-custom-container-transitions/tree/stage-3">阶段3</a>代码中，app delegate中设置代理的部分被注释掉了，这样就可以看到默认的动画效果了，你可以将其设置回再使用 Animator类，你可能想查看同<a href="https://github.com/objcio/issue-12-custom-container-transitions/compare/stage-2...stage-3">阶段2相比所有的修改</a></p>

<p>我们现在有一个自包含的提供了默认转场动画的 ContainerViewController 类，这个默认的转场动画可以被开发者定义的ios7自定义动画控制器(UIViewControllerAnimatedTransitioning)的对象代替，甚至都可以不用关心我们的源代码就可以方便的替换。</p>

<h2>结论</h2>

<p>在本文中，我们通过使用ios7提供的自定义视图控制器转场的新特性，使得我们自定义的视图控制器容器成为了UIkit的一等公民。</p>

<p>这意味着你可以把自定义的非交互的转场动画应用到自定义的视图控制器容器中。你可以看到我们把7个话题之前使用的转场类直接拿过来使用，而且没有做任何修改。</p>

<p>如果你想让自己的容器视图控制器作为一个类库或者框架，或者仅仅想使你的代码得到更好的复用，这将是非常完美的。</p>

<p>我们现在仅仅支持非交互式的转场，下一步就是对交互式的转场也提供支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的第三方类库&amp;学习资料]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/07/18/chang-yong-de-di-san-fang-lei-ku-and-xue-xi-zi-liao/"/>
    <updated>2016-07-18T17:57:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/07/18/chang-yong-de-di-san-fang-lei-ku-and-xue-xi-zi-liao</id>
    <content type="html"><![CDATA[<hr />

<p>自己总结的iOS、mac开源项目及库，持续更新。。。。
github排名 <a href="https://github.com/trending">https://github.com/trending</a>,github搜索：<a href="https://github.com/search">https://github.com/search</a></p>

<!--more-->


<h3>目录</h3>

<ul>
<li><a href="#UI">UI</a>

<ul>
<li><a href="#%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">下拉刷新</a></li>
<li><a href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C">模糊效果</a></li>
<li><a href="#AutoLayout">AutoLayout</a></li>
<li><a href="#%E5%AF%8C%E6%96%87%E6%9C%AC">富文本</a></li>
<li><a href="#%E5%9B%BE%E8%A1%A8">图表</a></li>
<li><a href="#%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%B8%8ETabbar">表相关与Tabbar</a></li>
<li><a href="#%E9%9A%90%E8%97%8F%E4%B8%8E%E6%98%BE%E7%A4%BA">隐藏与显示</a></li>
<li><a href="#HUD%E4%B8%8EToast">HUD与Toast</a></li>
<li><a href="#%E5%AF%B9%E8%AF%9D%E6%A1%86">对话框</a></li>
<li><a href="#%E5%85%B6%E4%BB%96UI">其他UI</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E7%94%BB">动画</a>

<ul>
<li><a href="#%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E%E6%89%8B%E5%8A%BF">侧滑与右滑返回手势</a></li>
<li><a href="#gif%E5%8A%A8%E7%94%BB">gif动画</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8A%A8%E7%94%BB">其他动画</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3">网络相关</a>

<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">网络连接</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E8%8E%B7%E5%8F%96">图像获取</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9">网络聊天</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%8B%E8%AF%95">网络测试</a></li>
<li><a href="#%E7%BD%91%E9%A1%B5%E6%A1%86%E6%9E%B6">网页框架</a></li>
<li><a href="#WebView%E4%B8%8EWKWebView">WebView与WKWebView</a></li>
</ul>
</li>
<li><a href="#Model">Model</a></li>
<li><a href="#%E9%80%9A%E8%AE%AF%E5%BD%95">通讯录</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%BA%93">其他库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86">缓存处理</a></li>
<li><a href="#PDF">PDF</a></li>
<li><a href="#%E5%9B%BE%E5%83%8F%E6%B5%8F%E8%A7%88%E5%8F%8A%E5%A4%84%E7%90%86">图像浏览及处理</a></li>
<li><a href="#%E6%91%84%E5%83%8F%E7%85%A7%E7%9B%B8%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86">摄像照相视频音频处理</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6">响应式框架</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%9B%B8%E5%85%B3">消息相关</a>

<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">消息推送客户端</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">消息推送服务器端</a></li>
<li><a href="#%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3">通知相关</a></li>
</ul>
</li>
<li><a href="#%E7%89%88%E6%9C%AC%E6%96%B0API%E7%9A%84Demo">版本新API的Demo</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E4%B8%8E%E5%AF%86%E7%A0%81">代码安全与密码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%8F%8A%E8%B0%83%E8%AF%95">测试及调试</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0">动态更新</a></li>
<li><a href="#AppleWatch">AppleWatch</a></li>
<li><a href="#VPN">VPN</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE">完整项目</a></li>
<li><a href="#%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0">好的文章</a></li>
<li><a href="#Xcode%E6%8F%92%E4%BB%B6">Xcode插件</a></li>
<li><a href="#%E7%BE%8E%E5%B7%A5%E8%B5%84%E6%BA%90">美工资源</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90">开发资源</a>

<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99">开发资料</a></li>
<li><a href="#swift">swift</a></li>
<li><a href="#%E4%BB%96%E4%BA%BA%E5%BC%80%E6%BA%90%E6%80%BB%E7%BB%93">他人开源总结</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8">开发博客列表</a></li>
</ul>
</li>
</ul>


<hr />

<h3>具体内容 =============================</h3>

<hr />

<h4>UI</h4>

<h5>下拉刷新</h5>

<ul>
<li><a href="https://github.com/enormego/EGOTableViewPullRefresh">EGOTableViewPullRefresh</a> - 最早的下拉刷新控件。</li>
<li><a href="https://github.com/samvermette/SVPullToRefresh">SVPullToRefresh</a> - 下拉刷新控件。</li>
<li><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> - 仅需一行代码就可以为UITableView或者CollectionView加上下拉刷新或者上拉刷新功能。可以自定义上下拉刷新的文字说明。具体使用看“使用方法”。 （国人写）</li>
<li><a href="https://github.com/xhzengAIB/XHRefreshControl">XHRefreshControl</a> - XHRefreshControl 是一款高扩展性、低耦合度的下拉刷新、上提加载更多的组件。（国人写）</li>
<li><a href="https://github.com/coolbeet/CBStoreHouseRefreshControl">CBStoreHouseRefreshControl</a> - 一个效果很酷炫的下拉刷新控件。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - 一个下拉刷新打砖块的开源 Swift 库，能让用户在等待下拉刷新的时候边玩撞球游戏边等待。</li>
<li><a href="https://github.com/KittenYang/KYJellyPullToRefresh">KYJellyPullToRefresh</a> - 实现弹性物理效果的下拉刷新，神奇的贝塞尔曲线，配合UIDynamic写的一个拟物的下拉刷新动画。</li>
<li><a href="https://github.com/michaelhenry/MHYahooParallaxView">MHYahooParallaxView</a> - 类似于Yahoo Weather和News Digest首屏的视差滚动。</li>
<li><a href="https://github.com/gsdios/SDRefreshView">SDRefreshView</a> - 简单易用的上拉和下拉刷新（多版本细节适配）。</li>
<li><a href="https://github.com/MakeZL/ZLSwiftRefresh">ZLSwiftRefresh</a> - swift下拉刷新/上拉加载更多，支持自定义动画，集成简单，兼容UITableView/CollectionView/ScrollView/WebView。</li>
<li><a href="https://github.com/dasdom/BreakOutToRefresh">BreakOutToRefresh</a> - swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/andreamazz/GearRefreshControl">GearRefreshControl</a> -  swift，上拉和下拉刷新。</li>
<li><a href="https://github.com/jcavar/refresher">refresher</a> -  swift，上拉和下拉刷新。</li>
<li><a href="http://d.cocoachina.com/code/detail/237753">可展开/收缩的下拉菜单&ndash;SvpplyTable</a> -  一个可展开可收缩的下拉菜单，类似Svpply app。</li>
<li><a href="https://github.com/Sephiroth87/ODRefreshControl">ODRefreshControl</a> - 原iOS6上的橡皮糖刷新样式，很有意思。现在也很多大的 App 在用，比如虾米音乐和 QQ 客户端。</li>
<li><a href="https://github.com/Yalantis/PullToMakeSoup">PullToMakeSoup</a> - PullToMakeSoup, 自定义下拉刷新的动画效果：煮饭, Yalantis新作！</li>
<li><a href="https://github.com/cyndibaby905/TwitterCover">TwitterCover</a> -  Twitter iOS客户端的下拉封面模糊效果。</li>
<li><a href="https://github.com/MartinRGB/Replace-iOS">Replace-iOS</a> - Replace-iOS 让人眼前一亮的下拉刷新（iOS）。</li>
<li><a href="https://github.com/fruitcoder/ReplaceAnimation">ReplaceAnimation.swift</a> - 基于 @ZeeYoung欧阳哲 同学的创意下拉刷新动画实现。值得称赞还有额外增加了“取消及滚动”效果支持。</li>
<li><a href="https://github.com/KittenYang/Animations">Animations</a> - 封装了一下，使用的时候只要两行代码。一些动画的飞机稿，都是一些单独分离出来的用于测试的子动画，现在统一归类一下。</li>
<li><a href="https://github.com/entotsu/PullToBounce">PullToBounce</a> - 下拉刷新的动画 for UIScrollView。</li>
<li><a href="https://github.com/li6185377/WaterDropRefresh">WaterDropRefresh</a> - 仿Path 水滴的下拉刷新效果 还有视差滚动。</li>
<li><a href="https://github.com/EnjoySR/ESRefreshControl">ESRefreshControl</a> - 仿新浪微博、百度外卖、网易新闻下拉刷新样式Demo（仅供参考）。</li>
<li><a href="https://github.com/alienjun/AJWaveRefresh">WaveRefresh</a> - 下拉刷新水波纹动画。</li>
<li><a href="https://github.com/gontovnik/DGElasticPullToRefresh">DGElasticPullToRefresh</a> - 是一款带有弹性效果的 iOS 下拉刷新组件。</li>
<li><a href="https://github.com/wuwen1030/CALayerAnimationDemoh">CALayerAnimationDemoh</a> - 双向注水动画下拉刷新组件,使用CALayer的mask实现。</li>
<li><a href="https://github.com/zangqilong198812/BanTangAnimation">BanTangAnimation</a> - 半糖下拉刷新的原理。简单来说是利用CGGlyph，字符图形转换成cgpath，然后绘制strokeEnd动画。把timeoffset和scrolloffset结合就行了。</li>
<li><a href="https://github.com/cbangchen/PullToReflesh-Swift">PullToReflesh-Swift</a> - 一款炫酷的下拉刷新封装库（Mobile page refresh concept inspired by Google and for something like a news app）。<a href="http://cbang.info/2016/03/04/CBReflesh%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析 </a></li>
<li><a href="https://github.com/eggswift/pull-to-refresh">pull-to-refresh.swift</a> - 是一款非常易于开发者使用的下拉刷新和加载更多组件。通过一个 UIScrollView 的扩展，可以轻松为 UIScrollView 的所有子类添加下拉刷新功能。</li>
</ul>


<h5>模糊效果</h5>

<ul>
<li><a href="https://github.com/nicklockwood/FXBlurView">FXBlurView</a> - 是一个UIView子类，支持iOS5.0以上版本，支持静态、动态模糊效果，继承与UIView的模糊特效。</li>
<li><a href="https://github.com/onevcat/VVBlurPresentation">VVBlurPresentation</a> -很简单易用的在原来viewconntroller基础上做模糊，然后present新的viewcontroller的。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;对话框 里面已经收藏。</li>
<li><a href="https://github.com/szk-atmosphere/SABlurImageView">SABlurImageView</a> - 支持渐变动画效果的图像模糊化类库。P.S. 与前几天推存类库 SAHistoryNavigationViewController 是同一位作者。</li>
<li><a href="https://github.com/FlexMonkey/Blurable">Blurable.swift</a> - swift模糊组件。</li>
</ul>


<h5>AutoLayout</h5>

<ul>
<li><a href="https://github.com/SnapKit/Masonry">Masonry</a> - Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性（ <a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/">使用介绍1</a>  <a href="http://ios.jobbole.com/81483/">使用介绍2</a>），<a href="http://www.cocoachina.com/ios/20150702/12217.html">iOS自适应前段库-Masonry的使用</a>），<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。<a href="https://github.com/lcddhr/DDMasonryTest">使用DEMO</a> 视图居中显示、子视图含边距、视图等距离摆放、计算ScrollView的contentsize。</li>
<li><a href="https://github.com/ClassyKit/Classy">Classy</a> - Classy是一个能与UIKit无缝结合stylesheet(样式)系统。它借鉴CSS的思想，但引入新的语法和命名规则，<a href="http://classy.as/getting-started/">Classy官网</a>，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/olegam/ClassyLiveLayout">ClassyLiveLayout</a> - ClassyLiveLayout通过结合Classy stylesheets与Masonry一起使用，能够在运行的模拟器中微调Auto Layout约束实时显示效果的工具，<a href="http://www.jianshu.com/p/2ed5f7444900">Masonry、Classy、ClassyLiveLayout介绍</a>。</li>
<li><a href="https://github.com/SnapKit/SnapKit">Snap</a> - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X。</li>
<li><a href="https://github.com/SnapKit/SnapKit">SnapKit</a> - 就是“snap”， &ndash;swift 喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。</li>
<li><a href="https://github.com/PureLayout/PureLayout">PureLayout</a> - PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。</li>
<li><a href="https://github.com/smileyborg/UIView-AutoLayout">UIView-AutoLayout</a> -
Deprecated in favor of PureLayout, which includes OS X support:<a href="https://github.com/smileyborg/PureLayout%E3%80%82">https://github.com/smileyborg/PureLayout%E3%80%82</a></li>
<li><a href="https://github.com/robb/Cartography">Cartography</a> - Cartography 是用来声明 Swift 中的 Auto Layout，无需输入任何 stringly 就可设置自己 Auto Layout 的约束声明。</li>
<li><a href="https://github.com/philcn/Auto-Layout-Showcase">Auto-Layout-Showcase</a> - swift,AutoLayout 进阶 Demo，宽高比约束、比例约束、不等约束、视差约束、低优先级约束等高级用法，无需写码即可进行复杂页面布局，Demo 还动态模拟了各屏幕下的效果。来自百度知道 iOS 小组的内部分享。</li>
<li><a href="https://github.com/forkingdog/UIView-FDCollapsibleConstraints">UIView-FDCollapsibleConstraints</a> - 一个AutoLayout辅助工具，最优雅的方式解决自动布局中子View的动态显示和隐藏的问题。第二个Demo模拟了一个经典的FlowLayout，任意一个元素隐藏时，底下的元素需要自动“顶”上来，配合这个扩展，你可以在IB里连一连，选一选，不用一行代码就能搞定。</li>
<li><a href="https://github.com/luodezhao/Autolayout_Demo">Autolayout_Demo</a> - 在项目中用自动布局实现的类似抽屉效果。</li>
<li><a href="http://code.cocoachina.com/detail/320405/">当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute</a> - 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute，从而不用大量的代码工作。</li>
<li><a href="https://github.com/gsdios/SDAutoLayout">SDAutoLayout</a> - AutoLayout 一行代码搞定自动布局！支持Cell、Label和Tableview高度自适应，致力于做最简单易用的AutoLayout库。</li>
<li><a href="https://github.com/mamaral/Neon">Neon.swift</a> - 功能强大的 UI 布局神器。</li>
<li><a href="https://github.com/nakiostudio/EasyPeasy">EasyPeasy.swift</a> - 编程方式自动布局框架库。</li>
</ul>


<h5>富文本</h5>

<ul>
<li><a href="https://github.com/topfunky/hpple">TFHpple </a> - TFHpple
解析html的轻量级框架</li>
<li><a href="https://github.com/honcheng/RTLabel">RTLabel</a> - RTLabel 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。32位，很久没有更新了。</li>
<li><a href="https://github.com/bingxue314159/RTLabel">RTLabel</a> - 富文本，RTLabel支持64位。</li>
<li><a href="https://github.com/12207480/TYAttributedLabel">TYAttributedLabel</a> -  TYAttributedLabel。 简单易用的属性文本控件(无需了解CoreText)，支持富文本，图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示。</li>
<li><a href="https://github.com/TinyQ/TQRichTextView">TQRichTextView</a> - 用于做富文本视图控件显示，用于即时通讯的表情显示，以及资源评论的富文本显示。</li>
<li><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel">TTTAttributedLabel</a> - 一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。<a href="http://blog.csdn.net/prevention/article/details/9998575">用TTTAttributedLabel创建变化丰富的UILabel</a> - 网易新闻iOS版使用。</li>
<li><a href="https://github.com/molon/MLEmojiLabel">MLEmojiLabel</a> - 自动识别网址、号码、邮箱、@、#话题#和表情的label。可以自定义自己的表情识别正则，和对应的表情图像。(默认是识别微信的表情符号)，继承自TTTAttributedLabel，所以可以像label一样使用。label的特性全都有，使用起来更友好更方便。</li>
<li><a href="https://github.com/nicklockwood/FXLabel">FXLabel</a> - FXLabel是一个功能强大使用简单的类库，通过提供一个子类改进了标准的UILabel组件，为字体增加了阴影、内阴影和渐变色等，可以被用在任何标准的UILabel中。FXLabel还提供了更多控件，可以对字体行距、字体间距等进行调整。</li>
<li><a href="https://github.com/TigerWf/WFReader">WFReader</a> - 一款简单的coretext阅读器，支持文本选择、高亮以及字体大小选择等。</li>
<li><a href="https://github.com/nigelgrange/WPAttributedMarkup">WPAttributedMarkup</a> - WPAttributedMarkup is a simple utility category that can be used to easily create an attributed string from text with markup tags and a style dictionary。</li>
<li><a href="https://github.com/MoZhouqi/KMPlaceholderTextView">KMPlaceholderTextView</a> - 可显示多行 placeholder 的 textView，可以在IB里面设置 &ndash; swift。</li>
<li><a href="https://github.com/mrchenhao/HHFlashSwitch">HHFlashSwitch</a> - 一个另类的UISwitch，选择后，背景水波扩散变色效果。</li>
<li><a href="https://github.com/zhangyu9050/UUColorSwitch">UUColorSwitch</a> - Switch 开关动画效果,当打开开关时，Switch可实现平滑渲染过渡到父视图的效果。</li>
<li><a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">UITextViewDIYEmojiExample</a> - <a href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/">UITextView编辑时插入自定义表情-简单的图文混编</a>。</li>
<li><a href="https://github.com/facebook/Shimmer">Shimmer</a> - BlingBling闪光效果，酷炫的Label的效果，可以用于加载等待提示。</li>
<li><a href="https://github.com/nnhubbard/ZSSRichTextEditor">ZSSRichTextEditor</a> - 适用于iOS的富文本WYSIWYG编辑器，支持语法高亮和源码查看。ZSSRichTextEditor包含所有WYSIWYG标准的编辑器工具。</li>
<li><a href="https://github.com/cjwirth/RichEditorView">RichEditorView</a> - swift，一套可定制富文本编辑器组件及示例。功能完整、代码简练、实现逻辑巧妙（编辑器核心与 WebView 结合，采用 HTML5 contentEditable 编辑模式，执行JS 配套命令 execCommand 实现富文本编辑功能）。</li>
<li><a href="https://github.com/Cocoanetics/DTCoreText">DTCoreText</a> - 可以解析HTML与CSS最终用CoreText绘制出来，通常用于在一些需要显示富文本的场景下代替低性能的UIWebView。<a href="http://blog.cnbang.net/tech/2630/">DTCoreText源码解析</a>。</li>
<li><a href="https://github.com/cloverstudio/CSGrowingTextView">CSGrowingTextView</a> - 用作即时通讯文本框和评论文本框使用，可以显示多行输入。</li>
<li><a href="https://github.com/indragiek/MarkdownTextView">MarkdownTextView</a> - 显示Markdown的TextView。</li>
<li><a href="https://github.com/SimonFairbairn/SwiftyMarkdown">SwiftyMarkdown.swift</a> - 用swift写的markdown解析库。</li>
<li><a href="https://github.com/macteo/Marklight">Marklight.swift</a> - Markdown 语法高亮显示编辑库（Swift）。</li>
<li><a href="http://d.cocoachina.com/code/detail/300299">高仿微信限定行数文字内容</a> - 采用Autolayout高仿微信纯文字限定行数。</li>
<li><a href="https://github.com/lingochamp/FuriganaTextView">FuriganaTextView</a> - 实现复杂的日文韩文排版。</li>
<li><a href="https://github.com/gmertk/ParkedTextField">ParkedTextField</a> - 带固定文本的输入组件。</li>
<li><a href="https://github.com/lexrus/LTMorphingLabel">LTMorphingLabel</a> - swift 能够实现文字变形动画效果的Label，用Swift写的一个能够实现文字变形动画效果的Label，很炫。</li>
<li><a href="https://github.com/zyprosoft/GJCFCoreText">GJCFCoreText</a> - 图文混排。</li>
<li><a href="https://github.com/KyoheiG3/AttributedLabel">AttributedLabel</a> - 显示性能数量级 UILabel 的 AttributedLabel。无畏无惧、挑战权威。</li>
<li><a href="https://github.com/liufan321/FFLabel">FFLabel</a> - 自动检测 URLs, @username, #topic# 等关链词（提供响应扩展）。实用的标签文本小组件。</li>
<li><a href="https://github.com/raulriera/TextFieldEffects">TextFieldEffects</a> - 标准的UITextField有些枯燥么？来认识一下TextFieldEffects吧！废话不多说，只要看几个例子,是啊，都是些简单的dropin控制器。甚至可以在storyboard中使用IBDesignables。</li>
<li><a href="https://github.com/filipstefansson/AutocompleteField">AutocompleteField</a> - 可应用于 iOS 应用中文字输入框自动补全的场景, 兼容到 iOS 8。</li>
<li><a href="https://github.com/yannickl/Splitflap">Splitflap.swift</a> - 可用于快速给 iOS 应用创建文字翻转的动画效果。</li>
<li><a href="https://github.com/wordpress-mobile/WordPress-Editor-iOS">WordPress-Editor-iOS</a> - 一个文本编辑器 简书和新浪博客都在用。</li>
<li><a href="https://github.com/ibireme/YYText">YYText</a> - 功能强大的 iOS 富文本框架。</li>
<li><a href="http://code.cocoachina.com/view/129099">placeholder_TextView</a> - 带有placeholder的TextView：带有提示信息的textview，使用懒加载的思想，支持扩展、自定义，类似许多APP内部的意见反馈页面 。</li>
<li><a href="https://github.com/FahimF/FloatLabelFields">FloatLabelFields.swift</a> - FloatLabelFields.swift浮动标签输入效果类。</li>
<li><a href="https://github.com/xiangwangfeng/M80AttributedLabel">M80AttributedLabel</a> - M80AttributedLabel实现文字与表情的混排。一般使用气泡作为背景。</li>
<li><a href="https://github.com/yatinsns/HPGrowingTextView">HPGrowingTextView</a> - HPGrowingTextView聊天输入文字，可以根据输入文字的多少自动改变输入框的高度。</li>
<li><a href="https://github.com/mortenjust/cleartext-mac">cleartext-mac.swift</a> - 提供一千个常用单词的编辑器。</li>
<li><a href="https://github.com/kciter/GlitchLabel">GlitchLabel.swift</a> - 可定制“黑（故障）文字标签”类库，熟称晃瞎你的眼文字标签。</li>
</ul>


<h5>图表</h5>

<ul>
<li><a href="https://github.com/kevinzhow/PNChart">PNChart</a> - 国内开源作者，动态的图表。</li>
<li><a href="https://github.com/zemirco/swift-linechart">swift-linechart</a> - 功能完整、实用的折线图组件。使用方便，参数配置简单。是不可多得的优质组件&ndash;swift。</li>
<li><a href="https://github.com/danielgindi/Charts">ios-charts</a> - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。</li>
<li><a href="https://github.com/xhacker/TEAChart">TEAChart</a> - xhacker/TEAChart 一个简洁的 iOS 图表库，支持柱状图、饼图以及日历等。</li>
<li><a href="https://github.com/yasuoza/YOChartImageKit">YOChartImageKit</a> - 支持在watchOS上绘制图表，看它最近更新挺勤快的，可以关注一下。</li>
<li><a href="https://github.com/kevinzhow/RealtimeGradientText">RealtimeGradientText</a> - Fun With CALayer Mask 刚好今天开源了一个有趣的项目 RealtimeGradientText，所以也好聊一下 CALayer 的 Mask，<a href="http://blog.zhowkev.in/2015/07/06/fun-with-mask/">说明</a>。</li>
<li><a href="https://github.com/xyfeng/XYPieChart">XYPieChart</a> -XYPieChart:饼状图,  饼图,  数据统计,  数据可视化,可以在图形上标注数据。效果十分漂亮，而且没有用到一张图片。</li>
<li><a href="https://github.com/Zirkfied/ZFChart">ZFChart</a> - 模仿PNChart写的一个图表库，用法简单，暂时有柱状图，线状图，饼图三种类型，后续可能会更新新的类型。</li>
<li><a href="https://github.com/philackm/Scrollable-GraphView">Scrollable-GraphView.swift</a> - 灵动感十足的自适应、可定制滚动曲（折）线图表库。</li>
<li><a href="https://github.com/danielgindi/Charts">charts</a>国外人写有各种效果的图表，非常强大</li>
<li><a href="https://github.com/xyfeng/XYPieChart">xypieChart</a>带有动画效果的饼状图</li>
<li><a href="https://github.com/zhiyu/chartee">chartee</a>股票K线图示例</li>
<li><a href="https://github.com/dangfm/stockChart">stockChart</a>股票K线图示例</li>
<li><a href="https://github.com/NunchakusHuang/HYStockChart">HYStockChart</a>股票图</li>
<li><a href="https://github.com/chenyk0317/YKLineChartView">YKLineChartView</a>iOS 股票的K线图 分时图 Kline <a href="http://chenyk.com">http://chenyk.com</a></li>
<li><a href="https://github.com/xiaofei86/LPLineChartView">LPLineChartView</a>不错的图形报表</li>
<li><a href="https://github.com/chenxiaoyu3/BBStockChartView">BBStockCharView</a>A full customizable iOS stock chart view, K-Line, volume graph, with gesture supported.</li>
<li><a href="https://github.com/i-schuetz/SwiftCharts">SwiftCharts</a> Easy to use and highly customizable charts library for iOS</li>
<li><a href="https://github.com/q946666800/DrawLineChart">drawLineChart</a>绘制简单折线图</li>
<li><a href="https://github.com/zhmch0329/MCChartView">MCChartview</a>MCChartView is some different charts used in my project! Bar, Line, Pie, Radar, Circle and Coverage chart views.</li>
<li><a href="Line%20and%20Bar%20of%20Chart,%20you%20can%20mark%20the%20range%20of%20value%20you%20want,%20and%20show%20the%20max%20or%20min%20values%20in%20linechart%20with%20the%20form%20style">UUChartView</a></li>
<li><a href="https://github.com/zhuayi/ZCharts">Zcharts</a>ZCharts 是一个图表库， 能够很简单便捷的为应用程序添加有交互性的图表</li>
</ul>


<h5>表相关与Tabbar</h5>

<ul>
<li><a href="https://github.com/onevcat/SWTableViewCell">SWTableViewCell</a> - 国内开源作者，带很多手势的表单元格。</li>
<li><a href="https://github.com/alikaragoz/MCSwipeTableViewCell">MCSwipeTableViewCell</a> - 带很多手势的表单元格。</li>
<li><a href="https://github.com/1000Memories/TMQuiltView">TMQuiltView</a> - 瀑布流。</li>
<li><a href="https://github.com/codingZero/XRWaterfallLayout">XRWaterfallLayout</a> - 超简单的瀑布流实现,<a href="http://www.cocoachina.com/ios/20160407/15872.html">实现说明</a>。</li>
<li><a href="https://github.com/lengmolehongyan/WaterfallFlowDemo">WaterfallFlowDemo</a> - 一个简单的UICollectionView瀑布流布局演示demo。</li>
<li><a href="https://github.com/xmartlabs/XLForm">XLForm</a> - 很多表格类的table,写法更高冷一点，推荐使用。</li>
<li><a href="https://github.com/xmartlabs/Eureka">Eureka.swift</a> - Eureka 是 XLForm 的 Swift 的移植版本, 一个可以帮助开发者们快速构建 iOS 各种复杂表单的库, 具有较高的可扩展性, 方便自定制样式。</li>
<li><a href="https://github.com/romaonthego/RETableViewManager">RETableViewManager</a> - 可以十分方便地生成各种样式、各种功能的TableView。只要开发者能想到的列表效果或者功能，都可以利用这份代码迅速编写出来。比如，之前要实现一个填写各种资料的列表，可能需要很多代码，现在只需要几行代码就可以实现。</li>
<li><a href="https://github.com/TomThorpe/UIScrollSlidingPages">UIScrollSlidingPages</a> - 允许添加多视图控件，并且可以横向滚动。有点类似于Groupon app。</li>
<li><a href="https://github.com/izyhuang/HBHorizontalTableView">HBHorizontalTableView</a> - swift，TableView 横向滚动小示例（仿照 AppStore 应用展示）。</li>
<li><a href="https://github.com/mcelayir/HorizontalScrollCell">HorizontalScrollCell</a> - HorizontalScrollCell是一款使用方便的水平方向可滚动的单元格，适用于UICollectionView中实现水片方向滚动视图。 。</li>
<li><a href="https://github.com/shiyuan17/syTableView">SYJiugonggeTableView</a> - tableView封装的九宫格。</li>
<li><a href="https://github.com/ZhipingYang/UUChatTableView">UUChatTableView</a> - UUChatTableView 气泡聊天界面，支持文本、图片以及音频的气泡聊天界面。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/acani/Chats">Chats</a> - 聊天 UI 示例程序。此项目应该只为演示或学习之用，没有服务器 &ndash; swift。</li>
<li><a href="https://github.com/layerhq/Atlas-iOS">Atlas-iOS</a> - 快速在iOS里集成聊天功能，类似开源版本的环信。Layer家开源了一套聊天app界面的解决方案.看起来很赞，很多蛮复杂的东西直接都帮封好了。不得不说现在做app开发真是很简单，大部分时间搭积木就可以了。<a href="https://atlas.layer.com/">官方网站</a>。</li>
<li><a href="https://github.com/badoo/Chatto">Chatto.swift</a> - Chatto.swift:轻量级聊天应用框架及示例。文字及图片可扩展输入栏，汽泡效果等聊天核心特性，分页及自动布局完善。</li>
<li><a href="https://github.com/agdsdl/DLSlideView">DLSlideView</a> - DLSlideView对常见的顶部Tab页点击、滑动分页做了封装。它使用基于ViewController的container特性（而不是scrollview）来管理各个子页面，以支持无限分页，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/pozi119/VOVCManager">VOVCManager</a> - 页面管理器:1.跳转指定页面,只需要知道viewController的Class名,如果有storyboard,则需要指定storyboard名；2.无需添加基类；3.支持URLScheme跳转指定页面。</li>
<li><a href="https://github.com/Moblox/MBXPageViewController">MBXPageViewController</a> - 简洁快速的页面切换&ndash;MBXPageViewController，带有按钮控件的UIPageController，非常整洁、简单以及快速。该项目通过三种形式展示页面之间的切换，比如导航栏上的多个tab切换、页面左右两端箭头指示切换，以及使用分段控件。</li>
<li><a href="https://github.com/ming1016/PagerTab">PagerTab</a> - UIScrollView实现滑动转换页面，类似网易云音乐iOS版的页面滑动切换效果。</li>
<li><a href="https://github.com/guilhermearaujo/GUITabPagerViewController">GUITabPagerViewController</a> - 多个tab滑动切换。</li>
<li><a href="https://github.com/pozi119/VOMetroLayoutDemo">VOMetroLayoutDemo</a> - Metro风格的UICollectionView, 目前只支持横向布局,仅在iPad上应用。</li>
<li><a href="https://github.com/KittenYang/KYCellAnimation">KYCellAnimation</a> - 给UITableViewCell增加进入的动画。</li>
<li><a href="https://github.com/knutigro/COBezierTableView">COBezierTableView</a> - swift，通过编辑 Bezier 曲线四点位置设置 TableView 内 Cell 及对应按扭位置。实验效果很赞。</li>
<li><a href="https://github.com/robbdimitrov/RDVTabBarController">RDVTabBarController</a> - 一个TabBar组件，可以方便设置底部菜单的文字图片，点击效果，小红点提示等。</li>
<li><a href="https://github.com/DeveloperLx/LxTabBarController">LxTabBarController</a> - 改变了原生tabbar切换tab时的生硬效果，并加入滑动切换手势（有和界面上的其它手势发生冲突的风险，可根据具体项目予以关闭），<a href="https://github.com/DeveloperLx/LxTabBarController-swift">swift版本</a>。</li>
<li><a href="https://github.com/leichunfeng/WXTabBarController">WXTabBarController</a> - 在系统 UITabBarController 的基础上完美实现了安卓版微信 TabBar 的滑动切换功能，单手操作 iPhone 6 Plus 切换 TabBar 一直是一件很痛苦的事情，而滑动切换是一种不错的解决方案，支持屏幕旋转。</li>
<li><a href="https://github.com/KittenYang/GooeyTabbar">GooeyTabbar</a> - 皮筋式弹性缩放工具栏示例及演示。</li>
<li><a href="https://github.com/ChenYilong/CYLTabBarController">CYLTabBarController</a> - 低耦合集成TabBarController,最低只需传两个数组即可完成主流App框架搭建。</li>
<li><a href="http://d.cocoachina.com/code/detail/298409">横向展示文本内容的自定义cell</a> - 可以横向展示文本内容的自定义cell，根据文本无限滚动。</li>
<li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell">UITableView-FDTemplateLayoutCell</a> - UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。</li>
<li><a href="https://github.com/jozsef-vesza/ExpandingStackCells">ExpandingStackCells</a> - 采用 UIStackView 实现表格单元格扩展内容显示示例及解决方案。</li>
<li><a href="https://github.com/forkingdog/FDStackView">FDStackView</a> - 可以将 UIStackView 的最低支持版本拉低到 iOS6，无需配置，没有代码侵染，扔到工程里后直接用系统 UIStackView 的 API 即可，同时兼容 Storyboard。</li>
<li><a href="https://github.com/nghialv/Sapporo">Sapporo</a> - swift 单元格模型驱动的集合视图管理器组件。又一个超实用的“轮子”。</li>
<li><a href="https://github.com/WeeTom/MDIHorizontalSectionTableViewController">MDIHorizontalSectionTableViewController</a> - 根据产品需求开源了一个交互项目，可以理解为横向Section的TableView，section和cell同时支持拖拽，后续安卓版本也会开源出来。</li>
<li><a href="https://github.com/JazysYu/JZNavigationExtension">JZNavigationExtension</a> - 多功能导航控制器，可以透明返回栏。</li>
<li><a href="https://github.com/itjhDev/NavTopImage">NavTopImage.swift</a> - NavigationController动态缩放titleView。</li>
<li><a href="https://github.com/okla/QuickRearrangeTableView">QuickRearrangeTableView</a> - 基于 UITableView 的快速重排功能扩展子类。通过长按选定单元格然后滚动移动到指定位置。</li>
<li><a href="https://github.com/nshintio/uicollectionview-reordering">uicollectionview-reordering</a> - UICollectionViews的拖拽(拖动、移动)效果,<a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/">实例教程</a>.</li>
<li><a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a> - DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理。</li>
<li><a href="https://github.com/LvJianfeng/LLNoDataView">LLNoDataView</a> - 超简单的空数据提示通用View支持UIScrollView、UITableView、UICollectionView、UIWebView。</li>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell">MGSwipeTableCell</a> - 另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。</li>
<li><a href="https://github.com/HebeTienCoder/XLPlainFlowLayout">XLPlainFlowLayout</a> - 可以让UICollectionView的header也支持悬停效果，类似于tableView的Plain风格。</li>
<li><a href="https://github.com/wangmchn/WMPageController">WMPageController</a> - 一个方便的 pageContrller 的控件，里面还包括滚动视图。</li>
<li><a href="https://github.com/steipete/PSTCollectionView">PSTCollectionView</a> - PSTCollectionView。</li>
<li><a href="https://github.com/lianleven/LLRiseTabBar-iOS">LLRiseTabBar-iOS</a> - 直接使用系统的特性实现的tabbar，比较简单。</li>
<li><a href="https://github.com/MartinRGB/MTMaterialDelete">MTMaterialDelete</a> - 非常有趣的Material Design动画，动画删除表里面的单元格。</li>
<li><a href="https://github.com/Ramotion/paper-onboarding">paper-onboarding.swift</a> - 漂亮的 material design 风格页面滑块。示例完整，易用。</li>
<li><a href="https://github.com/CosmicMind/Material">Material.swift</a> - 基于 Material Design 动画和图像框架库 （作者 Daniel Dahan）。</li>
<li><a href="https://github.com/gmertk/BusyNavigationBar">BusyNavigationBar</a> - 进度条式NavigationBar导航条。</li>
<li><a href="https://github.com/cemolcay/ReorderableGridView-Swift">ReorderableGridView-Swift</a> - 拖拽排序卡片。</li>
<li><a href="https://github.com/LiGoEX/LGSettingView">LGSettingView</a> - LGSettingView仅需三句代码即可快速集成设置界面，免去每次开发新应用都要重新布置设置界面的烦恼。</li>
<li><a href="http://code.cocoachina.com/view/129212">微博cell自动布局</a> - 使用autoLayout对微博的cell进行自动布局，自适应cell的高度。</li>
<li><a href="https://github.com/TyroneWing/TreeTableView">TreeTableView</a> - ZYTreeTableView：TreeView 模仿好友列表的实现方式。</li>
<li><a href="https://github.com/squarezw/ZWSlideViewController">ZWSlideViewController</a> - ZWSlideViewController多页滑动视图控制器（类似新闻类门户APP）,可以用最简单的继承方法使用，也可以不用继承，只用菜单或主视图页面，可实现丰富的定制，可以使用在多种不同形态的APP下，还可以将其做为多页或多图的滑动介绍。</li>
<li><a href="https://github.com/liuzhiyi1992/ZYThumbnailTableView">ZYThumbnailTableView.swift</a> - 可展开型预览TableView，开放接口，完全自由定制。<a href="http://zyden.vicp.cc/zythumbnailtableview/">实现教程</a></li>
<li><a href="https://github.com/wazrx/XWCatergoryView">XWCatergoryView</a> - 一个轻量级的顶部分类视图控件，只需要通过简单的设置，你就可以快速集成该控件， 控件目前暂时有底部横条移动，椭圆背景移动，文字缩放，文字颜色变化，和文字颜色渐变五种效果，五种效果可以叠加使用也可以单一使用。<a href="http://www.jianshu.com/p/274d19f97564">实现教程</a></li>
<li><a href="http://code.cocoachina.com/view/129675">jingDongFenLei</a> - 简单仿写京东分类中的多级分类页面。</li>
<li><a href="https://github.com/netyouli/WHC_CollectionViewFramework">WHC_CollectionViewFramework.swift</a> - 高仿支付宝可拖拽排序编辑动画效果cell的CollectionView集合视图。</li>
<li><a href="https://github.com/fortmarek/SwipeViewController">SwipeViewController.swift</a> - 一款好用的页面滑动和标签选项卡类库及示例。功能相当于 Objective-C 版 RKSwipeBetweenViewControllers。</li>
<li><a href="https://github.com/cwRichardKim/RKSwipeBetweenViewControllers">RKSwipeBetweenViewControllers</a> - 页面滑动和标签选项卡类库。</li>
<li><a href="http://www.cocoachina.com/ios/20160407/15870.html">FriendSearch</a> - 两种UI的搜索，搜索的算法可以满足中英文互搜，联想搜索等，其中还包含对一组数据自动进行按字母分组等功能。</li>
<li><a href="https://github.com/yixiangboy/YX_UITableView_IN_UITableView">YX_UITableView_IN_UITableView</a> - UITableview嵌套UITableView案例实践（仿淘宝商品详情页实现），<a href="http://blog.csdn.net/yixiangboy/article/details/51009010">项目讲解</a>。</li>
<li><a href="https://github.com/winslowdibona/TabDrawer">TabDrawer.swift</a> - 更适合单手操作的可定制 Tab Bar 组件库。P.S. 自动布局选择了 EasyPeasy。</li>
<li><a href="https://github.com/fdzsergio/SFFocusViewLayout">SFFocusViewLayout.swift</a> - UICollectionViewLayout实现的图片浏览器。</li>
<li><a href="https://github.com/12207480/TYPagerController">TYPagerController</a> - 简单，支持定制，页面控制器,可以滚动内容和标题栏,包含多种style。</li>
<li><a href="https://github.com/eggswift/ESTabBarController">ESTabBarController.swift</a> - 自定义TabBarController组件，继承自UITabBarControlle，可添加动画和自定义样式。<a href="http://www.jianshu.com/p/9e52630e7368">swift 高度自定义TabBarController，支持自定义TabBarItem样式或添加动画</a></li>
</ul>


<h5>隐藏与显示</h5>

<ul>
<li><a href="http://d.cocoachina.com/code/detail/286102">SlideTapBar</a> - 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。</li>
<li><a href="https://github.com/Yalantis/FoldingTabBar.iOS">FoldingTabBar.iOS</a> - 可折叠Tab Bar和Tab Bar Controller。</li>
<li><a href="https://github.com/ltebean/LTNavigationBar">LTNavigationBar</a> - LTNavigationBar为app导航栏添加动态着色效果，可自定义其背景色。Demo包含：1.变换背景色；2.滚动视图，导航栏和状态栏重叠。<a href="http://tech.glowing.com/cn/change-uinavigationbar-backgroundcolor-dynamically/">实现教程</a></li>
<li><a href="https://github.com/MoZhouqi/KMNavigationBarTransition">KMNavigationBarTransition</a> - LTNavigationBar在右滑返回的时候NavigationBar显示都不完美,KMNavigationBarTransition一个用来统一管理导航栏转场以及当 push 或者 pop 的时候使动画效果更加顺滑的通用库，并且同时支持竖屏和横屏。</li>
<li><a href="https://github.com/HelloYeah/HYNavBarHidden">HYNavBarHidden</a> - 导航条滚动透明，超简单好用的监听滚动,导航条渐隐的UI效果实现。</li>
<li><a href="https://github.com/bryankeller/BLKFlexibleHeightBar">BLKFlexibleHeightBar</a> - 固定Header的效果库，一个拥有非常灵活高度的标题栏，可以为使用软件的用户提供更多的阅读和滑动空间，现在已经被众多app所采用。</li>
<li><a href="https://github.com/kukumaluCN/JXT_iOS_Demos">JXT_iOS_Demos</a> - AboutNavigationBar:一些关于navigationBar的非常规的但是较为实用的操作，包括利用毛玻璃、动态透明、动态隐藏，以及头视图的动态缩放，并同时涉及了statusBar的动态设置（换色）。<a href="http://www.jianshu.com/p/b2585c37e14b">教程</a>。</li>
<li><a href="https://github.com/CoderJackyHuang/NavigationBarScaleViewDemo">NavigationBarScaleViewDemo</a> - iOS导航条自由缩放头像效果。<a href="http://www.henishuo.com/nav-photo-scale/">原理剖析</a>。</li>
</ul>


<h5>HUD与Toast</h5>

<ul>
<li><a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> - 最多人用的loading。</li>
<li><a href="https://github.com/LvJianfeng/EBuyCommon">EBuyCommon</a> - 1.基于MBProgressHUD实现得图形加载提示方式，及其它标题方式提醒。2.弹窗。</li>
<li><a href="https://github.com/SVProgressHUD/SVProgressHUD">SVProgressHUD</a> - SVProgressHUD的loading，如果你需要定制化的等待提示器，这个就是了（也许是最好的）。</li>
<li><a href="https://github.com/relatedcode/ProgressHUD">ProgressHUD</a> - ProgressHUD的loading，使用最简单。</li>
<li><a href="https://github.com/mutualmobile/MMProgressHUD">MMProgressHUD</a> - 设置HUD出现和消失的方式（包括上下、左右、淡入淡出、放大缩小等等），设置HUD的内容（可以在HUD中加入帧动画、动态图片等等），设置HUD出现时的底部覆盖层颜色，等等。总而言之，这是一份集大成的HUD代码。慢慢看视频吧，囊括了所有效果。</li>
<li><a href="https://github.com/devSC/WSProgressHUD">WSProgressHUD</a> - 一个小巧精致的HUD,支持添加到自定义View上, 还有更多小细节.。</li>
<li><a href="https://github.com/liuzhiyi1992/PreLoader">PreLoader</a> - 一个很有意思的HUD loading ，通过运动污点和固定污点之间的粘黏动画吸引用户的眼球跟踪，能有效分散等待注意力。<a href="http://www.cocoachina.com/ios/20160427/16029.html">PreLoader的实现讲解</a></li>
<li><a href="https://github.com/scalessec/Toast-Swift">Toast-Swift</a> - 高可定制易用的 Toast 弹出信息或通知用户界面组件类。</li>
</ul>


<h5>对话框</h5>

<ul>
<li><a href="https://github.com/m1entus/WCAlertView">WCAlertView</a> - 自定义的对话框。</li>
<li><a href="https://github.com/wimagguc/ios-custom-alertview">IOS7AlertView</a> - IOS7AlertView的对话框。</li>
<li><a href="https://github.com/mtonio91/AMSmoothAlert">AMSmoothAlert</a> - 动画效果不错，最多star，但不支持arm64。</li>
<li><a href="https://github.com/dinhquan/DQAlertView">DQAlertView</a> - 扁平化的样式不错。</li>
<li><a href="https://github.com/mrchenhao/HHAlertView">HHAlertView</a> - 一个简易的alertview  有三种样式，有成功，失败，和警告三种样式，支持Delegate和block两种回调。</li>
<li><a href="https://github.com/martinjuhasz/MJPopupViewController">MJPopupViewController</a> - 实现弹出视图的各种弹出和消失效果，包括淡入淡出（fade in，fade out），从屏幕上方飞进，下方飞出，从屏幕左方飞进，右方飞出等等效果，弹窗。</li>
<li><a href="https://github.com/adad184/MMPopupView">MMPopupView</a> - 弹出框的基类组件（弹窗）。</li>
<li><a href="https://github.com/fengchuanxiang/Menu">Menu</a> - 项目中可能会用到的常用菜单，以后有时间会继续补充，弹窗。</li>
<li><a href="https://github.com/teodorpatras/EasyTipView">EasyTipView</a> - 弹出提示框类及演示示例。同样地，API 简单、易用。好“轮子”，弹窗。</li>
<li><a href="https://github.com/kolyvan/kxmenu">kxmenu</a> - kxmenu弹出菜单，点击视图上任意位置的按钮，会弹出一个菜单，并且有个小箭头指向点击的按钮，类似气泡视图。弹出的菜单位置会根据按钮的位置来进行调整。</li>
<li><a href="https://github.com/questbeat/QBPopupMenu">QBPopupMenu</a> - QBPopupMenu弹出菜单，实现类似 UIMenuItem 的弹出菜单按钮。点击按钮，会弹出一个菜单，上面可以排列多个按钮。纯代码实现，不需要任何图片。</li>
<li><a href="https://github.com/zhenlintie/STModalDemo">STModalDemo</a> - 弹出视图（通知，提示，选择，窗口）。</li>
<li><a href="https://github.com/TaimurAyaz/TAOverlay">TAOverlay</a> - TAOverlay可通过叠加层展示有用的信息，可自定义文本和背景色，添加阴影和模糊效果，以及更改字体大小或者用自定义图片替换页面上的icon。</li>
<li><a href="https://github.com/pchernovolenko/UICustomActionSheet">UICustomActionSheet</a> - 通过模糊背景来着重强调与菜单相关的元素&ndash;模糊效果 里面已经收藏。</li>
<li><a href="http://code.cocoachina.com/detail/232178">ActionSheetPicker-3.0</a> - 该项目是此前热门项目ActionSheetPicker的新版本，快速复制了iOS 8上的下拉 UIPickerView/ActionSheet功能。</li>
<li><a href="https://github.com/mayuur/MJAlertView">MJAlertView</a> - 3D效果转场效果警示图&ndash;MJAlertView。</li>
<li><a href="https://github.com/morizotter/SwiftyDrop">SwiftyDrop</a> - 轻量、易用的小清新弹出列表及信息提示组件真心不错。</li>
<li><a href="https://github.com/steipete/PSTAlertController">PSTAlertController</a> - 兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，做到高低版本通用。</li>
<li><a href="https://github.com/hryk224/PCLBlurEffectAlert">PCLBlurEffectAlert.swfit</a> - 细节定制较丰富的弹出警报窗口组件。</li>
<li><a href="https://github.com/wxxsw/GSAlert">GSAlert.swfit</a> - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。</li>
<li><a href="https://github.com/codestergit/SweetAlert-iOS">SweetAlert-iOS</a> - SweetAlert-iOS 带动画效果弹窗对话框封装类。</li>
<li><a href="https://github.com/xiekw2010/DXPopover">DXPopover</a> - DXPopover微信右上角的+点击展示列表效果，弹窗菜单。</li>
<li><a href="https://github.com/maxmoo/CCActionSheet">CCActionSheet</a> - CCActionSheet：仿照微信朋友圈自定义actionsheet，一行代码即可使用。</li>
<li><a href="https://github.com/entotsu/TKSwarmAlert">TKSwarmAlert.swift</a> - TKSwarmAlert.swift:模仿 Swarm app 的 Alert 提醒框动画工具。</li>
<li><a href="https://github.com/maltsugar/CustomPopOverView">CustomPopOverView</a> - 自定义弹出视图，内容支持传一组菜单标题，也支持自定义view，或者自定义viewController，支持任意按钮触发，会显示在按钮底部，也支持切换按钮的对齐方式：左对齐、居中、右对齐。</li>
<li><a href="https://github.com/Codeido/PMAlertController">PMAlertController.Swift</a> - 可定制弹窗组件替代官版不可定制的 UIAlertController。</li>
<li><a href="https://github.com/yulingtianxia/TBActionSheet">TBActionSheet.swift</a> - 支持Carthage，可自定义度100%的 ActionSheet，支持微信样式。</li>
</ul>


<h5>其他UI</h5>

<ul>
<li><a href="https://github.com/levey/AwesomeMenu">AwesomeMenu</a> - 最多人用的Path菜单。</li>
<li><a href="https://github.com/Tangdixi/DCPathButton">DCPathButton</a> - Path，4.0的弹出菜单，呼出或者关闭菜单时，多个小图标会分别按照逆时针和顺时针的方向进行滚动。</li>
<li><a href="https://github.com/itouch2/SphereMenu">SphereMenu</a> - 利用UIDynamicAnimator的有趣的菜单，path类似。</li>
<li><a href="https://github.com/KittenYang/KYGooeyMenu">KYGooeyMenu</a> - KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件(卫星菜单、path)。</li>
<li><a href="https://github.com/yoavlt/LiquidFloatingActionButton">LiquidFloatingActionButton</a> - 卫星弹出菜单。</li>
<li><a href="https://github.com/JustinFincher/JZMultiChoicesCircleButton">JZMultiChoicesCircleButton</a> - 三维多选按钮。</li>
<li><a href="https://github.com/lianchengjiang/LCUIKit">LCUIKit</a> - 一个button上面既有icon又有文字。也许左icon右文字，或者上icon下文字。</li>
<li><a href="https://github.com/xhzengAIB/XHTwitterPaggingViewer">TwitterPaggingViewer</a>  - 多个Tableview，左右滑动。</li>
<li><a href="https://github.com/carantes/CircularProgressControl">CircularProgressControl</a> - Circular Progress Control using CAShapeLayer ，环形进度控制条。</li>
<li><a href="https://github.com/kentya6/KYCircularProgress">KYCircularProgress</a> - 简单、实用路径可定进程条。</li>
<li><a href="https://github.com/kaandedeoglu/KDCircularProgress">KDCircularProgress</a> -  KDCircularProgress是使用swift制作的色彩炫丽的进度条，可以加入多种颜色来控制进度条的渐变效果。</li>
<li><a href="https://github.com/cgwangding/TextProgress">TextProgress</a> - 自定义实现数字进度条：1、可以自定义数字（0-100），填充的比例为当前设置的数字，2、可以实现自定义填充颜色，上下部分都可以，3、可以自定义边界的颜色4、实现了水波动画，可以设置打开或关闭。</li>
<li><a href="https://github.com/gsdios/SDProgressView">SDProgressView</a> - 简便美观的进度指示器，此系列共有六种样式的进度指示器。</li>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView">NVActivityIndicatorView</a> -  loading 进度条动画，有20-30多种，是在此<a href="https://github.com/gontovnik/DGActivityIndicatorView">DGActivityIndicatorView</a> 基础上做得修改。</li>
<li><a href="https://github.com/saitjr/STLoopProgressView">LoopProgressDemo</a> - 环形渐变进度条，<a href="http://www.superqq.com/blog/2015/08/12/realization-circular-gradient-progress/">环形渐变进度条实现</a>。</li>
<li><a href="https://github.com/xmartlabs/XLPagerTabStrip">XLPagerTabStrip</a> - 做的很棒的iOS下的PagerTabStrip。</li>
<li><a href="https://github.com/alskipp/ASProgressPopUpView">ASProgressPopUpView</a> - 弹出的进度条显示进度。</li>
<li><a href="https://github.com/onevcat/RandomColorSwift">RandomColorSwift</a> - 一个自动生成好看的颜色的 Swift 库，RandomColorSwift。</li>
<li><a href="https://github.com/hyperoslo/Hue">Hue.Swift</a> - Hue.Swift：颜色常规功能集于一身的定义、使用 Color 工具类库（含图片取色）。</li>
<li><a href="https://github.com/bestswifter/MySampleCode/tree/master/KtColor">KtColor.swift</a> - 利用 Swift 的语法特性简化创建 UIColor对象的过程。具体文章可以参考博客：<a href="http://www.jianshu.com/p/f2173235cde8">当UIColor遇上 Swift</a>。</li>
<li><a href="https://github.com/ChangweiZhang/HexColorService">HexColorService</a> - 将16进制颜色字符串转成UIColor。</li>
<li><a href="https://github.com/NorthernRealities/Rainbow">Rainbow</a> - 旨在提高代码可读性及易用性的 UIColor 扩展，它使原先有限的预定义颜色（方法）选择，扩展至超过 1200 种。</li>
<li><a href="https://github.com/zhxnlai/UIColor-ChineseTraditionalColors">UIColor-ChineseTraditionalColors</a> - 中国传统颜色引用 UIColor 扩展。“UIColor.桃红()，UIColor.竹青() &hellip;”，共158种。</li>
<li><a href="https://github.com/MakeBetterMe/YPDropMenuViewDemo">YPDropMenuViewDemo.swift</a> - 一款DropMenu,menuView,类似之前美团的下拉菜单，支持swift2.2，因为用到iOS8.的毛玻璃。所以想支持到iOS8.0,支持自定义，支持等宽排列，支持从左向右排列。</li>
<li><a href="http://code.cocoachina.com/detail/284158">类似美团的下拉菜单</a> - 类似美团的下拉菜单，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="http://code4app.com/ios/%E7%B1%BB%E4%BC%BC%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E9%80%89%E9%A1%B9/538606d4933bf06e0a8b496e">类似美团的下拉选项</a> -  类似于美团、大众点评的下拉菜单选项，code4app代码，评论代码有瑕疵。</li>
<li><a href="http://code.cocoachina.com/detail/284267">CRMediaPickerController</a> - 一个简单易用的图片/视频选择器。1.可同时选择照片和视频。 2.挑选范围有Camera、Camera Roll、Photo Library以及最近拍摄的照片和视频。3.可自定义UIImagePickerController属性（Camera Overlay、Camera Device、Camera View Transform以及allowsEditing）。4.支持横屏和竖屏5.原生的iOS UI。，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChoose</a> - MDCSwipeToChoose可简单地添加滑动手势来调用UIView，并使用该行为提供了一个组件以创建类似Tinder app的like或者dislike界面的轻扫。基于轻扫的方向，你可以决定执行什么样的行为，并且你可以自定义文本颜色和图片。该项目适用于教学用的抽认卡、图片查看器以及其他等。</li>
<li><a href="http://d.cocoachina.com/code/detail/285611">iOS Material Design库</a> - 该项目借鉴于谷歌的Material Design guideline，用户可自定义背景色。</li>
<li><a href="https://github.com/fpt-software/Material-Controls-For-iOS">Material-Controls-For-iOS</a> - Material Design风格的各种控件，非常完整全面。</li>
<li><a href="https://github.com/richzertuche/ZMaterialDesignUIButton">ZMaterialDesignUIButton</a> - Swift Material Design UIButton。</li>
<li><a href="https://github.com/pixyzehn/MediumScrollFullScreen">MediumScrollFullScreen</a> - Medium的可扩展滚动页面，上下滚动时，全屏显示内容，并自然消隐上下菜单。由此项目感知，作者是一位很注重细节的开发者，他的另外<a href="https://github.com/pixyzehn">几个菜单类项目</a>也都不错，值得参考，比如：PathMenu, MediumMenu 等。</li>
<li><a href="https://github.com/SatanWoo/WZFlashButton">WZFlashButton</a> - WZFlashButton，点击后button里面出现水波扩散效果。</li>
<li><a href="https://github.com/piemonte/Twinkle">Twinkle</a> - 为字体加上钻石版闪耀的效果。使用Swift编写。</li>
<li><a href="https://github.com/palmin/ios-multi-back-button">ios-multi-back-button</a> - 可替换内置的UInavigationController返回按钮，长按左上角的返回按钮，实现多层级的快速返回。</li>
<li><a href="http://code.cocoachina.com/detail/226543">ASDayPicker</a> - 适用于iOS (iPhone)的日期选择器(时间选择器)，类似于Calendar app的周视图。</li>
<li><a href="http://adad184.com/2014/10/29/2014-10-29-how-to-setup-today-extension-programmatically/">today extension</a> - 用纯代码构建一个Widget(today extension) 。</li>
<li><a href="https://github.com/WenchaoD/FSCalendar">FSCalendar</a> - 日历视图，带有微妙和平滑的滚动效果，可自定义外观&ndash;国人。</li>
<li><a href="https://github.com/Mozharovsky/CVCalendar">CVCalendar</a> - 是一个方便开发者集成自定义日历视图到自己 iOS 应用的项目, 支持 Storyboard 和手动配置, 使用 CocoaPods 进行安装, 提供了丰富的 API 供开发者使用。</li>
<li><a href="https://github.com/EmilYo/HSDatePickerViewController">HSDatePickerViewController</a> - 带有Dropbox Mailbox感觉的时间日期选择器(时间选择器)。启动是背景被模糊化。界面也是主流的扁平化风格。</li>
<li><a href="https://github.com/huzhiqin/HZQDatePickerView">HZQDatePickerView</a> - 自定义时间选择器(日期选择器)，包括开始日期和结束日期两种类型。</li>
<li><a href="https://github.com/CharlinFeng/CFCityPickerVC">CFCityPickerVC</a> - 城市选取控制器。</li>
<li><a href="https://github.com/jonathantribouharet/JTCalendar">JTCalendar</a> - iOS下优美的 Calendar 组件，做 GTD 类 App 必备。</li>
<li><a href="https://github.com/Yalantis/Persei">Persei</a> - 动画隐藏或显示顶部菜单支持库及示例项目。&ndash;swift</li>
<li><a href="https://github.com/jivesoftware/PDTSimpleCalendar">PDTSimpleCalendar</a> - 是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。</li>
<li><a href="https://github.com/MrMage/DateRangePicker">DateRangePicker.swift</a> - 可能是目前最好的 OS X 日期选择器,高扩展性，界面风格看起来很舒服，不过注意，是 OS X 开发专用。</li>
<li><a href="https://github.com/hyperoslo/Form">Form</a> - JSON 驱动的 Form表单系统，复杂的表单填写类 App 极其需要（比如淘宝呢！）。</li>
<li><a href="https://github.com/neoneye/SwiftyFORM">SwiftyFORM</a> - swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件。</li>
<li><a href="https://github.com/icanzilb/SwiftSpinner">SwiftSpinner</a> - SwiftSpinner是使用swift制作的一款精致带感的指示器，并且连带有字体信息显示，模糊背景，半透明，扁平化等IOS8的效果。</li>
<li><a href="https://github.com/Akkyie/AKPickerView-Swift">AKPickerView-Swift</a> - 一款小而美的 3D 效果选择器。</li>
<li><a href="https://github.com/larcus94/ImagePickerSheetController">ImagePickerSheetController</a> - 图片或视频选择器（可多选）组件及其示例项目。</li>
<li><a href="https://github.com/saiwu-bigkoo/iOS-RatingBar">iOS-RatingBar</a> - iOS-RatingBar swift版的评分控件,跟Android的RatingBar一样有两种模式，评分模式和只读模式'支持视图编辑，自定义星星数量，评分等级,另外还能支持非整数星，0.5颗星，0.1颗星,可以开启动画效果。</li>
<li><a href="https://github.com/cwRichardKim/RKNotificationHub">RKNotificationHub</a> - 快速给 UIView 添加上炫酷的通知图标（Badge、红点、提示）。  * <a href="https://github.com/weng1250/WZLBadge">WZLBadge</a> - Badge，支持横竖屏支持iOS5~iOS8允许高度定制化，包括“红点”的背景颜色，文字(字体大小、颜色)，位置等。<a href="http://code.cocoachina.com/detail/316890/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A8%E9%80%81%E5%B0%8F%E7%BA%A2%E7%82%B9/">说明</a>.</li>
<li><a href="https://github.com/andreamazz/BubbleTransition">BubbleTransition</a> - 以气泡膨胀和缩小的动画效果来显示和移除 controller，Uber的就是这种取消操作的方式。</li>
<li><a href="https://github.com/KittenYang/KYFloatingBubble">KYFloatingBubble</a> - 类似iOS7中Game Center浮动气泡的效果。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - DKNightVersion 是一个支持夜间模式切换的框架。</li>
<li><a href="https://github.com/sx1989827/EasyUIControl">EasyUIControl</a> - 一个可以简化界面ui的控件框架。</li>
<li><a href="https://github.com/DeveloperLx/LxGridView">LxGridView-oc</a> <a href="https://github.com/DeveloperLx/LxGridView-swift">LxGridView-swift</a> - 利用UICollectionView模仿iOS系统桌面图标的交互，作用如动图。</li>
<li><a href="https://github.com/ZhongTaoTian/QQBtn">QQBtn</a> - 仿QQ未读消息弹性按钮动画，达到和手机QQ未读信息一样的动画效果，效果基本实现。</li>
<li><a href="https://github.com/gmertk/GMStepper">GMStepper</a> - swift 带动画效果、支持手势滑动操作的步进标签。</li>
<li><a href="https://github.com/tomvanzummeren/TZStackView">TZStackView</a> - OS 9 UIStackView 功能模拟实现于 iOS 7/ iOS 8 内。</li>
<li><a href="https://github.com/yushuyi/LayoutTrait">LayoutTrait</a> - swift 一个小类库。 做iPad 多任务分屏 适配的同学可以看一下。</li>
<li><a href="https://github.com/HAHAKea/HACursor">HACursor</a> - HACursor，是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能。</li>
<li><a href="https://github.com/wuzhentao/ZTPageController">ZTPageController</a> - 模仿网易新闻和其他新闻样式做的一个菜单栏，栏中有各自的控制器，其中有4中展示样式’网易style' ’搜狐style' ’腾讯style1' ’网易style2' 。</li>
<li><a href="https://github.com/nixzhu/Ruler">Ruler</a> - 尺子。</li>
<li><a href="https://github.com/justhum/HUMSlider">HUMSlider</a> - HUMSlider是一款能够自动显示刻度记号的滑竿，滑动到某处，该处的刻度会自动上升，两边还能配置图像。支持代码或storyboard中实现。</li>
<li><a href="https://github.com/zhangli4659507/JDSelectedDemo">JDSelectedDemo</a> - 仿京东筛选菜单实现。</li>
<li><a href="https://github.com/PhamBaTho/BTNavigationDropdownMenu">BTNavigationDropdownMenu</a> -  下拉列表暨导航标题组件。简单、直接、易用 -swift。</li>
<li><a href="https://github.com/luzefeng/3DTouchDemo">3DTouchDemo</a> - 详细介绍了每个参数的含义和3Dtouch的入口，保证包学包会。</li>
<li><a href="https://github.com/RichardLeung/3DTouchSample">3DTouchSample</a> - 3D-Touch的功能分为两个部分：Shortcut和Preview。</li>
<li><a href="https://github.com/DeskConnect/SBShortcutMenuSimulator">SBShortcutMenuSimulator</a> - 教你如何在模拟器上测试 3D Touch 功能!</li>
<li><a href="https://github.com/richzertuche/InceptionTouch">InceptionTouch.swift</a> - 让没有 3D Touch 设备也有类似交互体验的 InceptionTouch 类（基于 UITextView 实现，支持日期，链接，电话号码，地址触摸响应）。</li>
<li><a href="http://code.cocoachina.com/view/128287">仿LOL滚动视图</a> - 仿LOL滚动视图。</li>
<li><a href="http://code.cocoachina.com/view/128281">答题选择切换页</a> - 将scrollview和tableview封装在一起，在初始化的时候简单的将数据带上，就可以一页一页的左右来回滑动。</li>
<li><a href="https://github.com/SergioChan/SCTrelloNavigation">SCTrelloNavigation</a> - 类似trello的导航动效控件实现。</li>
<li><a href="https://github.com/Akateason/XTPaster">XTPaster</a> - 贴纸功能出现在很多图片社交中, 就是图片上面贴图片, 对贴纸而言就是需要控制贴纸的位置,旋转,大小,<a href="http://www.jianshu.com/p/d873d348bbfb">如何使用</a>。</li>
<li><a href="https://github.com/refinemobi/RGCategoryView">RGCategoryView</a> - 仿了个苏宁易购的分类页面。</li>
<li><a href="https://github.com/txaidw/TWControls">TWControls.swift</a> - 简单的开关和按钮控制器,使用闭包来执行由控件触发的操作。</li>
<li><a href="https://github.com/ephread/Instructions">Instructions.swift</a> - 可定制嵌入式操作指引框架及演示。</li>
<li><a href="https://github.com/Lves/LLPieCharts">LLPieCharts</a> - LLPieCharts iOS 绘制饼图，<a href="http://www.lvesli.com/?p=339">教程</a>。</li>
<li><a href="https://github.com/Boris-Em/BEMCheckBox">BEMCheckBox</a> - BEMCheckBox 是一个用于 iOS 应用上构建漂亮, 高度可定制化动画效果的复选框类库, 最低支持到 iOS 7 系统, 有多种不同风格的动画效果可供选择。</li>
<li><a href="https://github.com/kevin0571/STPopup">STPopup</a> - 提供了一个可在 iPhone 和 iPad 上使用的具有 UINavigationController 弹出效果的 STPopupController 类, 并能在 Storyboard 上很好的工。</li>
<li><a href="https://github.com/victorBaro/VBFPopFlatButton">VBFPopFlatButton</a> - 通过几条线段实现的非常Q萌的动画按钮效果。</li>
<li><a href="https://github.com/richzertuche/ZSeatSelector">ZSeatSelector</a> - 电影院位置排座位。</li>
<li><a href="https://github.com/zangqilong198812/CustomSearchBar">CustomSearchBar</a> - 自定义searchbar,类似于instagram的搜索框效果。</li>
<li><a href="https://github.com/LeoNatan/LNPopupController">LNPopupController</a> - AppleMusic式pop up，弹出是页面，可以上下拉动。</li>
<li><a href="https://github.com/gontovnik/DGRunkeeperSwitch/">DGRunkeeperSwitch</a> - 动画segment，节选器。</li>
<li><a href="https://github.com/KittenYang/DynamicMaskSegmentSwitch">DynamicMaskSegmentSwitch</a> - 一个简单有趣的 SegmentedControl 节选器。</li>
<li><a href="https://github.com/sima-11/SMSegmentView">SMSegmentView.swift</a> - 高可定制化，既支持横向，也支持纵向布局的图文 Segment Control 组件，节选器。</li>
<li><a href="https://github.com/yixiangboy/YXFilmSelectView">YXFilmSelectView</a> - 仿造时光网选择电影票的UI而开发的一个自定义View。</li>
<li><a href="http://code.cocoachina.com/view/129152">FJTagCollectionView</a> - 标签（适配宽度）。</li>
<li><a href="https://github.com/yukiasai/Gecco">Gecco.Swift</a> - Gecco.Swift 是一款支持对视图进行局部高亮的 Swift 库, 帮助 iOS 开发者快速创建产品的新手指导界面。</li>
<li><a href="https://github.com/anyunzhong/DFTimelineView">DFTimelineView</a> - DFTimelineView仿微信朋友圈 时间轴。</li>
<li><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit.swift</a> - AsyncDisplayKit.swift是 facebook的提供异步的界面高流畅性切换及更灵敏的响应框架。</li>
<li><a href="https://github.com/andreamazz/SubtleVolume">SubtleVolume.swift</a> - 更隐蔽的系统音量替代指示器。</li>
<li><a href="https://github.com/shaps80/InkKit">InkKit.swift</a> - 该类库帮助开发者绘制简单图形更容易。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBImageCliped">HYBImageCliped</a> - 可给任意继承UIView的控件添加任意多个圆角、可根据颜色生成图片且可带任意个圆角、给UIButton设置不同状态下的图片且可带任意圆角、给UIImageView设置任意图片，支持带圆角或者直接生成圆形。</li>
<li><a href="https://github.com/mchoe/SwiftSVG">SwiftSVG</a> - 支持多种接口（String, NS/UIBezierPath, CAShapeLayer, and NS/UIView）绘制 SVG 类库。</li>
<li><a href="https://github.com/wangshengjia/LeeGo">LeeGo.swift</a> - 带来更 声明式的，可配置的和易复用的UI开发方式，让UI开发变得像玩乐高积木一样简单直观，某种程度上取代ComponentKit。<a href="http://allblue.me/swift/2016/05/26/LeeGo-chinese-version/">用 struct 和 enum 来构建你的整套 UI</a></li>
<li><a href="https://github.com/prolificinteractive/Caishen">Caishen.swift</a> - 简易、实用的付款输入及校验 UI 组件。</li>
<li><a href="https://github.com/Khan/SwiftTweaks">SwiftTweaks</a> - 不用重新编译即可调整 UI 配置（按钮颜色、背景、动画延迟，简单布局等）的解决方案库。实现了发布生产版本前 UI 的简单配置，省却反复调试代码的麻烦。类似 OC 版 Facebook Tweats。</li>
<li><a href="https://github.com/seedco/StackViewController">StackViewController</a> - 方便 iOS 开发者使用 UIStackView 构建表单或其它静态内容视图。</li>
<li><a href="https://github.com/lilei644/LLBootstrapButton">LLBootstrapButton</a> - Bootstrap 3.0扁平化风格按钮，自带图标，一句代码直接调用！</li>
<li><a href="https://github.com/raozhizhen/JMRoundedCorner">JMRoundedCorner</a> - UIView设置不触发离屏渲染的圆角！</li>
<li><a href="https://github.com/raozhizhen/JMRoundedCornerSwift">JMRoundedCornerSwift</a> - swift版本：UIView设置不触发离屏渲染的圆角！</li>
</ul>


<hr />

<h4>动画</h4>

<ul>
<li><a href="http://www.starming.com/index.php?v=index&amp;view=62">Core Animation笔记，基本的使用方法</a> - Core Animation笔记，基本的使用方法：1.基本动画，2.多步动画，3.沿路径的动画，4.时间函数，5.动画组。</li>
<li><a href="https://github.com/sxyx2008/awesome-ios-animation">awesome-ios-animation</a> - <a href="https://github.com/sxyx2008/DevArticles/issues/91">iOS Animation 主流炫酷动画框架(特效)收集整理</a> 收集整理了下iOS平台下比较主流炫酷的几款动画框架。</li>
<li><a href="https://github.com/Animatious/awesome-animation">awesome-animation</a> -  在内的十多位童鞋们一起发起的一起动画开源组正式成立啦~Github组织名称：Animatious，这是我们第一期成员先前开源的一些动效库，我们的第一个合作开源项目正在紧锣密鼓的准备~请大家期待设计和代码的碰撞吧。</li>
</ul>


<h5>侧滑与右滑返回手势</h5>

<ul>
<li><a href="https://github.com/fastred/SloppySwiper">SloppySwiper</a> - iOS系统自带的UINavigationController要7.0才支持，但不过该手势只能从屏幕左侧边缘识别，如果要扩大到整个屏幕范围怎么办？配合一个SloppySwiper无需代码就可以轻松实现。此库支持iOS5.0以上版本（另外：Nav的title滑动不明显，本人写了2个类似的控件），<a href="https://github.com/Tim9Liu9/SloppySwiper-Example">SloppySwiper-demo</a> ：代码方式与storyboard方式。</li>
<li><a href="https://github.com/singro/SCNavigation">SCNavigation</a> - UINavigation可以右滑返回，隐藏UINavigationBar。</li>
<li><a href="https://github.com/YueRuo/UINavigationController-YRBackGesture">UINavigationController-YRBackGesture</a> - 支持右滑返回手势，标题栏不动。</li>
<li><a href="https://github.com/gresrun/GHSidebarNav">GHSidebarNav</a> - 现在比较流行使用侧开(侧滑)菜单设计。试了不少控件，感觉GHSidebarNav最成熟，尤其对纯代码创建的界面兼容性最好。<a href="http://www.cnblogs.com/zyl910/archive/2013/06/14/ios_storyboard_sidemenu.html">在Storyboard中使用GHSidebarNav侧开菜单控件</a>。</li>
<li><a href="https://github.com/aryaxt/iOS-Slide-Menu">iOS-Slide-Menu</a> - 能够类似Facebook和Path那样弹出左右边栏侧滑菜单,还支持手势。多种可以自定义的属性 (非常不错)。</li>
<li><a href="https://github.com/ECSlidingViewController/ECSlidingViewController">ECSlidingViewController</a> - 侧滑菜单。</li>
<li><a href="https://github.com/gotosleep/JASidePanels">JASidePanels</a> - 侧滑菜单,有左右菜单，有pop功能，支持手势侧滑,本人使用中：简单。</li>
<li><a href="https://github.com/Ramotion/animated-tab-bar">animated-tab-bar</a> - 让 Tabbar items能显示萌萌的动画。</li>
<li><a href="http://code.cocoachina.com/detail/284346">tabbar图标动画</a> - tabbar上图标的动画实现，<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/Yalantis/Side-Menu.iOS/tree/master/SideMenu">SideMenu</a> - swift实现，一款带动画效果可定制 Slide Menu，可以学习其动画实现思路。P.S. 对于Hamburger式菜单，虽然很常用，不过，苹果并不鼓励使用，甚至有开发小组对其弊病用自家上线应用前后数据对比进行了抨击。</li>
<li><a href="https://github.com/romaonthego/RESideMenu">RESideMenu</a> - 侧开菜单，qq类似。</li>
<li><a href="https://github.com/Jiahai/JHMenuTableViewDemo">JHMenuTableViewDemo</a> - 仿网易邮箱列表侧滑菜单。</li>
<li><a href="https://github.com/xudafeng/SlideMenuView">SlideMenuView</a> - 炫酷侧滑菜单布局框架，<a href="Android%20%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%80%E8%87%B4%E5%AE%9E%E7%8E%B0%E8%AF%B7%E8%A7%81%EF%BC%9Ahttps://github.com/xudafeng/SlidingMenu">Android版本的一致实现</a>。</li>
<li><a href="https://github.com/shinept/QQConfiguration">QQConfiguration</a> - swift，QQ-iPhone端框架，左侧菜单栏拖动手势。</li>
<li><a href="https://github.com/KyleGoddard/KGFloatingDrawer">KGFloatingDrawer</a> - 侧滑菜单，qq类似，KyleGoddard/KGFloatingDrawer：一款适合于大屏手机或平板的浮动抽屉式导航界面组件。效果很赞- 侧开菜单，qq类似（与RESideMenu类似）。</li>
<li><a href="https://github.com/cocoatoucher/AIFlatSwitch">AIFlatSwitch</a> - 一款带平滑过渡动画的 Switch 组件类，类相同风格的 Menu/Back<a href="https://github.com/fastred/HamburgerButton">HamburgerButton</a>,类似相同风格的 Menu/Close<a href="https://github.com/robb/hamburger-button">hamburger-button</a>.</li>
<li><a href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a> - 在应用中采用链式写出酷炫的动画效果, 使代码更加清晰易读，利用block实现的链式编程。</li>
<li><a href="https://github.com/WXGBridgeQ/WXGSlideMenuDemo">WXGSlideMenuDemo</a> - 个简单实现侧拉（侧滑）菜单的小demo，供初学者共同学习、练习使用。</li>
<li><a href="https://github.com/pkluz/PKRevealController">PKRevealController</a> - PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷），这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。</li>
<li><a href="https://github.com/GabrielAlva/SwiftPages">SwiftPages</a> - 高可定制类似 Instagram 视图滑动切换功能类库。API 简单、易用。</li>
<li><a href="https://github.com/michaelhenry/FlipBoardNavigationController">FlipBoardNavigationController</a> - FlipBoardNavigationController。</li>
<li><a href="https://github.com/mutualmobile/MMDrawerController">MMDrawerController</a> - 最多人用的一个有关侧边“抽屉”导航框架，里面还有很多你意想不到的交互效果，侧滑。</li>
<li><a href="http://code.cocoachina.com/detail/316925/UIWebView%E7%BF%BB%E9%A1%B5%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C%EF%BC%88%E5%8F%98%E9%80%9A%E6%96%B9%E6%B3%95%EF%BC%89/">UIWebView翻页返回效果</a> - UIWebView翻页返回效果（变通方法）。</li>
<li><a href="https://github.com/lilei644/LLSlideMenu">LLSlideMenu</a> - 一个弹性侧滑菜单,弹性动画原理借鉴该项目中阻尼函数实现。</li>
<li><a href="https://github.com/yannickl/FlowingMenu">FlowingMenu.swift</a> - 菜单如此出场方式（橡皮筋弹跳式动画）好玩又有趣。</li>
</ul>


<h5>gif动画</h5>

<ul>
<li><a href="https://github.com/yfme/UIImageView-PlayGIF">UIImageView-PlayGIF</a> - UIImageView-PlayGIF。</li>
<li><a href="https://github.com/liyong03/YLGIFImage">YLGIFImage</a> - YLGIFImage。</li>
<li><a href="https://github.com/liyong03/YLGIFImage-Swift">YLGIFImage-Swift</a> - YLGIFImage-Swift。</li>
<li><a href="https://github.com/kaishin/gifu">gifu.Swift</a> - gifu.Swift高性能GIF显示类库。</li>
<li><a href="https://github.com/mortenjust/droptogif">droptogif</a> -  droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。</li>
<li><a href="https://github.com/wangjwchn/JWAnimatedImage">JWAnimatedImage.swift</a> - JWAnimatedImage.swift集中了目前主流的 GIF 显示库(如 FLAnimatedImage,Gifu 等)的优点，进行重构，代码短小精悍。而且使用了新的 frame 提取算法。</li>
<li><a href="https://github.com/kirualex/SwiftyGif">SwiftyGif</a> - 高性能 Gif 播放引擎。</li>
<li><a href="https://github.com/producthunt/PHImageKit">PHImageKit.swift</a> - 出自 Product Hunter 开发小组的带下载、缓存的 GIF 播放组件库。使用简单又方便。</li>
</ul>


<h5>其他动画</h5>

<ul>
<li><a href="https://github.com/schneiderandre/popping">popping</a> - popping是一个POP 使用实例工程</li>
<li><a href="https://github.com/xhzengAIB/PopMenu">PopMenu</a> - 用POP动画引擎写的Sina微博的Menu菜单。</li>
<li><a href="https://github.com/adad184/MMTweenAnimation">MMTweenAnimation</a> - facebook POP的自定义动画扩展(基于POPCustomAnimation) 提供10种函数式动画。</li>
<li><a href="https://github.com/zangqilong198812/ZQLRotateMenu">ZQLRotateMenu</a> - 这是一个旋转视图的选择器。</li>
<li><a href="https://github.com/zangqilong198812/CoolLoadAniamtion">CoolLoadAniamtion</a> - 一个简单但是效果不错的loading动画。</li>
<li><a href="https://github.com/zangqilong198812/SequenRotateAnimation">SequenRotateAnimation</a> - 一个简单的loading次序动画。</li>
<li><a href="https://github.com/yushuyi/SYAppStart">SYAppStart</a> - App启动插画的自定义过度。</li>
<li><a href="https://github.com/victorjiang/UIImage-VJDeviceSpecificMedia/">VJDeviceSpecificMedia</a> - <a href="http://www.imooc.com/wenda/detail/249271">如何根据设备选择不同尺寸的图片</a> 可以通过设置不同尺寸设备的LaunchImage，来使得App适配这些设备，要是在不同不同尺寸设备上使用不同大小的图片，则需要在代码中一一判断，然后加载。</li>
<li><a href="https://github.com/michaelbabiy/RMParallax">RMParallax</a> - RMParallax是一个app启动页引导开源项目，除了细微的翻页视差效果，描述文本的过渡也非常美观（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/Nododo/ADo_GuideView">ADo_GuideView</a> - 转动的用户引导页(模仿网易bobo) 因为没有从app包里抓到@3x的图片,建议在iPhone5模拟器运行,保证效果~ （版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/CharlinFeng/CoreNewFeatureVC">CoreNewFeatureVC</a> - 版本新特性（引导页），1.封装并简化了版本新特性启动视图！2.添加了版本的本地缓存功能，3.集成简单，使用方便，没有耦合度，4.支持block回调（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MachelleZhang/MZGuidePages">MZGuidePages</a> - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/ijoshsmith/Wizardry">Wizardry.swift</a> - 可重用的方法和框架实现向导式用户界面管理。（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/AdamBCo/ABCIntroView">ABCIntroView</a> - ABCIntroView是一个易于使用的入门类，让你到达主屏幕之前介绍你的应用程序（版本新特性、导航页、引导页）。</li>
<li><a href="https://github.com/MengTo/Spring">Spring</a> - Spring是一个Swift编写的开源库，可简化Swift编写的iOS动画。支持shake、pop、morph、squeeze、wobble、swing、flipX、flipY、fall、squeezeLeft、squeezeRight以及squeezeDown等多种动画形式，用 IBDesignable 让使用者可以在 Xcode 中快速设置动画效果。</li>
<li><a href="https://github.com/KittenYang/KYBezierBounceView">KYBezierBounceView</a> - 手势控制贝塞尔曲线，取消手势贝塞尔曲线会有反弹效果。</li>
<li><a href="http://kittenyang.com/cadisplaylinkanduibezierpath/">cadisplaylinkanduibezierpath</a> - CADisplayLink结合UIBezierPath的神奇妙用。</li>
<li><a href="https://github.com/KittenYang/KYCuteView">KYCuteView</a> - 实现类似QQ消息拖拽消失的交互+GameCenter的浮动小球效果，<a href="http://kittenyang.com/drawablebubble/">分析</a>。</li>
<li><a href="https://github.com/KittenYang/KYWaterWaveView">KYWaterWaveView</a> - 一个内置波浪动画的UIView，里面有鱼跳跃水溅起来的效果。</li>
<li><a href="https://github.com/liuzhiyi1992/WaveLoadingView">WaveLoadingView</a> - iOS 唯一完美的波浪进度加载指示器，<a href="http://zyden.vicp.cc/waveloadingindicator/">实现说明</a>。</li>
<li><a href="https://github.com/KittenYang/KYPingTransition">KYPingTransition</a> - 实现圆圈放大放小的转场动画，可以根据自己的需要使用Paper中的弹性效果，有Material风格。</li>
<li><a href="https://github.com/KittenYang/KYNewtonCradleAnimiation">KYNewtonCradleAnimiation</a> - 牛顿摆动画。</li>
<li><a href="https://github.com/scotteg/LayerPlayer">LayerPlayer</a> - 一款全面展示核心动画 API 示例项目（上架应用）。包括 CALayer, CAScrollLayer, CATextLayer, AVPlayerLayer, CAGradientLayer, CAReplicatorLayer, CATiledLayer, CAShapeLayer, CAEAGLLayer, CATransformLayer, CAEmitterLayer 等使用的互动演示。</li>
<li><a href="https://github.com/JayGajjar/JGTransitionCollectionView">JGTransitionCollectionView</a> - swift，基于集合视图扩展实现完成自动布局及单元项 Flip式动画效果（效果很赞）。组件使用方便、自然（只需设置集合视图数据源的标准方式即可）。</li>
<li><a href="https://github.com/KittenYang/KYShareMenu">KYShareMenu</a> - 带弹性动画的分享菜单。</li>
<li><a href="https://github.com/Yalantis/Context-Menu.iOS">Context-Menu.iOS</a> - 可以为app的菜单添加漂亮的动画内容，可自定义icon，并可根据自己的喜好设计单元格和布局。</li>
<li><a href="https://github.com/LuciusLu/DeformationButton">DeformationButton</a> - 一个简单的变换形状动画按钮。</li>
<li><a href="https://github.com/heroims/UnReadBubbleView">UnReadBubbleView</a> - UnReadBubbleView是一个能够拖拽并拉长的气泡视图。拖拽到一定的长度会消失，可以通过系数设置来控制拖拽的长度。气泡也支持多种属性设置。</li>
<li><a href="https://github.com/smallmuou/PPDragDropBadgeView">PPDragDropBadgeView</a> - 实现了类似于QQ 5.0 水滴拖拽效果. 支持iOS 5.0+ ARC，气泡能够带有数字标识，同时支持消失block方法。消失时还带有消失效果动画。</li>
<li><a href="https://github.com/MartinRGB/GiftCard-iOS">GiftCard-iOS</a> - 礼品卡购买的炫酷动画。</li>
<li><a href="https://github.com/gsdios/SDCycleScrollView">SDCycleScrollView</a> - 无限循环自动图片轮播器(一步设置即可使用)。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBLoopScrollView">HYBLoopScrollView</a> - HYBLoopScrollView实现自动循环滚动，一般用于展示广告页。微信在贴纸宣传处就使用了轮播。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/BuildAnInfiniteCarousel">BuildAnInfiniteCarousel</a> - 自己动手造无限循环图片轮播，<a href="https://autolayout.club/2015/10/29/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%80%A0%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD/">教程</a>。</li>
<li><a href="https://github.com/nicklockwood/iCarousel">iCarousel</a> - iCarousel是一个类，它继承于UIView。用于简化实现各种类型的旋转木马(分页滚动视图），无限轮播 ，<a href="http://www.cocoachina.com/ios/20150828/13198.html">iOS开发之多图片无缝滚动组件封装与使用</a>。</li>
<li><a href="https://github.com/smartwalle/KIPageView">KIPageView</a> - 无限循环PageView，横向TableView，无限轮播。</li>
<li><a href="http://code.cocoachina.com/view/128288">简单实用的无限循环轮播图</a> - 简单实用的无限循环轮播图 。</li>
<li><a href="https://github.com/crespoxiao/CPInfiniteBanner">CPInfiniteBanner</a> - 是一个循环播放的组件，可以左右无缝滑动,3个imageview实现。<a href="http://ios.jobbole.com/84711/">高效图片轮播，两个ImageView实现</a>。</li>
<li><a href="https://github.com/Akateason/XTLoopScroll">XTLoopScroll</a> - 用两个 timer 三个重用的 view 实现无限循环 scrollView，1自动轮播 2点击监听回调当前图片 3手动滑动后重新计算轮播的开始时间, 良好的用户体验。</li>
<li><a href="https://github.com/zangqilong198812/HotGirls">HotGirls</a> - 卡片动画。</li>
<li><a href="https://github.com/tispr/tispr-card-stack">tispr-card-stack</a> - swift 卡片风格动画切换组件及完整交互示例。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - swift 卡片堆叠效果的实现（ZLSwipeableView)】可实现类似Tinder和Potluck应用程序的卡片堆叠效果，该项目基于<a href="https://github.com/zhxnlai/ZLSwipeableView/">ZLSwipeableView objective-c</a>实现。1.自定义动画。2.自定义滑动切换。3.自定义方向。4.撤销。</li>
<li><a href="https://github.com/Yalantis/Koloda">Koloda</a> - 基于卡片的 Tinder-style 动画效果示例。精细绝人。更赞的是额外附了详细开发教程 How We Built Tinder-Like Koloda Animation in Swift <a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/">网页链接</a> 。Yalantis 出品动画程序款款精品。</li>
<li><a href="https://github.com/zangqilong198812/QQPersonalInfoTransition">QQPersonalInfoTransition</a> - 仿照QQ的转场。</li>
<li><a href="https://github.com/KittenYang/KYAnimatedPageControl">KYAnimatedPageControl</a> - 除了滚动视图时PageControl会以动画的形式一起移动，点击目标页还可快速定位。支持两种样式：粘性小球和旋转方块。</li>
<li><a href="https://github.com/likedan/KDIntroView">KDIntroView</a> - swift 动态介绍视图框架及演示。另外两个相似的类库是 RazzleDazzle和 Presentation，择需使用。</li>
<li><a href="https://github.com/IFTTT/RazzleDazzle">RazzleDazzle</a> - 【IFTTT开源Swift编写的帧动画框架&ndash;RazzleDazzle】RazzleDazzle 是IFTTT开源的一个iOS帧动画框架，非常适用于APP初次使用时的介绍和引导信息。JazzHands是UIKit一个简单的关键帧基础动画框架，可通过手势、scrollview、KVO等控制动画，被IFTTT应用在IFTTT for iPhone上。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 一个类似RazzleDazzle的框架。</li>
<li><a href="https://github.com/poolqf/FillableLoaders">FillableLoaders</a> - 基于 CGPaths 可定制个性化填空式装载类库。附水波上涨式示例。</li>
<li><a href="https://github.com/dsxNiubility/SXWaveAnimate">SXWaveAnimate</a> - 实现非常美观的灌水动画。</li>
<li><a href="https://github.com/liusen001/LSPaomaView">LSPaomaView</a> - 可循环滚动的较长文字，跑马灯，效果很好，一句话集成。</li>
<li><a href="https://github.com/ProudOfZiggy/SIFloatingCollection_Swift">SIFloatingCollection_Swift</a> - 可定制的 Apple Music 风格浮动形状动画组件及演示。</li>
<li><a href="https://github.com/suguru/Cheetah">Cheetah</a> - 易用、高可读链式动画类库。另一个类似类库是 <a href="https://github.com/Draveness/DKChainableAnimationKit">DKChainableAnimationKit</a>。</li>
<li><a href="https://github.com/CezaryKopacz/CKWaveCollectionViewTransition">CKWaveCollectionViewTransition</a> - swift， UICollectionViewController之间切换的动画。</li>
<li><a href="https://github.com/entotsu/TKSubmitTransition">TKSubmitTransition</a> - 基于 UIButton 的登录加载、返回按钮转场动画组件及示例。</li>
<li><a href="https://github.com/AugustRush/ARAnimation">ARAnimation</a> - ARAnimation 对 Core Animation 进行了封装, 帮助 iOS 开发者能更加便捷的在项目中使用动画。</li>
<li><a href="https://github.com/adow/CardsAnimationDemo">CardsAnimationDemo</a> - swift， <a href="http://swiftcn.io/topics/64?f=w">《使用 UICollectionView 实现的一个卡片动画》</a>不是直接操作所有 UIView 和 CALayer 的 transform3D 属性来实现整个效果的，而是使用 UICollectionView 来完成所有的视图管理和实现。</li>
<li><a href="https://github.com/TBXark/TKRubberIndicator">TKRubberIndicator.swift</a> - 一个很不错的 page control。</li>
<li><a href="http://code.cocoachina.com/view/127174">渐变特效文字</a> - 做了一个仿iPhone的移动滑块来解锁的渐变特效文字,还有一个类似ktv歌词显示的文字特效。</li>
<li><a href="https://github.com/zekunyan/TTGEmojiRate">TTGEmojiRate.swift</a> - TTGEmojiRate.swift以Emoji表情为基础绘图，<a href="http://tutuge.me/2015/10/25/ttgemojirate-lib/">Swift开源项目: TTGEmojiRate的实现</a>。</li>
<li><a href="https://github.com/nathanwhy/HYAwesomeTransition">HYAwesomeTransition</a> - 模仿格瓦拉的转场效果。</li>
<li><a href="https://github.com/seedante/CardAnimation">CardAnimation.swift</a> - CardAnimation 是国人开发的一个用 Swift 实现卡片垂直翻转动画的 Demo, <a href="http://www.jianshu.com/p/286222d4edf8">实现思路</a>。</li>
<li><a href="https://github.com/Glow-Inc/TaskSwitcherDemon">TaskSwitcherDemon</a> -  是仿造iOS9的Task Switcher做出来的动画效果, 具体的实现思路可参照<a href="http://tech.glowing.com/cn/implement-ios9-task-switcher-animation/">这篇文章</a>。</li>
<li><a href="https://github.com/lzwjava/CoreAnimationCode">CoreAnimationCode.swift</a> - 提供了 &ldquo;iOS Core Animation Advanced Techniques&rdquo; 书籍中的代码实例, 方便开发者们进行参考学习。</li>
<li><a href="https://github.com/xxycode/UIViewXXYBoom">UIViewXXYBoom.swift</a> - 一个炫酷好玩的爆炸效果，<a href="http://xxycode.com/ru-he-zhi-zuo-ge-xuan-ku-hao-wan-de-bao-zha-xiao-guo-2/">如何实现这个效果</a>。</li>
<li><a href="https://github.com/zhxnlai/ZLSwipeableViewSwift">ZLSwipeableViewSwift</a> - <a href="https://github.com/zhxnlai/ZLSwipeableView">ZLSwipeableView</a> - ZLSwipeableViewSwift在Tinder and Potluck中的动画效果实现思路（连续卡片翻页效果），最贴心的是作者提供了OC和Swift两个版本来供开发者使用，非常丝滑顺畅的效果。</li>
<li><a href="https://github.com/Resory/RYCuteView">RYCuteView</a> - 用UIBezierPath实现果冻效果。 <a href="http://www.jianshu.com/p/21db20189c40">教程</a></li>
<li><a href="https://github.com/JakeLin/IBAnimatable">IBAnimatable.swift</a> - 第三方开源库IBAnimatable可以帮助我们在Interface Builder和Swift Playground里面设计UI, 交互, 导航模式, 换场和动画。整个App 都是通过 IBAnimatable 在Interface Builder 设计完成，没有任何一行代码。</li>
<li><a href="https://github.com/poetmountain/MotionMachine">MotionMachine.swift</a> - 功能强大、优雅、模块化动画库。</li>
<li><a href="https://github.com/Ramotion/circle-menu">circle-menu.swift</a> - 动画效率很赞的圆形缩放菜单演示及类库。</li>
<li><a href="https://github.com/ariok/BWWalkthrough">BWWalkthrough.swift</a> - BWWalkthrough.swift界面切换中加入灵动的动画效果。</li>
<li><a href="https://github.com/robb/hamburger-button">hamburger-button.swift</a> - hamburger-button.swift一个汉堡包动画关闭按钮。</li>
<li><a href="https://github.com/fastred/HamburgerButton">HamburgerButton.swift</a> - HamburgerButton.swift一个汉堡包动画返回按钮。</li>
<li><a href="https://github.com/modocache/MDCSwipeToChoose">MDCSwipeToChooseView</a> - MDCSwipeToChooseView翻牌子效果。</li>
<li><a href="https://github.com/StoneLeon/STLBGVideo">STLBGVideo</a> - STLBGVideo让您的视图控制器的自定义backgroundvideo,<a href="http://www.jianshu.com/p/c4704c086b67">实现说明1</a>、<a href="http://www.jianshu.com/p/3dcebf0493d1">实现说明2</a>。</li>
<li><a href="https://github.com/storehouse/Advance">Advance.swift</a> - 简单易用、功能强大的动画框架库。在手势交互、帧动画、自定义动画及仿真类型将是不错的选择。</li>
<li><a href="https://github.com/zangqilong198812/PanelDemo">PanelDemo</a> - 仪表盘,模拟汽车的车速仪表盘,<a href="http://reviewcode.cn/article.html?reviewId=16">一些简单的数学知识</a>。</li>
<li><a href="https://github.com/Loveway/HWAnimationTransition_Swift">HWAnimationTransition_Swift</a> 、<a href="https://github.com/Loveway/HWAnimationTransition_OC">HWAnimationTransition_OC</a> - 类似于格瓦拉启动页中的放大转场动画（objective-C &amp;&amp; Swift）。<a href="http://www.jianshu.com/p/8c29fce5a994">教程</a></li>
<li><a href="https://github.com/MatthewYork/MYBlurIntroductionView">MYBlurIntroductionView</a> - 方便好用的引导类库，在App注册登录页面可以用到。</li>
<li><a href="https://github.com/WZF-Fei/ZFCityGuides">ZFCityGuides</a> - 实现City Guides的动画效果，数字动态变化的动画效果。</li>
<li><a href="https://github.com/me-abhinav/NumberMorphView">NumberMorphView.swift</a> - 可爱的数字补间（变身）动画类库。</li>
<li><a href="https://github.com/Yalantis/DisplaySwitcher">DisplaySwitcher.swift</a> - 两个集合视图在不同布局（平铺和列表）间平滑切换。Yalantis 出品。</li>
<li><a href="https://github.com/yannickl/DynamicButton">DynamicButton.swift</a> - 一套完整、且带动画过渡的图标按钮库。</li>
<li><a href="https://github.com/TBXark/TKDotSegment">TKDotSegment.swift</a> - 是一个带有圆点动画的 segment。</li>
<li><a href="https://github.com/yoavlt/LiquidLoader">LiquidLoader.swift</a> - 液态加载动画的轻量级 UI 组件。</li>
<li><a href="https://github.com/larrynatalicio/15DaysofAnimationsinSwift">15DaysofAnimationsinSwift</a> - 15DaysofAnimationsinSwift动画。</li>
<li><a href="https://github.com/marmelroy/Interpolate">Interpolate.swift</a> - 手势驱动交互式转场动画框架库。这个很专业，且非常有意思。</li>
<li><a href="https://github.com/indragiek/INPopoverController">INPopoverController</a> - OS X可自由定制的  Popover 视图。</li>
<li><a href="https://github.com/Wzxhaha/WZXJianShuPopDemo">WZXJianShuPopDemo</a> - 仿简书、淘宝等等的View弹出效果，已封装好，使用简单。<a href="http://www.jianshu.com/p/a697d2a38b3c">实现原理</a></li>
<li><a href="https://github.com/marmelroy/PeekPop">PeekPop.swift</a> - 3DTouch动画组件。</li>
<li><a href="https://github.com/onmyway133/fantastic-ios-animation">fantastic-ios-animation.swift</a> - 基于 UI 组件类别分类，且带精彩动画效果的 iOS 组件库集合。</li>
<li><a href="https://github.com/facebook/pop">pop</a> - facebook出品的非常赞的动画引擎。</li>
</ul>


<hr />

<h4>网络相关</h4>

<h5>网络连接</h5>

<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> - ASI不升级以后，最多人用的网络连接开源库，<a href="http://www.superqq.com/blog/2014/11/07/ioswang-luo-bian-cheng-zhi-afnetworkingshi-yong/">iOS网络编程之AFNetworking使用</a>,<a href="http://www.superqq.com/blog/2015/01/29/ioskai-fa-xia-zai-wen-jian-su-du-ji-suan/">iOS开发下载文件速度计算</a> , <a href="http://www.cocoachina.com/ios/20151022/13831.html">AFNetworking 3.0迁移指南</a> , <a href="http://www.cocoachina.com/ios/20140829/9480.html">AFNetworking2.0源码解析&lt;一></a> 、<a href="http://www.cocoachina.com/ios/20140904/9523.html">AFNetworking2.0源码解析&lt;二></a>、<a href="http://www.cocoachina.com/ios/20140916/9632.html">AFNetworking源码解析&lt;三></a>、<a href="http://www.cocoachina.com/ios/20141120/10265.html">AFNetworking源码解析&lt;四></a>。</li>
<li><a href="https://github.com/Alamofire/Alamofire">Alamofire.swift</a> - Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。<a href="https://github.com/ipader/SwiftGuide/wiki/Alamofire%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">Alamofire 最佳实践</a></li>
<li><a href="https://github.com/tristanhimmelman/AlamofireObjectMapper">AlamofireObjectMapper.swift</a> - 将Alamofire JSON响应数据 转为swift对象。</li>
<li><a href="https://github.com/RxSwiftCommunity/RxAlamofire">RxAlamofire.swift</a> - 为Alamofire提供函数响应式（FRP）调用接口,以优雅的方式使用Alamofire进行网络请求。</li>
<li><a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a> - 是基于 AFNetworking 封装的 iOS网络库，提供了更高层次的网络访问抽象。相比AFNetworking，YTKNetwork提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。</li>
<li><a href="https://github.com/CoderJackyHuang/HYBNetworking">HYBNetworking</a> - 基于AFN封装的网络库，可以通用。<a href="http://www.henishuo.com/base-on-afnetworking-wrapper/">基于AFNetworking封装网络库说明</a>目前已经提供了通用的GET/POST、上传、下载API等。</li>
<li><a href="https://github.com/DeveloperLx/LxFTPRequest">LxFTPRequest</a> - 支持获取FTP服务器资源列表，下载/上传文件，创建/销毁ftp服务器文件/目录，以及下载断点续传，下载/上传进度，自动判断地址格式合法性跟踪等功能！国人开发，QQ：349124555。</li>
<li><a href="https://github.com/HHuiHao/HSDownloadManager">HSDownloadManager</a> - HSDownloadManager，下载音乐、视频、图片各种资源，支持多任务、断点下载。</li>
<li><a href="https://github.com/HHuiHao/MutableUploadDemo">MutableUploadDemo</a> - 模拟需求：图文混编，要求用户选择图片后就上传，可选择多图，并行上传，用户确定提交后后台执行，必须全部图片上传完才能提交文字。</li>
<li><a href="https://github.com/swtlovewtt/WTRequestCenter">WTRequestCenter</a> - 方便缓存的请求库，提供了方便的HTTP请求方法，传入请求url和参数，返回成功和失败的回调。 UIKit扩展提供了许多不错的方法，快速缓存图片，图片查看，缩放功能， 颜色创建，设备UUID，网页缓存，数据缓存等功能。 无需任何import和配置，目前实现了基础需求。</li>
<li><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole</a> - Message passing between iOS apps and extensions 2个iOS设备之间通信。</li>
<li><a href="https://github.com/socketio/socket.io-client-swift">socket.io-client-swift</a> - WebSockect 客户端类库。开放的通讯协议，有利于构建强大地跨平台应用。</li>
<li><a href="https://github.com/nghialv/Transporter">Transporter</a> - swift， 短小、精悍、易用的多文件（并发或顺序）上传和下载传输库。还支持后台运行、传输进程跟踪、暂停/续传/取消/重试控制等功能。</li>
<li><a href="https://github.com/kevin0571/STNetTaskQueue">STNetTaskQueue</a> - STNetTaskQueue Objective-C 可扩展网络请求管理库。</li>
<li><a href="https://github.com/robbiehanson/CocoaAsyncSocket">CocoaAsyncSocket</a> - 在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大，<a href="http://www.superqq.com/blog/2015/04/03/ioskai-fa-zhi-asyncsocketshi-yong-jiao-cheng/">使用教程</a>。</li>
<li><a href="https://github.com/roustem/AsyncSocket">AsyncSocket</a> - AsyncSocket。</li>
<li><a href="http://code.cocoachina.com/view/128711">Socket通信</a> - 通过AsyncSocket封装的Socket通讯方法，简单实用，通俗易懂，初学者不能错过 。</li>
<li><a href="https://github.com/eugenehp/GCDAsyncSocket">GCDAsyncSocket</a> - GCDAsyncSocket ， <a href="https://github.com/smalltask/TestTcpConnection">不错的Demo</a>。</li>
<li><a href="https://github.com/JustHTTP/Just">Just</a> - 小而美的 HTTP 类。功能简单、直接、完整且健壮性高&ndash; swift。</li>
<li><a href="https://github.com/nghialv/Future">Future</a> - 基于微框架设计思想的异步执行及结果响应类，代码即简单又干净&ndash; swift。</li>
<li><a href="https://github.com/mzeeshanid/MZDownloadManager">MZDownloadManager</a> - 下载管理。</li>
<li><a href="https://github.com/venmo/DVR">DVR</a> - 针对网络请求的测试框架，超实用的工具。且支持 iOS, OSX, watchOS 全平台。</li>
<li><a href="https://github.com/hongfenglt/HFDownLoad">HFDownLoad</a> - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 <a href="http://blog.csdn.net/hongfengkt/article/details/48290561">下载方式具体的思路、区别见Blog</a> 。</li>
<li><a href="https://github.com/johnlui/Pitaya">Pitaya.swift</a> - Pitaya 是纯 Swift 写的 iOS 网络库，支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持，开箱即用。 <a href="https://github.com/johnlui/Pitaya/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3">中文文档</a></li>
<li><a href="https://github.com/daltoniam/starscream">starscream.swift</a> - starscream.swift:WebSocket客户端类库。</li>
<li><a href="https://github.com/FengDeng/SwiftNet">SwiftNet.swift</a> - 基于 RxSwift 和 Alamofire 的网络请求简易封装库。</li>
<li><a href="https://github.com/3lvis/Networking">Networking.Swift</a> - 使用简单、功能惊喜，基于 NSURLSession 的网络封装。</li>
</ul>


<h5>图像获取</h5>

<ul>
<li><a href="https://github.com/rs/SDWebImage">SDWebImage</a> - SDWebImage 网络图片获取及缓存处理。</li>
<li><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a> - 纯 Swift 实现的类 SDWebImage 库，实现了异步下载和缓存图片。</li>
<li><a href="https://github.com/kiavashfaisali/KFSwiftImageLoader">KFSwiftImageLoader</a> - Swift，一个图像缓存加载库。</li>
<li><a href="https://github.com/path/FastImageCache">FastImageCache</a> - FastImageCache 网络图片获取及缓存处理，<a href="http://www.imooc.com/wenda/detail/247239">iOS图片加载速度极限优化—FastImageCache解析</a>。</li>
<li><a href="https://github.com/enormego/EGOCache">EGOCache</a> - 十分知名的第三方缓存类库，可以缓存NSString、UIImage、NSImage以及NSData。除此，如果还可以缓存任何一个实现了<NSCoding>接口的对象。所有缓存的数据都可以自定义过期的时间，默认是1天。EGOCache 支持多线程（thread-safe），<a href="http://www.superqq.com/blog/2014/11/06/ioskai-fa-:uitableviewjia-zai-duo-zhang-zhao-pian-dao-zhi-nei-cun-shang-zhang-de-wen-ti/">UITableView加载多张照片导致内存上涨的问题</a>。</li>
<li><a href="https://github.com/ibireme/YYWebImage/">YYWebImage</a> - 一个图片加载库 YYWebImage，支持 APNG、WebP、GIF 播放，支持渐进式图片加载，更高性能的缓存，更多图像处理方法，可以替代 SDWebImage 等开源库，<a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">相关文章</a>。</li>
</ul>


<h5>网络聊天</h5>

<ul>
<li><a href="https://github.com/robbiehanson/XMPPFramework">XMPPFramework</a> - XMPPFramework openfire聊天。</li>
<li><a href="https://github.com/dsxNiubility/SXTheQQ">SXTheQQ</a> - 用xmppFramework框架编写QQ程序，主要为了练习通讯的一些原理，界面比较渣 必须要先在本地配置好环境才可以运行。</li>
<li><a href="http://www.easemob.com/">环信</a> - 给开发者更稳定IM云功能。8200万用户考验，好用！（暂无及时语音、视频通话）</li>
<li><a href="http://www.rongcloud.cn/">融云</a> - 即时通讯云服务提供商。（暂无及时语音、视频通话）</li>
<li><a href="http://www.yuntongxun.com">容联云通讯</a> - 提供基于互联网通话,视频会议,呼叫中心/IVR,IM等通讯服务。</li>
<li><a href="https://github.com/ChatSecure/ChatSecure-iOS">ChatSecure-iOS</a> - 基于XMPP的iphone、android加密式聊天软件， <a href="https://chatsecure.org/">chatsecure官网</a> 。 <a href="https://github.com/ChatSecure/ChatSecure-iOS">iOS代码1</a>，<a href="https://github.com/ChatSecure/ChatSecure-iOS">iOS代码2</a>， <a href="http://www.cocoachina.com/bbs/read.php?tid=153156">iOS中文版</a>。</li>
<li><a href="https://github.com/xhzengAIB/MessageDisplayKit">MessageDisplayKit</a> - 仿微信聊天，参考JSQMessagesViewController。（国人写）</li>
<li><a href="https://github.com/jessesquires/JSQMessagesViewController">JSQMessagesViewController</a> - 聊天 。</li>
<li><a href="https://github.com/MessageKit/MessageKit">MessageKit.swift</a> - 消息 UI 库 JSQMessagesViewController 的 Swift 版。</li>
<li><a href="https://github.com/HanYaZhou1990/-SunFlower">SunFlower</a> - 环信聊天demo，比较多功能 。</li>
<li><a href="http://code4app.com/ios/BlueTalk%E8%93%9D%E7%89%99%E8%81%8A%E5%A4%A9-%E6%89%8B%E6%9C%BA%E4%B9%8B%E9%97%B4/552b8190933bf0291e8b4748">BlueTalk蓝牙聊天</a> - 以MultipeerConnectivity为基础， 实现了简单的蓝牙聊天。</li>
<li><a href="https://github.com/jpush/jchat-swift">jchat-swift</a> - 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。</li>
</ul>


<h5>网络测试</h5>

<ul>
<li><a href="https://github.com/tonymillion/Reachability">Reachability</a> - 苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。<a href="http://www.jianshu.com/p/efcfa3c87306">iOS网络监测如何区分2、3、4G</a></li>
<li><a href="https://github.com/ashleymills/Reachability.swift">Reachability.swift</a> - 用于替换苹果的 Reachability 类，可以方便地检测当前是否联网以及具体的联网状态。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrier">SimpleCarrier</a> - 简单的运营商信息获取!。</li>
<li><a href="https://github.com/crazypoo/SimpleCarrie">NetReachability</a> - swift2.0 简单的方法检查网络连接的连通性，提供通知中心集成接口。</li>
<li><a href="https://github.com/coderyi/NetworkEye">NetworkEye</a> - 一个网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。</li>
<li><a href="https://github.com/bin1991/SimpleBS">SimpleBS.swift</a> - 网络测试小工具。</li>
<li><a href="https://github.com/dustturtle/RealReachability">RealReachability</a> - <a href="http://www.cocoachina.com/ios/20160224/15407.html">iOS下的实际网络连接状态检测</a>，解决“如何判断设备是否真正连上互联网？而不是只有网络连接”的问题。</li>
</ul>


<hr />

<h5>网页框架</h5>

<ul>
<li><a href="https://github.com/PerfectlySoft/Perfect">Perfect.swift</a> - Perfect 致力于 Swift 服务端应用，从打造专业应用服务器开始。<a href="http://blog.csdn.net/kinfey/article/details/50644752">Swift服务端编程：Perfect项目上手指南</a></li>
<li><a href="https://github.com/huytd/swift-http">swift-http</a> - Swift HTTP Server，又一个 Swift 服务器，最大的亮点是支持 Docker 部署。</li>
<li><a href="https://github.com/necolt/Swifton">Swifton</a> - Swifton是一个优秀的Swift on Rails 的Web Framework。</li>
<li><a href="https://github.com/izqui/Taylor">Taylor.swift</a> - Taylor一个swift的轻量级的http服务器的库。</li>
<li><a href="https://github.com/colemancda/NetworkObjects">NetworkObjects.swift</a> - NetworkObjects.swift轻量版HttpServer框架，跨平台解决方案。</li>
<li><a href="https://github.com/qutheory/vapor">vapor.swift</a> - vapor.swift：swift的服务器库 vapor。</li>
<li><a href="https://github.com/IBM-Swift/Kitura">Kitura.swift</a> - Kitura.swift：安装、使用步骤及文档最为清晰地来自 IBM Swift 开发组的开源 Web 服务器。此外，IBM 云服务 Bluemix 也为 Swift 打开通路。</li>
</ul>


<hr />

<h5>WebView与WKWebView</h5>

<ul>
<li><a href="https://github.com/mattgemmell/MGTemplateEngine">MGTemplateEngine</a> - MGTemplateEngine比较象 PHP 中的 Smarty、FreeMarker 和 Django的模版引擎，是一个轻量级的引擎，简单好用。只要设置很多不同的HMTL模版，就能轻松的实现一个View多种内容格式的显示，对于不熟悉HTML或者减轻 工作量而言，把这些工作让设计分担一下还是很好的，也比较容易实现设计想要的效果。</li>
<li><a href="https://github.com/ninjinkun/NJKWebViewProgress">NJKWebViewProgress</a> - 一个 UIWebView 的进度条接口库,UIWebView 本身是不提供进度条的。</li>
<li><a href="https://github.com/siriusdely/GTMNSString-HTML">GTMNSString-HTML</a> - 谷歌开源的用于过滤HTML标签。</li>
<li><a href="https://github.com/WangXiaoxi/IOSLearing/">js-in-ios</a> - webView与js的交互。</li>
<li><a href="https://github.com/mozhenhau/D3Generator/">D3Generator</a> - D3Generator根据dict字典生成对象。 适用webview和push推送时，根据后台传回字典实现动态跳转。<a href="http://mozhenhau.com/2016/02/07/D3Generator%E5%AE%9E%E7%8E%B0%E4%B8%87%E8%83%BD%E8%B7%B3%E8%BD%AC%E7%95%8C%E9%9D%A2%EF%BC%8CUIWebview%E4%B8%8Ejs%E9%9A%8F%E6%84%8F%E4%BA%A4%E4%BA%92/">实现说明</a></li>
<li><a href="https://github.com/CoderJackyHuang/IOSCallJsOrJsCallIOS">IOSCallJsOrJsCallIOS</a> - IOSCallJsOrJsCallIOS：利用iOS7.0后出来的JavaScriptCore framework，webview与Js交互是常见的需求。OC版本与swift版本。<a href="http://www.henishuo.com/oc-js/">《OC JavaScriptCore与js交互》</a>,<a href="http://www.henishuo.com/swift-js/">《Swift JavaScriptCore与js交互》</a>。</li>
<li><a href="https://github.com/CoderJackyHuang/WKWebViewTestDemo">WKWebViewTestDemo.swift</a> - WKWebViewTestDemo：WKWebView新特性及JS交互,<a href="http://www.henishuo.com/wkwebview-js/">文章讲解</a>。</li>
<li><a href="https://github.com/alexdrone/Render">React.swift</a> - 启发自 React 的纯 Swift 函数版基于 UIKit 封装类库。这种结构是否似曾相识。</li>
</ul>


<hr />

<h4>Model</h4>

<ul>
<li><a href="https://github.com/johnezang/JSONKit">JSONKit</a> - JSONKit库是非常简单易用而且效率又比较高的，重要的JSONKit适用于ios 5.0以下的版本,使用JSONKit库来解析json文件，只需要下载JSONKit.h 和JSONKit.m添加到工程中；然后加入libz.dylib即可。</li>
<li><a href="https://github.com/icanzilb/JSONModel">JSONModel</a> - 解析服务器返回的Json数据的库,<a href="http://www.jianshu.com/p/3d795ea37835">JSONModel源码解析一</a>。</li>
<li><a href="https://github.com/Mantle/Mantle">Mantle</a> - Mantle主要用来将JSON数据模型化为OC对象, 大系统中使用。<a href="http://www.iwangke.me/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么选择Mantle</a>。</li>
<li><a href="https://github.com/refusebt/RFJModel">RFJModel</a> - RFJModel是一个IOS类库，可以将JSON字典自动装填到OBJC对象。相比JSONModel有一些非常好的特性，使用上也比较简单。</li>
<li><a href="https://github.com/nicklockwood/XMLDictionary">XMLDictionary</a> - ios与mac os平台下xml与NSDictionary相互转化开源类库。</li>
<li><a href="https://github.com/tadija/AEXML">AEXML.swift</a> - AEXML.swift简单又易于的XML解析类及示例。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">MJExtension</a> - 用于json转model进行使用，转换效率很高，使用也比较简单，只要前后台约定好，json直接就转成了model。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension">CFRuntime</a> - “Swift 版的 MJExtension，运行时、反射与一键字典模型互转”。</li>
<li><a href="https://github.com/openboy2012/DDModel">DDModel</a> - 快速搭建项目Model层，支持ORM映射关系，能从JSON/XML直接实例一个Model对象。支持SQLite本地数据持久化，封装了HTTP， 减少HTTP代码与UIViewController的代码耦合，支持Cache；类似RESTKit、Mantle的功能；使用该类库以后简化了网络层的开发工作，把更多的精力放在UI上面；目前只支持GET/POST方法的请求。使用到的第三方库有：1.SQLitePersistentObject; 2.JTObjectMapping; 3.AFNetworking; 4.XMLDictionary;</li>
<li><a href="https://github.com/alexeyxo/protobuf-swift">protobuf-swift</a> - Protocol Buffers 的 Swift 语言实现库。P.S. Protocol Buffers 是 Google 开源项目，主要功能是实现直接序列化结构化的对象数据，方便跨平台快速传递，开发者也可以直接修改 protobuf 中的数据。相比 XML 和 JSON，protobuf 解析更快，存储更小。</li>
<li><a href="https://github.com/matthewcheok/JSONCodable">JSONCodable</a> - 基于 Swift 2.0 新特性（Protocol Extensions and Error Handling）的JSON 解析类。</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a> - 使Swift的JSON解析变得简单。</li>
<li><a href="https://github.com/johnlui/JSONNeverDie">JSONNeverDie.swift</a> - JSON 到 Model 类的自动映射工具。</li>
<li><a href="https://github.com/cezheng/Fuzi">Fuzi.swift</a> - Swift实现的轻量快速的 XML/HTML 解析器。</li>
<li><a href="https://github.com/drmohundro/SWXMLHash">SWXMLHash.swift</a> - 易用的 XML 解析类库。非常实用的“轮子”。</li>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> - 高性能的 iOS JSON 模型框架。</li>
<li><a href="https://github.com/benloong/TidyJSON">TidyJSON.swift</a> - TidyJSON.swift一款简单、易用、明了的 JSON 解析小类库。</li>
<li><a href="https://github.com/postmates/PMJSON">PMJSON.swift</a> - PMJSON.swift简单、实用、高效的 JSON 解析类库。</li>
<li><a href="https://github.com/JohnSundell/Unbox">Unbox.swift</a> - 极为易用、轻量，更少辅助代码的 JSON 解析类。</li>
<li><a href="https://github.com/JohnSundell/Wrap">Wrap.swift</a> - 方便、易用的对象转 JSON 类库。</li>
</ul>


<hr />

<h4>通讯录</h4>

<ul>
<li><a href="http://code.cocoachina.com/view/128245">快速查找联系人</a> - 类似微信联系人搜索的界面,快速查找联系人,并支持点击查询结果 。</li>
</ul>


<hr />

<h4>其他库</h4>

<ul>
<li><a href="https://github.com/exsortis/DateTimeKit">DateTimeKit</a> - 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a> - 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</li>
<li><a href="https://github.com/nst/iOS-Runtime-Headers">iOS私有API</a> - 私有API，绿色 == public，红色 == private，蓝色 == dylib。</li>
<li><a href="http://opensource.apple.com/source/CF/">iOS源代码</a> - iOS源代码。</li>
<li><a href="https://github.com/ShiqiYu/libfacedetection">libfacedetection</a> - C++ 人脸识别 包含正面和多视角人脸检测两个算法.优点:速度快(OpenCV haar+adaboost的2-3倍), 准确度高 (FDDB非公开类评测排名第二），能估计人脸角度。</li>
<li><a href="https://github.com/Brimizer/Slidden">Slidden</a> - 一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。</li>
<li><a href="https://github.com/michaeltyson/TPKeyboardAvoiding">TPKeyboardAvoiding</a> - 用户键盘弹出自动计算高度，进行屏幕滚动操作。</li>
<li><a href="http://d.cocoachina.com/code/detail/298267">CDPMonitorKeyboard</a> - CDPMonitorKeyboard封装,可以解决输入视图(例如textField,textView等)被键盘覆盖问题，并可设置高于键盘多少。</li>
<li><a href="http://code.cocoachina.com/detail/297973/%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E9%94%AE%E7%9B%98%E9%AB%98%E5%BA%A6/">自动监听键盘高度</a> - 自动监听键盘高度，初始界面，输入框在屏幕最下方，当键盘出现时，输入框随即移动到键盘上方。</li>
<li><a href="https://github.com/liuzhiyi1992/ZYKeyboardUtil">ZYKeyboardUtil</a> - 全自动处理键盘遮挡事件，只需要一个Block，全自动处理任何多层嵌套复杂界面 因键盘升降 造成的输入控件遮挡问题。
第三方键盘分次弹出问题 ,<a href="http://ios.jobbole.com/85135/">说明</a>。</li>
<li><a href="https://github.com/Jiar/KeyboardToolBar/">KeyboardToolBar</a> - 从此不再担心键盘遮住输入框，<a href="http://www.jianshu.com/p/48993ff982c1">文档</a>。</li>
<li><a href="https://github.com/yushuyi/SYKeyboardTextField">SYKeyboardTextField</a> - SYKeyboardTextField 是一个轻巧,简单,非侵入式的键盘附随输入框! 采用Swift编写。</li>
<li><a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a> - 处理键盘事件强大的库，有OC和Swift版本，纯代码、Storyboard和Xib都适用。</li>
<li><a href="https://github.com/zwaldowski/BlocksKit">BlocksKit</a> - block框架，为 OC 常用类提供了强大的 Block 语法支持，使得编写 OC 代码变得舒适、快速、优雅。</li>
<li><a href="https://github.com/facebook/KVOController">KVOController</a> - 在项目中有使用 KVO ，那么 KVOController 绝对是个好选择。它是 facebook 开源的一个 KVO 增强框架。</li>
<li><a href="https://github.com/arashpayan/appirater">appirater</a> - 用于提醒用户给你的 APP 打分的工具。</li>
<li><a href="https://github.com/MHaroonBaig/MotionKitr">MotionKitr</a> - 为核心运动框架（The Core Motion framework）提供友好的类库封装，以更方便使用三轴陀螺仪和加速感应器特性。</li>
<li><a href="https://launchkit.io/reviews/">Review Monitor</a> -  第一时间自动推送 Apple Store 的用户评论到你的邮件箱或者 Slack，第一时间跟进用户反馈，打造优秀 App 必备工具！类似的有：App annie 的类似功能。</li>
<li><a href="https://github.com/Naituw/WBWebViewConsole">WBWebViewConsole</a> - 类似微博iPhone客户端的 “调试选项” 吗？把其中的 “内置浏览器网页调试” 开源在 Github 上了。</li>
<li><a href="https://github.com/futurice/ios-good-practices">ios-good-practices</a> - ios-good-practices iOS 开发最佳实践。</li>
<li><a href="http://ios.jobbole.com/81830/">iOS开发最佳实践</a> - iOS 开发最佳实践 &ndash; 中文。</li>
<li><a href="http://code.cocoachina.com/detail/232160">TodayExtensionSharingDefaults</a> - TodayExtensionSharingDefaults是一个iOS 8 Today扩展示例，可以使用NSUserDefaults与其containing app分享数据。</li>
<li><a href="http://code.cocoachina.com/view/129108">原生实现扫描二维码条码</a> - iOS原生实现扫描二维码条码.</li>
<li><a href="https://github.com/Zirkfied/ZFScan">ZFScan</a> - 仿微信 二维码/条形码 扫描。</li>
<li><a href="https://github.com/yannickl/QRCodeReader.swift">QRCodeReader.swift</a> - QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。</li>
<li><a href="https://github.com/MxABC/swiftScan">swiftScan</a> - 具有丰富功能的二维码扫描组件及类库。<a href="https://github.com/MxABC/LBXScan">对应OC版本LBXScan</a>。</li>
<li><a href="https://github.com/appcoda/QR-Code-Generator">QR-Code-Generator.swift</a> - 生成二维码。</li>
<li><a href="https://github.com/100mango/QRCatcher">QRCatcher</a> - 一个简洁美观的二维码扫描应用， <a href="https://github.com/100mango/zen/blob/master/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86/iOS%E5%AD%A6%E4%B9%A0%EF%BC%9AAVFoundation%20%E8%A7%86%E9%A2%91%E6%B5%81%E5%A4%84%E7%90%86%20.md">iOS学习：AVFoundation 视频流处理&ndash;二维码扫描</a>。</li>
<li><a href="https://github.com/zhengjinghua/MQRCodeReaderViewController">MQRCodeReaderViewController</a> - 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用。</li>
<li><a href="https://github.com/ayanonagon/Parsimmon">Parsimmon</a> - swift，小而美的语言学类库封装工具包。提供分词、标记词性、词形归并、朴素贝页斯分类、决策树等自然语言分析小工具。P.S. 英语分词效果好于中文，感兴趣的同学可以针对中文做一些优化开发。参考译文 NSHipster - <a href="http://nshipster.cn/nslinguistictagger/">NSLinguistic​Tagger</a>。</li>
<li><a href="https://github.com/liuchunlao/Password-keyboard">Password-keyboard</a> - 随机变换数字位置的密码键盘。 模仿银行类应用在付款时输入的随机密码键盘。</li>
<li><a href="https://github.com/SemperIdem/MKMapView-Extension">MKMapView-Extension</a> - 这是关于 MKMapView 写的一个基于swift的扩展，可以扩展 MKMapView 的相关功能，减少复用代码量。</li>
<li><a href="https://github.com/nomothetis/SemverKit">SemverKit</a> - 针对符合『语义化版本规范 2.0.0』版本号的解析、比较运算类库。不仅支持 Major, Minor, Patch，还支持 Alpha 和 Beta 预发布版本，以及相应地递增运算扩展。</li>
<li><a href="https://github.com/jpotts18/SwiftValidator">SwiftValidator</a> - 基于规则的输入验证类库。项目良好的面向对象设计思想，使规则的扩展及自定义非常方便。更专业的规则引擎（甚至是基于自然语言的规则配置）解决方案，比如：开源的 Drools，商用的 ILOG 等。</li>
<li><a href="https://github.com/Ben-G/Validated">Validated.swift</a> - Validated.swift通过值验证或限定，快速定义新类型的微类库（约50行代码）。</li>
<li><a href="https://github.com/gali8/Tesseract-OCR-iOS">Tesseract-OCR-iOS</a> - 有关OCR文字识别项目。</li>
<li><a href="https://github.com/osnr/Screenotate">Screenotate</a> - 支持 OCR 文字识别的载屏笔记 Mac 完整应用。</li>
<li><a href="https://github.com/garnele007/SwiftOCR">SwiftOCR</a> - 识别字母和数字相较于 Tesseract 有压倒性优势（附图）的 OCR 类库。</li>
<li><a href="http://cocoacats.com/">cocoacats</a> - 【分类汇总】里面收集了 iOS 中常用的分类文件，一直在更新。</li>
<li><a href="https://github.com/nonstriater/Olla4iOS">Olla4iOS</a> - 过去积累的一些方便复用的类和方法，还在整理中。</li>
<li><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> - 用最快的方式给你的应用加上夜间和白天的切换效果。</li>
<li><a href="https://github.com/morizotter/TouchVisualizer">TouchVisualizer</a> - 实用的多点触摸可视化组件。扩展并作用于 UIWindows，结构上提供了简单地针对触摸显示定制，比如触摸点的颜色。</li>
<li><a href="https://github.com/wezm/RegexKitLite">RegexKitLite</a> - 用来处理正则表达式。</li>
<li><a href="https://github.com/sharplet/Regex">Regex.swift</a> - 实用的正则表达式微框架类库。</li>
<li><a href="https://github.com/cezheng/PySwiftyRegex">PySwiftyRegex.swift</a> - 像Python一样简洁高效地作正则处理。</li>
<li><a href="https://github.com/marmelroy/PhoneNumberKit">PhoneNumberKit.swift</a> -  解析、格式化及验证国际电话号码工具库（相当于 Google 的 libphonenumber 库的 Swift 版本）。</li>
<li><a href="https://github.com/czechboy0/XcodeServerSDK">XcodeServerSDK</a> - 非官方 Xcode Server SDK 封装库。 P.S. 该 SDK 分离自之前推荐的由该作者开发的自动测试框架 <a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a>。</li>
<li><a href="https://github.com/FabrizioBrancati/BFKit-Swift">BFKit-Swift</a> - BFKit-Swift 这套工具库可以提高应用开发效率。</li>
<li><a href="https://github.com/nofelmahmood/Seam">Seam</a> - 基于 CloudKit 服务器实现多终端数据同步。</li>
<li><a href="https://github.com/oisdk/SwiftSequence">SwiftSequence</a> - 简洁、灵活、多变的操作 SequenceType 的类库（基于微框架（μframework）设计思想）。</li>
<li><a href="https://github.com/photondragon/IDNFeedParser">IDNFeedParser</a> - 一个简单易用的Rss解析库。</li>
<li><a href="https://github.com/CharlinFeng/CoreUmeng">CoreUmeng</a> - 简单：友盟分享封装。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。</li>
<li><a href="https://github.com/tomkowz/Swifternalization">Swifternalization</a> - 一套实用的本地化工具库。使用教程及 API 文档完整。值得收入项目的“轮子”。</li>
<li><a href="https://github.com/marmelroy/Localize-Swift">Localize-Swift</a> - Localize-Swift一款开发者不可或缺的国际化及本地化字符串框架支持类库。同样地，使用简单、直观又方便。</li>
<li><a href="https://github.com/owensd/apous">apous</a> - 一款有趣的 Swift 应用 － 让 Swift 成为脚本语言。</li>
<li><a href="https://github.com/kostiakoval/Mirror">Mirror</a> - 通过反射（Refection）实现镜像对象封装库。从而可以更轻松获取（或输出）对象属性名、类型及值变量。</li>
<li><a href="https://github.com/nixzhu/Proposer">Proposer</a> - Proposer 用单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。</li>
<li><a href="https://github.com/nickoneill/PermissionScope">PermissionScope</a> - 用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高。</li>
<li><a href="https://github.com/intuit/LocationManager">LocationManager</a> - 地理位置管理封装库， CoreLocation使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单！<a href="http://www.cocoachina.com/ios/20150721/12611.html">iOS-CoreLocation：无论你在哪里，我都要找到你！</a> 。</li>
<li><a href="https://github.com/Cee/pangu.objective-c">pangu.objective-c</a> - 有多种语言实现版本～ Pangu.Objective-C：格式化中英文之间的空格（OC）。</li>
<li><a href="https://github.com/atomicobject/objection">objection</a> - 一个轻量级的依赖注入框架Objection。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS/tree/master/ControlOrientation/ControlOrientation">ControlOrientation</a> - 如何用代码控制以不同屏幕方向打开新页面【iOS】， <a href="https://lvwenhan.com/ios/458.html">使用说明</a>。</li>
<li><a href="https://github.com/nicklockwood/iRate">iRate</a> - 问卷调查。</li>
<li><a href="https://github.com/nihalahmed/GameCenterManager">GameCenterManager</a> - 在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。</li>
<li><a href="https://github.com/slackhq/SlackTextViewController">SlackTextViewController</a> - 用作极佳、定制的文本输入控制时，自适应文本区域，手势识别、自动填充、多媒体合并，快速drop-in解决方案。</li>
<li><a href="https://github.com/saturngod/IAPHelper">IAPHelper</a> - 应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。</li>
<li><a href="https://github.com/WildDylan/IAPDemo">IAPDemo</a> - 应用内支付IAP全部流程, <a href="http://www.jianshu.com/p/e9ae4cece800">教程</a>。</li>
<li><a href="https://github.com/bizz84/SwiftyStoreKit">SwiftyStoreKit</a> - 一款轻量级的 iOS 应用内购买框架。</li>
<li><a href="https://github.com/JanC/TAPromotee">TAPromotee</a> - 交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。</li>
<li><a href="https://github.com/cgwangding/DownloadFontOnline">DownloadFontOnline</a> - 实现了在线下载一些字体的功能，不用在工程中导入字体库，下载的字体也不会保存在你的应用中，所以可以放心使用。修复了一下崩溃的bug。</li>
<li><a href="https://github.com/zhenlintie/STClock">STClock</a> - 仿锤子时钟。</li>
<li><a href="https://github.com/git-up/GitUp">GitUp</a> - GitUp是一个可视化的Git客户端，能够实时的进行编辑、合并、回滚等多种操作，更多功能，请下载体验。</li>
<li><a href="http://code.cocoachina.com/detail/320392/">获取联系人信息，通讯录</a> - 获取联系人信息，通讯录。</li>
<li><a href="https://github.com/HHuiHao/Universal-Jump-ViewController">Universal-Jump-ViewController</a> - 根据规则跳转到指定的界面(runtime实用篇一)。</li>
<li><a href="https://github.com/Ekhoo/Device">Device-swift</a> - 可以非常方便的获取设备型号和屏幕尺寸，实现起来难度不大，大家可以学习一下源码。</li>
<li><a href="https://github.com/khoiln/RunKit">RunKit.swift</a> - 针对 GCD 框架的一个友好访问封装库（支持方法链式调用）。</li>
<li><a href="https://github.com/FlexMonkey/Plum-O-Meter">Plum-O-Meter</a> - swift 称重应用， (3D Touch之我见)[<a href="http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/">http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/</a>]。</li>
<li><a href="http://code.cocoachina.com/view/128249">打开自带地图、百度地图、腾讯地图</a> - 打开自带地图、百度地图、腾讯地图。</li>
<li><a href="https://github.com/varshylmobile/MapManager">MapManager.swift</a> - MapManager.swift地图及路径管理封装库。</li>
<li><a href="https://github.com/googollee/eviltransform">eviltransform.swift</a> - eviltransform.swift解决国内GPS地图坐标偏移问题,它将政府加密过的GCJ-02坐标，转成世界通用的WGS-84坐标。</li>
<li><a href="https://github.com/colin1994/batteryLevelTest">batteryLevelTest</a> - runtime精准获取电池电量，<a href="http://www.jianshu.com/p/11c1afdf5415">文档</a>。</li>
<li><a href="https://github.com/100apps/openshare">openshare</a> - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。</li>
<li><a href="https://github.com/MatthewYork/DateTools">DateTools</a> - 用于提高Objective-C中日期和时间相关操作的效率。灵感来源于 DateTime和Time Period Library。</li>
<li><a href="https://github.com/deepdevelop/DDSlackFeedback">DDSlackFeedback</a> - 用这个接口实现的摇一摇上传文字或者截屏反馈到你的 Slack channel，特别适合测试 app 的时候用，集成也很简单。</li>
<li><a href="https://github.com/coolnameismy/BabyBluetooth">BabyBluetooth</a> - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。<a href="http://www.cocoachina.com/ios/20160219/15301.html">iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍</a></li>
<li><a href="https://github.com/Polidea/RxBluetoothKit">RxBluetoothKit.swift</a> - 基于 RxSwift 的蓝牙通讯库。</li>
<li><a href="https://github.com/rasmusth/BluetoothKit">BluetoothKit.swift</a> - 基于 CoreBluetooth API 实现iOS/OS X 设备间蓝牙通讯封装类库。功能强大、传输稳定，示例完整，很酷。</li>
<li><a href="https://github.com/bignerdranch/CoreDataStack">CoreDataStack.swift</a> - 存储栈。</li>
<li><a href="https://github.com/THREDOpenSource/SYNQueue">SYNQueue.swift</a> - 执行队列类库。</li>
<li><a href="https://github.com/davedelong/DDMathParser">DDMathParser.swift</a> - 相比 NSExpression 和 GCMathPaser，功能更强大的数学表达式解析器。</li>
<li><a href="https://github.com/soffes/RateLimit">RateLimit.swift</a> - 简单、实用定时执行任务工具类库。</li>
<li><a href="https://github.com/shaojiankui/IOS-Categories">iOS-Categories</a> - 收集了许多有助于开发的iOS扩展,各种category分类。</li>
<li><a href="https://github.com/ibireme/YYCategories">YYCategories</a> - 功能丰富的 Category 类型工具库。</li>
<li><a href="https://github.com/ibireme/YYAsyncLayers">YYAsyncLayers</a> -  iOS 异步绘制与显示的工具。</li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a> -  iOS 全局并发队列管理工具。</li>
<li><a href="https://github.com/ibireme/YYKeyboardManager">YYKeyboardManager</a> -   iOS 键盘监听管理工具。</li>
<li><a href="https://github.com/6ag/shoppingCart">shoppingCart.swift</a> - swift的购物车demo，采用纯代码UI，autolayout自动布局，core animation动画效果。</li>
<li><a href="https://github.com/gbaldera/ShoppingCartExample">ShoppingCartExample</a> - 购物车最多star demo。</li>
<li><a href="https://github.com/yhangeline/shoppingCart">shoppingCart1</a> - 仿美团购物车效果。</li>
<li><a href="https://github.com/WZF-Fei/ZFShoppingCart">ZFShoppingCart</a> - 仿照美团外卖加入购物车的动态效果。</li>
<li><a href="https://github.com/spxvszero/ShoppingCart">shoppingCart2</a> - 一个购物车demo，包含购物车动画效果、购物车多选、删除、编辑等功能。</li>
<li><a href="https://github.com/DrYrw/shoppingCart-demo">shoppingCart-demo</a> - 一个简单的购物车功能实现demo。</li>
<li><a href="https://github.com/ZyZwei/iOS_oShoppingCart_Demo">iOS_oShoppingCart_Demo</a> - 简单实现购物车常见的筛选功能。</li>
<li><a href="https://github.com/342261733/XNQShoppingTrolley">XNQShoppingTrolley</a> - 购物车功能 基本功能仿照淘宝的购物车。</li>
<li><a href="https://github.com/Zhangjingwang1993/ShoppingDemo">ShoppingDemo</a> - iOS仿美团外卖饿了吗App点餐动画,购物车。</li>
<li><a href="http://code.cocoachina.com/view/129430">shopCarDemobyCX</a> - shopCarDemobyCX一个简易购物车效果，最重要的是可以分单结算，分单个商品结算，代理是主要技术。</li>
<li><a href="http://code.cocoachina.com/view/128713">MVVM KVO购物车</a> - MVVM KVO 购物车(一处计算总价钱)。</li>
<li><a href="https://github.com/bb-coder/BHBDrawBoarderDemo">BHBDrawBoarderDemo车</a> - 仿写猿题库练题画板功能，没有用drawRect，而是用CAShapeLayer来做画板绘画，特别省内存，赞1个，<a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/">实现分析</a>。</li>
<li><a href="https://github.com/uraimo/SwiftyGPIO">SwiftyGPIO</a> - 通过 Swift 语言去控制基于 Linux 主板（比如：C.H.I.P. 和 树莓派） 的 GPIO（General Purpose Input Output ），去完成简单的工控功能（比如 LED 灯的显示）。</li>
<li><a href="https://github.com/onmyway133/Scale">Scale.swifty</a> - 简单直观的单位计算及换算类库（支持常用计量类型）。代码简洁性、直观性杠杠的。</li>
<li><a href="https://github.com/dankogai/swift-pons">swift-pons</a> - 面向协议的不受长度限制数字类型及数学计算扩充类库。用它做一款最牛科学计算器妥妥地。</li>
<li><a href="https://github.com/amayne/SwiftString">SwiftString</a> - SwiftString:String 扩展功能很丰富（无论格式化杂乱字符串，还是子串查找，亦或是格式转换都很强大）。</li>
<li><a href="https://github.com/rentzsch/jrswizzle">jrswizzle</a> - runtime实现的Method Swizzling第三方框架。</li>
<li><a href="https://github.com/marmelroy/FileBrowser">FileBrowser.swift</a> - FileBrowser.swift 一款开源的 iOS 文件浏览器, 支持文件搜索, 文件预览和 3D touch 功能。</li>
<li><a href="https://github.com/marmelroy/FileBrowser">AFBrushBoard.swift</a> -  AFBrushBoard.swift基于swift的毛笔画板Demo。包含多阶贝塞尔曲线的抽取、模拟画笔速度等算法。</li>
<li><a href="https://github.com/ortuman/SwiftForms">SwiftForms</a> - SwiftForms表单递交库，快速开发利器。</li>
<li><a href="https://github.com/ochococo/Design-Patterns-In-Swift">Design-Patterns-In-Swift</a> - Design-Patterns-In-Swift如何使用常用设计模式及示例。</li>
<li><a href="https://github.com/ankurp/Dollar">Dollar.swift</a> - Dollar.swift是一个Swift库，无需扩展任何内置对象就为Swift语言提供有效的函数式编程辅助方法，类似于Lo-Dash或JavaScript中的Underscore。而Cent则是通过扩展功能来扩展Swift中的特定对象类型。</li>
<li><a href="https://github.com/JakeLin/Underscore">Underscore.swift</a> - 函数式编程辅助方法，可靠性上压倒目标对手是 Dollar。</li>
<li><a href="https://github.com/kylef/PathKit">PathKit.swift</a> - PathKit.swift小而美的路径管理类。</li>
<li><a href="https://github.com/mattt/Surge">Surge.swift</a> - Surge.swift基于苹果Accelerate高性能计算数学框架封装库。</li>
<li><a href="https://github.com/duemunk/Async">Async.swift</a> - Async.swift简洁的后台执行代码的异步封装库。</li>
<li><a href="https://github.com/Alecrim/AlecrimAsyncKit">AlecrimAsyncKit.swift</a> - 一款很优雅的异步执行框架库。</li>
<li><a href="https://github.com/Thomvis/BrightFutures">BrightFutures.swift</a> - BrightFutures.swift漫长或复杂计算由独立线程异步来完成。</li>
<li><a href="https://github.com/mattt/Euler">Euler.swift</a> - Euler.swift直观、简洁的数学表达式∛27÷3+∑[3,1,2]。</li>
<li><a href="https://github.com/ArtSabintsev/Siren">Siren.swift</a> - Siren.swift当应用更新时，通知用户并提供App Store链接。</li>
<li><a href="https://github.com/nutletor/Demo_ProductDetailScroll">Demo_ProductDetailScroll</a> - Demo_ProductDetailScroll ：仿京东商品详情滚动翻页。</li>
<li><a href="https://github.com/huangzhibiao/-">BGTaobao</a> - ios 高仿淘宝/京东详情页 - 集合各种测试框架。</li>
<li><a href="https://github.com/LQQZYY/CartDemo">CartDemo</a> - CartDemo比较完整的购物车界面及逻辑,商品展示,多选,单选,全选及滑动删除,价格计算。</li>
<li><a href="https://github.com/joeldev/JLRoutes">JLRoutes</a> - JLRoutes好用的URL map库，它的作用是让按钮的点击像网页里的链接一样，只是触发了某个URL，而没有像pushViewController这样的行为，实现解耦。</li>
<li><a href="https://github.com/lorentey/BTree">BTree.swift</a> - BTree.swift:相对于标准集合类型具有更优执行性能的基于B-Tree的优化集合类型实现类库。</li>
<li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> - 同时支持 Swift 及 Objective-C 的 Promise 类库，异步编程类库 提供了很多实用的异步函数 让异步编程更简单。</li>
<li><a href="https://github.com/ZipArchive/ZipArchive">ZipArchive</a> - 适用iOS和OS X的解压库。</li>
<li><a href="https://github.com/SwiftStudies/Duration">Duration.swift</a> - 测量代码片段执行时间工具类库（Swift）。</li>
<li><a href="https://github.com/BoltsFramework/Bolts-Swift">Bolts-Swift</a> - 全平台（所有支持 Swift 的设备）任务管理 futures/promises 异步实现类库。</li>
<li><a href="https://github.com/boycechang/BCColor">BCColor.swift</a> - 轻量而强大的颜色处理库，纯 Swift 版。 支持从图片拾取一套主题色，类似AppleMusic；支持图片黑白化、对颜色的加深和变浅、生成渐变颜色等。</li>
<li><a href="https://github.com/KevinCoble/AIToolbox">AIToolbox.swift</a> - AI 主流模块集工具箱库。其中涉及 AI 知识实在广阔又高端。</li>
<li><a href="https://github.com/Loveway/HWChangeFont">HWChangeFont</a> - 利用runtime一键改变字体。<a href="http://www.jianshu.com/p/b9fdd17c525e">教程</a>。</li>
<li><a href="https://github.com/Tuccuay/RuntimeSummary">RuntimeSummary</a> - 一个集合了常用 Objective-C Runtime 使用方法的 Playground。</li>
<li><a href="https://github.com/goktugyil/EZSwiftExtensions">EZSwiftExtensions</a> - 对Swift标准库， Foundation， UIKit 提供了很多高级扩展函数。</li>
<li><a href="https://github.com/jscalo/TempiBeatDetection">TempiBeatDetection.swift</a> - Swift 语言写的音乐节奏节拍检测库。</li>
<li><a href="https://github.com/VeniceX/Venice">Venice.swift</a> - 让 Swift 3 提前支持协程（Coroutine）。P.S.  Chris  曾答疑过，Coroutine 不在 Swift 3 支持范围中，将在更晚时候讨论语言级支持。</li>
<li><a href="https://github.com/mzaks/FlatBuffersSwift">FlatBuffersSwift</a> - Swift 版 FlatBuffers 实现类库。P.S. FlatBuffers 是跨平台、高效，提供了 C++/Java 接口的序列化开源工具库。</li>
<li><a href="https://github.com/genadyo/Lyft">Lyft.swift</a> - 一套面向 Lyft 开发者的 Swift API 类库。</li>
<li><a href="https://github.com/gjiazhe/Up-Down">Up-Down.swift</a> - Up-Down.swift:在 OS X 菜单栏上实时显示网络上传和下载速度小工具。</li>
<li><a href="https://github.com/genadyo/Lyft">Algorithm.swift</a> - 算法和概率模型工具集。（作者 Daniel Dahan）</li>
<li><a href="https://github.com/cyanzhong/GCDThrottle">GCDThrottle</a> - 限制频率过高的调用GCD多线程。</li>
<li><a href="https://github.com/hyperoslo/Spots">Spots.swift</a> - 一套为了加速开发效率、将 view models 采用 JSON 格式存储于云端 view controller 框架库。</li>
<li><a href="https://github.com/Lickability/PinpointKit">PinpointKit.swift</a> - 简单的手势动作快速触发反馈组件。主要功能包含自动截屏、附加说明和日志。支持添加可定制箭头、着重框、文本、模糊打码等常用快照编辑功能。它非常适合开发过程中测试人员反馈缺陷。</li>
<li><a href="https://github.com/X140Yu/Switcher">Switcher.swift</a> - 一个 OS X 小 App，可以很轻松地切换 App Store 和 iTunes 的账号，对于同时使用多个 Apple ID 的人来说非常地方便。</li>
</ul>


<hr />

<h4>数据库</h4>

<ul>
<li><a href="https://github.com/ccgus/fmdb">FMDB</a> - sqlite的工具， <a href="https://github.com/tangqiaoboy/FmdbSample">多线程FMDatabaseQueue实例</a>，<a href="https://github.com/liuchunlao/LVDatabaseDemo">FMDB数据库的使用演示和封装工具类</a>，<a href="http://code.cocoachina.com/view/128312">基于fmdb 的基本操作</a> 通过 fmdb 进行的数据库的 基本操作(增删改查 )查找是使用 UISearchBar 和UISearchDisplayController 进行混合使用。</li>
<li><a href="https://github.com/Gerry1218/GXDatabaseUtils">GXDatabaseUtils</a> - 在FMDB基础上的工具。</li>
<li><a href="https://github.com/realm/realm-cocoa">realm-cocoa</a> - Realm是一个真正为移动设备打造的数据库，同时支持Objective-C和Swfit。Realm宣称其相比Sqlite，在移动设备上有着更好的性能表现,<a href="https://realm.io/cn/">官方中文</a> ，<a href="http://swift.gg/2015/12/08/ios-realm-instead-of-coredata/">iOS：选择 Realm 而不是 CoreData</a>, <a href="http://swift.gg/2015/12/08/building-a-todo-app-using-realm-and-swift/">使用 Realm 和 Swift 创建 ToDo 应用</a>。</li>
<li><a href="https://github.com/eure/RealmIncrementalStore">RealmIncrementalStore.swift</a> - RealmIncrementalStore.swift:集 Realm 数据库和 CoreData 对象模型两者优势的 Realm 数据库访问类库。</li>
<li><a href="https://github.com/andrelind/Breeze">Breeze</a> - 用Swift写的一个轻量级的CoreData管理工具，并且还支持iCloud 。</li>
<li><a href="https://github.com/Alecrim/AlecrimCoreData">AlecrimCoreData</a> - Swift，更容易地访问 CoreData 对象封装类库。除了 CRUD，还提供指针定位，强大的排序、筛选，异步数据获取，以及独立线程后台存取数据。</li>
<li><a href="https://github.com/AfryMask/AFBrushBoard">CoreStore</a> -  Core Data 管理类库。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a> - CoreData第一库，MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。</li>
<li><a href="http://rentzsch.github.io/mogenerator/">mogenerator</a> - mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。</li>
<li><a href="https://github.com/hyperoslo/Presentation">Presentation</a> - 重量级好项目 Presentation，它可以方便你制作定制的动画式教程、Release Notes、个性化演讲稿等。</li>
<li><a href="https://github.com/terhechte/CoreValue">CoreValue</a> - Swift 2 版 Core Data 封装库。相比另外两个 <a href="https://github.com/arkverse/SwiftRecord">SwiftRecord</a>和 <a href="https://github.com/JohnEstropia/CoreStore">CoreStore</a>更轻量。</li>
<li><a href="https://github.com/sqlcipher/sqlcipher">SQLCipher</a> - SQLCipher使用256-bit AES加密，SQLCipher分为收费版本和免费版本。<a href="https://www.zetetic.net/sqlcipher/ios-tutorial/">官方教程</a>， <a href="http://foggry.com/blog/2014/05/19/jia-mi-ni-de-sqlite/">加密你的SQLite</a> - 各种sqlite数据库加密介绍。 <a href="http://download.csdn.net/detail/wzzvictory_tjsd/7379055">SQLCipherDemo下载</a> 。</li>
<li><a href="https://github.com/stephencelis/SQLite.swift">SQLite.swift</a> - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。</li>
<li><a href="https://github.com/qutheory/fluent">fluent.swift</a> - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。</li>
<li><a href="http://www.appcoda.com/swiftydb/">swiftydb</a> - 是一个第三方 SQLite 工具，能够大大简化数据库操作。如果你不放心 Realm，那就用 SwiftyDB 吧。<a href="http://swift.gg/2016/05/17/swiftydb/">使用教程</a>、<a href="https://github.com/appcoda/SwiftyDB-Demo">demo</a></li>
<li><a href="https://github.com/CosmicMind/Graph">Graph.swift</a> - 设计新颖、使用简单基于 Core Data 的数据驱动框架库 （作者Daniel Dahan）。</li>
</ul>


<hr />

<h4>缓存处理</h4>

<ul>
<li><a href="https://github.com/yuantiku/YTKKeyValueStore">YTKKeyValueStore</a> - Key-Value存储工具类，<a href="http://tangqiaoboy.gitcafe.io/blog/2014/10/03/opensouce-a-key-value-storage-tool/">说明</a>。</li>
<li><a href="https://github.com/tumblr/TMCache">TMCache</a> - TMCache 是 Tumblr 开源的一个基于 key/value 的数据缓存类库,可以用于缓存一些临时数据或者需要频繁加载的数据,比如某些下载的数据或者一些临时处理结果。</li>
<li><a href="https://github.com/jl322137/JLKeychain">JLKeychain</a> - 快捷使用keychain存储数据的类，使keychain像NSUserDefaults一样工作。</li>
<li><a href="https://github.com/soffes/sskeychain">sskeychain</a> - SSKeyChains对苹果安全框架API进行了简单封装,支持对存储在钥匙串中密码、账户进行访问,包括读取、删除和设置。</li>
<li><a href="https://github.com/kishikawakatsumi/KeychainAccess">KeychainAccess</a> - 管理Keychain接入的小助手。</li>
<li><a href="https://github.com/ibireme/YYCache">YYCache</a> - 高性能的 iOS 缓存框架。</li>
<li><a href="https://github.com/CoderJackyHuang/RuntimeDemo">RuntimeDemo</a> - runtime自动归档/解档,<a href="http://www.henishuo.com/runtime-archive-unarchive-automaticly/">源码分析</a>。</li>
<li><a href="https://github.com/soffes/Cache">Cache.swift</a> - 一款简单、易用的缓存库。支持 MemoryCache, DiskCache 以及前两项组合的 MultiCache。</li>
<li><a href="https://github.com/hyperoslo/Cache">Cache.swift</a> - Nothing but Cache。</li>
<li><a href="https://github.com/aschuch/AwesomeCache">AwesomeCache.swift</a> - Delightful on-disk cache (written in Swift)。</li>
<li><a href="https://github.com/maquannene/Track">Track.swift</a> - 基于文件系统和链表的 Cache。分为 Disk 和 Memory，线程安全，支持 LRU 淘汰，性能尚可。</li>
</ul>


<hr />

<h4>PDF</h4>

<ul>
<li><a href="https://github.com/vfr/Reader">Reader</a> - Reader可提供类似iBooks的文档导航，支持屏幕旋转和所有方向，并通过密码保护加密PDF文件，支持PDF链接和旋转页面。</li>
</ul>


<hr />

<h4>图像浏览及处理</h4>

<ul>
<li><a href="https://github.com/liric28/FLAnimatedImage">FLAnimatedImage</a> - gif播放处理的工具。</li>
<li><a href="https://github.com/yackle/CLImageEditor">CLImageEditor</a> - 超强的图片编辑库，快速帮你实现旋转，防缩，滤镜等等一系列麻烦的事情。</li>
<li><a href="https://github.com/esilverberg/ios-image-filters">ios-image-filters</a> - 图像滤镜，库比较旧了，很容易崩溃。</li>
<li><a href="https://github.com/xissburg/XBImageFilters">XBImageFilters</a> - 图像滤镜。</li>
<li><a href="https://github.com/mwaterfall/MWPhotoBrowser">MWPhotoBrowser</a> - 一个非常不错的照片浏览器，在github的star接近3000个，<a href="http://www.superqq.com/blog/2015/01/22/jie-jue-mwphotobrowserzhong-de-sdwebimagejia-zai-da-tu-dao-zhi-de-nei-cun-jing-gao-wen-ti/">解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题</a>。</li>
<li><a href="https://github.com/objcio/issue-21-core-image-explorer">core-image-explorer</a> -  Core Image 滤镜处理图片&ndash; swift ，<a href="http://objccn.io/issue-21-6/">Core Image 介绍</a>。</li>
<li><a href="https://github.com/rFlex/CoreImageShop">CoreImageShop</a> - CoreImageShop图片滤镜处理&ndash; Mac app that let you create a complete Core Image Filter usable on iOS using SCRecorder。</li>
<li><a href="https://github.com/BradLarson/GPUImage">GPUImage</a> - 处理图片效果。</li>
<li><a href="https://github.com/BradLarson/GPUImage2">GPUImage2.swift</a> - Swift 版基于 GPU 图像和视频处理框架库。</li>
<li><a href="https://github.com/ruslanskorb/RSKImageCropper">RSKImageCropper</a> - 适用于iOS的图片裁剪器，类似Contacts app，可上下左右移动图片选取最合适的区域。</li>
<li><a href="http://code.cocoachina.com/detail/232156">WZRecyclePhotoStackView</a> - 删除照片交互&ndash;WZRecyclePhotoStackView，就是模拟生活中是删除或保留犹豫不决的情形而产生的。 在上滑，下滑的部分，借鉴了<a href="https://github.com/cwRichardKim/TinderSimpleSwipeCards">TinderSimpleSwipeCards</a>。</li>
<li><a href="https://github.com/schwa/TimingFunctionEditor">TimingFunctionEditor</a> - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器。 <a href="https://github.com/Carthage/Carthage">Carthage</a> ，而非常用的 CocoaPods。<a href="http://www.cocoachina.com/ios/20141204/10528.html">Carthage介绍中文</a>。</li>
<li><a href="https://github.com/aaronabentheuer/AAFaceDetection">AAFaceDetection</a> - AAFaceDetection&ndash;swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。</li>
<li><a href="https://github.com/itouch2/PhotoTweaks">PhotoTweaks</a> - 这个库挺赞的，正好是对图像操作的。</li>
<li><a href="https://github.com/contentful-labs/Concorde">Concorde</a> - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。</li>
<li><a href="https://github.com/tristanhimmelman/ZoomTransition">ZoomTransition</a> - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。</li>
<li><a href="https://github.com/melvitax/AFImageHelper">AFImageHelper</a> - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取。</li>
<li><a href="https://github.com/demonnico/PinterestSwift">PinterestSwift</a> - swift,Pinterest 风格图片缩放、切换示例。</li>
<li><a href="https://github.com/KittenYang/KYElegantPhotoGallery">KYElegantPhotoGallery</a> - 一个优雅的图片浏览库。</li>
<li><a href="https://github.com/gsdios/SDPhotoBrowser">SDPhotoBrowser</a> - 仿新浪动感图片浏览器,非常简单易用的图片浏览器，模仿微博图片浏览器动感效果，综合了图片展示和存储等多项功能。</li>
<li><a href="https://github.com/chennyhuang/HZPhotoBrowser">HZPhotoBrowser</a> - 一个类似于新浪微博图片浏览器的框架（支持显示和隐藏动画；支持双击缩放，手势放大缩小；支持图片存储；支持网络加载gif图片，长图滚动浏览；支持横竖屏显示）。</li>
<li><a href="https://github.com/ijoyc/PhotoStackView-Swift">PhotoStackView-Swift</a> - PhotoStackView——照片叠放视图，<a href="http://blog.csdn.net/u013604612/article/details/46336657">使用说明</a>。</li>
<li><a href="https://github.com/FlexMonkey/MarkingMenu">MarkingMenu</a> - 基于手势、类似 Autodesk Maya 风格标记菜单及图片渲染。</li>
<li><a href="https://github.com/dsxNiubility/SXPhotoShow">SXPhotoShow</a> - UICollectionViewFlowLayout流水布局 是当下collectionView中常用且普通的布局方式。本代码也写了三种好看的布局，其中LineLayout和流水布局有很大的相同点就直接继承UICollectionViewFlowLayout，然后StackLayout，CircleLayout这两种都是直接继承自最原始的UICollectionViewLayout 布局方案。</li>
<li><a href="https://github.com/cgwangding/PictureWatermark">PictureWatermark</a> - 主要实现了给图片加文字以及图片水印的功能，已封装成了UIImage的类别，方便使用。</li>
<li><a href="http://code.cocoachina.com/detail/320603/">自定义宽高比的相册框 拍照</a> - 取出照片时 弹出自定义view。在这个自定义view上创建一个需要的相框大小的view层 把取出的图片赋值给UIImageView按缩放添加到这个层上。对uiimageView添加捏合、移动 手势。添加按钮 选取，最后根据位移和缩放比例 裁剪image。</li>
<li><a href="https://github.com/gang544043963/LGPhotoBrowser">LGPhotoBrowser</a> - LGPhotoBrowser:相册选择/浏览器/照相机（仿微信）,包含三个模块：照片浏览器，相册选择器，照相机。</li>
<li><a href="https://github.com/oscarWyz/PhotoBrowser">PhotoBrowser</a> - 一个简单的好用的的图片浏览器。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">BeautyHour</a> - 完整应用，功能与“美图秀秀”雷同。</li>
<li><a href="https://github.com/DroidsOnRoids/MPParallaxView">MPParallaxView</a> - 是用 Swift 写的类似 Apple TV Parallax 效果的视图。</li>
<li><a href="https://github.com/zhengjinghua/StitchingImage">StitchingImage</a> - 仿微信群组封面拼接控件, 直接拖进项目就可使用，<a href="http://gold.xitu.io/entry/56395f5360b20b143a9178f6">教程</a>。</li>
<li><a href="https://github.com/seedante/SDECollectionViewAlbumTransition">SDECollectionViewAlbumTransition</a> - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。</li>
<li><a href="https://github.com/xujingzhou/BeautyHour">SKPhotoBrowser.swift</a> - swift中规中矩、实用的图片浏览类库。示例也很完整。</li>
<li><a href="https://github.com/kean/Nuke">Nuke.swift</a> - 完整、强大、实用的图片管理类库。主要功能包括可定制装载，缓存，滤镜及尺寸变换。</li>
<li><a href="https://github.com/AwesomeDennis/DNImagePicker">DNImagePicker</a> - 类似wechat的图片选择。</li>
<li><a href="https://github.com/lioonline/CocoaPicker">CocoaPicker</a> - 仿QQ图片选择器（OC）。</li>
<li><a href="https://github.com/johnil/JFImagePickerController">JFImagePickerController</a> - vvebo作者：多选照片、预览已选照片、针对超大图片优化。</li>
<li><a href="https://github.com/vitoziv/VIPhotoView">VIPhotoView</a> - 图片浏览，用于展示图片的工具类，因为是个 View，所以你可以放在任何地方显示。支持旋转，双击指定位置放大等。</li>
<li><a href="https://github.com/SpringOx/AGImagePickerController">AGImagePickerController</a> - 是一个图片选择器，支持图片多选，支持大图横滑预览，支持放大预览，支持横竖屏，支持所有的iOS设备。</li>
<li><a href="https://github.com/ibireme/YYImage">YYImage</a> - 功能强大的 iOS 图像框架，支持大部分动画图像、静态图像的播放/编码/解码。</li>
<li><a href="https://github.com/KyoheiG3/PagingView">PagingView.swift</a> - 注重细节的自动布局分页视图组件。</li>
<li><a href="https://github.com/banchichen/TZImagePickerController">TZImagePickerController</a> - 一个支持多选、选原图和视频的图片选择器，同时有预览功能，适配了iOS6789系统。<a href="http://www.cocoachina.com/ios/20160112/14942.html">教程</a>.</li>
<li><a href="http://code.cocoachina.com/view/129134">更换头像</a> - 用户选取从相机或者相册获取图片，并且显示在View上。</li>
<li><a href="https://github.com/luzefeng/DouBanMeinv">DouBanMeinv.swift</a> - 抓取豆瓣美女图片，瀑布流显示。</li>
<li><a href="https://github.com/ACEYL/ZZPhotoKit">ZZPhotoKit</a> - 基于Photos和AVFoundation框架开源，相册多选与相机连拍。</li>
<li><a href="https://github.com/startry/SwViewCapture">SwViewCapture.swift</a> - SwViewCapture.swift一个用起来还不错的iOS截图库.(支持截取所有内容, 适用于所有ScrollView组成的视图, 包括WebView)。</li>
<li><a href="https://github.com/Guikunzhi/BeautifyFaceDemo">BeautifyFaceDemo</a> - 一个基于 GPUImage 的实时直播磨皮滤镜的开源实现,主要功能脸部去斑磨皮！</li>
<li><a href="https://github.com/YuAo/YUCIHighPassSkinSmoothing">YUCIHighPassSkinSmoothing</a> - 磨皮滤镜！</li>
<li><a href="https://github.com/FlexMonkey/Filterpedia">Filterpedia.swift</a> - 强大的图片滤镜库演示。</li>
<li><a href="https://github.com/YuAo/YUGPUImageHighPassSkinSmoothing">YUGPUImageHighPassSkinSmoothing</a> - 一个基于 GPUImage 的磨皮滤镜！</li>
<li><a href="https://github.com/Ramotion/preview-transition">preview-transition.swift</a> - 通过向导式代码实现步骤，实现完整、自然流畅的图片预览及转场功能。</li>
<li><a href="https://github.com/FlexMonkey/CartoonEyes">CartoonEyes.swift</a> - 前置摄像头捕获图像后，采用 Core Image 脸部识别 CIDetector 和漫画效果滤镜复合出卡通效果眼睛。</li>
<li><a href="https://github.com/Guikunzhi/YLFaceuDemo">YLFaceuDemo</a> - 在直播应用中添加Faceu贴纸效果。Faceu贴纸效果其实就是在人脸上贴一些图片，同时这些图片是跟随着人脸的位置改变的。<a href="http://www.jianshu.com/p/ba1f79f8f6fa">说明</a></li>
</ul>


<hr />

<h4>摄像照相视频音频处理</h4>

<ul>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - SCRecorder 短视频录制。</li>
<li><a href="https://github.com/zangqilong198812/VideoPushDemo">VideoPushDemo</a> - 视频剪辑 <a href="http://www.jianshu.com/p/3006502912aa">视频特效制作1</a> <a href="http://www.jianshu.com/p/6313025349a9">视频特效制作2</a>。</li>
<li><a href="https://github.com/omergul123/LLSimpleCamera">LLSimpleCamera</a> - A simple, customizable camera control for iOS， 摄像头。</li>
<li><a href="https://github.com/syedhali/EZAudio">EZAudio</a> - EZAudio 是一个 iOS 和 OSX 上简单易用的音频框架，根据音量实时显示波形图，基于Core Audio，适合实时低延迟音频处理，非常直观。<a href="https://segmentfault.com/blog/news/1190000000370957">中文介绍</a>,<a href="http://www.syedharisali.com/about">官网</a>。</li>
<li><a href="http://ffmpeg.org/">ffmpeg</a> - ffmpeg官网，<a href="http://www.cocoachina.com/ios/20150514/11827.html">FFmpeg在iOS上完美编译</a>。</li>
<li><a href="http://www.videolan.org/">VLC</a> - VCL官网,<a href="https://www.videolan.org/vlc/download-ios.html">VLC for iOS 2.7.2 source code</a>。</li>
<li><a href="https://github.com/kolyvan/kxmovie">kxmovie</a> - 使用ffmpeg的影片播放器，<a href="http://www.cocoachina.com/bbs/read.php?tid=145575">修改说明</a>， <a href="https://github.com/kinglonghuang">修改代码</a>，<a href="https://github.com/namebryant/FFmpeg-Compilation">基于FFmpeg的kxMoive艰难的编译运行</a>。</li>
<li><a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a> - B站开源的视频播放器，支持Android和iOS。 <a href="http://www.jianshu.com/p/1f06b27b3ac0">iOS中集成ijkplayer视频直播框架</a>。</li>
<li><a href="https://github.com/tumtumtum/StreamingKit">StreamingKit</a> - StreamingKit流媒体音乐播放器。</li>
<li><a href="https://github.com/muhku/FreeStreamer">FreeStreamer</a> - FreeStreamer流媒体音乐播放器，cpu占用非常小。</li>
<li><a href="https://github.com/douban/DOUAudioStreamer">DOUAudioStreamer</a> - DOUAudioStreamer豆瓣的音乐流媒体播放器。</li>
<li><a href="https://github.com/fmpro/fmpro">fmpro</a> - 电台播放器，支持锁屏歌词，支持基本播放流程，歌词展示，后台锁屏播放和控制以及锁屏后封面+歌词，<a href="https://github.com/jovisayhehe/fmpro_R">fmpro_R</a> 。</li>
<li><a href="https://github.com/mmackh/IPDFCameraViewController">IPDFCameraViewController</a> - 支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。</li>
<li><a href="https://github.com/rFlex/SCRecorder">SCRecorder</a> - 酷似 Instagram/Vine 的音频/视频摄像记录器，以 Objective-C 为基础的过滤器框架。 你可以做很多如下的操作：记录多个视频录像片段。删除任何你不想要的记录段。可以使用任何视频播放器播放片段。保存的记录可以在序列化的 NSDictionary 中使用。（在 NSUserDefaults 的中操作）添加使用 Core Image 的视频滤波器。可自由选择你需要的 parameters 合并和导出视频。</li>
<li><a href="https://github.com/GabrielAlva/Cool-iOS-Camera">Cool-iOS-Camera</a> - Cool-iOS-Camera。</li>
<li><a href="https://github.com/IFTTT/FastttCamera">FastttCamera</a> - FastttCamera 快速照相。</li>
<li><a href="https://github.com/itsmeichigo/ICGVideoTrimmer">ICGVideoTrimmer</a> - ICGVideoTrimmer提供提供视频剪切的视图（类似系统相册中浏览视频时顶部那个条状视图）。左右两个边界选择器还能够自定义。</li>
<li><a href="http://d.cocoachina.com/code/detail/285717">IOS录音和播放功能demo</a> - 比较完整的ios录音和播放功能的实现。</li>
<li><a href="https://github.com/imaginary-cloud/CameraManager">CameraManager</a> - 相机管理封装类库。看着极好用的样子&mdash;-swift。</li>
<li><a href="https://github.com/msching/MCAudioInputQueue">MCAudioInputQueue</a> - 简易录音类，基于AudioQueue的。</li>
<li><a href="https://github.com/vizllx/DraggableYoutubeFloatingVideo">DraggableYoutubeFloatingVideo</a> - 展示像类似Youtube移动应用的那种浏览视频的效果，当点击某视频时能够从右下方弹出一个界面，并且该界面能够通过手势，再次收缩在右下方并继续播放。这是通过AutoLayout设计实现。</li>
<li><a href="http://www.penguin.cz/~utx/amr">amr</a> - 做即时通讯的音频处理，录音文件是m4a，便于web端的音频播放。</li>
<li><a href="http://code4app.com/ios/%E8%BE%B9%E5%BD%95%E9%9F%B3%E8%BE%B9%E8%BD%AC%E7%A0%81/521c65d56803fab864000001">边录音边转码</a> - 一边录音，一边将录制成的 wav 格式音频文件转码成 amr 音频格式。只支持真机运行调试。</li>
<li><a href="https://github.com/f33chobits/FSVoiceBubble">FSVoiceBubble</a> - 一个轻量级播放录音音频的气泡：1.支持短时间的音频播放（支持网络音频）；2.播放时的声波动画；3.自定义包括声波的颜色，气泡的背景等。</li>
<li><a href="https://github.com/36Kr-Mobile/KRVideoPlayer">KRVideoPlayer</a> - 类似Weico的播放器，支持竖屏模式下全屏播放。</li>
<li><a href="http://code.cocoachina.com/view/128253">自定义视频播放器AVPlayer</a> - 利用系统类AVPlayer实现完全自定义视频播放器，显示播放时间，缓存等功能。代码清晰，注释详细。</li>
<li><a href="https://github.com/xujingzhou/VideoBeautify">VideoBeautify</a> - 功能酷似美拍,秒拍等应用的源码：对视频进行各种美化处理，采用主题形式进行分类，内含各种滤镜，动画特效和音效等。</li>
<li><a href="https://github.com/hanton/HTY360Player">HTY360Player</a> - 是一款提供在 iOS 中使用 360 度无死角拖拽视频进行不同角度播放的视频播放器。</li>
<li><a href="https://github.com/AlexLittlejohn/ALCameraViewController">ALCameraViewController</a> - ALCameraViewController 摄像头视图控制器（含可定制照片选择器，图片简单裁切功能）及演示。</li>
<li><a href="https://github.com/lfb-cd/recordDemo">recordDemo.swift</a> - 一个Swift语言实现直接可以用的录音Demo，<a href="http://www.jianshu.com/p/f0b88355d7cb">实现说明</a>。</li>
<li><a href="https://github.com/swiftcodex/Swift-Radio-Pro">Swift-Radio-Pro</a> - 集成 LastFM 的专业电台应用（基于 Swift 2.0）。</li>
<li><a href="https://github.com/coderyi/Eleven">Eleven</a> - Eleven Player - 一个使用 FFmpeg 实现的简单强大的 iOS 开源播放器。</li>
<li><a href="https://github.com/mobileplayer/mobileplayer-ios">mobileplayer-ios.swift</a> - 很不错的高度可定制播放器项目。</li>
<li><a href="https://github.com/lajos/iFrameExtractor">iFrameExtractor</a> - 开源视频播放器， ffmpeg在iOS的使用-iFrameExtractor源码解析，<a href="http://ios.jobbole.com/82408/">文章</a>。</li>
<li><a href="https://github.com/gontovnik/Periscope-VideoViewController">Periscope-VideoViewController.swift</a> - 简洁实用的视频快进、倒带控制视图类库。</li>
<li><a href="https://github.com/audiokit/AudioKit">AudioKit.swift</a> - 音频合成、加工及分析平台（支持 iOS、OS X、tvOS）框架库。无论其易用性，还是功能性及专业性。</li>
<li><a href="https://github.com/menxu/MusicPlayert">MusicPlayert</a> - MusicPlayert本地音乐播放+音乐信息显示+在线歌词搜索显示（千千静听服务器）。</li>
<li><a href="https://github.com/liuFangQiang/MusicPlayer">MusicPlayert</a> - MusicPlayert音乐播放器，用reveal可以查看层次关系，主要实现了歌词的同步显示。</li>
<li><a href="http://code.cocoachina.com/view/129435">音乐播放器</a> - 音乐播放器：显示歌词。</li>
<li><a href="https://github.com/suifengqjn/TBPlayer">TBPlayer</a> - 视频变下变播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer。<a href="http://www.jianshu.com/p/990ee3db0563">实现说明</a></li>
<li><a href="https://github.com/zhengwenming/WMPlayer">WMPlayer</a> - WMPlayer视频播放器，AVPlayer的封装，继承UIView，想怎么玩就怎么玩。支持播放mp4、m3u8、3gp、mov，网络和本地视频同时支持。全屏和小屏播放同时支持。 cell中播放视频，全屏小屏切换自如。</li>
<li><a href="https://github.com/280772270/IWatch">IWatch</a> - 一个视频日报类的app 播放器用到了AVFoudation。</li>
<li><a href="https://github.com/wubianxiaoxian/SkfSwiftCammer">SkfSwiftCammer</a> - 一个相机demo，在oc里面调用了swift。</li>
<li><a href="https://github.com/renzifeng/ZFPlayer">ZFPlayer</a> - 基于AVPlayer，支持横屏、竖屏（全屏播放还可锁定屏幕方向），上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。</li>
<li><a href="https://github.com/BrikerMan/BMPlayer">BMPlayer.swift</a> - 基于 AVPlayer 使用 Swift 封装的视频播放器，方便快速集成,支持横屏、竖屏，上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。</li>
</ul>


<hr />

<h4>响应式框架</h4>

<ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> - ReactiveCocoa 受函数响应式编程激发。不同于使用可变的变量替换和就地修改，RAC提供Signals来捕获当前值和将来值（ <a href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/">使用介绍</a> ），<a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">不错的例子</a>,入门好教程：<a href="http://www.cocoachina.com/ios/20150123/10994.html">ReactiveCocoa入门教程：第一部分 </a>。<a href="http://ios.jobbole.com/82232/">Reactive Cocoa 3.0 在 MVVM 中的应用</a> ,<a href="http://www.jianshu.com/p/87ef6720a096">小码哥：快速让你上手ReactiveCocoa之基础篇</a>。</li>
<li><a href="https://github.com/CrazySurfBoy/LoginWithReactiveCocoa">LoginWithReactiveCocoa</a> - ReactiveCocoa - 登录交互效果的实现。</li>
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> - RxSwift:函数响应式编程框架。</li>
<li><a href="https://github.com/sunshinejr/RxPermission">RxPermission.swift</a> - 通过绑定 RxSwift 实现的 RxPermission。</li>
<li><a href="https://github.com/delba/Permission">Permission.swift</a> - 统一的 API 请求 iOS 本地设备及资源权限类库。</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveAnimation">ReactiveAnimation</a> - ReactiveCocoa 推出了一个叫 ReactiveAnimation 的子项目，直接用完全用 Swift 来实现了。</li>
<li><a href="https://github.com/gavinkwoe/BeeFramework">BeeFramework</a> -  与ReactiveCocoa类似，<a href="http://www.lanrenios.com/tutorials/all/2012/1220/641.html">BeeFramework用户指南 v1.0</a>。</li>
<li><a href="https://github.com/Tricertops/Objective-Chain">Objective-Chain</a> - Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。</li>
<li><a href="https://github.com/bppr/Swiftest">Swiftest</a> - BDD 全称 Behavior Driven Development，行为驱动开发。各种 DD 数不胜数，孰优孰劣争论不休，其实归根结底还是要根据使用场景进行选择。</li>
<li><a href="https://github.com/lovemo/MVVMFramework">MVVMFramework</a> - (OC版)总结整理下一个快速开发框架，分离控制器中创建tableView和collectionView的代码，已加入cell自适应高度，降低代码耦合，提高开发效率。<a href="https://github.com/lovemo/MVVMFramework-Swift">MVVMFramework-Swift</a> - swift版本。</li>
</ul>


<hr />

<h4>消息相关</h4>

<h5>消息推送客户端</h5>

<ul>
<li><a href="https://github.com/sagiwei/SGPush/tree/master/SGPushDemo">SGPushDemo</a> - 消息推送客户端</li>
<li><a href="https://github.com/mattt/Orbiter">Orbiter</a> - 消息推送客户端:Push Notification Registration for iOS.</li>
<li><a href="https://github.com/ios44first/PushDemo">PushDemo</a> - 客户端消息接收消息代码，<a href="http://blog.sina.com.cn/s/blog_71715bf80102uy2k.html">IOS开发之 &mdash;- IOS8推送消息注册</a> ， <a href="http://my.oschina.net/u/2340880/blog/413584">分分钟搞定IOS远程消息推送</a>。</li>
</ul>


<h5>消息推送服务端</h5>

<ul>
<li><a href="https://code.google.com/p/archive/downloads/list">javapns源代码</a> - 消息推送的java服务端代码，注意：DeviceToken中间不能有空格。</li>
<li><a href="https://github.com/stefanhafeneger/PushMeBaby">pushMeBaby</a> - Mac端消息推送端代码，注意：DeviceToken中间要有空格。</li>
</ul>


<h5>通知相关</h5>

<ul>
<li><a href="https://github.com/jessesquires/JSQNotificationObserverKit">JSQNotificationObserverKit</a> - 一款轻量、易用的通知发送及响应框架类库。作者是知名开源项目 JSQMessagesViewController（Objective-C 版即时聊天）的作者 Jesse Squires.</li>
<li><a href="https://github.com/Glow-Inc/GLPubSub">GLPubSub</a> - 一个简短实用的 NSNotificationCenter 的封装。</li>
<li><a href="https://github.com/lizyyy/Homeoff">Homeoff</a> - 用swift写了一个模仿Launcher通知中心快捷方式的应用。支持20个应用，并增加了一个返回到桌面来解放Home键的功能。</li>
<li><a href="https://github.com/jaydee3/JDStatusBarNotification">JDStatusBarNotification</a> - 在状态栏顶部显示通知。可以自定义颜色字体以及动画。支持进度显示以及显示状态指示器。</li>
<li><a href="https://github.com/100mango/SwiftNotificationCenter">SwiftNotificationCenter</a> - 一个面向协议的类型安全、线程安全、内存安全的通知中心。</li>
</ul>


<hr />

<h4>版本新API的Demo</h4>

<ul>
<li><a href="https://github.com/WildDylan/appleSample">appleSample</a> - iOS 苹果官方Demo合集， <a href="https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&amp;topic=Sample%20Code">官方demo</a>.</li>
<li><a href="https://github.com/shu223/iOS7-Sampler">iOS7-Sampler</a> - 整合了iOS7.0的一些十分有用的特性，比如：Dynamic Behaviors、碰撞检测、语音合成、视图切换、图像滤镜、三维地图、Sprite Kit（动画精灵）、Motion Effect（Parallax）、附近蓝牙或者wifi搜索连接、AirDrop、运动物体追踪（iPhone 5S以上，需要M7处理器）等等。对于日常的应用开发十分实用。</li>
<li><a href="https://github.com/shu223/iOS8-Sampler">iOS8-Sampler</a> - 日本的shuさん制作的 iOS8 参考代码集。01.Audio Effects ；02.New Image Filters；03.Custom Filters；04.Metal Basic；05.Metal Uniform Streaming；06.SceneKit；07.HealthKit；08.TouchID；09.Visual Effects；10.WebKit；11.UIAlertController；12.User Notification；13.Pedometer；14.AVKit；15.Histogram；16.Code Generator；17.New Fonts；18.Popover；19.Accordion Fold Transition</li>
<li><a href="https://github.com/shu223/iOS-9-Sampler">iOS-9-Sampler</a> - 通过实例介绍了iOS 9 SDK中重要新特性的使用。</li>
<li><a href="https://github.com/MartinRGB/MTSwift-Learning">MTSwift-Learning</a> - 通过一些简单项目实战演练开始学习 Swift 。</li>
<li><a href="https://github.com/shinobicontrols/iOS8-day-by-day">iOS8-day-by-day</a> - swift。</li>
<li><a href="https://github.com/shinobicontrols/iOS9-day-by-day">iOS9-day-by-day</a> - swfit <a href="http://www.jianshu.com/p/039f8de6ee4d">iOS9 Day-by-Day :: Day 2 :: UI Testing</a>。</li>
<li><a href="http://www.cocoachina.com/ios/20150714/12557.html">iOS 9 分屏多任务</a> - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。</li>
<li><a href="https://github.com/uraimo/uistackview-sample">uistackview-sample.swift</a> - iOS 9 引进了 UIStackViews，提供 auto-layout 特性。如果你开发过 Android 应用，会发现它和 LinearLayouts 概念上很类似，它是增强版。你可以手动创建，也可以使用 IB 自动创建，本文用的是代码实现。</li>
<li><a href="https://github.com/fish-yan/Search-APIs">Search-APIs</a> - iOS 9 学习系列: SearchAPIs。<a href="http://blog.csdn.net/fish_yan_/article/details/50635433">教程</a></li>
</ul>


<hr />

<h4>代码安全与密码</h4>

<ul>
<li><a href="https://github.com/Polidea/ios-class-guard">ios-class-guard</a> - 一个用于混淆iOS的类名、方法名以及变量名的开源库&ndash;有人反映编译出来的app运行不了。</li>
<li><a href="https://www.polidea.com/#!heartbeat/blog/Protecting_iOS_Applications">《Protecting iOS Applications》</a>：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。</li>
<li><a href="https://github.com/facebook/fishhook">fishhook</a> - fishhook是Facebook开源的一个可以hook系统方法的工具。</li>
<li><a href="https://github.com/smilingxinyi/GesturePassword">GesturePassword</a> - 一个iOS手势密码功能实现，iPad/iPhone 都可以用，没有使用图片，里面可以通过view自己添加。keychain做的数据持久化，利用苹果官方KeychainItemWrapper类。操作部分都在controller了。删除直接用一下clear。</li>
<li><a href="https://github.com/Juuman/JMPasswordView">JMPasswordView</a> - 简单实用的手势密码，效果可自行调控。</li>
<li><a href="http://code.cocoachina.com/detail/298556/%E4%BB%BF%E5%AF%86%E7%A0%81%E9%94%81-%E4%B9%9D%E5%AE%AB%E6%A0%BC/">仿密码锁-九宫格</a> - 仿密码锁-九宫格，主要是使用UIButton 手势事件  UIBezierPath画图，解锁失败弹出“密码错误”。</li>
<li><a href="https://github.com/CharlinFeng/CoreLock">CoreLock</a> - 本框架是高仿支付宝，并集成了所有功能，并非一个简单的解锁界面展示。个人制作用时1周多，打造解锁终结者框架。</li>
<li><a href="https://github.com/crazypoo/LikeAlipayLockCodeView">LikeAlipayLockCodeView</a> - 高仿支付宝手势解锁（超级版）。</li>
<li><a href="https://github.com/liu044100/Smile-Lock">Smile-Lock.swfit</a> - 一个类似于iOS的解锁界面。</li>
<li><a href="https://github.com/iosdeveloperpanc/PCGestureUnlock">PCGestureUnlock</a> - 目前最全面最高仿支付宝的手势解锁，而且提供方法进行参数修改，能解决项目开发中所有手势解锁的开发。</li>
<li><a href="https://github.com/icoder20150719/ICPayPassWordDemo">ICPayPassWordDemo</a> - CPayPassWordDemo，一个模仿支付宝支付密码输入对话框小demo。</li>
<li><a href="https://github.com/bigsan/RSAESCryptor">RSAESCryptor</a> - 加密 RSA+AES Encryption/Decryption library for iOS. This library uses 2048-bit RSA and 256-bit key with 128-bit block size AES for encryption/decryption。</li>
<li><a href="https://github.com/bringbird/TouchID">TouchID</a> - 用法简单的TouchID验证框架：两行代码搞定。</li>
<li><a href="https://github.com/OAuthSwift/OAuthSwift">OAuthSwift</a> - OAuthSwift国外主流网站OAuth授权类库。</li>
<li><a href="https://github.com/krzyzanowskim/CryptoSwift">CryptoSwift</a> - swift加密库, 支持md5,sha1,sha224,sha256&hellip;。</li>
</ul>


<hr />

<h4>测试及调试</h4>

<ul>
<li><a href="https://github.com/tapwork/HeapInspector-for-iOS">HeapInspector</a> - HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。</li>
<li><a href="http://try.crashlytics.com/">Crashlytics</a> - Crashlytics 崩溃报告 崩溃日志   <a href="http://www.infoq.com/cn/articles/crashlytics-crash-statistics-tools">使用说明</a> 。</li>
<li><a href="https://github.com/RuiAAPeres/UIViewController-Swizzled">UIViewController-Swizzled</a> - 把你进入的每一个controller的类名打出来,如果看一些特别复杂的项目的时候直接运行demo就可以知道执行次序了。</li>
<li><a href="https://code.google.com/archive/p/snoop-it/">snoop-it</a> - snoop-it比UIViewController-Swizzled好用，代码托管在google上。</li>
<li><a href="https://github.com/zenangst/Versions">Versions</a> - 版本比较小工具。</li>
<li><a href="http://code4app.com/ios/MobileWebPerformanceTest/5465d3e9933bf00c658b4f43">MobileWebPageTest</a> - MobileWebPageTest是用来测试移动网页性能的软件，它可以对页面的加载和渲染过程进行截屏，协助开发者分析出页面性能瓶颈。</li>
<li><a href="https://github.com/Coneboy-k/KKLog">KKLog</a> - 一个日志管理系统。</li>
<li><a href="https://github.com/emaloney/CleanroomLogger">CleanroomLogger</a> - 相当于 CocoaLumberjack 或 Log4j 的 Swift 版本，功能上甚至更强大。另外，源代码中已经内含了完整的 API 文档，使用非常方便。</li>
<li><a href="https://github.com/czechboy0/Buildasaur">Buildasaur</a> - 自动测试框架 Buildasaur。</li>
<li><a href="http://www.devtf.cn/?p=739">使用Quick框架和Nimble来测试ViewControler</a> - Quick是一个用于创建BDD测试的框架。配合Nimbl，可以为你创建更符合预期目标的测试。</li>
<li><a href="https://github.com/fastlane/fastlane">fastlane</a> - 一套iOS开发和持续集成的命令行工具fastlane，可以用来快速搭建CI甚至自动提交的开发环境。这套工具中包括了上传ipa文件，自动截取多语言截屏，生成推送证书，管理产品证书等一系列实用工具。</li>
<li><a href="https://github.com/kif-framework/KIF">KIF</a> - 是一个开源的用户界面UI测试框架. 使用 KIF, 并利用 iOS中的辅助功能 API, 你将能够编写模拟用户输入，诸如点击，触摸和文本输入，自动化的UI测试.</li>
<li><a href="https://github.com/Quick/Quick">Quick</a> - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。</li>
<li><a href="https://github.com/railsware/Sleipnir">Sleipnir</a> - Swift的测试框架。</li>
<li><a href="https://github.com/kiwi-bdd/Kiwi/wiki">kiwi-bdd</a> - TDD或BDD，objective-c语言的测试框架，最流行的BDD测试框架了，Kiwi最受欢迎（根据github上的star数来推断，行为描述和期望写起来也比较易懂，至少我是这么认为的） <a href="http://www.jianshu.com/p/7e3f197504c1#">iOS开发中的测试框架</a>。</li>
<li><a href="https://github.com/specta/specta">specta</a> -  TDD或BDD，objective-c语言的测试框架，用的人多。</li>
<li><a href="https://github.com/pivotal/cedar">cedar</a> -  TDD或BDD，objective-c语言的测试框架，用的人少。</li>
<li><a href="https://github.com/daisuke0131/ViewMonitor">ViewMonitor</a> - 能够帮助 iOS 开发者们精确的测量视图, 可直接在调试应用中查看具体某个视图的坐标, 宽高等参数。</li>
<li><a href="https://github.com/adad184/MMPlaceHolder">MMPlaceHolder</a> - 一行代码显示UIView的位置及相关参数。</li>
<li><a href="https://github.com/adad184/XXPlaceHolder">XXPlaceHolder.swift</a> - MMPlaceHolder的swift版本。</li>
<li><a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a> - KMCGeigerCounter通过复杂和简单的视图演示了类似盖革计数器的帧速计算功能。掉帧通常是可见的，但是很难区分55fps和60fps之间的不同，而KMCGeigerCounter可以让你观测到掉落5帧的情况。</li>
<li><a href="https://github.com/SwiftyBeaver/SwiftyBeaver">SwiftyBeaver</a> - 一个完善的日志工具，支持彩色输出、输出内容到文件、重要性分级、多输出目标。工具执行在后台，不影响性能，可以极大提高开发效率。</li>
<li><a href="https://github.com/iachievedit/swiftlog">swiftlog</a> - 为Swift 应用提供快捷添加日志信息的方法，Swift 包管理支持（SPM）、 使用惊艳的 Rainbow 包输出彩色日志、支持写入文件。<a href="https://segmentfault.com/a/1190000004512773">使用 swiftlog</a></li>
<li><a href="https://github.com/delba/Log">Log.swift</a> - 灵活、易用、可定制输出格式和主题风格的日志类（Swift）,支持控制台彩色输出。</li>
<li><a href="https://github.com/SwiftKit/Cuckoo">Cuckoo.swift</a> - Cuckoo.swift一款用法更接近于传统单元测试 Mock 框架库（区别之处在于需要用脚本预先生成 Mock 类）。</li>
<li><a href="https://github.com/DaveWoodCom/XCGLogger">XCGLogger.swift</a> - XCGLogger.swift功能完整的日志管理类库。</li>
<li><a href="https://github.com/mindsnacks/MSLeakHunter">MSLeakHunter</a> - 自动检测 UIViewController 和 UIView 对象的内存泄露。<a href="https://github.com/Zepo/MLeaksFinder">MLeaksFinder 的使用参照</a></li>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a> - 是一个快速、简单，但很强大的日志框架。</li>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a> - 是一个快速、简单，但很强大的日志框架。</li>
<li><a href="https://github.com/hades0918/ipapy">ipapy</a> - iOS项目自动打包脚本，并且上传到fir.im，然后发送邮件给测试人员。</li>
<li><a href="https://github.com/facebook/fbretaincycledetector">fbretaincycledetector</a> - Facebook出品,通过Runtime监测循环引用。</li>
<li><a href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a> - Facebook出品,内存检测库。<a href="http://ifujun.com/fbmemoryprofiler-shi-yong-ji-chu-jiao-cheng/">FBMemoryProfiler 基础教程</a>。</li>
<li><a href="https://github.com/facebook/FBAllocationTracker">FBAllocationTracker</a> - Facebook出品,跟踪oc对象的分配情况。</li>
<li><a href="https://github.com/facebook/xctool">xctool</a> - Facebook出的自动化打包工具，它规范了输出的log日志，而且一些错误信息也更为清晰一些。</li>
<li><a href="https://github.com/shaps80/Peek">Peek.swift</a> - 更友好、手势方式检查界面内组件布局信息（相当于浏览器元素检查功能），界面调试利器。</li>
</ul>


<hr />

<h4>动态更新</h4>

<ul>
<li><a href="https://github.com/mmin18/WaxPatch">waxPatch</a> - 大众点评的屠毅敏同学在基于<a href="https://github.com/probablycorey/wax">wax</a>的基础上写了waxPatch，这个工具的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。</li>
<li><a href="https://github.com/bang590/JSPatch">JSPatch</a> - JSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。<a href="https://github.com/bang590/JSPatch">官网</a>。(JSPatchX)[<a href="https://github.com/bang590/JSPatchX">https://github.com/bang590/JSPatchX</a>] JSPatch的XCode 代码补全插件。</li>
<li><a href="https://github.com/casatwy/CTJSBridge">CTJSBridge</a> - JCTJSBridge：a javascript bridge for iOS app to interact with h5 web view。</li>
</ul>


<hr />

<h4>AppleWatch</h4>

<ul>
<li><a href="https://github.com/eleks/rnd-apple-watch-tesla">Tesla汽车AppleWatch app demo演示</a> - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。<a href="http://www.cocoachina.com/ios/20150205/11116.html">源码推荐说明</a>。</li>
<li><a href="https://github.com/kostiakoval/WatchKit-Apps">WatchKit-Apps</a> - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。</li>
<li><a href="https://github.com/KittenYang/KYVoiceCurve">KYVoiceCurve</a> - 类似Apple Watch中语音的声音曲线动画。</li>
<li><a href="https://github.com/facebookarchive/IGInterfaceDataTable">IGInterfaceDataTable</a> - IGInterfaceDataTable是WKInterfaceTable对象的一个类别，可以让开发者更简单地配置多维数据。该项目使用类似UITableViewDataSource的数据源模式配置Apple Watch表格，而不是将数据结构扁平化成为数组。</li>
<li><a href="http://www.swiftkiller.com/?p=613">Apple Watch开发教程资料汇总</a> - Apple Watch开发教程资料汇总。</li>
<li><a href="https://github.com/contentful-labs/Stargate">Stargate</a> - 通过 iPhone 桥接实现 Mac 与 Watch 的即时通讯。Stargate 通过封装两个优秀的基础类库 MMWormhole 和 PeerKit 实现高效的通讯应用。&ndash;swift</li>
<li><a href="https://github.com/sandofsky/soon">soon</a> - 一款倒计时 WatchKit 示例应用。作者从架构的角度，思考如何设计一款完整、通讯高效且性能又好的 WatchKit 扩展应用。该示例学习性非常强。&ndash;swift</li>
<li><a href="https://github.com/shu223/watchOS-2-Sampler">watchOS-2-Sampler</a> - 基于 watchOS 2 若干新特性，写了相应的示例代码供大家学习、参考。</li>
<li><a href="https://github.com/KhaosT/HMWatch">HMWatch</a> - HMWatch是个有待完善的watchOS 2.0 HomeKit 应用示例。</li>
<li><a href="https://github.com/manavgabhawala/CocoaMultipeer">CocoaMultipeer</a> - CocoaMultipeer这个开源框架支持OS X, iOS和watchOS设备间的点对点通信，解决watchOS和Mac之间通信的方案还是很有用的。</li>
<li><a href="https://github.com/GetHighstreet/HighstreetWatchApp">HighstreetWatchApp</a> - 是电商平台Highstreet针对App Watch的一款应用，该demo中加载的是虚拟数据。</li>
<li><a href="https://github.com/NilStack/NKWatchChart">NKWatchChart</a> - NKWatchChart是一个基于PNChart专门为Apple Watch 开发的图表库,目前支持 line, bar, pie, circle 和 radar 等 图表形式。</li>
<li><a href="https://github.com/diwu/BeijingAirWatch">BeijingAirWatch</a> - 国人的开源项目代码 ！WatchOS 2.0 Complication of Real-time Air Quality for Major Chinese Cities 苹果表盘实时刷新北上广沈蓉空气质量。</li>
<li><a href="https://github.com/mutualmobile/MMWormhole">MMWormhole.swift</a> - MMWormhole.swift:iOS或OS X扩展与宿主应用的通讯框架。</li>
</ul>


<hr />

<h4>VPN</h4>

<ul>
<li><a href="https://github.com/lexrus/vpnon/">vpnon</a> - swift的VPN On 的源码和本地化内容都是开放的: <a href="https://crowdin.com/project/vpnon">官方网站</a>。</li>
<li><a href="https://github.com/CatchChat/Hydro.network">Hydro.network</a> - <a href="http://blog.zhowkev.in/2015/03/09/hydro-network-de-kai-fa-lu-cheng/">Hydro.network 的开发旅程</a>, <a href="https://gitcafe.com/Catch/Hydro.network">gitcafe</a>。</li>
</ul>


<hr />

<h4>完整项目</h4>

<ul>
<li><a href="https://github.com/gsdios/GSD_WeiXin">GSD_WeiXin</a> 高仿微信</li>
<li><a href="https://github.com/singro/v2ex">v2ex</a> - v2ex 的客户端，新闻、论坛。</li>
<li><a href="https://github.com/Finb/V2ex-Swift">V2ex-Swift</a> - 用 Swift 写的 V2EX 客户端。</li>
<li><a href="https://github.com/iAugux/iBBS-Swift">iBBS-Swift</a> - “新手开源一个用Swift（2.0）写的论坛客户端”。<a href="http://obbs.sinaapp.com/">BBS 服务端</a>。</li>
<li><a href="https://github.com/wikimedia/wikipedia-ios">wikipedia-ios</a> - wikipedia-ios 客户端。</li>
<li><a href="https://github.com/uber/jetstream-ios">jetstream-ios</a> - 一款 Uber 的 MVC 框架。它同时提供了多用户实时通讯支持，一旦启动 JetStream 后端服务，通过 WebSocket 协议可以分分钟建立多用户实时通讯应用。</li>
<li><a href="https://github.com/jpsim/DeckRocket">DeckRocket</a> - 在相同 WiFi 网络环境内，通过iPhone 控制并播放 Mac 中的 PDF 文档。</li>
<li><a href="https://github.com/JayFang1993/ScanBook">ScanBook</a> - 扫扫图书:可以扫描条形码查询图书，也可以关键字搜索，遇到合乎你口味的书，还可以看看别人的读书笔记，不同角度去体会。</li>
<li><a href="https://github.com/MengTo/DesignerNewsApp">DesignerNewsApp</a> - Swift 开发的 DesignerNews 客户端，看着美美的！</li>
<li><a href="https://github.com/KittenYang/KYWeibo">KYWeibo</a> - 调用新浪API自己写的第三方微博客户端。</li>
<li><a href="https://github.com/li6185377/DouQu_IOS">DouQu_IOS</a> - 逗趣IOS手机端（一款笑话软件）,拥有完整的功能的手机应用app 。</li>
<li><a href="https://github.com/itjhDev/itjh">IT江湖iOS客户端</a> - IT江湖iOS客户端。</li>
<li><a href="https://github.com/artsy/eidolon">Eidolon</a> - 艺术品拍卖的投标亭平台，用swift与反应式编程框架 ReactiveCocoa。</li>
<li><a href="https://github.com/nonstriater/CrazyPuzzle">CrazyPuzzle</a> - 模仿“看图猜成语”App，功能齐全，配有音效，效果很不错。游戏使用cocoa框架完成，没有使用cocos2d的框架。</li>
<li><a href="https://github.com/Tim9Liu9/WhoCall">WhoCall</a> - 谁CALL我，iOS来电信息语音提醒，无需越狱。（需要iOS 7.0及以上版本。)骚扰电话预警、来电归属地提醒、联系人姓名播报，这些有中国特色人性化的电话功能，iOS上也应该有。电话提醒、私有API。</li>
<li><a href="http://www.devtf.cn/?p=562">仿iOS猎豹垃圾清理(实现原理+源码)</a> -  仿iOS猎豹垃圾清理(实现原理+源码),用到私有API。</li>
<li><a href="https://github.com/sam408130/DSLolita">DSLolita</a> - 模仿新浪微博做的一款app，有发送博文，评论，点赞，私聊功能。</li>
<li><a href="https://github.com/STShenZhaoliang/STPhotoBrowser">STPhotoBrowser</a> - 高仿新浪微博的图片浏览器，极佳的编写方式，易扩展，低耦合。</li>
<li><a href="https://github.com/gsdios/GSD_ZHIFUBAO">GSD_ZHIFUBAO</a> - 支付宝高仿版。</li>
<li><a href="https://github.com/thoughtbot/Tropos">Tropos</a> - Tropos, 由 thoughtbot 推出的一款用 Objective-C 写的开源天气类应用, 截至今天, thoughtbot 已在 GitHub 上贡献了 174 个开源项目, 实在令人敬佩。</li>
<li><a href="https://github.com/liu044100/SmileWeather">SmileWeather</a> -开源天气类应用,天气图标很完整。</li>
<li><a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> - GitBucket 2.0 通过审核啦，她是我在公司实践了一年多 MVVM 和 RAC 的基础上，利用业余时间开发的第三方 GitHub 客户端，旨在能够对想实践 MVVM 和 RAC 的 iOS 开发者有所帮助。<a href="https://itunes.apple.com/cn/app/id961330940?mt=8">AppStore地址</a>，欢迎下载使用GitBucket和收藏MVVMReactiveCocoa。</li>
<li><a href="https://github.com/dasdom/Tomate">Tomate</a> - 这个圆盘式计时器让你更专注于工作或学习。P.S. App Store 上架收费应用（0.99 欧）。</li>
<li><a href="https://github.com/joeshang/StoveFireiOSMenu">StoveFireiOSMenu</a> - 炉火餐饮系统iPad点餐端。</li>
<li><a href="https://github.com/belm/BaiduFM-Swift">BaiduFM-Swift</a> - 百度FM, swift语言实现，基于最新xcode6.3+swift1.2,初步只是为了实现功能，代码比较粗燥，后面有时间会整理，支持Apple Watch。</li>
<li><a href="https://github.com/ZhongTaoTian/WNXHuntForCity">WNXHuntForCity</a> - iOS高仿城觅项目（开发思路和代码）。</li>
<li><a href="https://github.com/zyprosoft/ZYChat">ZYChat</a> - 关于聊天界面的可消息类型扩展，响应绑定设计。</li>
<li><a href="https://github.com/lookingstars/meituan">meituan</a> - 美团5.7iOS版（高仿），功能包括，团购首页，高德地图搜索附近美食并显示在地图上，上门服务，商家，友盟分享。</li>
<li><a href="https://github.com/zangqilong198812/MeituanDemo">MeituanDemo</a> - 造美团应用界面构建的 iOS 应用, 第一个是 @叶孤城___ 的 MeituanDemo。</li>
<li><a href="https://github.com/tubie/JFMeiTuan">JFMeiTuan</a> - 造美团应用界面构建的 iOS 应用, 第二个是 @tubiebutu 的 JFMeiTuan。</li>
<li><a href="https://github.com/lookingstars/chuanke">chuanke</a> - 高仿百度传课iOS版。</li>
<li><a href="https://github.com/aiqiuqiu/Tuan">Tuan</a> - 模仿MJ老师iPad版美团（swift版），偶有bug 见谅。</li>
<li><a href="https://github.com/dsxNiubility/SXNews">SXNews</a> - 模仿网易新闻做的新闻软件，完成了主导航页，新闻详情页，图片浏览页，评论页。效果不错，比网上流传的各种和网易新闻UI架构有关的代码都要完整，都要好。</li>
<li><a href="https://github.com/coderyi/Monkey">Monkey</a> - Monkey for GitHub是一个GitHub开发者和仓库排名的开源App。这次主要增加了登录GitHub的功能，随手follow和star，并且增加发现模块，包括GitHub的trending，动态，showcases等。</li>
<li><a href="https://github.com/callmewhy/Uther">Uther</a> -  跟蠢萌的外星人聊天，还能帮你记事”。<a href="https://itunes.apple.com/cn/app/uther/id1024104920">itunes下载</a> 。</li>
<li><a href="https://github.com/zixun/CocoaChinaPlus">CocoaChinaPlus</a> - CocoaChina+是一款开源的第三方CocoaChina移动端。整个App都用Swift2.0编写(除部分第三方OC代码外，比如JPush和友盟)。</li>
<li><a href="http://code.cocoachina.com/view/128246">高仿斗鱼TV</a> - 高仿斗鱼TV，点击头部滚动视图可以播放视频。</li>
<li><a href="https://github.com/LonelyTown/LXZEALER">LXZEALER</a> - 模仿着做了zealer客户端,App里几乎所有请求都是Post,所以内容都是固定的URL加载的,登录功能只做了微博的第三方登录。</li>
<li><a href="https://github.com/pengleelove/ShiXiSeng_ios">ShiXiSeng_ios</a> - 完整app的UI框架。</li>
<li><a href="https://github.com/Coding/Coding-iPad">Coding-iPad</a> - Coding-iPad 是@Coding的官方 iPad 客户端, 又是一个完整的开源应用。</li>
<li><a href="https://github.com/likumb/SimpleMemo">SimpleMemo</a> - 易便签已经转到Swift2.0，全面适配iOS9和Watch OS2，并支持iPhone6s和iPhone6sPlus的3D Touch功能，包括图标快捷键和内容预览。</li>
<li><a href="https://github.com/xxycode/XXYAudioEngine">XXYAudioEngine.swift</a> - 基于NSURLSession 和 AVAudoPlayer的在线音乐的工具，可以把音乐保存在本地，也可以支持后台播放，后台下载，最低支持iOS7，swift版本1.2。</li>
<li><a href="https://github.com/twitterdev/furni-ios">furni-ios.swift</a> - furni-ios.swift是由 Twitter 开发团队出品的一款用 Swift 写的 iOS 家居商城应用, 其主要目的在于让开发者从这款 Demo 应用中看出 Fabric 的强大。</li>
<li><a href="https://github.com/sheepy1/SelectionOfZhihu">SelectionOfZhihu.swift</a> - 『看知乎』iOS 客户端, <a href="http://www.jianshu.com/p/2c3a0f109788">项目说明</a>。</li>
<li><a href="https://github.com/TigerWf/WFZhiHu">WFZhiHu</a> - WFZhiHu仿知乎日报客户端app。</li>
<li><a href="https://github.com/zpz1237/NirZhihuDaily2.0">NirZhihuDaily2.0_swift</a> - 精仿了知乎日报iOS端练手，Swift2.0，注释相当详细。</li>
<li><a href="https://github.com/CatchChat/Yep">Yep.swift</a> - Yep 一个由天才开发给天才们使用的社交软件。</li>
<li><a href="https://github.com/ZhongTaoTian/LoveFreshBeen">LoveFreshBeen.swift</a> - 高仿爱鲜蜂 - Swift2.0</li>
<li><a href="https://github.com/ZhongTaoTian/LoveFreshBeen">trySwiftApp.swift</a> - trySwiftApp一款较为完整的会议原型应用。有需求的同学可以做为开发参考。</li>
<li><a href="https://github.com/gaowanli/PinGo">PinGo.swift</a> - PinGo.swift：纯Swift编写的仿“随遇”App。</li>
<li><a href="https://github.com/ZeroJian/UmbrellaWeather">UmbrellaWeather.swift</a> - UmbrellaWeather.swift使用 Swift 编写的一款天气应用,现已上架 AppStore。</li>
<li><a href="https://github.com/JakeLin/SwiftWeather">SwiftWeather</a> - SwiftWeather清新淡雅持续改进天气预报项目。</li>
<li><a href="https://github.com/iAugux/Phonetic">Phonetic.swift</a> - Phonetic一个 iOS 版的 Phonetic Contacts，功能很多，其中昵称功能非常实用，已在 GitHub 开源并上架 App Store。</li>
<li><a href="https://github.com/tnantoka/edhita">edhita.swift</a> - edhita.swift支持Markdown, HTML预览的文本编辑器。</li>
<li><a href="https://github.com/cornerAnt/PilesSugar">PilesSugar.swift</a> - PilesSugar.swift:Swift高仿项目,堆糖。</li>
<li><a href="https://github.com/xiekw2010/react-native-gitfeed">react-native-gitfeed</a> - 目前最实用简洁的github客户端了。</li>
<li><a href="https://github.com/Aufree/phphub-ios">phphub-ios</a> - PHPHub的iOS客户端，同时兼容iPhone和iPad。</li>
<li><a href="https://github.com/pepibumur/SoundCloudSwift">SoundCloudSwift</a> - SoundCloud的Swift版本，采用Swift2.0，Reactive API with ReactiveCocoa 4.0。</li>
<li><a href="https://github.com/HarrisHan/LeagueofLegends">LeagueofLegends</a> - 一个关于英雄联盟的完整iOS开源项目，接口均来自多玩，腾讯各大游戏平台。</li>
<li><a href="https://github.com/wenghengcong/Coderpursue">Coderpursue.swift</a> - 一款 Github 第三方客户端，使用最新 Swift 语言编写。</li>
<li><a href="https://github.com/Ryan0520/BTApp">BTApp</a> - BTApp 仿半糖 iOS App 的 Demo 应用。</li>
<li><a href="http://www.henishuo.com/ios-app-fully-code/">iOS完整App资源收集</a> - iOS开发学习者都希望得到实战训练，但是很多资料都是只有一小部分代码，并不能形成完成的App，笔者在此处收集了很多开源的完整的App，都有源代码哦！&ndash;标哥的技术博客</li>
<li><a href="https://github.com/callmejoejoe/XCFApp">XCFApp-1</a> - 高仿下厨房App，Objective-C，Xcode7.2，数据通过Charles抓的，有接口也有本地数据。说明：关于代码被清空，会用git的你肯定明白，<a href="http://www.jianshu.com/p/a8f619a2c622/">教程</a></li>
<li><a href="https://github.com/STShenZhaoliang/XCFAPP">XCFApp-2</a> - 高仿下厨房APP。</li>
<li><a href="https://github.com/YouXianMing/YoCelsius">YoCelsius</a> - 已经上线的一款天气预报的应用,几乎所有的交互动画效果，想学习动画的开发人员可以作为参考。</li>
<li><a href="https://github.com/HansRove/XiMaLaYa-by-HansRove-">XiMaLaYa-by-HansRove-</a> - 仿喜马拉雅FM, 对AVFoundation框架的一次尝试，采用MVVM模式，<a href="http://ios.jobbole.com/85275/">教程</a>。</li>
</ul>


<hr />

<h4>好的文章</h4>

<ul>
<li><a href="http://www.jianshu.com/p/38cd35968864">自定义转场动画</a> - 3 种方法～ 关于自定义转场动画。</li>
<li><a href="https://github.com/icepy/_posts/blob/master/iOS%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7.md">iOS提高效率的方法和工具</a> - iOS提高效率的方法和工具。</li>
<li><a href="http://jsonapi.org.cn/">用 JSON 构建 API 的标准指南</a> - 用 JSON 构建 API 的标准指南。</li>
<li><a href="http://blog.callmewhy.com/2015/09/21/rxswift-getting-started-0/">RxSwift入坑手册</a> - RxSwift入坑手册。</li>
<li><a href="http://miketech.it/ios-transparent-viewcontroller/">iOS创建半透明ViewController</a> - iOS创建半透明ViewController。</li>
<li><a href="http://www.jianshu.com/p/cda4b0fe07e0">Xcode使用技巧</a> - SwiftGG 交流分享：Xcode使用技巧。</li>
<li><a href="http://www.cocoachina.com/ios/20160219/15301.html">iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍</a> - <a href="http://www.cocoachina.com/ios/20150915/13454.html">iOS蓝牙开发（一）蓝牙相关基础知识</a>,<a href="http://www.cocoachina.com/ios/20160217/15294.html">iOS蓝牙开发（二）：iOS连接外设的代码实现</a>,<a href="http://www.cocoachina.com/ios/20160218/15299.html">iOS蓝牙开发（三）：App作为外设被连接的实现</a>。</li>
<li><a href="http://blog.adorkabledean.cn/blog/20151027/tong-ji-xiang-mu-zhong-tu-pian-shi-yong-qing-kuang/">统计项目中图片使用情况</a> - 统计项目中图片使用情况;工具：<a href="http://jeffhodnett.github.io/Unused/">Unused</a>:找出项目中未使用的图片, Unused 的基础上改了一下的<a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a>;工具：<a href="https://imageoptim.com/">ImageOptim</a> 图片保真压缩。【iOS图片压缩工具】效率最高的是<a href="http://www.alfredforum.com/topic/1520-tiny-png-workflow-updated-to-v12/">tiny-png</a>:在线压缩，前500张免费。</li>
<li><a href="http://ios.jobbole.com/83952/">iOS推送之远程推送</a> 、<a href="http://ios.jobbole.com/83949/">iOS推送之本地推送</a>。</li>
<li><a href="http://www.cocoachina.com/ios/20151019/13761.html">动态部署方案</a> - iOS应用架构谈动态部署方案。</li>
<li><a href="https://github.com/AntBranch/awesome-github">awesome-github</a> - awesome-github:收集这个列表，只是为了更好地使用亲爱的GitHub。</li>
<li><a href="http://www.jianshu.com/p/fccba7be1ca1">ReactiveCocoa 4 文档翻译目录</a> - ReactiveCocoa 4 文档翻译目录。</li>
<li><a href="http://geek.csdn.net/news/detail/58593">Swift编程的15个技巧</a> - Swift编程的15个技巧。</li>
<li><a href="http://www.cocoachina.com/ios/20160304/15558.html">每个Xcode开发者应该知道的七个使用技巧</a> - 每个Xcode开发者应该知道的七个使用技巧。</li>
<li><a href="http://blog.jobbole.com/94261/">腾讯力作！超实用的iOS 9人机界面指南</a> - 腾讯力作！超实用的iOS 9人机界面指南。</li>
<li><a href="http://ios.jobbole.com/84956/">iOS开发-超链接富文本案</a> - iOS开发-超链接富文本。</li>
<li><a href="https://segmentfault.com/a/1190000005112043">UIView+RedPoint实现底部UITabBarItem和控件的右上角显示和隐藏红点/数字的需求</a> -</li>
<li><a href="www.jianshu.com/p/54bbacfcc31b">使用GCD实现和封装分组并发网络请求</a> - 使用GCD实现和封装分组并发网络请求。</li>
<li><a href="http://www.jianshu.com/p/1d354feacf3c">微信语音连播的实现思路</a> - 微信语音连播的实现思路。</li>
<li><a href="http://www.jianshu.com/p/b422d92738ac">UITableView 手势延迟导致subview无法完成两次绘制</a> - UITableView 手势延迟导致subview无法完成两次绘制。</li>
</ul>


<hr />

<h4>Xcode插件</h4>

<ul>
<li><a href="http://www.cocoachina.com/special/xcode/">iOS开发进阶，从Xcode开始</a> - 学习使用Xcode构建出色的应用程序！</li>
<li>在Xcode启动的时候，Xcode将会寻找位于~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中的后缀名为.xcplugin的bundle作为插件进行加载（运行其中的可执行文件）。<a href="http://studentdeng.github.io/blog/2014/02/21/xcode-plugin-fun/">Xcode5 Plugins 开发简介</a>  <a href="http://joeyio.com/ios/2013/07/25/write_xcode4_plugin_of_your_own/">写个自己的Xcode4插件</a></li>
<li><a href="https://www.onevcat.com/2013/02/xcode-plugin/">Xcode 4 插件制作入门</a> - Xcode 4 插件制作入门:Xcode所使用的所有库都包含在Xcode.app/Contents/的Frameworks，SharedFrameworks和OtherFrameworks三个文件夹下。其中和Xcode关系最为直接以及最为重要的是Frameworks中的IDEKit和IDEFoundation，以及SharedFrameworks中的DVTKit和DVTFoundation四个。</li>
<li><a href="https://github.com/rickytan/RTImageAssets">RTImageAssets</a> - 一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本。<a href="https://itunes.apple.com/app/asset-catalog-creator-free/id866571115?mt=12">Asset Catalog Creator</a> 功能强大，能自动生成全部尺寸：包括App Icons、Image Sets、Launch Screens Generator。</li>
<li><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a> - 一个Xcode插件，build后，随手打开一个你之前的项目，然后在任意一个方法上面连按三下"/&ldquo;键盘，就ok了。</li>
<li><a href="https://github.com/Jintin/Swimat">Swimat</a> - Swimat，是一款Xcode 插件，帮你一键格式化 swift 代码。</li>
<li><a href="https://github.com/shjborage/Reveal-Plugin-for-XCode">Reveal-Plugin-for-XCode</a> - 一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。<a href="http://security.ios-wiki.com/issue-3-4/">Reveal：分析iOS UI的利器</a> 。</li>
<li><a href="https://github.com/google/j2objc">java2Objective-c</a> - Google公司出得java转Obje-C转换工具，转换逻辑，不转换UI。</li>
<li><a href="https://github.com/kzaher/RegX">RegX</a> - 专治代码强迫症的 Xcode 插件，使用 Swift 和 Objective-C 编写。其用竖向对齐特定源代码的元素，使得代码更易读和易理解。<a href="http://www.cocoachina.com/ios/20141224/10743.html">说明</a> ； 菜单：xcode——》Edit-》Regx 。</li>
<li><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed</a> - 自动完成，特别是如果你正在写Objective-C，如果Xcode能自动完成文件名难道不会很伟大吗？比如图像文件的名称。</li>
<li><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin">FuzzyAutocomplete</a> - Xcode的实现自动完成还不完美，此插件能给出你所期望或想要的建议，设置：xcode-》Editor-》FuzzyAutocomplete-》plugin settings。</li>
<li><a href="https://github.com/johnno1962/GitDiff">GitDiff</a> - Xcode的代码编辑器的一个微妙的补强，加上了足够的可见信息以了解上次git提交以来发生了什么变化，设置：xcode-》Edit-》GitDiff。</li>
<li><a href="https://github.com/trawor/XToDo">XToDo</a> - 这个插件不仅凸显TODO，FIXME，???，以及！！！注释，也在便利列表呈现他们。 菜单：xcode-》view-》snippets;   调出列表显示: xcode-》view-》ToDo List ： ctrl + T 。</li>
<li><a href="https://github.com/limejelly/Backlight-for-XCode">Backlight</a> - 突出显示当前正在编辑的行。菜单：xcode-》view-》Backlight 。</li>
<li><a href="https://github.com/kattrali/cocoapods-xcode-plugin">CocoaPods</a> - 该CocoaPods的插件增加了一个CocoaPods菜单到Xcode的产品菜单。如果你不喜欢命令行，那么你一定会喜欢这个插件。 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做iOS程序的依赖管理 </a>。</li>
<li><a href="https://github.com/markohlebar/Peckham">Peckham</a> - 添加import语句比较麻烦，此插件 按Command-Control-P，给出的选项列表中选择要的头文件。先要安装<a href="http://alcatraz.io/">Alcatraz</a> ,在终端输入： <strong>curl -fsSL <a href="https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh">https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh</a> | sh</strong> ； 重启xcode-》window-》Package Manager：搜索 <strong>Peckham</strong> 安装，打开Peckham.xcodeproj，编译 Peckham target，重启Xcode 。</li>
<li><a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode">Auto-Importer</a> - Auto-Importer是一个自动导入类对应的头文件的Xcode插件。</li>
<li><a href="http://alcatraz.io/">Alcatraz</a> -使用Alcatraz来管理Xcode插件 <a href="http://tangqiaoboy.gitcafe.io/blog/2014/03/05/use-alcatraz-to-manage-xcode-plugins/">使用说明</a> 。</li>
<li><a href="https://github.com/kimsungwhee/KSHObjcUML">KSHObjcUML</a> -KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。</li>
<li><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense-for-Xcode</a> - 颜色插件，安装之后，就不用根据RGB选择颜色，直接从取色板中取颜色，会自动补齐RGB代码。</li>
<li><a href="http://www.codeceo.com/article/10-ios-xcode-plugins.html">10款提高iOS开发效率的XCode插件</a> - 10款提高iOS开发效率的XCode插件：1. XcodeColors；5. ACCodeSnippetRepository；10. <a href="https://github.com/omz/Dash-Plugin-for-Xcode">Dash for Xcode</a>。</li>
<li><a href="https://github.com/MakeZL/ZLGotoSandboxPlugin">ZLGotoSandboxPlugin</a> - 支持Xcode快捷键了跳转当前应用沙盒了！快捷键是 Shift+Common+w。</li>
<li><a href="https://github.com/burczyk/XcodeSwiftSnippets">XcodeSwiftSnippets</a> - XcodeSwiftSnippets, 提供了很多可在 Xcode 上使用的 Swift 代码片段, 通过自动补全的方式极大的提高了开发效率， <a href="https://github.com/Xcode-Snippets/Objective-C">另外还有 Objective-C 版的</a>。</li>
<li><a href="https://vimeo.com/128713880">CoPilot</a> - 通过此插件， Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。</li>
<li><a href="https://github.com/EnjoySR/ESJsonFormat-Xcode">ESJsonFormat-Xcode</a> - 将Json格式化输出为模型的属性。</li>
<li><a href="https://github.com/stefanceriu/SCXcodeMiniMap">SCXcodeMiniMap</a> - Xcode迷你小地图-SCXcodeMiniMap。</li>
<li><a href="http://code.cocoachina.com/detail/316095/xTransCodelation/">xTransCodelation</a> - XCODE中英文翻译插件，提供API查询模式和网页模式，都是利用的百度翻译。另外集成了一个可以一键关闭其他所有APP的实用功能，方便开发者！</li>
<li><a href="https://github.com/jwaitzel/SuggestedColors/">SuggestedColors</a> - Xcode 插件SuggestedColors，用于 IB颜色设置 辅助插件，非常好用。</li>
<li><a href="https://github.com/paulot/Colorsp">Colors</a> - 打印彩色字符串，可以修改 Swift 中终端输出的字符串颜色，有趣的小工具。</li>
<li><a href="https://github.com/Sephiroth87/Crayons">Crayons</a> - Xcode调色板增强插件。</li>
<li><a href="https://github.com/johnno1962/injectionforxcode">injectionforxcode</a> - Injection for Xcode：成吨的提高开发效率,<a href="http://www.jianshu.com/p/27be46d5e5d4">使用说明</a>。</li>
<li><a href="https://github.com/kaphacius/IconMaker">IconMaker</a> - 只需要一步，自动生成不同尺寸的App icon。超级方便。</li>
<li><a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode">BuildTimeAnalyzer-for-Xcode</a> - 实用的编译时间分析 Xcode 插件。</li>
<li><a href="https://github.com/music4kid/FastStub-Xcode">FastStub-Xcode</a> - 一只快速生成代码的Xcode插件，<a href="http://mrpeak.cn/blog/faststub/">说明</a>。</li>
<li><a href="https://github.com/EnjoySR/ESTranslate-Xcode">ESTranslate-Xcode</a> - 一个快速翻译Xcode代码里面单词(我主要用于翻译句子～)的插件，快捷键：Ctrl+Shift+T。</li>
</ul>


<hr />

<h4>美工资源</h4>

<ul>
<li><a href="https://github.com/markohlebar/Peckham">TWG_Retina_Icons</a> - 一套支持 Retina 高清屏的 iPhone 免费图标集。</li>
<li><a href="https://github.com/cparnot/ASCIImage">ASCIImage</a> - 使用 NSString 创建 image，<a href="http://cocoamine.net/blog/2015/03/20/replacing-photoshop-with-nsstring/">说明</a>。</li>
<li><a href="https://github.com/RayPS/my-sketch-colors">my-sketch-colors</a> - 配色。</li>
<li><a href="http://www.imooc.com/wenda/detail/250367">Font Awesome</a> - Font Awesome：一套绝佳的图标字体库和CSS框架，详细的安装方法请参考<a href="http://fortawesome.github.io/Font-Awesome/icons/">官方网站</a><a href="http://fontawesome.dashgame.com/">中文网站</a>,<a href="https://github.com/FortAwesome/Font-Awesome">GitHub地址</a> 。</li>
<li><a href="https://github.com/yannickl/DynamicColor">DynamicColor</a> - 强大的颜色操作扩展类。通过该类，你可以通过扩展方法基于某个颜色得到不同深浅、饱和度、灰度、色相，以及反转后的新颜色。是不可多得的好类库。</li>
<li><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a> - Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。</li>
<li><a href="https://github.com/ArtSabintsev/FontBlaster">FontBlaster</a> - 载入定制字体时更简单。</li>
</ul>


<h4>其他资源</h4>

<ul>
<li><a href="http://githuber.info/#/index">githuber</a> - 最好用的GitHub人才搜索工具。</li>
<li><a href="https://www.codatlas.com">codatlas</a> - 源代码搜索利器。</li>
<li><a href="https://searchcode.com/">searchcode</a> - 源代码搜索利器：来自悉尼的代码搜索引擎汇聚了 Github, Bitbucket, Sourceforge&hellip;等多家开源站点超20万个项目、180亿行源代码，能以特殊字符、语言、仓库和源方式从90多种语言找到函数、API的真实代码。</li>
<li><a href="https://github.com/docker/kitematic">kitematic</a> - Mac 上使用 Docker 最简单的方案。</li>
</ul>


<hr />

<h4>开发资源</h4>

<h5>开发资料</h5>

<ul>
<li><a href="https://www.douban.com/note/276160185/?type=like">豆瓣iOS开源库列表</a> - 豆瓣iOS开源库列表，很多开源项目。</li>
<li><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques">iOS-Core-Animation-Advanced-Techniques</a> - 中文版iOS 高级动画技术。</li>
<li><a href="http://www.jianshu.com/p/50b63a221f09">iOS开发的一些奇巧淫技1</a> - TableView不显示没内容的Cell怎么办; 键盘事件：<a href="https://github.com/hackiftekhar/IQKeyboardManager">IQKeyboardManager</a>;  app不流畅:<a href="https://github.com/kconner/KMCGeigerCounter">KMCGeigerCounter</a>;  CoreData用起来好烦:<a href="https://github.com/magicalpanda/MagicalRecord">MagicalRecord</a>;  CollectionView实现悬停的header:<a href="https://github.com/jamztang/CSStickyHeaderFlowLayout">CSStickyHeaderFlowLayout</a>。</li>
<li><a href="http://www.jianshu.com/p/08f194e9904c">iOS开发的一些奇巧淫技2</a> -  用一个pan手势来代替UISwipegesture的各个方向、拉伸图片、播放GIF、上拉刷新、把tableview里cell的小对勾的颜色改变、navigationbar弄成透明的而不是带模糊的效果、改变uitextfield placeholder的颜色和位置。</li>
<li><a href="http://code4app.com/article/cocoapods-install-usage">cocoapods安装指南</a> - cocoapods安装指南。</li>
<li><a href="https://github.com/johnno1962/Remote">RemoteControl</a> - Control your iPhone from inside Xcode for end-to-end testing 。</li>
<li><a href="http://objccn.io/issue-13-1/">MVVM 介绍</a> - 替换MVC的开发模式。</li>
<li><p><a href="http://apistore.baidu.com/astore/index">第三方接口</a> - 基本所有第三方接口都在这，再也不用那么麻烦去找了。</p></li>
<li><p><a href="http://yyny.me/ios/%E6%8F%90%E9%AB%98iOS%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B7%A5%E5%85%B7/">提高iOS开发效率的方法和工具</a> - 提高iOS开发效率的方法和工具。</p></li>
<li><a href="https://github.com/oa414/objc-zen-book-cn">禅与 Objective-C 编程艺术</a> - 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）。</li>
<li><a href="http://www.imooc.com/article/1216">Objective-C编码规范：26个方面解决iOS开发问题</a> - 【Objective-C编码规范：26个方面解决iOS开发问题：“我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。”今天分享的规范来自raywenderlich.com团队成员共同完成的，希望对学习OC的朋友们有所指导和帮助。</li>
</ul>


<h6>swift</h6>

<ul>
<li><a href="http://dev.swiftguide.cn/archive/featured-open-source-projects-in-swift_v1.0.html">Swift 开源项目精选－v1.0</a> - Swift 开源项目精选－v1.0。</li>
<li><a href="https://github.com/ipader/SwiftGuide/blob/master/Featured.md">Swift开源项目精选</a> - Swift开源项目精选&ndash;推荐，每周都有更新。</li>
<li><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese">Swift中文指南</a> - 中文版Apple官方Swift教程《The Swift Programming Language》，<a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/">老码版本</a>  <a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter1/03_revision_history.html">历史版本更新说明</a>。</li>
<li><a href="http://wiki.jikexueyuan.com/project/swift/">The Swift Programming Language 中文版</a> - The Swift Programming Language 中文版。</li>
<li><a href="http://www.swifttoolbox.io/">swifttoolbox</a> -  swifttoolbox swift开发的开源库汇总。</li>
<li><p><a href="https://github.com/ipader/SwiftGuide">SwiftGuide</a> -  这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排&ndash; 非常不错，值得推荐。</p></li>
<li><p><a href="https://swift.zeef.com/robin.eggenkamp">Awesome Swift</a> - 一个收集了很多 Swift 开发资源的网站。</p></li>
<li><a href="https://github.com/CS193P-Translation-Group/Developing_iOS_8_Apps_With_Swift">Developing_iOS_8_Apps_With_Swift</a> - Developing iOS 8 Apps with Swift 字幕简体中文翻译项目（斯坦福白胡子老头swift教学视频）。</li>
<li><a href="https://github.com/johnlui/Swift-On-iOS">Swift-On-iOS</a> - JohnLui 的 Swift On iOS 代码仓库。</li>
<li><a href="https://github.com/allenwong/30DaysofSwiftp">30DaysofSwift</a> - 30DaysofSwift 自学 iOS - <a href="http://weibo.com/ttarticle/p/show?id=2309403942494873235448">三十天三十个 Swift 项目</a>。</li>
</ul>


<h5>他人开源总结</h5>

<ul>
<li><a href="https://github.com/iCHAIT/awesome-osx">awesome-osx</a> - Awesome OS X。</li>
<li><a href="http://www.code4app.com/">code4app</a> - 最多国人用的代码库。</li>
<li><a href="http://code.cocoachina.com/">cocoachina</a> - 国内最热门的iOS社区的代码库。</li>
<li><a href="https://github.com/vsouza/awesome-ios">awesome-ios</a> - 一个老外整理的，<a href="http://app.memect.com/doc/ios.html">中文版</a>。</li>
<li><a href="https://github.com/cjwirth/awesome-ios-ui">awesome-ios-ui</a> - 收集了不少 iOS UI/UX 库, 包含了很多酷炫的动画效果。</li>
<li><a href="http://www.ios-cosmos.com/">ios-cosmos</a> - The iOS Cosmos：收录了iOS绝大部分的开源框架和工具。</li>
<li><a href="https://haskell.zeef.com/konstantin.skipor#block_28362_basics">Awesome Haskell资料大全</a> -    Awesome Haskell 资料大全：框架，库和软件。</li>
<li><a href="http://ios-cosmos.com">Cosmos</a> - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。</li>
<li><a href="https://www.cocoacontrols.com/">cocoacontrols</a> -  收集了很多UI控件效果代码，缺点是需要翻墙，而且代码分类不够好。</li>
<li><a href="https://github.com/lexrus">lexrus</a> -  lexrus国内出名的iOS开源coder，非常酷的label动画、textfield动画。</li>
<li><a href="https://github.com/dkhamsing/open-source-ios-apps">open-source-ios-apps</a> - iOS App集合，分：swift与Objective-C&ndash;国外人整理。</li>
<li><a href="http://www.csdn.net/article/2015-03-04/2824108-ios-developers-sites">适合iOS开发者的15大网站推荐</a> -  适合 iOS 开发者的 15 大网站推荐 &mdash; 英文网站。</li>
<li><a href="https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md">Objective-C GitHub 排名前 100 项目简介</a> -  主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况。</li>
<li><a href="http://github.ibireme.com/github/list/ios/">Github-iOS备忘</a> -整理了比较常用的iOS第三方组件，以及github上的统计。</li>
<li><a href="http://www.cocoachina.com/ios/20160121/14988.html">超全！整理常用的iOS第三方资源</a> - 超全！整理常用的iOS第三方资源。</li>
<li><a href="https://github.com/JanzTam/MyGithubMark">MyGithubMark</a> - Github上的iOS资料-个人记录（持续更新）。</li>
<li><a href="http://ios.jobbole.com/84684/">Github 上的 iOS 开源项目</a> - Github 上的 iOS 开源项目总结。</li>
<li><a href="https://github.com/jobbole/awesome-ios-cn">iOS资源大全中文版</a> - iOS资源大全中文版。</li>
<li><a href="http://www.ioscookies.com/">iOSCookies.swift</a> - 外国开发者弄了个Swift开源库、开源Apps等超全资源整合网站！不得不说真用心啊！</li>
</ul>


<h5>开发博客列表</h5>

<ul>
<li><a href="https://github.com/tangqiaoboy/iOSBlogCN">唐巧整理</a> - 猿题库唐巧整理。</li>
<li><a href="http://www.cocoachina.com/ios/20150626/11348.html">11个超棒的iOS开发学习国外网站</a> - 11个超棒的iOS开发学习网站:<a href="https://www.objc.io">objc.io</a> ;<a href="http://subjc.com">subjc.com</a> ;<a href="http://nshipster.com">NSHipster</a> ;<a href="http://petersteinberger.com">Peter Steinberger</a> ;<a href="http://oleb.net">Ole Begemann</a> ;<a href="http://floriankugler.com">Florian Kugler</a> ;<a href="https://www.mikeash.com/pyblog/">NSBlog</a> ;<a href="http://cocoa.tumblr.com">Cocoa</a> ;<a href="http://iosdevweekly.com">iOS Dev Weekly</a> ;<a href="http://iosdevelopertips.com">iOS Developer Tips</a> ;<a href="http://ios-goodies.com">iOS Goodies</a> ;<a href="http://www.appcoda.com">AppCoda</a> 香港人创建;<a href="http://merowing.info">Krzysztof Zab?ocki</a> ;<a href="http://iosdevtips.co">iOS Development tips</a> ;</li>
</ul>


<table>
<thead>
<tr>
<th>博客地址 </th>
<th> RSS地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://southpeak.github.io/">南峰子的技术博客</a> </td>
<td> 南峰子的技术博客。</td>
</tr>
<tr>
<td><a href="http://blog.devtang.com">唐巧的技术博客</a> </td>
<td> <a href="http://blog.devtang.com/atom.xml">http://blog.devtang.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="https://onevcat.com">OneV&rsquo;s Den</a> </td>
<td> <a href="https://onevcat.com/atom.xml">https://onevcat.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://objccn.io/">objc 中国</a> </td>
<td> 为中国 Objective-C 社区带来最佳实践和先进技术。</td>
</tr>
<tr>
<td><a href="http://beyondvincent.com">破船之家</a> </td>
<td> <a href="http://beyondvincent.com/atom.xml">http://beyondvincent.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nshipster.cn">NSHipster</a> </td>
<td> <a href="http://nshipster.cn/feed.xml">http://nshipster.cn/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://limboy.me/">Limboy 无网不剩</a> </td>
<td> <a href="http://feeds.feedburner.com/lzyy">http://feeds.feedburner.com/lzyy</a></td>
</tr>
<tr>
<td><a href="http://lextang.com">Lex iOS notes</a> </td>
<td> <a href="http://ios.lextang.com/rss">http://ios.lextang.com/rss</a></td>
</tr>
<tr>
<td><a href="http://nianxi.net">念茜的博客</a> </td>
<td> <a href="http://nianxi.net/feed.xml">http://nianxi.net/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.xcodev.com">Xcode Dev</a> </td>
<td> <a href="http://blog.xcodev.com/atom.xml">http://blog.xcodev.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wufawei.com/">Ted&rsquo;s Homepage</a></td>
<td> <a href="http://wufawei.com/feed">http://wufawei.com/feed</a></td>
</tr>
<tr>
<td><a href="http://blog.t-xx.me">txx&rsquo;s blog</a> </td>
<td> <a href="http://blog.t-xx.me/atom.xml">http://blog.t-xx.me/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imkevin.me">KEVIN BLOG</a> </td>
<td> <a href="http://imkevin.me/rss">http://imkevin.me/rss</a></td>
</tr>
<tr>
<td><a href="http://xiangwangfeng.com/">阿毛的蛋疼地</a> </td>
<td> <a href="http://xiangwangfeng.com/atom.xml">http://xiangwangfeng.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://billwang1990.github.io">亚庆的 Blog</a> </td>
<td> <a href="http://billwang1990.github.io/atom.xml">http://billwang1990.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nonomori.farbox.com">Nonomori</a> </td>
<td> <a href="http://nonomori.farbox.com/feed">http://nonomori.farbox.com/feed</a></td>
</tr>
<tr>
<td><a href="http://tang3w.com">言无不尽</a> </td>
<td> <a href="http://tang3w.com/atom.xml">http://tang3w.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://wonderffee.github.io">Wonderffee&rsquo;s Blog</a> </td>
<td> <a href="http://wonderffee.github.io/atom.xml">http://wonderffee.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imtx.me">I&rsquo;m TualatriX</a> </td>
<td> <a href="http://imtx.me/feed/latest/">http://imtx.me/feed/latest/</a></td>
</tr>
<tr>
<td><a href="http://www.vclwei.com/">vclwei</a> </td>
<td> <a href="http://www.vclwei.com/posts.rss">http://www.vclwei.com/posts.rss</a></td>
</tr>
<tr>
<td><a href="http://blog.cocoabit.com">Cocoabit</a> </td>
<td> <a href="http://blog.cocoabit.com/atom.xml">http://blog.cocoabit.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://nixzhu.me">nixzhu on scriptogr.am</a> </td>
<td> <a href="http://nixzhu.me/feed">http://nixzhu.me/feed</a></td>
</tr>
<tr>
<td><a href="http://studentdeng.github.io">不会开机的男孩</a> </td>
<td> <a href="http://studentdeng.github.io/atom.xml">http://studentdeng.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.taofengping.com">Nico</a> </td>
<td> <a href="http://www.taofengping.com/rss.xml">http://www.taofengping.com/rss.xml</a></td>
</tr>
<tr>
<td><a href="http://hufeng825.github.io">阿峰的技术窝窝</a> </td>
<td> <a href="http://hufeng825.github.io/atom.xml">http://hufeng825.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://answerhuang.duapp.com">answer_huang</a> </td>
<td> <a href="http://answerhuang.duapp.com/index.php/feed/">http://answerhuang.duapp.com/index.php/feed/</a></td>
</tr>
<tr>
<td><a href="http://webfrogs.me">webfrogs</a> </td>
<td> <a href="http://webfrogs.me/feed/">http://webfrogs.me/feed/</a></td>
</tr>
<tr>
<td><a href="http://joeyio.com">代码手工艺人</a> </td>
<td> <a href="http://joeyio.com/atom.xml">http://joeyio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://gracelancy.com">Lancy&rsquo;s Blog</a> </td>
<td> <a href="http://gracelancy.com/atom.xml">http://gracelancy.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imallen.com/">I&rsquo;m Allen</a> </td>
<td> <a href="http://imallen.com/atom.xml">http://imallen.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://imi.im/">Travis' Blog</a></td>
<td> <a href="http://imi.im/feed">http://imi.im/feed</a></td>
</tr>
<tr>
<td><a href="http://wangzz.github.io/">王中周的技术博客</a> </td>
<td><a href="http://wangzz.github.io/atom.xml">http://wangzz.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://jiajun.org/">会写代码的猪</a></td>
<td><a href="http://gaosboy.com/feed/atom/">http://gaosboy.com/feed/atom/</a></td>
</tr>
<tr>
<td><a href="http://wangkewei.cnblogs.com/">克伟的博客</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/23857/rss">http://feed.cnblogs.com/blog/u/23857/rss</a></td>
</tr>
<tr>
<td><a href="http://www.cnblogs.com/biosli">摇滚诗人</a></td>
<td><a href="http://feed.cnblogs.com/blog/u/35410/rss">http://feed.cnblogs.com/blog/u/35410/rss</a></td>
</tr>
<tr>
<td><a href="http://geeklu.com/">Luke&rsquo;s Homepage</a> </td>
<td> <a href="http://geeklu.com/feed/">http://geeklu.com/feed/</a></td>
</tr>
<tr>
<td><a href="http://iiiyu.com/">萧宸宇</a> </td>
<td> <a href="http://iiiyu.com/atom.xml">http://iiiyu.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.heyuan110.com/">Yuan博客</a> </td>
<td> <a href="http://www.heyuan110.com/?feed=rss2">http://www.heyuan110.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="http://shiningio.com/">Shining IO</a> </td>
<td> <a href="http://shiningio.com/atom.xml">http://shiningio.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.yifeiyang.net/">YIFEIYANG&ndash;易飞扬的博客</a> </td>
<td> <a href="http://www.yifeiyang.net/feed">http://www.yifeiyang.net/feed</a></td>
</tr>
<tr>
<td><a href="http://koofrank.com/">KooFrank&rsquo;s Blog</a> </td>
<td> <a href="http://koofrank.com/rss">http://koofrank.com/rss</a></td>
</tr>
<tr>
<td><a href="http://helloitworks.com">hello it works</a> </td>
<td> <a href="http://helloitworks.com/feed">http://helloitworks.com/feed</a></td>
</tr>
<tr>
<td><a href="http://msching.github.io/">码农人生</a> </td>
<td> <a href="http://msching.github.io/atom.xml">http://msching.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://yulingtianxia.com">玉令天下的Blog</a> </td>
<td> <a href="http://yulingtianxia.com/atom.xml">http://yulingtianxia.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://www.hotobear.com/">不掏蜂窝的熊</a> </td>
<td> <a href="http://www.hotobear.com/?feed=rss2">http://www.hotobear.com/?feed=rss2</a></td>
</tr>
<tr>
<td><a href="https://andelf.github.io/">猫·仁波切</a> </td>
<td> <a href="https://andelf.github.io/atom.xml">https://andelf.github.io/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://ivoryxiong.org/">煲仔饭</a> </td>
<td> <a href="http://ivoryxiong.org/feed.xml">http://ivoryxiong.org/feed.xml</a></td>
</tr>
<tr>
<td><a href="http://adad184.com">里脊串的开发随笔</a> </td>
<td> <a href="http://adad184.com/atom.xml">http://adad184.com/atom.xml</a></td>
</tr>
<tr>
<td><a href="http://blog.ibireme.com/">ibireme伽蓝之堂</a> </td>
<td> <a href="http://blog.ibireme.com/feed/">http://blog.ibireme.com/feed/</a></td>
</tr>
</tbody>
</table>


<h4>物联网</h4>

<ul>
<li><a href="https://github.com/phodal/awesome-iot">awesome-iot</a> - 这份物联网学习参考大全太给力。从物联网协议、嵌入式系统、相关开源库、相关书籍、博客、学习笔记、标准应有尽有。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua/"/>
    <updated>2016-05-30T09:26:31+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/30/iosdong-hua</id>
    <content type="html"><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要使用用户的需求以及为执行各种任务而改变状态。</p>

<p>在这些状态之间转换时，清晰的揭示正在发生什么是非常重要的。而不是在页面之间跳跃，动画帮助我们解释用户从哪里来，要到哪里去。</p>

<!--more-->


<p>键盘在View中滑进滑出给了我们一个错觉，让我们以为它是简单的被隐藏在屏幕下方的，并且是手机很自然的一个部分。View Controller转场加强了我们的应用程序的导航结构，并且给了用户正在移向那个方向的提示。微妙的反弹和碰撞使界面栩栩如生，并且激发出了物理的质感。要是没有这些的话，我们就只有一个没有视觉设计的干巴巴的环境了。</p>

<p>动画是叙述你的应用的故事的绝佳方式，在了解动画背景的基本原理之后，设计它们会轻松很多。</p>

<h2>首要任务</h2>

<p>在这篇文章中，我们将特别地针对  Core Anmiation进行探讨，虽然你将看到的很多东西也可以用更高级的UIKit的方法来完成，但是Core Animation将会让你更好的理解正在发生什么。它以一种更明确的方式来描述动画，这对这篇文章以及你自己的代码的读者来说都非常有用。</p>

<p>在看动画如何与我们的屏幕上的看到的内容交互之前，我们需要快速浏览一下Core Animation的<code>CALayer</code>，这是动画产生作用的地方。</p>

<p>你大概知道UIView实例，以及layer-backed的NSView,修改它们的layer来委托强大的Core Graphics框架来进行渲染。然而你务必要理解，当把动画添加到一个layer时，是不直接修改它的属性的。</p>

<p>取而代之，Core Animation维护了两个平行的layer层次结构:mode layer tree(模型层树)和presentation layer tree(表示层树)。前者中的layers反映了我们能直接看到的layers的状态，而后者的layers则是正在表现的值的近似。</p>

<p>考虑在view上增加一个渐出动画。如果在动画中的任意时刻，查看layer的opacity值，你是得不到与屏幕内容对应的透明度的。取而代之，你需要查看presentaion layer 以获得正确的结果。</p>

<p>虽然你可能不会去直接设置presentaion layer的属性，但是使用它的当前值来创建新的动画护着在动画发生时与layers交互式非常有用的。</p>

<p>通过使用 <code>-[CALayer presentaionLayer]</code>和<code>[CALayer modelLayer]</code>，你可以在两个layer之间轻松切换。</p>

<h2>基本动画</h2>

<p>可能最常见的情况是将一个View的属性从一个值改变为另一个值，考虑夏敏的这个例子。</p>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-linear.gif" alt="w" />
 
在这里，我们让红色小火箭的 x-position从77 变为455,刚好超过的parent View的边，为了填充所有路径，我们需要确定我们的火箭在任意时刻所到达的位置。这通常使用线性插值法来完成。</p>

<pre><code>X(T)=x0 + t△x
</code></pre>

<p>也就是说，对于动画给定的一个分数t,火箭的x坐标就是起始点的x坐标77，加上一个到终点的距离∆x = 378,乘以该分数的值。</p>

<p>使用<code>CABasicAnimation</code>，我们可以如下实现这个动画:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span></code></pre></td></tr></table></div></figure>


<p>请注意我们的动画键路径，也就是position.x,实际上包含一个存储在<code>position</code>属性中的CGPoint结构体成员。这是CoreAnimation一个非常方便的特性。请查看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html">支持的键路径的完整列表</a></p>

<p>然而，当我们运行该代码时，我们意识到火箭在完成动画后马上回到了初始位置，这是因为在默认情况下，动画不会再超出其持续时间后还修改 presentaion layer.实际上，在结束时它甚至会被彻底移除。</p>

<p>一旦动画被移除，presentation layer将回到 model layer的值，并且因为我们从未修改该layer的 postion属性，所以我们的飞船将重新出现在它开始的地方。</p>

<p>这里有两种解决这个问题的方法:</p>

<p>第一种方法是直接在 model layer上更新尚需经，这是推荐的做法，因为它使得动画完全可选。</p>

<p>一旦动画完成并且从layer中移除，presentation layer将回到model layer设置的值，而这个值恰好与动画最后一个步骤相匹配</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rocket.layer.position = CGPointMake(455, 61);</span></code></pre></td></tr></table></div></figure>


<p>或者，你可以通过设置动画的fillMode属性为<code>kCAFillModeForward</code>，并设置<code>removedOnCompletion</code>为No以防止它被自动移除:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.fillMode = kCAFillModeForward;
</span><span class='line'>animation.removedOnCompletion = NO;
</span><span class='line'>
</span><span class='line'>[rectangle.layer addAnimation:animation forKey:@"basic"];</span></code></pre></td></tr></table></div></figure>


<p>如果将已完成的动画保持在layer上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>

<p>指的指出的是，实际上我们创建的动画对象在被添加到layer时立刻就复制了一份。这个特性在多个view中重用动画时这非常有用。比方说我们想要第二个火箭在第一个火箭起飞后不久后起飞：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.byValue = @378;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>[rocket1.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>rocket1.layer.position = CGPointMake(455, 61);
</span><span class='line'>
</span><span class='line'>animation.beginTime = CACurrentMediaTime() + 0.5;
</span><span class='line'>
</span><span class='line'>[rocket2.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>rocket2.layer.position = CGPointMake(455, 111);</span></code></pre></td></tr></table></div></figure>


<p>设置动画的<code>beginTime</code>为未来0.5秒将只会影响<code>rocket2</code>，因为动画在执行语句<code>[rocket1.layer addAnimation:animation forKey:@"basic"];</code>时已经被复制了，并且之后的rocket1也不会考虑对动画对象的改变。</p>

<p>不妨看一看David的<a href="http://ronnqvi.st/controlling-animation-timing/">关于动画时间的一篇很棒的文章</a>，通过它可以学习如何更精确的控制你的动画。</p>

<p>我决定再使用<code>CABasicAnimation</code>的byValule属性创建一个动画，这个动画从presentaion layer的当前值开始，加上byValue的值后结束。这使得动画更易于重用，因为你不需要精确的指定可能无法提前知道的from- 和 toValue的值。</p>

<p><code>fromValue</code>,<code>byValue</code>和<code>toValue</code>的不同组合可以用来实现不同的效果，如果你需要创建一个可以在你的不同应用中重用的动画，你可以<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004496-CH1-SW4">查看文档</a></p>

<h2>多步动画</h2>

<p>这很容易想到一个场景，你想要为你的冻哈定义超过两个步骤，我们可以使用更通用的<code>CAKeyframeAnimation</code>，而不是去链接多个<code>CABasicAnimation</code>实例。</p>

<p>关键帧(keyFrame)使我们能够定义动画中任意的一个点，然后让core Animation填充所谓的中间帧</p>

<p>比方说我们正在制作我们下一个Iphone应用程序汇总的登录表单，我们希望当用户输入错误的密码时表单会晃动，使用关键帧动画，看起来大概像是这样：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/form.gif" alt="d" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.values = @[ @0, @10, @-10, @10, @0 ];
</span><span class='line'>animation.keyTimes = @[ @0, @(1 / 6.0), @(3 / 6.0), @(5 / 6.0), @1 ];
</span><span class='line'>animation.duration = 0.4;
</span><span class='line'>
</span><span class='line'>animation.additive = YES;
</span><span class='line'>
</span><span class='line'>[form.layer addAnimation:animation forKey:@"shake"];</span></code></pre></td></tr></table></div></figure>


<p>values数组定义了表单应该到哪些位置、</p>

<p>设置keytimes属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>

<blockquote><p><em>注意:</em></p>

<p><a style="font-style:normal">
请注意我是如何选择不同的值从0到10到-10转换以维持恒定的速度的。
</a></p></blockquote>

<p>设置additive尚需经为YES 使 Core Animation在更新 presentaion layer之前将动画的值添加到 model layer中去。这使得我们能够对所有形式的需要更新的元素重用相同的动画，且无需提前知道它们的位置。因为这个属性从<code>CAPropertyAnimation</code>继承，所以你也可以在使用<code>CABasicAnimation</code>时使用它。</p>

<h2>沿路径的动画</h2>

<p>虽然用代码实现一个简单的水平晃动并不难，但是沿着复杂路径的 动画就需要我们在关键帧的values数组中存储大量box化的CGPoint.指的庆幸的是，<code>CAKeyFrmeAnimaiton</code>提供了更加便利的Path属性作为代替</p>

<p>举个例子，我们如何让一个view做圆周运动:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets.gif" alt="1" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CGRect boundingRect = CGRectMake(-150, -150, 300, 300);
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *orbit = [CAKeyframeAnimation animation];
</span><span class='line'>orbit.keyPath = @"position";
</span><span class='line'>orbit.path = CFAutorelease(CGPathCreateWithEllipseInRect(boundingRect, NULL));
</span><span class='line'>orbit.duration = 4;
</span><span class='line'>orbit.additive = YES;
</span><span class='line'>orbit.repeatCount = HUGE_VALF;
</span><span class='line'>orbit.calculationMode = kCAAnimationPaced;
</span><span class='line'>orbit.rotationMode = kCAAnimationRotateAuto;
</span><span class='line'>
</span><span class='line'>[satellite.layer addAnimation:orbit forKey:@"orbit"];</span></code></pre></td></tr></table></div></figure>


<p>使用<code>CGPathCreateWithEllipseInRect ()</code>，我们创建一个圆形的<code>CGPath</code>作为我们的关键帧动画的path.</p>

<p>使用<code>calculationMode</code>是控制关键帧动画时间的另一种方式。我们通过将其设置为<code>kCAAnimationPaced</code>，让Core Animation想被驱动的对象施加一个恒定速度，不管路径的各个线程有多长，将其设置为<code>kCAAnimationPaced</code>将无视所有我们已经设置的 keyTimes.</p>

<p>设置 rotationsMode属性为 <code>kCAAnimationRotateAuto</code>，确保飞船沿着路径旋转。作为对比，我们将该属性设置为nil，那动画会怎么样呢？</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/planets-incorrect.gif" alt="2" /></p>

<h2>时间函数</h2>

<p>让我们再次来看看第一个例子 ：</p>

<p>你会发现我们的火箭的动画有些看起来非常不自然的地方，那是因为我们在现实时间中看到的大部分运动需要时间来加速或者减速。对象瞬间达到最高速度，然后再立即停止往往看起来非常不自然。除非你在让机器人跳舞，但这很少是想要的结果。</p>

<p>为了给我们的动画一个存在惯性的感觉，我们可以使用我们上面提到的参数因子来进行插值。然而，如果我们接下来需要为每个需要加速或减速的行为创建一个新的插值函数，这将是一个很难扩展的方法。</p>

<p>取而代之，常见的做法是把要进行动画的属性的插值从动画的速度中解耦出来。这样一来，给动画提速会差生一种小火箭加速运动的效果，而不用改变我们的插值函数。</p>

<p>我们可以通过引入一个时间函数 （timing function）来实现这个目标。该函数通过修改持续时间的分数来控制动画的速度。</p>

<p>最简单的easing函数是linear.它在整个动画上维持一个恒定的速度。在 Core Animation中，这个功能由CAMediaTimingFunction来表示。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-linear.gif" alt="2" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x"; 
</span><span class='line'>animation.fromValue = @50;
</span><span class='line'>animation.toValue = @150;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
</span><span class='line'>
</span><span class='line'>[rectangle.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rectangle.layer.position = CGPointMake(150, 0);</span></code></pre></td></tr></table></div></figure>


<p>Core Animation附带了一些linear之外的内置easing函数，如:</p>

<ul>
<li><p>Ease in (kCAMediaTimingFunctionEaseIn):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easein.gif" alt="1" /></p></li>
<li><p>Ease out (kCAMediaTimingFunctionEaseOut):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeout.gif" alt="2" /></p></li>
<li><p>Ease in ease out (kCAMediaTimingFunctionEaseInEaseOut):</p></li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-easeineaseout.gif" alt="3" /></p>

<ul>
<li>默认 (kCAMediaTimingFunctionDefault):
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/rect-default.gif" alt="4" /></li>
</ul>


<p>在一定限度内，你也可以使用<code>+functionWithControlPoints::::</code>创建自己的easing函数。通过传递cubic Bezier曲线的两个控制点的x和y坐标，你可以轻松的创建自定义easying函数，比如我为我们的红色小火箭选择的那个。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/rocket-custom.gif" alt="custom" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *animation = [CABasicAnimation animation];
</span><span class='line'>animation.keyPath = @"position.x";
</span><span class='line'>animation.fromValue = @77;
</span><span class='line'>animation.toValue = @455;
</span><span class='line'>animation.duration = 1;
</span><span class='line'>
</span><span class='line'>animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0.5:0:0.9:0.7];
</span><span class='line'>
</span><span class='line'>[rocket.layer addAnimation:animation forKey:@"basic"];
</span><span class='line'>
</span><span class='line'>rocket.layer.position = CGPointMake(150, 0);</span></code></pre></td></tr></table></div></figure>


<p>我不打算讲太多关于Bezier曲线的细节，在计算机图形学中，它们是创建平滑曲线的常用技术。你可能在基于矢量的绘图工具，比如Sketch或者Adobe lllustrotor中见过它们。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/bezier.png" alt="1" /></p>

<p>传递给 <code>+functionWithControlPoints::::</code>的值有效地控制了控制点的位置。所得到的定时函数将基于得到的路径来调整动画的速度。X轴代表时间的分数，而Y轴是插值函数的插入值。</p>

<p>遗憾的是，由于这些部分被锁定在[0-1]的范围内，我们不可能用它来创建一些像预期动作(Anticipation,一种像目标进发前先回退一点，到达目标后还过冲一会，见下图)这样的常见效果 .</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/anticipate.gif" alt="3" /></p>

<h2>动画组</h2>

<p>对于某些复杂的效果，可能需要同时为多个属性进行动画。想象一下，在一个媒体播放程序中，当切换到随机曲目时我们让随机动画效果，看起来就想下面这样:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/covers.gif" alt="animaiton" /></p>

<p>你可以看到，我们需要同时对上面的封面的 position,roation和 z-position进行动画，使用 CAAimationGroup来动画其中一个封面的代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CABasicAnimation *zPosition = [CABasicAnimation animation];
</span><span class='line'>zPosition.keyPath = @"zPosition";
</span><span class='line'>zPosition.fromValue = @-1;
</span><span class='line'>zPosition.toValue = @1;
</span><span class='line'>zPosition.duration = 1.2;
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *rotation = [CAKeyframeAnimation animation];
</span><span class='line'>rotation.keyPath = @"transform.rotation";
</span><span class='line'>rotation.values = @[ @0, @0.14, @0 ];
</span><span class='line'>rotation.duration = 1.2;
</span><span class='line'>rotation.timingFunctions = @[
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>CAKeyframeAnimation *position = [CAKeyframeAnimation animation];
</span><span class='line'>position.keyPath = @"position";
</span><span class='line'>position.values = @[
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointZero],
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointMake(110, -20)],
</span><span class='line'>    [NSValue valueWithCGPoint:CGPointZero]
</span><span class='line'>];
</span><span class='line'>position.timingFunctions = @[
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
</span><span class='line'>    [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]
</span><span class='line'>];
</span><span class='line'>position.additive = YES;
</span><span class='line'>position.duration = 1.2;
</span><span class='line'>
</span><span class='line'>CAAnimationGroup *group = [[CAAnimationGroup alloc] init];
</span><span class='line'>group.animations = @[ zPosition, rotation, position ];
</span><span class='line'>group.duration = 1.2;
</span><span class='line'>group.beginTime = 0.5;
</span><span class='line'>
</span><span class='line'>[card.layer addAnimation:group forKey:@"shuffle"];
</span><span class='line'>
</span><span class='line'>card.layer.zPosition = 1;</span></code></pre></td></tr></table></div></figure>


<p>我们使用CAAimationGroup得到一个好处是可以将所有动画作为一个对象暴露出去。如果你要在应用程序中的多个地方用工厂对象创建的重用的动画的话，这将会非常有用。</p>

<p>你也可以使用动画组同时控制所有动画组成部分的时间</p>

<h2>Core Animation 之外</h2>

<p>你应该已经听过 UIKIT Dynamics了，这是ios7中引入的一个物理模拟框架，它允许你使用约束和力来为 views做动画。与core Animation不同，它与你在屏幕上看到的内容交互更为间接，但是它的动态特性让你可以在事先不知道结果时创建动画。</p>
]]></content>
  </entry>
  
</feed>
