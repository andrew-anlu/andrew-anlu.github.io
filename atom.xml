<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-12-24T21:40:23+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS的后台模式]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/23/iosde-hou-tai-mo-shi/"/>
    <updated>2016-12-23T14:32:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/23/iosde-hou-tai-mo-shi</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Core Location和MapView进行路线规划]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua/"/>
    <updated>2016-12-21T16:04:20+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/21/shi-yong-core-locationhe-mapviewjin-xing-lu-xian-gui-hua</id>
    <content type="html"><![CDATA[<h2>开始</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/11/ProcrastinatorsRevenge-starter.zip">下载开始工程</a></p>

<p>并且打开<code>ProcrastinatorsRevenge.xcodeproj</code>,编译运行，界面效果如下:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/starter_screenshots1.png" alt="1" /></p>

<p>第一个屏幕是输入文本框，设置开始和终止地点，点击<code>Route it</code>,App将会跳转到第二个页面，开始规划路线图。</p>

<h2>使用MapKit和Coreloaction</h2>

<p>官方文档中对Core Loaction的描述是这样的:&ldquo;Core location框架让你决定当前的坐标或者或者当前的方位通过使用设备"，你将要用Core Location的特性去填充用户的开始点，Core Location能翻译坐标的经纬度为用户能够看得懂的地址信息。在MapView中，使用MapItem类的<code>CLGeocoder</code>类将会完成这个教程的第一部分。</p>

<p>在这个教程的第二部分，你将要从<code>CLGeocoder</code>返回的<code>CLPlacemark</code>中转为一个<code>MKPlacemark</code>，然后把<code>MKPlacemark</code>转换为一个<code>MKMapItem</code>。你将要使用<code>MKMapItems</code>去运行一个<code>MKDirectionsRequest</code>，这个最终将会返回一个<code>MKRoute</code>对象。</p>

<p>关系如下-><code>CLGeocoder &gt; CLPlacemark &gt; MKPlacemark &gt; MKMapItem &gt; MKDirectionsRequest &gt; MKRoute.</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/ef1905fa6eccb7e1cd85141d065d49f8.jpg-320x320.gif" alt="1" /></p>

<h2>通过CoreLocation获取当前的坐标信息</h2>

<p>在<code>ViewController.swift</code>中，添加如下代码，替换<code>viewDidLoad</code>已经存在的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let locationManager = CLLocationManager()
</span><span class='line'> 
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  originalTopMargin = topMarginConstraint.constant
</span><span class='line'>  // 2
</span><span class='line'>  locationManager.delegate = self
</span><span class='line'>  locationManager.requestWhenInUseAuthorization()
</span><span class='line'>  // 3
</span><span class='line'>  if CLLocationManager.locationServicesEnabled() {
</span><span class='line'>    locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
</span><span class='line'>    locationManager.requestLocation()
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>让我们说说每一步都做了什么:</p>

<ol>
<li>你定义了一个全局常量<code>locationManager</code></li>
<li>在<code>ViewDidLoad</code>中，设置location manager的代理，当用户打开App的时候，询问用户是否允许访问用户地理位置的权限，这个弹出框第一次将会显示，当用户做出响应之后，这个框就不会再出现了。</li>
<li>一旦用户定位服务开启，设置这个<code>CLLocationManager’s</code>的定位精度信息，请求当前坐标</li>
</ol>


<p>编译运行你的程序，你是否弹出了提示框让你授权地理定位信息呢？</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/reaction_faces___confused_by_awesomesauceuk-d4od42z.png" alt="1" /></p>

<p>这是因为你还有一件事情需要完成，那就是权限问题，你需要提供原因为你的请求。
打开<code>Supoorting Files&gt;info.plist</code>，按如下步骤进行设置:</p>

<ol>
<li>添加<code>NSLocationWhenInUseUsageDescription</code>作为<code>Key</code>在 Information Property List中</li>
<li>让这个<code>Type</code>为<code>String</code>类型</li>
<li>设置这个<code>Value</code>值去向用户展示，解释为什么你需要访问他们的地理信息：“请运行我们访问你的当前坐标信息，这样我们就能自动填充你的开始和结束地点了”</li>
</ol>


<blockquote><p><code>注意:</code>
<em>.requestWhenInUseAuthorization()</em> 让这个app访问当前的用户地理信息，当这个App是在使用的时候</p>

<p>*.requestAlwaysAuthorization() * 当这个app不管是在前台还是后台的时候.这个app都能访问用户的地理信息，</p></blockquote>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/plist.png" alt="1" /></p>

<p>编译运行你的app,这次提示框将会显示:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/LocationAuthorization.png" alt="1" /></p>

<p>点击<code>Allow</code>,这个location Manager现在将会访问到你的地理坐标</p>

<p>下一步，你将要创建<code>CLGeocoder</code>去解码当前的坐标信息。解码过程就是把获取到的地理坐标，比如经纬度，转换成我们能看的懂得地理位置信息，比如长江道第三大街33号</p>

<p>在<code>ViewConroller.swift</code>的底部，添加如下代码，<code>locationManager(_:didUpdateLocations:locations:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CLGeocoder().reverseGeocodeLocation(locations.last!,
</span><span class='line'>  completionHandler: {(placemarks:[CLPlacemark]?, error:NSError?) -&gt; Void in
</span><span class='line'>  if let placemarks = placemarks {
</span><span class='line'>    let placemark = placemarks[0]
</span><span class='line'>  }
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p><code>reverseGeocodeLocation(_:completionHandler:)</code>将会返回一组<code>placemarks</code>，对于多数的<code>geocoding</code>结果来说，这个数组仅仅是包含一个元素;很少的情况，一个单独的地点能返回多个地理位置附近的信息。在这个例子中，我们获取第一个placemark,即：placemarks[0],将会满足需求。</p>

<p>你可以可以停止更新坐标信息，当你发现了一个适当的placemark的时候。</p>

<p>现在你通过用户的地理位置已经找到对应地理坐标的<code>CLPlacemark</code>，你需要去联想其它跟他相关的地理数据信息，通过用户输入的文本框中的位置。为了实现这个，当用户输入一个单独的值的时候，通过swift的元组结构值去匹配多个值。</p>

<p>在<code>ViewDidLoad</code>中，添加下面的全局变量去匹配每个<code>UITextField</code>响应的<code>MKMapItem</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var locationTuples: [(textField: UITextField!, mapItem: MKMapItem?)]!</span></code></pre></td></tr></table></div></figure>


<p>对用户的坐标信息，你将要存储<code>MKMapItems</code>而不是<code>CLPlacemarks</code>，这个类型你最终将会用在初始化<code>MKDirectionsRequest</code>上，用来计算路径规划。</p>

<p>在<code>ViewDidLoad</code>中，添加如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>locationTuples = [(sourceField, nil), (destinationField1, nil), (destinationField2, nil)]</span></code></pre></td></tr></table></div></figure>


<p>这里，你定义了一个数组，里面包含了元组,每个元组都包含了一个文本框和一个为空的 MKMapItem的值，这个值最终会被和文本框绑定到一起。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/happy-thumbs-up.png" alt="1" /></p>

<p>在<code>locationManager(_:didUpdateLocations:location:)</code>方法中，添加如下代码片段，在<code>reverseGeocodeLocation(_:completionHandler:)</code>的完成回调方法中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.locationTuples[0].mapItem = MKMapItem(placemark:
</span><span class='line'>  MKPlacemark(coordinate: placemark.location!.coordinate,
</span><span class='line'>  addressDictionary: placemark.addressDictionary as! [String:AnyObject]?))</span></code></pre></td></tr></table></div></figure>


<p>添加了一个<code>MKMapItem</code>代表用户当前的地理位置作为<code>locationTuples</code>的第一个元组对象。</p>

<p>下一步，在ViewController中添加下面的函数 ，去把location data中的地理信息提取出来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func formatAddressFromPlacemark(placemark: CLPlacemark) -&gt; String {
</span><span class='line'>  return (placemark.addressDictionary!["FormattedAddressLines"] as! 
</span><span class='line'>    [String]).joinWithSeparator(", ")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>formatAddressFromPlacemark(_:)</code>从<code>CLPlacemark's</code>地址字典中通过<code>FormattedAddressLines</code>key提取一组地址信息，然后每两个元素之间用逗号连接起来组成一个新的字符串。</p>

<p>滑动到<code>locationManager(_:didUpdateLocations:locations:)</code>方法，在self.locationTuples[0].mapItem初始化后添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.sourceField.text = self.formatAddressFromPlacemark(placemark)</span></code></pre></td></tr></table></div></figure>


<p>这将设置UItextField为一个新地址。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.enterButtonArray.filter{$0.tag == 1}.first!.selected = true</span></code></pre></td></tr></table></div></figure>


<p>在开始工程中，按钮的选择文本是提前设置好的，按钮的tag是按照顺序设置的，每个<code>Enter</code>按钮都和页面<code>enterButtonArray</code>建立了连接关系，上面的代码找到 tag=1的 <code>Enter</code>按钮，并且每个UItextField也是按照顺序设置的tag，和按钮是一一对应的。</p>

<p>所以按钮的状态为选中时的文本会变为<code>✓</code>。</p>

<p>编译运行你的APP，假如当前坐标是:Apple HQ,你的文本框中的文本将会是:<code>Apple Inc., 2 Infinite Loop, Cupertino, CA 95014-2083, United States</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Apple_source.png" alt="1" /></p>

<p>在模拟器中，修改当前的坐标 <code>select Debug &gt; Location &gt; Custom location…:</code>
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Menu_bar-700x374.png" alt="1" /></p>

<p>输入坐标信息:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/CustomLocation-e1437159760381.png" alt="1" /></p>

<p><code>Latitude: 29.049186, Longitude: -95.45384</code></p>

<p>编译运行程序，这个文本框中将会显示:<code>05 Any Way St, Lake Jackson, TX, 77566-4198, United States
</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Any_Way_source.png" alt="1" /></p>

<p>下一步，你需要用户正确的输入地址，然后通过文本框中的值获取关联的地理位置信息，通过创建<code>MKMapItems</code>来获取。</p>

<h2>用户调用CoreLoaction过程</h2>

<p>在<code>ViewController.swift</code>中，更新<code>addressEntered(_:)</code>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@IBAction func addressEntered(sender: UIButton) {
</span><span class='line'>  view.endEditing(true)
</span><span class='line'>  // 1
</span><span class='line'>  let currentTextField = locationTuples[sender.tag-1].textField
</span><span class='line'>  // 2
</span><span class='line'>  CLGeocoder().geocodeAddressString(currentTextField.text!,
</span><span class='line'>    completionHandler: {(placemarks: [CLPlacemark]?, error: NSError?) -&gt; Void in
</span><span class='line'>    if let placemarks = placemarks {
</span><span class='line'> 
</span><span class='line'>    } else {
</span><span class='line'> 
</span><span class='line'>    }
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你添加的代码做的工作如下:</p>

<ol>
<li>在interface builder中，每个<code>Enter</code>按钮都有一个tag,从上到下依次为1,2,3.你可以通过sender.tag来找到是那个text field.(UItextField的tag和Enter按钮的tag是一一对应的)</li>
<li>通过<code>CLGeocoder's geocodeAddressString(_:completionHandler:).</code>去解码地理坐标</li>
</ol>


<p>不像<code>reverseGeocodeLocation(_:completionHandler:), geocodeAddressString(_:completionHandler:)</code>，经常会返回多个<code>CLPlacemark</code>信息，在文本中输入的值经常不是仅仅匹配一个值。幸运的是，我们创建一个Tableview来显示多个数据信息，当用户选择了一项之后我们就会返回一个<code>CLPlacemarks</code></p>

<p>看一下<code>AddressTableView.swift.</code>这个类，你应该很清楚<code>tableView(_:numberOfRowsInSection:)</code>和<code>tableView(_:cellForRowAtIndexPath:),</code>代理方法的作用，你将要使用在顶部定义的全局变量<code>address</code>数组去填充这个tableview.</p>

<p>在<code>ViewController</code>中添加如下的函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showAddressTable(addresses: [String]) {
</span><span class='line'>  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds,
</span><span class='line'>    style: UITableViewStyle.Plain)
</span><span class='line'>  addressTableView.addresses = addresses
</span><span class='line'>  addressTableView.delegate = addressTableView
</span><span class='line'>  addressTableView.dataSource = addressTableView
</span><span class='line'>  view.addSubview(addressTableView)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过方法<code>geocodeAddressString(_:completionHandler:).</code>返回一组<code>CLPlacemarks</code>数据。这里你创建一个AddressTable，并且设置了数据源<code>addresses</code>数组，数组中包含的元素就是<code>CLPlacemarks</code></p>

<p>回到<code>addressEntered(_:)</code>方法中，在<code>if let placemarks = placemarks</code>回调函数<code>geocodeAddressString(_:completionHandler:)‘s</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var addresses = [String]()
</span><span class='line'>for placemark in placemarks {
</span><span class='line'>  addresses.append(self.formatAddressFromPlacemark(placemark))
</span><span class='line'>}
</span><span class='line'>self.showAddressTable(addresses)</span></code></pre></td></tr></table></div></figure>


<p>你看到了属性<code>placemarks</code>，遍历访问并且把地址追加到Addresses数组中。最后把<code>addresses</code>作为参数传递给<code>self.showAddressTable</code></p>

<p>当在第一屏幕的文本框中输入地址，并且点击<code>Enter</code>按钮，就会跳转到一个页面，让你选择具体是那个地址:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/OysterCreekTable.png" alt="1" /></p>

<p>当你选择了其中了一个地址之后，会发生什么呢？这个table将会消失。好了，让我去实现它</p>

<p>当你选择另一个地址之后，你想要自动的设置选择的文本去填充第一屏幕中的文本框中的值，更新查询到的locations数组，并且设置相关的<code>MKMapItem</code>,并且设置<code>Enter</code>按钮的选中状态。</p>

<p>更新<code>showAddressTable(_:)</code>方法在<code>ViewController.swift</code>中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showAddressTable(addresses: [String], textField: UITextField,
</span><span class='line'>  placemarks: [CLPlacemark], sender: UIButton) {
</span><span class='line'> 
</span><span class='line'>  let addressTableView = AddressTableView(frame: UIScreen.mainScreen().bounds, style: UITableViewStyle.Plain)
</span><span class='line'>  addressTableView.addresses = addresses
</span><span class='line'>  addressTableView.currentTextField = textField
</span><span class='line'>  addressTableView.placemarkArray = placemarks
</span><span class='line'>  addressTableView.mainViewController = self
</span><span class='line'>  addressTableView.sender = sender
</span><span class='line'>  addressTableView.delegate = addressTableView
</span><span class='line'>  addressTableView.dataSource = addressTableView
</span><span class='line'>  view.addSubview(addressTableView)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里，你通过当前的文本框字段，数组placemarks,和当前的<code>ViewController.swift</code>的实例 创建一个AddressTableView。</p>

<p>在<code>geocodeAddressString(_:completionHandler:)</code>方法中，更新<code>showAddressTable(_:)</code>的参数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.showAddressTable(addresses, textField: currentTextField,
</span><span class='line'>    placemarks: placemarks, sender: sender)</span></code></pre></td></tr></table></div></figure>


<p>在查询不到地址的情况下，应该马上弹出提示框:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>self.showAlert("Address not found.")</span></code></pre></td></tr></table></div></figure>


<p>如果<code>geocodeAddressString(_:completionHandler:)</code>没有返回任何placemarks,你应该显示一个error:</p>

<p>下一步，在表格的点击方法<code>tableView(_:didSelectRowAtIndexPath:)</code>中，加入代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>if addresses.count &gt; indexPath.row {
</span><span class='line'>  // 2
</span><span class='line'>  currentTextField.text = addresses[indexPath.row]
</span><span class='line'>  // 3
</span><span class='line'>  let mapItem = MKMapItem(placemark:
</span><span class='line'>    MKPlacemark(coordinate: placemarkArray[indexPath.row].location!.coordinate,
</span><span class='line'>    addressDictionary: placemarkArray[indexPath.row].addressDictionary
</span><span class='line'>    as! [String:AnyObject]?))
</span><span class='line'>  mainViewController.locationTuples[currentTextField.tag-1].mapItem = mapItem
</span><span class='line'>  // 4
</span><span class='line'>  sender.selected = true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面解释代码的意思:</p>

<ol>
<li>当addresses的数量是大于当前行的索引的时候,表格的最后一行将会显示:<code>None of the above</code></li>
<li>更新当前的文本框中的值为选择的地址</li>
<li>使用placemark去创建创建<code>MKMapItem</code>，placemark是通过获取当前行创建的。根据当前文本框的tag获取<code>mainViewController's locationTuples</code>中的mapitem,并且设置它</li>
<li>设置当前<code>Enter</code>为选中状态</li>
</ol>


<p>编译运行，在<code>Stop#1</code>中输入地址，点击<code>Enter</code>，然后选择正确的地址，这个文本框中的值，地址元组(location tuple arra)，还有<code>Enter</code>按钮将会自动更新:
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/Two_entries.png" alt="1" /></p>

<p><em>Addresses updated. (Checkmarks et al.)</em></p>

<p>在<code>ViewController.swift</code>中你还有一部分工作需要完成。</p>

<p>更新代码在<code>textField(_:shouldChangeCharactersInRange:replacementString:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func textField(textField: UITextField,
</span><span class='line'>  shouldChangeCharactersInRange range: NSRange,
</span><span class='line'>  replacementString string: String) -&gt; Bool {
</span><span class='line'> 
</span><span class='line'>  enterButtonArray.filter{$0.tag == textField.tag}.first!.selected = false
</span><span class='line'>  locationTuples[textField.tag-1].mapItem = nil
</span><span class='line'>  return true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户编辑了文本框，你将要设置MKMapItem失效，因为MKMapItem是不再需要，这样用户就可以重新选择正确的地址。</p>

<p>下一步，更新<code>swapFields(_:)</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>swap(&destinationField1.text, &destinationField2.text)
</span><span class='line'>    swap(&locationTuples[1].mapItem, &locationTuples[2].mapItem)
</span><span class='line'>    swap(&self.enterButtonArray.filter{$0.tag == 2}.first!.isSelected, &self.enterButtonArray.filter{$0.tag == 3}.first!.isSelected)</span></code></pre></td></tr></table></div></figure>


<p>当用户点击<code>↑↓</code>，你需要交换两个文本框的值，还有在数组<code>locationTuples</code>对应的MKMapItems</p>

<p>在<code>ViewController</code>类中，找到<code>getDirections(_:)</code>方法，覆盖<code>shouldPerformSegueWithIdentifier(_:sender:)</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func shouldPerformSegueWithIdentifier(identifier: String, sender: AnyObject?) -&gt; Bool {
</span><span class='line'>  if locationTuples[0].mapItem == nil ||
</span><span class='line'>    (locationTuples[1].mapItem == nil && locationTuples[2].mapItem == nil) {
</span><span class='line'>    showAlert("Please enter a valid starting point and at least one destination.")
</span><span class='line'>    return false
</span><span class='line'>  } else {
</span><span class='line'>    return true
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在<code>ViewDidload:</code>中对<code>locationsArray</code>进行设置，它是一个只读的属性，当你访问它的时候，它会从<code>locationTuples</code>中过滤<code>mapItem</code>不为nil的元素.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var locationsArray: [(textField: UITextField!, mapItem: MKMapItem?)] {
</span><span class='line'>  var filtered = locationTuples.filter({ $0.mapItem != nil })
</span><span class='line'>  filtered += [filtered.first!]
</span><span class='line'>  return filtered
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>filtered += [filtered.first!]</code>拷贝元组中的第一个元素的值作为这个数组的最后一个元素。</p>

<p>在<code>prepareForSegue(_:sender:):</code>中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
</span><span class='line'>  var directionsViewController = segue.destinationViewController as! DirectionsViewController
</span><span class='line'>  directionsViewController.locationArray = locationsArray
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个传递的参数<code>locationsArray</code>将会在下一个View controller中用到</p>

<p>现在切换到<code>DirectionsViewController.swift</code>，去开始路径规划吧.</p>

<h2>在MapKit中进行路径规划</h2>

<p>现在，你已经知道了addresses,你将要创建一个<code>MKDirections</code>对象，调用<code>calculateDirectionsWithCompletionHandler(_:)</code>设置开始坐标和结束坐标就可以开始路径规划了.</p>

<p>在DirectionsViewController中添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func calculateSegmentDirections(index: Int) {
</span><span class='line'>  // 1
</span><span class='line'>  let request: MKDirectionsRequest = MKDirectionsRequest()
</span><span class='line'>  request.source = locationArray[index].mapItem
</span><span class='line'>  request.destination = locationArray[index+1].mapItem
</span><span class='line'>  // 2
</span><span class='line'>  request.requestsAlternateRoutes = true
</span><span class='line'>  // 3
</span><span class='line'>  request.transportType = .Automobile
</span><span class='line'>  // 4
</span><span class='line'>  let directions = MKDirections(request: request)
</span><span class='line'>  directions.calculateDirectionsWithCompletionHandler ({
</span><span class='line'>    (response: MKDirectionsResponse?, error: NSError?) in
</span><span class='line'>    if let routeResponse = response?.routes {
</span><span class='line'> 
</span><span class='line'>    } else if let _ = error {
</span><span class='line'> 
</span><span class='line'>    }
</span><span class='line'>  })
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>创建一个<code>MKDirectionsRequest</code>，通过索引获取<code>locationArray</code>对应的mapItem,设置MKDirectionsRequest的开始坐标为这个mapitem,设置索引的下一个(index+1)为这个请求的目的地坐标</li>
<li>设置<code>requestsAlternateRoutes</code>为true,请求从源目标到目的地所有可能的路径</li>
<li>设置交通方式为 汽车驾驶,其它几个可能的方式为:步行，所有,公交车等</li>
<li>通过<code>MKDirectionsRequest</code>初始化<code>MKDirections</code>，然后调用<code>calculateDirectionsWithCompletionHandler</code>获取到一个<code>MKDirectionsResponse</code>，这会包含一组<code>MKRoutes</code>数据</li>
</ol>


<p>如果<code>calculateDirectionsWithCompletionHandler(_:)</code>没有返回任何routes,而是返回一个错误，那么<code>else if let _ = error</code>代码将会执行，添加这个代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alert = UIAlertController(title: nil,
</span><span class='line'>  message: "Directions not available.", preferredStyle: .Alert)
</span><span class='line'>let okButton = UIAlertAction(title: "OK",
</span><span class='line'>  style: .Cancel) { (alert) -&gt; Void in
</span><span class='line'>  self.navigationController?.popViewControllerAnimated(true)
</span><span class='line'>}
</span><span class='line'>alert.addAction(okButton)
</span><span class='line'>self.presentViewController(alert, animated: true,
</span><span class='line'>  completion: nil)</span></code></pre></td></tr></table></div></figure>


<p>假设<code>MKRoutes</code>是找到了，在第一个<code>if let</code>声明中<code>calculateDirectionsWithCompletionHandler(_:)</code>将会执行，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>let quickestRouteForSegment: MKRoute =
</span><span class='line'>  routeResponse.sort({$0.expectedTravelTime &lt;
</span><span class='line'>  $1.expectedTravelTime})[0]</span></code></pre></td></tr></table></div></figure>


<p>这里你按照 到达的时间 进行排序，用时最短的时间将会排在第一个，这对你的路线规划来说是有好处的。
<img src="https://koenig-media.raywenderlich.com/uploads/2015/07/troll-troll-dad-dance-jump.png" alt="2" /></p>

<p>但是，你仍然需要计算多个路径在每两个地点之间。</p>

<p>首先，更新<code>calculateSegmentDirections(_:)</code>参数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func calculateSegmentDirections(index: Int,
</span><span class='line'>  time: NSTimeInterval, routes: [MKRoute]) {</span></code></pre></td></tr></table></div></figure>


<p><code>calculateSegmentDirections(_:time:routes:)</code>现在接受一个数组和一个 NSTimeInterval 参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>// 1
</span><span class='line'>var timeVar = time
</span><span class='line'>var routeVar = routes
</span><span class='line'>//2
</span><span class='line'>routesVar.append(quickestRouteForSegment)
</span><span class='line'>// 3
</span><span class='line'>timeVar += quickestRouteForSegment.expectedTravelTime
</span><span class='line'>// 4
</span><span class='line'>if index+2 &lt; self.locationArray.count {
</span><span class='line'>  self.calculateSegmentDirections(index+1, time: timeVar, routes: routesVar)
</span><span class='line'>} else {
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>创建两个变量，一个是timeVar,一个是routeVar</li>
<li>为当前的分段路线routesVar添加最快的路径规划</li>
<li>在timeVar中添加路径规划的预计到达时间</li>
<li>当你当前的索引加上最后两个值后没有超过<code>location array</code>数量值，递归调用自身方法<code>calculateSegmentDirections(_:time:routes:)</code>，传递索引+1,当前的time和路径values.</li>
</ol>


<p>现在回到<code>viewDidLoad</code>中，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addActivityIndicator()
</span><span class='line'>calculateSegmentDirections(0, time: 0, routes: [])</span></code></pre></td></tr></table></div></figure>


<p>这个代码添加一个转子activity indicator,当路径规划开始计算的时候，然后调用<code>calculateSegmentDirections(_:time:routes:)</code>去计算路径，从locationArray第一个索引开始，初始化时间为0,初始化一个空的路径数组</p>

<p>然后回到<code>calculateDirectionsWithCompletionHandler(_:)</code>中，在<code>else</code>的回调函数判断中，在<code>if index+2 &lt; self.locationArray.count</code>的下面添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.hideActivityIndicator()</span></code></pre></td></tr></table></div></figure>


<p>当计算完所有的路径规划后，隐藏转子</p>

<h2>在MKMapIVew中添加MKRoutes</h2>

<p>为了去规划每一个<code>MKMapView</code>在MKMapView中，你需要在<code>DirectionsViewController</code>添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func plotPolyline(route: MKRoute) {
</span><span class='line'>  // 1
</span><span class='line'>  mapView.addOverlay(route.polyline)
</span><span class='line'>  // 2
</span><span class='line'>  if mapView.overlays.count == 1 {
</span><span class='line'>    mapView.setVisibleMapRect(route.polyline.boundingMapRect,
</span><span class='line'>      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
</span><span class='line'>      animated: false)
</span><span class='line'>  }
</span><span class='line'>  // 3
</span><span class='line'>  else {
</span><span class='line'>    let polylineBoundingRect =  MKMapRectUnion(mapView.visibleMapRect,
</span><span class='line'>      route.polyline.boundingMapRect)
</span><span class='line'>    mapView.setVisibleMapRect(polylineBoundingRect,
</span><span class='line'>      edgePadding: UIEdgeInsetsMake(10.0, 10.0, 10.0, 10.0),
</span><span class='line'>      animated: false)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>plotPolyline(_:)</code>做的工作如下:</p>

<ol>
<li>添加<code>MKRoute</code>到地图上，作为一个覆盖层</li>
<li>如果规划的路径仅仅是一个覆盖层，设置地图的可见区域足够大足以填充整个覆盖层，外边缘留出10个点的间距</li>
<li>如果规划的路径不是一个，设置地图的可见区域为新的和旧的的区域的联合，外边缘留出10个点的间距</li>
</ol>


<p>下一步，更新<code>mapView(_:rendererForOverlay:)</code>方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func mapView(mapView: MKMapView,
</span><span class='line'>  rendererForOverlay overlay: MKOverlay) -&gt; MKOverlayRenderer! {
</span><span class='line'> 
</span><span class='line'>  let polylineRenderer = MKPolylineRenderer(overlay: overlay)
</span><span class='line'>  if (overlay is MKPolyline) {
</span><span class='line'>    if mapView.overlays.count == 1 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.blueColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    } else if mapView.overlays.count == 2 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.greenColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    } else if mapView.overlays.count == 3 {
</span><span class='line'>      polylineRenderer.strokeColor =
</span><span class='line'>        UIColor.redColor().colorWithAlphaComponent(0.75)
</span><span class='line'>    }
</span><span class='line'>    polylineRenderer.lineWidth = 5
</span><span class='line'>  }
</span><span class='line'>  return polylineRenderer
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>给每一个路径路段设置不同的颜色</p>

<p>在<code>calculateSegmentDirections(_:time:routes:)</code>添加:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func showRoute(routes: [MKRoute]) {
</span><span class='line'>  for i in 0..&lt;routes.count {
</span><span class='line'>    plotPolyline(routes[i])
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[倒车入库技巧]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/21/dao-che-ru-ku-ji-qiao/"/>
    <updated>2016-12-21T13:58:07+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/21/dao-che-ru-ku-ji-qiao</id>
    <content type="html"><![CDATA[<p><img src="http://img0.pcauto.com.cn/pcauto/1306/21/2537510_22.jpg" alt="1" /></p>

<p>倒车入库难在哪儿呢？倒车不只需要对油门、刹车和方向的操作，同时还考验着对整部车安全范围以及行驶轨迹的判断。倒不好，不但失面子、影响心情，还浪费时间甚至让爱车受伤……那么，怎样才能练就一身过硬功夫，做到准确而漂亮的入库呢？</p>

<!--more-->


<p><img src="http://img0.pcauto.com.cn/pcauto/1306/03/2537510_1(1" alt="1" />_thumb.jpg)</p>

<h2>“非”字形停车位</h2>

<p>城市的停车位，最常见的就是“非”字形停车位了。现在就让婷MM先来演示下“非”字形车位攻略法，请看图</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1306/03/2537510_IMG_1752_thumb.jpg" alt="1" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_1_thumb.jpg" alt="2" /></p>

<h3>第一步</h3>

<p>判断目标车位左右距离是否够用，确定后，稍微靠近车位并控制车侧间距在1.5m左右</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_2_thumb.jpg" alt="1" /></p>

<p>所坐的位置，正好处于隔一个车位的中间。</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_3_thumb.jpg" alt="2" /></p>

<p>然后向后倒车，倒车时适当改变转向角度，控制与临位车辆的距离。</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_4_thumb.jpg" alt="2" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_5_thumb.jpg" alt="3" /></p>

<p>车尾左后方越过车位边界线后，减慢倒车速度，并注视右侧后视镜</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_6_thumb.jpg" alt="1" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_7_thumb.jpg" alt="2" /></p>

<p>当与右侧车辆出现间隙时，适当调节转向角度，调整左右车距，并且尽量使左侧车距略大于右侧，为开车门提供方便</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_8_thumb.jpg" alt="1" />
　只要掌握好以上几个要点，把握好打方向的时机，不要太早也不要太晚，“非”字形停车位就不再可怕了
　
　</p>

<h1>侧方位停车位</h1>

<p>侧方位停车现在已经成为城市行车中越来越常见的，特别是在市区停车场车位愈加紧张的情况下，很多地区将道路两旁规划成停车位，也就变成“侧方位停车位”了。很多朋友对侧方位停车都感到比较棘手，其实这种停车也是有技巧的，掌握了以后你就能轻松应付侧向停车</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_9_thumb.jpg" alt="1" /></p>

<p>第一步：开过车位，观察该车位是否符合要求，侧方车位有时大，有时小，这就要判断自己的车能否停进去</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_10_thumb.jpg" alt="1" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_11_thumb.jpg" alt="1" /></p>

<p>确定车位“合格”后，就将车向前开至与前车大致齐平的位置，两车横向相距约1米</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_12_thumb.jpg" alt="1" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_13_thumb.jpg" alt="1" />
然后，就可以把方向向右打死，开始倒车。同时还要留意后方是否有车尾随，如果有，应打开双闪灯示意后车暂时不要靠近</p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_14_thumb.jpg" alt="2" /></p>

<p><img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_15_thumb.jpg" alt="2" />
　保持右打方向到底慢慢倒车，直至左侧后视镜能完全看到后车的车头时，快速把方向从最右打到最左（或停顿一下原地打盘），继续倒车
　
　<img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_16_thumb.jpg" alt="2" />
　
　
　<img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_17_thumb.jpg" alt="2" />
　通过右侧后视镜，注意观察右后轮与路肩的距离，通过打方向调节车子的后退轨迹，尽量向路肩靠近，但又要保持足够距离让车身可以回直
　
　<img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_18_thumb.jpg" alt="2" />
　
　<img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_19_thumb.jpg" alt="2" />
　右打方向前移摆正车身，同时注意，不要距离前车太近，停车时应留好出去的距离，就大功告成了
　
　<img src="http://img0.pcauto.com.cn/pcauto/1305/31/2537510_20_thumb.jpg" alt="2" />
　</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用CoreLocation实现-地理围栏]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/19/yong-corelocationshi-xian-di-li-wei-lan/"/>
    <updated>2016-12-19T14:58:38+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/19/yong-corelocationshi-xian-di-li-wei-lan</id>
    <content type="html"><![CDATA[<p>地理围栏就是当你的手机设备进入或者离开某个区域的时候进行消息提醒,它会让你的程序变得更cool,设想一下，当你离开家，或者靠近一家你喜欢的商场附近时，能够及时给你发送最新的或者最优惠的信息。</p>

<!--more-->


<p>在这个教程中，你将会学会如何用region监听区域，这个工程是采用swift3语言实现的。</p>

<p>为了练习，你将要创建一个位置点去提醒app调用地理围栏进行提醒，假想它们就是现实世界中的位置坐标。好了，让我们开始吧。</p>

<h2>开始</h2>

<p>下载这个<a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Geotify-Starter-1.zip">开始工程</a>,这个工程提供了简单的在地图上添加/删除 地图注解(Annotation)的方法</p>

<p>编译运行程序，你将会看到一个空白的地图:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoInitial-281x500.png" alt="1" /></p>

<p>点击<code>+</code>按钮，去添加一个新的地理围栏，首先会打开一个新的页面，你可以设置你想要的位置坐标，点击<code>Add</code>就添加到了地图上，并且大头针显示</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLooking-Around-281x500.png" alt="2" /></p>

<p>这个<code>radius</code>代表指定地点的半径范围，单位是米
<code>note</code>在导航过程中，能够展示你想要展示的任何内容。</p>

<p>这个App也能够设置触发提醒方式，当用户进入或者离开某个区域的时候，进行提醒。</p>

<p>对radius设置1000，并且设置note为<code>Say Hi to Tim!</code>,选择触发类型为<code>Upon Entry</code>,然后点击<code>Add</code></p>

<p>然后你将要看到的地理围栏已经出来了一个新的大头针在地图上，下面还有一个圆形的渲染图层</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/Geo-Say-Hi-281x500.png" alt="2" /></p>

<p>点击这个大头针，将会显示详细信息，比如提示信息和半径大小，不要点击左边的删除按钮，因为点击之后这个地理围栏信息将会被删除掉从地图上和内存中</p>

<blockquote><p><em>注意:</em>
所有的地理围栏的信息都存储到了NSUserDefaults中</p></blockquote>

<h2>设置 Location Manager和权限</h2>

<p>你添加到地图上的地理围栏仅仅是能看的，但是不能进行消息提醒。</p>

<p>你将要修复这个通过core location来进行监听</p>

<p>打开<code>GeotificationsViewController.swift</code>，然后在类的顶部定义一个常量实例<code>CLLocationManager</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class GeotificationsViewController: UIViewController {
</span><span class='line'> 
</span><span class='line'>  @IBOutlet weak var mapView: MKMapView!
</span><span class='line'> 
</span><span class='line'>  var geotifications = [Geotification]()
</span><span class='line'>  let locationManager = CLLocationManager() // Add this statement
</span><span class='line'> 
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下一步，替换<code>viewDidLoad()</code>中为下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // 1
</span><span class='line'>  locationManager.delegate = self
</span><span class='line'>  // 2
</span><span class='line'>  locationManager.requestAlwaysAuthorization()
</span><span class='line'>  // 3
</span><span class='line'>  loadAllGeotifications()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们解析下代码:</p>

<ol>
<li>设置locationManager的代理，只有设置了代理，相关的代理方法才会被调用</li>
<li>你调用了<code>requestAlwaysAuthorization()</code>方法，它会调用一个提示，"Always"总是允许使用定位服务，因为App一直需要拥有<code>Always</code>权限去进行地理围栏的监听，直到这个app不在运行的时候，就不再需要这个权限了。在info.plist中已经设置了消息去告诉用户当请求定位信息时必须设置key:<code>NSLocationAlwaysUsageDescription</code></li>
<li>调用<code>loadAllGeotifications()</code>，转换存储在<code>NSUserDefaults</code>中的地理围栏的信息，然后加载它们，这个方法加载地图上所有的地理围栏和大头针的数据</li>
</ol>


<p>当app设置了用户权限之后，界面上将会显示<code>NSLocationAlwaysUsageDescription</code>提示，一个友好的提示为什么app需要请求用户的地理坐标。这个key是强制性假如你使用定位服务的话，如果这个key没有的话，系统将会忽略程序请求并且终止定位服务</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationWhenNotUsing-281x500.png" alt="2" /></p>

<p>OK，你已经设置好了app的请求权限，点击<code>Allow</code>去允许<code>location manager</code>在合适的时机调用代理方法</p>

<p>在你实现地理围栏的提醒之前，这里有个小的问题你必须解决：用户的当前坐标没有展示在地图上，这个特性是不能实现的，你必须手动的点击左上角的那个定位按钮，才能定位到当前用户的地理坐标。</p>

<p>幸运的是，修复这个是很容易的-在你允许了app获取权限之后，仅仅需要点下那个定位按钮</p>

<p>在<code>GeotificationsViewController.swift</code>，添加<code>CLLocationManagerDelegate</code>的扩展如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension GeotificationsViewController: CLLocationManagerDelegate {
</span><span class='line'>  func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
</span><span class='line'>    mapView.showsUserLocation = (status == .authorizedAlways)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>不管什么时候用户的权限状态改变的时候，location manager都会调用<code>locationManager(_:didChangeAuthorizationStatus:)</code>代理方法。假如用户授权app去使用当前定位服务，在你初始化好后locationManager,并且设置了代理之后，这个方法将会被调用</p>

<p>这个方法是个理想的地方去检查这个app是否被授权，如果是，你将能确保mapView展示当前用户的坐标</p>

<p>编译运行这个app,如果你用真机测试，你将会在mapView中看到当前的坐标；如果你运行在模拟器上，点击 <code>Debug\Location\Apple</code> 来查看地图上的标记</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationFar-281x500.png" alt="1" /></p>

<p>放大地方，你看到的将会是这样:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoLocationZoomed-281x500.png" alt="1" /></p>

<h2>注册你自己的地理围栏</h2>

<p>当你的location manager配置好了之后，下一步就是允许你的app去注册一个地理围栏用来被监听</p>

<p>在你的app中，你的地理围栏的信息是被存储为<code>Geotification</code>模型，在你注册为被监听之前，core Location 请求每一个地理围栏去返回一个<code>CLCircularRegion</code>实例。为了去处理这个请求，你将要创建一个helper方法，然后从指定的<code>Geotification</code>对象中返回一个  <code>CLCircularRegion</code></p>

<p>打开<code>GeotificationsViewController.swift</code>，然后在主体代码中添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func region(withGeotification geotification: Geotification) -&gt; CLCircularRegion {
</span><span class='line'>  // 1
</span><span class='line'>  let region = CLCircularRegion(center: geotification.coordinate, radius: geotification.radius, identifier: geotification.identifier)
</span><span class='line'>  // 2
</span><span class='line'>  region.notifyOnEntry = (geotification.eventType == .onEntry)
</span><span class='line'>  region.notifyOnExit = !region.notifyOnEntry
</span><span class='line'>  return region
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的方法做的工作如下：</p>

<ol>
<li>你用地理围栏的坐标进行<code>CLCircularRegion</code>的初始化，这个地理围栏的半径和identifier允许ios去判断注册的地理围栏的距离，这个初始化是很简单的，<code>Geotification</code>模型已经包含了要请求的属性。</li>
<li><code>CLCircularRegion</code>实例也需要设置两个BOOL值得属性，<code>notifyOnEntry</code>和<code>notifyOnExit</code>,这是两个标识，当设备进入或者离开指定的地理围栏的时候，定义的地理围栏的回调事件将会被触发，你也可以为你的每个地理围栏设计去响应一个消息通知，你可以设置一个是true,另外一个是false,前提是你需要使用<code>Geotification</code>实体的枚举值</li>
</ol>


<p>下一步，当用户添加坐标的时候，你需要一个方法去开始监听这个地理围栏</p>

<p>添加下面的方法在<code>GeotificationsViewController</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func startMonitoring(geotification: Geotification) {
</span><span class='line'>  // 1
</span><span class='line'>  if !CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) {
</span><span class='line'>    showAlert(withTitle:"Error", message: "Geofencing is not supported on this device!")
</span><span class='line'>    return
</span><span class='line'>  }
</span><span class='line'>  // 2
</span><span class='line'>  if CLLocationManager.authorizationStatus() != .authorizedAlways {
</span><span class='line'>    showAlert(withTitle:"Warning", message: "Your geotification is saved but will only be activated once you grant Geotify permission to access the device location.")
</span><span class='line'>  }
</span><span class='line'>  // 3
</span><span class='line'>  let region = self.region(withGeotification: geotification)
</span><span class='line'>  // 4
</span><span class='line'>  locationManager.startMonitoring(for: region)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>让我们一步一步讲解上面的方法:</p>

<ol>
<li><code>isMonitoringAvailableForClass(_:)</code>方法决定我们的设备是否支持监听地理围栏，假如不能够监听，程序将会返回并且弹出一个提示框进行提醒。</li>
<li>下一步，你检查当前权限的状态，确保这个app已经被授权去请求用户的定位服务，加入这个app没有被授权，这个设备将不会接受到地理围栏的任何提示信息。然而，在这个案例中，你将要始终允许用户去保存地理围栏信息，因为当你的app没有权限的时候，core loaction会让你注册地理围栏。当用户权限给这个app的时候，监听这些地理围栏将会自动开启</li>
<li>在之前定义的方法中，你创建一个<code>CLCircularRegion</code>实例从指定的(geotification)中。</li>
<li>最后，你用Core Location注册监听<code>CLCircularRegion</code>实例</li>
</ol>


<p>当用户删除地理围栏的时候，你同样需要停止监听</p>

<p>在<code>GeotificationsViewController.swift</code>中，添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func stopMonitoring(geotification: Geotification) {
</span><span class='line'>  for region in locationManager.monitoredRegions {
</span><span class='line'>    guard let circularRegion = region as? CLCircularRegion, circularRegion.identifier == geotification.identifier else { continue }
</span><span class='line'>    locationManager.stopMonitoring(for: circularRegion)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法执行调用<code>locationManager</code>去停止监听<code>CLCircularRegion</code>通过<code>geotification</code>对象去判断</p>

<p>现在你已经完成了开始和停止的方法，当你不管什么时候添加和删除geotification,你将会调用到这两个方法</p>

<p>首先，在<code>GeotificationsViewController.swift</code>中找到<code>addGeotificationViewController(_:didAddCoordinate)</code>方法，这个方法是一个代理方法，在创建geotification的时候调用；</p>

<p>当创建一个新的新的<code>Geotification</code>通过 AddGeotificationsViewController，同时更新mapView和<code>geotifications</code>的集合，然后调用<code>saveAllGeotifications()</code>进行数据保存，最新的数据是被保存到<code>NSUserDefaults</code>中。</p>

<p>现在，替换为下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addGeotificationViewController(controller: AddGeotificationViewController, didAddCoordinate coordinate: CLLocationCoordinate2D, radius: Double, identifier: String, note: String, eventType: EventType) {
</span><span class='line'>  controller.dismiss(animated: true, completion: nil)
</span><span class='line'>  // 1
</span><span class='line'>  let clampedRadius = min(radius, locationManager.maximumRegionMonitoringDistance)
</span><span class='line'>  let geotification = Geotification(coordinate: coordinate, radius: clampedRadius, identifier: identifier, note: note, eventType: eventType)
</span><span class='line'>  add(geotification: geotification)
</span><span class='line'>  // 2
</span><span class='line'>  startMonitoring(geotification: geotification)
</span><span class='line'>  saveAllGeotifications()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>你调用了location manager的<code>maximumRegionMonitoringDistance</code>属性和半径值进行比较，如果半径值超过了这个属性值，则获取该属性值，反之则取半径值，这是重要的一点，因为任何大于最大值的半径将会引发监听程序失败</li>
<li>用core location对新创建的geotification进行监听，通过调用<code>startMonitoringGeotification(_:)</code>方法，参数为<code>geofence</code></li>
</ol>


<p>通过这些代码，这个注册的App是有能力去进行监听，然而，有一个限制，作为地理围栏是和系统资源共享的，Core loaction要求每个设备最多只能注册20个地理围栏。</p>

<p>添加如下代码在<code>updateGeotificationsCount()</code>方法中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func updateGeotificationsCount() {
</span><span class='line'>  title = "Geotifications (\(geotifications.count))"
</span><span class='line'>  navigationItem.rightBarButtonItem?.isEnabled = (geotifications.count &lt; 20)  // Add this line
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这行代码意义就是当数量达到限制数量值得时候，导航栏的<code>Add</code>按钮将会变成<code>不可用</code>状态</p>

<p>最后，让我们处理删除地理围栏的操作，这个函数是在<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>这个代理方法中进行处理的，当用户点击每一个annotationView的左边的<code>delete</code>按钮的时候，将调用删除地理围栏的处理函数</p>

<p>添加停止监听的方法在<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>代理方法调用的时候：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
</span><span class='line'>  // Delete geotification
</span><span class='line'>  let geotification = view.annotation as! Geotification
</span><span class='line'>  stopMonitoring(geotification: geotification)   // Add this statement
</span><span class='line'>  removeGeotification(geotification)
</span><span class='line'>  saveAllGeotifications()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>添加声明去停止监听地理围栏通过传递<code>geotification</code>参数，在删除之前，请先改变<code>NSUserDefaults</code>中存储的值</p>

<p>通过这个方法，你的App可以停止监听地理围栏。</p>

<p>编译运行，你不会看到任何改变，但是这个App已经注册成了地理围栏的监听并且可以监听该区域，然而，它还不能响应任何的地理围栏的监听事件，不要着急-那就是你下一步需要做的事情.</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/These_eyes.png" alt="1" /></p>

<h2>响应地理围栏的事件</h2>

<p>你将要实现一些当发生错误时的代理方法，当发生错误的时候这些代理将会被调用.</p>

<p>在<code>GeotificationsViewController.swift</code>中，添加CLLocationManagerDelegate的代理方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error) {
</span><span class='line'>  print("Monitoring failed for region with identifier: \(region!.identifier)")
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
</span><span class='line'>  print("Location Manager failed with the following error: \(error)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这些代理方法仅仅是打印一些日志信息，当location manager发生错误的时候</p>

<p>下一步，打开<code>AppDelegate.swif</code>，在这里你将要添加一些代理用来处理和响应当设备进入或者离开事件</p>

<p>首先你需要导入<code>Corelocation</code>框架</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import CoreLocation</span></code></pre></td></tr></table></div></figure>


<p>确保在AppDelegate的顶端中有<code>CLLocationManager</code>的实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AppDelegate: UIResponder, UIApplicationDelegate {
</span><span class='line'>  var window: UIWindow?
</span><span class='line'> 
</span><span class='line'>  let locationManager = CLLocationManager() // Add this statement
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换<code>application(_:didFinishLaunchingWithOptions:)</code>中的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool {
</span><span class='line'>  locationManager.delegate = self
</span><span class='line'>  locationManager.requestAlwaysAuthorization()
</span><span class='line'>  return true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你设置你的AppDelegate去接收地理围栏的事件，你可能好奇，“为什么我要用AppDelegate去替换ViewController呢?”</p>

<p>注册了一个地理围栏随时都在监听，包括当这个App停止运行的时候。假如这个设备是在App停止运行的时候去触发，ios将会自动进入后台运行模式，这使得AppDelegate是一个理想的地方去处理这个事件，这个时候ViewController可能不会被加载。</p>

<p>现在你可能还会好奇，“新创建的<code>CLLocationManager</code>实例是如何知道去监听地理围栏的呢?”</p>

<p>你的app注册的地理围栏是很容易去监听的，所以不会担心你的locaion Manager是什么地方初始化的。</p>

<p>现在你只需要实现代理方法去响应地位围栏的事件信息，在你做这些之前，你将要创建一个方法去处理地理围栏的事件。</p>

<p>添加下面的方法在AppDelegate.swift中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func handleEvent(forRegion region: CLRegion!) {
</span><span class='line'>  print("Geofence triggered!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个方法中，传递一个CLRegion参数，并且打印一个日志声明，稍后你将会实现这个事件处理。</p>

<p>下一步，在AppDelegate.swift的扩展中，添加下面的代理方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension AppDelegate: CLLocationManagerDelegate {
</span><span class='line'> 
</span><span class='line'>  func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
</span><span class='line'>    if region is CLCircularRegion {
</span><span class='line'>      handleEvent(forRegion: region)
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
</span><span class='line'>    if region is CLCircularRegion {
</span><span class='line'>      handleEvent(forRegion: region)
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你的设备进入<code>CLRegion</code>区域时，<code>locationManager(_:didEnterRegion:)</code>方法将会被调用，当你离开该区域时，<code>locationManager(_:didExitRegion:)</code>方法将会被调用</p>

<p>两个方法都会返回<code>CLRegion</code>，你需要去检查并且确保它是<code>CLCircularRegion</code>，因为返回有可能是<code>CLBeaconRegion</code>，假如你的App使用iBeacons来进行监听的。</p>

<p>假如你的region属于<code>CLCircularRegion</code>返回之内，你将会调用<code>handleRegionEvent(_:)</code></p>

<p>现在你的App是能收到地理围栏的事件了，你要准备去测试它的准备性，如果这个不足以让你兴奋，因为在这个教程的第一次测试，你想要看到一些结果;</p>

<p>测试你的App最精确的方式是用真机，添加一些地理围栏并且进行走路或者驾驶汽车测试，然而，现在做这些有些不明智，因为你不能去验证打印的日志信息当用真机改变了地理位置之后，另外，在你提交一个大头针之前，它不能很好的保证App的工作。</p>

<p>幸运的是，这里有一个更容易的方式去做这个，你不用离开你舒适的家。</p>

<p>Xcode允许你包含一个WayPoint文件在你工程中，你能用Monique去测试地点位置。很幸运吧，你在你工程中导入这个文件即可。</p>

<p>打开<code>TestLocations.gpx</code>这个文件，检查下这个内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0"?&gt;
</span><span class='line'>&lt;gpx version="1.1" creator="Xcode"&gt;
</span><span class='line'>  &lt;wpt lat="37.422" lon="-122.084058"&gt;
</span><span class='line'>    &lt;name&gt;Google&lt;/name&gt;
</span><span class='line'>  &lt;/wpt&gt;
</span><span class='line'>  &lt;wpt lat="37.3270145" lon="-122.0310273"&gt;
</span><span class='line'>    &lt;name&gt;Apple&lt;/name&gt;
</span><span class='line'>  &lt;/wpt&gt;
</span><span class='line'>&lt;/gpx&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个GPX文件一个XML格式的，包含两个waypoints:<code>Google’s Googleplex in Mountain View and Apple’s Headquarters in Cupertino.</code></p>

<p>用模拟器运行工程，当App加载这Main View Controller时，回到Xcode,在Debug bar中选中Locationt图标，选择<code>TestLocations</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/Screen-Shot-2015-02-02-at-9.04.37-pm.png" alt="2" /></p>

<p>回到App中，点击导航栏上的左上角的Zoom按钮，定位当前位置，一旦你放大这个区域，你将会看到定位点在Google 像素点和 Apple像素点 来回移动。</p>

<p>添加两个地理围栏去测试这个App,Apple坐标和Google坐标，（如果之前你添加过其他的地理围栏，请先删除之前的，再开始）</p>

<p>为了测试这些地点，添加具体细节如下:</p>

<ul>
<li>Google:Radius: 1000m, Message: “Say Bye to Google!”, Notify on Exit</li>
<li>Apple:Radius: 1000m, Message: “Say Hi to Apple!”, Notify on Entry</li>
</ul>


<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/Geo2Fences-281x500.png" alt="1" /></p>

<p>一旦你添加了地理围栏信息，你将会看到每次当坐标点进入或者离开地理围栏的时候，控制台都会打印日志信息，如果你按下home键或者锁屏让App进入到后台，你将会看到日志信息每次都会打印，现在你可以很显然的验证之前的判断</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/GeofenceTriggered.png" alt="1" /></p>

<h2>用通知来响应地理围栏事件</h2>

<p>你已经有了很大的进步，当你的设备通过这个地理围栏的时候，你可以发送一个通知提示用户。准备好做下这个操作</p>

<p>为了获得通知消息，你可以通过触发<code>CLCircularRegion</code>来获得，你需要获取一个地理围栏信息从<code>NSUserDefaults</code>存储的数据中，在已经注册的地理围栏中，你可以用这个唯一的<code>identifier</code>去找到正确的<code>CLCircularRegion</code>。</p>

<p>在AppDelegate.swift中，添加下面的帮助方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func note(fromRegionIdentifier identifier: String) -&gt; String? {
</span><span class='line'>  let savedItems = UserDefaults.standard.array(forKey: PreferencesKeys.savedItems) as? [NSData]
</span><span class='line'>  let geotifications = savedItems?.map { NSKeyedUnarchiver.unarchiveObject(with: $0 as Data) as? Geotification }
</span><span class='line'>  let index = geotifications?.index { $0?.identifier == identifier }
</span><span class='line'>  return index != nil ? geotifications?[index!]?.note : nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法会从持久化的内存中找到地理围栏的消息，仅仅靠<code>identifier</code>，就会返回地理围栏的消息</p>

<p>在<code>application(_:didFinishLaunchingWithOptions:)</code>添加如下方法，去注册一个通知:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.sound, .alert, .badge], categories: nil))
</span><span class='line'>UIApplication.shared.cancelAllLocalNotifications()</span></code></pre></td></tr></table></div></figure>


<p>你添加的提示权限是为了确保这个App能否发送通知</p>

<p>现在，替换<code>handleRegionEvent(_:)</code>的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func handleEvent(forRegion region: CLRegion!) {
</span><span class='line'>  // Show an alert if application is active
</span><span class='line'>  if UIApplication.shared.applicationState == .active {
</span><span class='line'>    guard let message = note(fromRegionIdentifier: region.identifier) else { return }
</span><span class='line'>    window?.rootViewController?.showAlert(withTitle: nil, message: message)
</span><span class='line'>  } else {
</span><span class='line'>    // Otherwise present a local notification
</span><span class='line'>    let notification = UILocalNotification()
</span><span class='line'>    notification.alertBody = note(fromRegionIdentifier: region.identifier)
</span><span class='line'>    notification.soundName = "Default"
</span><span class='line'>    UIApplication.shared.presentLocalNotificationNow(notification)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当这个App激活的时候，出现主界面的时候，将会弹出一个alert提示信息</p>

<p>编译运行工程，当坐标点经过你添加的地理围栏的时候，你的地理围栏事件将会被触发，将会受到一个提示信息，并且展示出来:</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/GeoSayByeToGoogle-281x500.png" alt="1" /></p>

<p>按一下home按钮，使得App进入后台模式，你依然能够通过地理围栏的事件信号定期收到通知信息</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/09/IMG_2239-281x500.png" alt="1" /></p>

<p> 现在，你已经有完整的功能，定位提示功能在你的App中，你可以添加其他的大头针，然后去到你添加坐标的地方测试~</p>

<h2>最终工程</h2>

<p>最后的工程你可以在这里<a href="https://koenig-media.raywenderlich.com/uploads/2016/09/Geotify-Final-1.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MapKit教程:起步]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/15/mapkitjiao-cheng-qi-bu/"/>
    <updated>2016-12-15T15:02:58+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/15/mapkitjiao-cheng-qi-bu</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/maps/">MapKit</a>在ios开发中真的是很棒的API,它能很容易的展示地图和位置坐标，定位当前位置，可以路线规划甚至可以自定义覆盖物在地图上面</p>

<!--more-->


<p>在这个教程中，你将要创建一个app，在指定的地点能够放大缩小，并且可以设置大头针，支持点击操作，显示详情信息。</p>

<p>根据路线规划可以选择驾驶，步行等方式去往目的地。你的App将会解析json数据从服务器。</p>

<p>在这个过程中，你将会学会如何去添加一个MapKit在你的app中，放大或者缩小</p>

<h2>Getting Started</h2>

<p>在Xcode中新建一个工程，命名为: HonoluluArtMapDemo;</p>

<p>然后打开ViewController中，在顶部引入 地图框架
<code>import MapKit</code></p>

<p>然后手动创建一个mapView,代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> func initMap() -&gt; Void {
</span><span class='line'>        mapView = MKMapView(frame: CGRect(x: 0, y: 0, width: screenWidth, height: screenHeight))
</span><span class='line'>        self.view.addSubview(mapView)
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>


<h2>设置可见区域</h2>

<p>在顶部设置一个可见区域</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// set initial location in Honolulu
</span><span class='line'>let initialLocation = CLLocation(latitude: 21.282778, longitude: -157.829444)</span></code></pre></td></tr></table></div></figure>


<p>你将要使用这个坐标去设置地图在地点Honolulu的位置。</p>

<p>当你尝试去告诉地图去显示什么的时候，你不能仅仅提供一个经度和纬度，对于定位中心点这个已经足够了，但是你还需要制定一个范围 region 去显示半径。</p>

<p>增加一个辅助方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let regionRadius: CLLocationDistance = 1000
</span><span class='line'>func centerMapOnLocation(location: CLLocation) {
</span><span class='line'>  let coordinateRegion = MKCoordinateRegionMakeWithDistance(location.coordinate, 
</span><span class='line'>    regionRadius * 2.0, regionRadius * 2.0)
</span><span class='line'>  mapView.setRegion(coordinateRegion, animated: true)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在<code>ViewDidload</code>中，添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>initMap()
</span><span class='line'>centerMapOnLocation(initialLocation)</span></code></pre></td></tr></table></div></figure>


<h3>运行测试</h3>

<p>现在运行你的app,应该能看到一个地图，并且坐标是在 <code>Honolulu</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run2.png" alt="1" /></p>

<h2>获取Artworks Data</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/03/HonoluluArtResources.zip">HonoluluArtResources.zip</a>是服务器上的json文件，下载解压后有两个文件：Public.json和JSON.swift.你将会用JSON.swift去解析Public.json</p>

<p>把这两个文件拖拽到你的工程中，确保<code>Destination: Copy items if needed</code>并且<code>Add to targets: HonoluluArt</code>是选择状态。</p>

<h2>新建一个Artwork.swift 模型类</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import UIKit
</span><span class='line'>import MapKit
</span><span class='line'>
</span><span class='line'>class Artwork: NSObject ,MKAnnotation {
</span><span class='line'>    public var title: String?
</span><span class='line'>    
</span><span class='line'>    let locationName: String
</span><span class='line'>    let discipline: String
</span><span class='line'>    let coordinate: CLLocationCoordinate2D
</span><span class='line'>    
</span><span class='line'>    init(title: String, locationName: String, discipline: String, coordinate: CLLocationCoordinate2D) {
</span><span class='line'>        self.title = title
</span><span class='line'>        self.locationName = locationName
</span><span class='line'>        self.discipline = discipline
</span><span class='line'>        self.coordinate = coordinate
</span><span class='line'>        
</span><span class='line'>        super.init()
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    public var subtitle: String? {
</span><span class='line'>        return locationName
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>在这个模型类中，定义了标题和子标题，坐标和详细描述，并且实现了MKAnnotation协议。该协议中有两个属性必须实现:title 和 subtitle。</p>

<p>OK，这些属性title,locationName和coordinate属性将要被用于MKAnnotation上，但是<code>discipline</code>这个属性是做什么的呢？在这个教程中，你将会找到答案</p>

<p>接下来，在<code>ViewController</code>的 <code>ViewDiDload</code>方法中，加入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// show artwork on map
</span><span class='line'>let artwork = Artwork(title: "King David Kalakaua",
</span><span class='line'>  locationName: "Waikiki Gateway Park", 
</span><span class='line'>  discipline: "Sculpture",
</span><span class='line'>  coordinate: CLLocationCoordinate2D(latitude: 21.283921, longitude: -157.831661))
</span><span class='line'> 
</span><span class='line'>mapView.addAnnotation(artwork)</span></code></pre></td></tr></table></div></figure>


<p>创建了一个Artwork的对象，作为一个annotation加入到mapView 中。这个mapView有 addAnnotaion方法。</p>

<p>OK，接下来你需要展示这个annotaion在map view中，为了实现这个，你必须实现MKMapViewDelegate协议 <code>MKPinAnnotationView</code>该协议负责显示大头针annotation的</p>

<p>代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>import MapKit
</span><span class='line'> 
</span><span class='line'>extension ViewController: MKMapViewDelegate {
</span><span class='line'> 
</span><span class='line'>  // 1
</span><span class='line'>  func mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! {
</span><span class='line'>    if let annotation = annotation as? Artwork {
</span><span class='line'>      let identifier = "pin"
</span><span class='line'>      var view: MKPinAnnotationView
</span><span class='line'>      if let dequeuedView = mapView.dequeueReusableAnnotationViewWithIdentifier(identifier)
</span><span class='line'>        as? MKPinAnnotationView { // 2
</span><span class='line'>        dequeuedView.annotation = annotation
</span><span class='line'>        view = dequeuedView
</span><span class='line'>      } else {
</span><span class='line'>        // 3
</span><span class='line'>        view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier)
</span><span class='line'>        view.canShowCallout = true
</span><span class='line'>        view.calloutOffset = CGPoint(x: -5, y: 5)
</span><span class='line'>        view.rightCalloutAccessoryView = UIButton.buttonWithType(.DetailDisclosure) as! UIView
</span><span class='line'>      }
</span><span class='line'>      return view
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这些代码并不复杂</p>

<ol>
<li><code>mapView(_:viewForAnnotation:)</code>是一个方法，每一个annotation都会调用去添加到mapView中，就像tableview中的<code>(_:cellForRowAtIndexPath:)</code>，每次都会返回一个View为每一个annotation</li>
<li>和<code>tableview</code>的'tableView(_:cellForRowAtIndexPath:)&lsquo;方法类似，当一些区域滑出屏幕外面的时候，map View也会返回一些重用的annotation View 的视图，所以这个代码第一次检查reusable annotation 是否存在，如果不存在，创建一个新的</li>
<li>如果<code>MKAnnotationView</code>可以从缓存池子中获取到，则用Artwork的title和subtitle属性去设置它，并且决定显示callout，可以支持点击的功能-当点击这个pin大头针的时候会出现一个气泡效果</li>
</ol>


<p>当然，你同样要设置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mapView.delegate = self</span></code></pre></td></tr></table></div></figure>


<p>这样代理方法才会被调用到。</p>

<p>好了，运行程序：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run32-174x320.png" alt="2" /></p>

<p><code>mapView(_:viewForAnnotation:)</code>方法中，在弹出的气泡中，右边有一个详情按钮，可以设置点击它的处理事件，你可以弹出一个alert框，或者调到一个详情页面，
在这个教程中：当用户点击了这个按钮之后，我们弹出Maps的app,完成驾车/步行 等导航路线的功能，这很酷的!</p>

<h2>加载Maps App</h2>

<p>为了提高用户体验，打开<code>Artwork.swift</code>，并且添加如下代码，导入 AddressBook(地址薄)框架</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import AddressBook</span></code></pre></td></tr></table></div></figure>


<p>这里添加了一个<code>AddressBook</code>框架，你可能会问，这个地址簿框架是做什么的，和Map有什么关系呢？well,它包含了一些字典的键，比如<code>kABPersonAddressStreetKey</code>,当你设置一些地址或者城市或者州 的地址坐标时会用到它。</p>

<p>下一步，添加下面的帮助方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// annotation callout info button opens this mapItem in Maps app
</span><span class='line'>func mapItem() -&gt; MKMapItem {
</span><span class='line'>  let addressDictionary = [String(kABPersonAddressStreetKey): subtitle]
</span><span class='line'>  let placemark = MKPlacemark(coordinate: coordinate, addressDictionary: addressDictionary)
</span><span class='line'> 
</span><span class='line'>  let mapItem = MKMapItem(placemark: placemark)
</span><span class='line'>  mapItem.name = title
</span><span class='line'> 
</span><span class='line'>  return mapItem
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里你从一个<code>MKPlacemark</code>中创建了一个<code>MKMapItem</code>，这个Maps app是可以从<code>MKMapItem</code>中获取到并且展示出来</p>

<p>下一步，你必须告诉MapKit当你点击 callout button 的时候，你要做什么</p>

<p>打开ViewController,添加<code>MKMapViewDelegate</code>的另外一个协议方法:<code>func mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!,
    calloutAccessoryControlTapped control: UIControl!)</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> func mapView(mapView: MKMapView!, annotationView view: MKAnnotationView!, 
</span><span class='line'>    calloutAccessoryControlTapped control: UIControl!) {
</span><span class='line'>  let location = view.annotation as! Artwork
</span><span class='line'>  let launchOptions = [MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeDriving]
</span><span class='line'>  location.mapItem().openInMapsWithLaunchOptions(launchOptions)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户点击地图上的大头针，弹出一个气泡视图，然后点击气泡视图上的info button,当用户点击这个info button的时候，<code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>该代理方法被调用</p>

<p>在这个方法中，你获取到Artwork对象，然后通过创建一个关联的<code>MKMapItem</code>，然后调用mapItem的<code>openInMapsWithLaunchOptions</code>方法去加载一个 <code>Maps app</code></p>

<p>注意，你传递了一个字典给这个方法，这里允许你去指定几个不同的选项，这里的<code>DirectionModeKeys</code>设置成了<code>Driving</code>，这个就是显示的自驾模式，从你的当前定位地点到这个大头针的位置，当然，你可以设置其他的选项，比如walking,bus等模式。</p>

<p>我建议你通过传递在字典参数中传递其他几个不同的选项，看看展现的效果，你可以去查看<code>MKMapItem</code>类，这个类同事允许你传递多了可选项参数</p>

<p>在你运行程序之后，最后在xcode中设置一下你的坐标，打开<code>Product\Scheme\Edit Scheme</code>,然后选择<code>Run</code>,打开<code>Options</code>标签，选择<code>Core Location: Allow Location Simulation</code>,选择<code>Honolulu</code></p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2014/12/defaultUserLocation-480x232.png" alt="1" /></p>

<p>好了，运行程序，你将会看到一个地图，点击地图上的大头针，然后点击info button,将会加载一个 Maps App</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run4b-174x320.png" alt="1" /></p>

<p>如果你也像我一样打开了地图，恭喜你！</p>

<h2>解析JSon数据并且转化成Artwork对象</h2>

<p>现在你知道如何在地图上展示artwork,怎嘛一股脑加载一个Maps app通过点击大头针的 callout info button,接下来我们介绍如何解析数据集。之后你可以从本地的地图区域中搜索数据。</p>

<p>首先，找到<code>JSON.swift</code>和文件：<code>PublicArt.json.</code>。<code>JSON.swift</code>包含了很好的解析json数据的API,提提供了对每个JSON value数据的转化。</p>

<p>把这两个文件拖入到工程中，在<code>Artwork.swift</code>添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func fromJSON(json: [JSONValue]) -&gt; Artwork? {
</span><span class='line'>  // 1
</span><span class='line'>  var title: String
</span><span class='line'>  if let titleOrNil = json[16].string {
</span><span class='line'>    title = titleOrNil
</span><span class='line'>  } else {
</span><span class='line'>    title = ""
</span><span class='line'>  }
</span><span class='line'>  let locationName = json[12].string
</span><span class='line'>  let discipline = json[15].string
</span><span class='line'> 
</span><span class='line'>  // 2
</span><span class='line'>  let latitude = (json[18].string! as NSString).doubleValue
</span><span class='line'>  let longitude = (json[19].string! as NSString).doubleValue
</span><span class='line'>  let coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
</span><span class='line'> 
</span><span class='line'>  // 3
</span><span class='line'>  return Artwork(title: title, locationName: locationName!, discipline: discipline!, coordinate: coordinate)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码解析:</p>

<ol>
<li><code>fromJSON‘s</code>方法将会从一个数组中返回一个Artwork对象，如果你传递一个数组的元素，你将会看到title, locationName等字段，在这个方法中都有指定的索引来获取数据，这<code>title</code>对某些artwork来说又能是空的(nil).</li>
<li>转换经纬度为double</li>
<li>返回artwork对象</li>
</ol>


<p>返回的json数据大概是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[ 55, "8492E480-43E9-4683-927F-0E82F3E1A024", 55, 1340413921, "436621", 1340413921, "436621", "{\n}", "Sean Browne",
</span><span class='line'>"Gift of the Oahu Kanyaku Imin Centennial Committee", "1989", "Large than life-size bronze figure of King David Kalakaua
</span><span class='line'>mounted on a granite pedestal. Located at Waikiki Gateway Park.", "Waikiki Gateway Park", 
</span><span class='line'>"http://hiculturearts.pastperfect-online.com/34250images/002/199103-3.JPG", "1991.03", "Sculpture", "King David 
</span><span class='line'>Kalakaua", "Full", "21.283921", "-157.831661", [ null, "21.283921", "-157.831661", null, false ], null ]</span></code></pre></td></tr></table></div></figure>


<p>在<code>ViewController.swift</code>中调用<code>fromJSON(_:)</code>方法，然后添加一个数组去存储从数据集中读到的json数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var artworks = [Artwork]()</span></code></pre></td></tr></table></div></figure>


<p>然后，添加下面的help方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func loadInitialData() {
</span><span class='line'>  // 1
</span><span class='line'>  let fileName = NSBundle.mainBundle().pathForResource("PublicArt", ofType: "json");
</span><span class='line'>  var readError : NSError?
</span><span class='line'>  var data: NSData = NSData(contentsOfFile: fileName!, options: NSDataReadingOptions(0),
</span><span class='line'>    error: &readError)!
</span><span class='line'> 
</span><span class='line'>  // 2
</span><span class='line'>  var error: NSError?
</span><span class='line'>  let jsonObject: AnyObject! = NSJSONSerialization.JSONObjectWithData(data, 
</span><span class='line'>    options: NSJSONReadingOptions(0), error: &error)
</span><span class='line'> 
</span><span class='line'>  // 3
</span><span class='line'>  if let jsonObject = jsonObject as? [String: AnyObject] where error == nil,
</span><span class='line'>  // 4
</span><span class='line'>  let jsonData = JSONValue.fromObject(jsonObject)?["data"]?.array {
</span><span class='line'>    for artworkJSON in jsonData {
</span><span class='line'>      if let artworkJSON = artworkJSON.array,
</span><span class='line'>      // 5
</span><span class='line'>      artwork = Artwork.fromJSON(artworkJSON) {
</span><span class='line'>        artworks.append(artwork)
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>标注Artworks</h2>

<p>现在你已经有了一组artwork的数据集，现在你需要把它们加入到地图上。</p>

<p>在<code>ViewDidLoad</code>方法中，创建<code>initialLocation</code>,然后设置map的中心点，调用<code>loadInitialData()</code>和<code>mapView.addAnnotations(artworks):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>loadInitialData()
</span><span class='line'>mapView.addAnnotations(artworks)</span></code></pre></td></tr></table></div></figure>


<p>删除之前创建的<code>King David Kalakaua</code>地图注解 数据的代码，你现在不需要它们了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//    let artwork = Artwork(title: "King David Kalakaua", locationName: "Waikiki Gateway Park",
</span><span class='line'>//      discipline: "Sculpture", coordinate: CLLocationCoordinate2D(latitude: 21.283921, longitude: -157.831661))
</span><span class='line'>//    mapView.addAnnotation(artwork)</span></code></pre></td></tr></table></div></figure>


<p>编译运行程序，你的app可以看到很多的大头针</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/03/run5a1-174x320.png" alt="2" /></p>

<h2>为大头针设置不同的颜色</h2>

<p>还记的在artwork中的<code>discipline</code>属性吗？
它的值像<code>Sculpture, Plaque, Mural, Monument, other</code></p>

<p>在<code>Artwork.swift</code>中添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// pinColor for disciplines: Sculpture, Plaque, Mural, Monument, other
</span><span class='line'>func pinColor() -&gt; UIColor  {
</span><span class='line'>        switch discipline {
</span><span class='line'>        case "Sculpture", "Plaque":
</span><span class='line'>            return UIColor.red
</span><span class='line'>        case "Mural", "Monument":
</span><span class='line'>            return UIColor.purple
</span><span class='line'>        default:
</span><span class='line'>            return UIColor.green
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>然后在ViewController中找到<code>mapView(_:viewForAnnotation:)</code>代码方法，设置pinColor属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>view.pinTintColor = annotation.pinColor()
</span></code></pre></td></tr></table></div></figure>


<h2>使用定位权限</h2>

<p>想要获取定位服务，首先要导入 <code>Corelocation</code>框架</p>

<p>在ViewController中加入下面代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// MARK: - location manager to authorize user location for Maps app
</span><span class='line'>var locationManager = CLLocationManager()
</span><span class='line'>func checkLocationAuthorizationStatus() {
</span><span class='line'>  if CLLocationManager.authorizationStatus() == .AuthorizedWhenInUse {
</span><span class='line'>    mapView.showsUserLocation = true
</span><span class='line'>  } else {
</span><span class='line'>    locationManager.requestWhenInUseAuthorization()
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>override func viewDidAppear(animated: Bool) {
</span><span class='line'>  super.viewDidAppear(animated)
</span><span class='line'>  checkLocationAuthorizationStatus()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>在info.plist中需要加入权限设置</h2>

<p>这里有几个权限设置你需要添加，你不加入的话，你的程序不会崩溃，但是你的locationManager’s的请求将会无效。为了让其工作良好，你必须添加<code>NSLocationWhenInUseUsageDescription</code>在你的app's的<code>Information Property Lis</code>,设置它的类型是string,值为一个消息，这个消息解释了为什么用户需要允许app访问他们的位置信息。</p>

<p>打开 <code>Info.plist</code>，点开左边的小三角
<img src="https://koenig-media.raywenderlich.com/uploads/2015/01/Infoplist-480x190.png" alt="1" /></p>

<p>最好再添加两个选线 Privacy 开头的和定位信息有关：
三个权限设置如下:</p>

<ol>
<li>Privacy - Location When In Use Usage Description</li>
<li>Privacy - Location Usage Description</li>
<li>Privacy - Location Always Usage Description</li>
</ol>


<h2>Final project</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/03/HonoluluArt-Swift3.zip">swift3版本的工程</a>下载</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手动挡汽车如何刹车]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-qi-che-ru-he-cha-che/"/>
    <updated>2016-12-15T10:46:18+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-qi-che-ru-he-cha-che</id>
    <content type="html"><![CDATA[<p>动力的传输路径:发动机－>离合器－>变速箱－>差速器－>半轴－>轮毂（轮胎）</p>

<!--more-->


<h2>变速箱的作用</h2>

<p>总体上，变速箱里的齿轮分为主动齿和从动齿两种。主动齿接受从发动机输出的转速（此说发不准确但便于理解）带动从动齿，然后从动齿再输出给后面部件让汽车行使。在发动机转速不变的情况下，调节不同齿数（速比）的从动齿，就可以让汽车以不同的速度行使。这就是驾驶过程中的换档。低速的时候用速比小的齿轮（既低档），高速时用速比高的齿轮（既高档）。当然，每辆车都有空档，既主动齿空转，不将动力传输给从动齿。所以，我们在停车时如果发动机不熄火就必须放空档</p>

<h3>离合器的作用</h3>

<p>在汽车行使过程中，发动机保持运转。主动齿接受动力传递给从动齿是一个连续不间断的过程。此时，主从齿轮间相互咬合的力非常大（你可以想象一辆汽车的重量至少在一吨以上），没办法更换从动齿调解速度，必须将发动机熄火（既停车）才能更换。很麻烦而且不具可操作性（如果直接换高速比从动齿，扭矩太小无法起步，类似于杠杆原理，速度必须逐渐的阶梯式的增加）。所以，人们就想，能不能有办法在需要换档时，暂时脱离发动机的动力输出呢？于是，就发明了离合器。离合器，顾名思义，是分离和合拢发动机输出动力的器件。就目前最常用的离合器，简单的说，分为主动盘和从动盘两大部分。主动盘（既发动机飞轮）与发动机曲轴相连，从动盘通过花键（花键可伸缩）与变速箱主动齿相连。从动盘依靠弹簧紧紧的压在飞轮上接受发动机动力传递给变速箱主动齿。我们在驾驶过程中踩离合器踏板，其实是通过一套杠杆系统作用在从动盘上，使它克服弹簧的压力脱离飞轮，从而实现脱离发动机动力。松开踏板则从动盘在弹簧的作用下又压紧飞轮继续传递动力</p>

<h3>刹车</h3>

<p>我们踩下刹车踏板其实是将力通过一套液压系统（或气压:气刹车）传递给刹车片，刹车片紧紧的抱住刹车盘（蝶刹）或轮毂（毂刹）从而实现汽车的制动。</p>

<p>有两种方法可以脱离发动机的动力：放空挡或者踩下离合器踏板</p>

<h2>为什么手动挡踩刹车会熄火？</h2>

<p>汽车从行使中停车（当然变速箱没有放空档），当踩下刹车时，制动力从轮毂通过动力传递路径反向传递到发动机，而发动机正在正常工作，保持运转。这显然是一对矛盾，最后，发动机败给了制动力被活活的憋熄火了（同时这也是一种保护功能，要不然会有某个部件断裂或解题的）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>所以，你该知道，在车速较快时，踩刹车，不踩离合器，没问题，因为车速快，发动机能保持车速。
</span><span class='line'>
</span><span class='line'>当车快停止时，请踩下离合器，分离发动机动力，免得给发动机制造麻烦。然后将变速箱放空挡，可以松开离合器踏板</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手动挡驾驶技巧1]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-jia-shi-ji-qiao-1/"/>
    <updated>2016-12-15T10:31:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-jia-shi-ji-qiao-1</id>
    <content type="html"><![CDATA[<p>手动挡车不同于自动挡，离合器、刹车、油门要配合好才可以稳稳当当的开好车，手动挡车驾驶虽然比自动挡繁琐些，但也有自身优点，开常了便会驾轻就熟的。下面就我自己的一点经验给大家说一下</p>

<!--more-->


<h3>1</h3>

<p>起步技巧:不同于自动挡车，手动挡车起步时，左脚把离合器踩到底，挂一档，右脚虚空着放到油门上方，慢抬离合的同时松手刹同时轻踩油门，踩油门后踩离合器的左脚慢慢完全抬起，车辆平稳起步。但遇到高坡起步时，左脚离合器要抬到恰到好处，即车辆处于“半联动”状态，这时即使松了手刹，松了刹车，车辆也不会溜车。然后紧跟上踩油门，慢抬离合器，松手刹，车辆起步</p>

<h3>2</h3>

<p>起步这一关键步骤完成后，紧接着换二档时，离合器要快踩慢抬，否则车辆闯动，很不平稳。换三档时离合器仍要快踩慢抬，到四档以后就无关紧要了</p>

<h3>3</h3>

<p>当车辆快到信号灯前时，要提前判断，如果离信号灯还有二三百米，绿灯闪烁，就可以摘个空挡，滑行到路口，等红灯。这样不仅可以省油，还不用急急忙忙的猛踩刹车</p>

<h3>4</h3>

<p>在下长而陡的坡道时，千万不要空挡滑行，别以为能省点油，其实省不了多少。空挡时失去了发动机的制动减速功能，万一遇到紧急情况，光靠刹车很难快速减速，有时甚至能导致刹车失灵</p>

<h3>5</h3>

<p>在雨雪天行车，需要特别注意，不仅要放慢车速，还要提前做好判断，特别是到路口，必须提前减速，否则到跟前会刹不住车。谨记的是，减速时要“点刹”，防止车辆侧滑，虽然很多车都有ABS EBD之类的，遇到紧急情况还是靠驾驶员的提前准备和判断</p>

<h3>6</h3>

<p>当我们通过积水较深的路段时，在不知深浅的情况下最好绕行，如果非走不可，那一定记住，挂上低档，踩住油门不要松，一定要跟上油门，不能换挡，轰着油门一气通过。如果换挡，排气管进水就麻烦了</p>

<h3>7</h3>

<p>换挡的技巧：以1.5升排量的家庭用车在平路上行走为例，最理想的换挡时机大致如下</p>

<ul>
<li>1挡起步：约1500rpm</li>
<li>1挡转2挡：20km/h</li>
<li>2挡转3挡：30km/h</li>
<li>3挡转4挡：40km/h</li>
<li>4挡转5挡：50km/h</li>
</ul>


<p>转入抵挡也是一样，不要等转速过低，车辆几乎没有力气时才减挡，这样会增加引擎负担。要车辆保持一定的驱动力和速度，减少引擎负担，及早减挡是必要的，特别是上坡、车辆慢速行驶和负重行驶的时候</p>

<p>一般来说，最佳的减挡时间大致如下</p>

<ul>
<li>5挡换4挡：55km/h</li>
<li>4挡换3挡：45km/h</li>
<li>3挡换2挡：35km/h</li>
<li>2挡换1挡：25km/h</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[手动挡驾驶技巧-侧方停车]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-jia-shi-ji-qiao-ce-fang-ting-che/"/>
    <updated>2016-12-15T09:28:01+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/15/shou-dong-dang-jia-shi-ji-qiao-ce-fang-ting-che</id>
    <content type="html"><![CDATA[<p>基本知识：A柱在发动机舱和驾驶舱之间，左右后视镜的上方，会遮挡你一部分的转弯视界，尤其是左转弯；B柱在驾驶舱的前座和后座之间，就是两侧两扇门之间的那根纵向杠子，从车顶延伸到车底部，从内侧看，安全带就在B柱上；C柱在后座头枕的两侧。A柱、B柱与C柱都是支撑车辆结构强度的主要部分</p>

<!--more-->


<p><img src="http://s3.sinaimg.cn/mw690/001ysyNNzy6NsZU9llwa2&amp;690" alt="1" /></p>

<p> 侧方位可以说是比较常见的一种车位，也是比较容易停的一种车位。唯一的问题就是，这种停车通常都在道路两边，停车时必须“速战速决”，要不然会被后方车辆催促</p>

<h3>判断车位大小</h3>

<p> 想要将车停进所谓的“车位”，首先要做的就是车位足够大，如果是侧方停车的路边车位，我们建议选择至少要比车长再多出至少一米的车位才算保险，当然如果你自认为技术过硬，小一点也无妨</p>

<p> <img src="http://img.autohome.com.cn/upload/spec/5616/w_20120312210521986118.jpg" alt="1" />
 对于判断车位大小，这主要是凭感觉，我们也很难给出严谨的方法，不过这也并非完全没有技巧可循，当驾驶员的视线与机器盖右前角所形成的直线在右前车辆的左后轮之后，相对来说前端就是比较保险的</p>

<p> <img src="http://s11.sinaimg.cn/mw690/001ysyNNzy6NvBv8KHo8a&amp;690" alt="1" /></p>

<p>  同时转头看自己车辆的右后窗中，如果露出的车辆面积不超过四分之一车身，基本上都是属于安全范围，当然下车观察也是非常提倡的。对比一下自己的车，下车多看几次就心中有数了</p>

<p>  <img src="http://s4.sinaimg.cn/mw690/001ysyNNzy6Nw4aOsV553&amp;690" alt="1" /></p>

<p>侧方位停车有三种比较实用的方法:后视镜倒车法、定点倒车法、摆斜倒车法</p>

<h1>后视镜倒车法</h1>

<p>之所以把这种方法叫做“后视镜倒车法”，是因为汽车后视镜在整个倒车过程中一直要用到，对汽车能否顺利倒进车位起着决定性因素。</p>

<h3>第一步</h3>

<p>先将车开过车位，判断该车位是否能够容得下自己的车。如果确定可以容得下，就将车往前开至与车位前车大致齐平的位置，两车横向相距约1米。然后调整右后视镜的角度，尽量往下调，直到能看到右侧车轮为止。接着就往右打满方向，开始倒车</p>

<p><img src="http://s12.sinaimg.cn/mw690/001ysyNNzy6NtErxDLB8b&amp;690" alt="1" /></p>

<blockquote><p><em>注意:</em>
1. 为了保护助力转向泵，这里所指的“打满方向”是先把方向打到头，然后稍微回撤一些</p>

<p>2.所指的“往左”、“往右”打方向都是以驾驶员视角为参照物</p>

<p>3.后视镜调节这一步不可忽略。但如果对自己车很熟悉，能够很准确的把握车辆与路肩的距离则可忽略这一步</p>

<p>4.以上是两车横向相距约1米。如果两车横向相距太近，例如30cm，就要晚一点向右打满方向，例如本车的后视镜与侧方前车的B柱在一条线上时再向右打满方向，见下面的方法二，这样就把倒车技术学活了，此时，本车的后轮已经在侧方前车的尾端附近。 30厘米是一个很近的距离，你从驾驶位看过去会觉得两台车就要蹭上了，其实还没有，这就需要多加练习来强化你对距离的感知（在车上看一下，再下车看一下，多多练习）</p></blockquote>

<h3>第二步</h3>

<p>车辆向后移动之后，视线立马从右后视镜移到左后视镜，注意观察左方来车和障碍物。在打满方向的情况下慢慢倒车，直至左侧后视镜能完全看到后车的车头时（这是一个非常重要的经验技巧，通常这个时候车身相对于车库的角度是最理想的，或者观察右后视镜，当自己的右边车身能完全挡住后面已停放好的那辆车时就要回正方向），这时回正方向继续往后倒。视线转到右后视镜，并通过右后视镜查看右侧情况</p>

<p><img src="http://s7.sinaimg.cn/mw690/001ysyNNzy6NtEDoKWy56&amp;690" alt="2" /></p>

<h3>第三步 回正倒车</h3>

<p>通过右侧后视镜，观察右后轮与路肩的距离，觉得可以时往左打满方向，然后尽可能让车靠近路肩，但又要保持足够距离让车身可以摆直</p>

<p><img src="http://img.autohome.com.cn/2012/3/12/12-22-47-57-737917601.jpg" alt="1" /></p>

<p>回正方向后一定不要着急反打，此时车尾还没有进入车位中，需要正直方向继续倒车，当左侧反光镜中观察左后车轮即将与后车左侧在一条直线上，或是右侧后视镜外侧与右前车的左后尾灯即将在一条线上时，车辆可以停止后退并且向左侧打满</p>

<p><img src="http://s15.sinaimg.cn/mw690/001ysyNNzy6NtEF1TXg7e&amp;690" alt="1" /></p>

<h3>第四步</h3>

<p>当车身差不多都进入车位后，车主要通过扭头方式或者倒车辅助系统判断与后车距离。当然，如果车位狭小的话，最好是找个帮手在车外观察和提示</p>

<p><img src="http://s9.sinaimg.cn/mw690/001ysyNNzy6NtEN3DiUe8&amp;690" alt="1" /></p>

<h3>第五步</h3>

<p>往右回正打方向，调整前后距离，就大功告成了
<img src="http://image.16888.com/upload/Images/2014/05/2014051902281434843_600.jpg" alt="1" /></p>

<p><em>注：以上是两车横向相距约1米，需要一段直线后倒，如果开始停车时两车横向相距太近，例如30cm，就没有直线后退的距离，需要快速把方向从最右打到最左（或停顿一下原地打方向盘），见下面的方法二。</em></p>

<h2>后视镜倒车要领总结</h2>

<ol>
<li>距离要尽可能接近1米(不能贴车太近，也不能离车太远)</li>
<li>倒车不要偷懒，后视镜一定要向下调节好，可以帮助精准倒车；</li>
<li>倒车过程中速度一定要控制好，缓慢进行；</li>
<li>发现车位失误无法倒进去时，不要原地多次细微调整，重新出来调整位置再倒一次</li>
<li>倒进去以后要调整好与前后车的距离，确保其他车辆可以出去，利己利人。</li>
</ol>


<h1>定点倒车法</h1>

<p>这种方法比较适用于汽车左方空间不大的侧方位停车，车辆外摆幅度相对没有那么大</p>

<h3>第一步</h3>

<p>先将车开过车位，判断该车位是否能够容得下自己的车。如果确定可以容得下，就将车往前开至与车位前车大致齐平的位置停车，两车横向相距约0.3～0.5米。 0.3米是一个很近的距离，你从驾驶位看过去会觉得两台车就要蹭上了，其实还没有，这就需要多加练习来强化你对距离的感知（在车上看一下，再下车看一下，多多练习）</p>

<p><img src="http://s1.sinaimg.cn/mw690/001ysyNNzy6Is66nRUQ80&amp;690" alt="1" />
此时要调节后视镜的角度——左侧后视镜保持正常水平，右侧后视镜要往下调，到能看到右侧车轮为止，这是为后面的倒车过程做的准备。此时还要留意后方行车道上是否有车尾随，如果有，应打开双闪灯示意后车暂时不要靠近</p>

<h3>第二步</h3>

<p>开始缓慢倒车，当车开到右反光镜与右侧车辆B柱在同一平行线时迅速向右打满方向，并继续缓慢倒车
<img src="http://s16.sinaimg.cn/mw690/001ysyNNzy6NtFAUpUX4f&amp;690" alt="2" /></p>

<h3>第三步</h3>

<p>当车辆倒到与前车成大约45°夹角时，方向盘打满方向，然后接着倒车。 掌握不好45度的范围？没关系，有一个简单的方法来判断：左侧后视镜能完全看到后车的车头时（这是一个非常重要的经验技巧，通常这个时候车身相对于车库的角度是最理想的），或者观察右后视镜，当自己的右边车身能完全挡住后面已停放好的那辆车时就要向左打满方向</p>

<p>判断45°的方法:</p>

<ol>
<li>当你观察右侧后视镜的外侧与旁车B柱即将重叠</li>
<li>右后视镜，当自己的右边车身能完全挡住后面已停放好的那辆车</li>
<li>左侧后视镜能完全看到后车的车头时</li>
</ol>


<p><img src="http://s10.sinaimg.cn/mw690/001ysyNNzy6NtFNA1Khc9&amp;690" alt="1" /></p>

<h3>第四步</h3>

<p>也就是最后一步了。当车辆基本摆正时，回正方向盘，调节车辆前后距离，尽可能与前车、后车留出一段距离
<img src="http://s3.sinaimg.cn/mw690/001ysyNNzy6NtG8cEaSe2&amp;690" alt="1" /></p>

<h3>定点倒车要领总结</h3>

<ol>
<li>距离一定要把握好，它是决定倒车成功的关键因素</li>
<li>后视镜与右侧对准时记得向右打满方向</li>
<li>根据不同车型的体型不同，车主要懂得适当调节</li>
</ol>


<h1>斜摆倒车法</h1>

<h3>第一步</h3>

<p><img src="http://s11.sinaimg.cn/mw690/001ysyNNzy6NuOqP8zU9a&amp;690" alt="1" />
首先判断车位是否“合格”，如何可以的话，沿距离车位约0.5米的位置往前开，当车头到达前车中央的位置时，开始打方向（在车中看到自己车的A柱超过前车C柱后，如下图，向左打方向），让车朝远离车位的方向驶去</p>

<p><img src="http://s16.sinaimg.cn/mw690/001ysyNNzy6NwkO86iX8f&amp;690" alt="1" />
当车开到右反光镜(A柱)与右侧车辆B柱在同一平行线上时停车，这时车头两车横向相距约1米。自己的车与路边的车有40～45度的夹角</p>

<p><img src="http://s13.sinaimg.cn/mw690/001ysyNNzy6NtYyT5Pm2c&amp;690" alt="3" /></p>

<p>在车内看到的情况见下图（右反光镜(A柱)与右侧车辆B柱在同一平行线上）</p>

<p><img src="http://s16.sinaimg.cn/mw690/001ysyNNzy6NuONm1pZ6f&amp;690" alt="2" /></p>

<h3>第二步</h3>

<p>然后往右打满方向，并开始缓慢倒车。当看到右侧后视镜与前车的车尾部的后灯在一条直线（与路边垂直的直线）上时，开始向左回满方向，继续倒车
<img src="http://s13.sinaimg.cn/mw690/001ysyNNzy6NtYYe47W8c&amp;690" alt="2" /></p>

<h3>第三步</h3>

<p>当车辆倒到与前车成大约45°夹角时，方向盘向左打满方向，然后接着倒车。 掌握不好45度的范围？没关系，有一个简单的方法来判断：左侧后视镜能完全看到后车的车头时（这是一个非常重要的经验技巧，通常这个时候车身相对于车库的角度是最理想的），或者观察右后视镜，当自己的右边车身能完全挡住后面已停放好的那辆车时就要向左打满方向</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift3-GCD]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/12/14/swift3-gcd/"/>
    <updated>2016-12-14T16:05:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/12/14/swift3-gcd</id>
    <content type="html"><![CDATA[<p>在swift3中，<a href="https://developer.apple.com/reference/dispatch">GCD</a>的语法已经全面修改，变得更加swift化了。</p>

<!--more-->


<h2>DispatchQueue</h2>

<p>首先，dispatch的全局函数不再为下划线风格的名称了，它变成了更符合Swift风格的DispatchQueue的样子</p>

<h3>main thread</h3>

<p>同样的，你不在需要去用<code>dispatch_get_main_queue()</code>来获取主线程，而是<code>DispatchQueue.main</code>，那么要放到主线程的代码怎么执行呢？只需要在后面使用<code>.async{}</code>即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DispatchQueue.main.async { [weak self] in
</span><span class='line'>      your code runs in main thread
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>优先级</h2>

<p>我们知道，GCD的默认队列的优先级有四个:</p>

<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>


<p>现在swift3中正式更名为：</p>

<ul>
<li>.userInitialted</li>
<li>.default</li>
<li>.utility</li>
<li>.background</li>
</ul>


<p>当然，它们的对应关系也就是与顺序相同的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> DISPATCH_QUEUE_PRIORITY_HIGH:         .userInitiated
</span><span class='line'> DISPATCH_QUEUE_PRIORITY_DEFAULT:      .default
</span><span class='line'> DISPATCH_QUEUE_PRIORITY_LOW:          .utility
</span><span class='line'> DISPATCH_QUEUE_PRIORITY_BACKGROUND:   .background</span></code></pre></td></tr></table></div></figure>


<h2>获取一个队列</h2>

<p>我们使用<code>DispatchQueue.global()</code>获取一个系统的队列，这样的话获取的就是默认<code>.default</code>优先级的队列了，如果要获取其它优先级的队列，就使用<code>DispatchQueue.global(qos: .userInitiated)</code>,最后，我们使用<code>.async{}</code>来执行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DispatchQueue.global(qos: .userInitiated).async {
</span><span class='line'>            //your code here
</span><span class='line'>        }</span></code></pre></td></tr></table></div></figure>


<h2>创建一个队列</h2>

<p>直接用<code>DispatchQueue</code>的初始化来创建一个队列，最简单的方法就是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let queue = DispatchQueue(label: "myBackgroundQueue")</span></code></pre></td></tr></table></div></figure>


<p>复杂一点，你可以指定优先级以及队列类别:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let queue = DispatchQueue(label: "myBackgroundQueue", qos: .userInitiated, attributes: .concurrent)</span></code></pre></td></tr></table></div></figure>


<p>然后把代码放进去:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>queue.async {
</span><span class='line'>    print("aaa")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>队列组</h2>

<p>对于组，现在你可以使用这样的语法直接创建一个组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let group = DispatchGroup()</span></code></pre></td></tr></table></div></figure>


<p>使用如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let group = DispatchGroup()
</span><span class='line'> 
</span><span class='line'>let queue = DispatchQueue(label: "myBackgroundQueue")
</span><span class='line'> 
</span><span class='line'>queue.async(group:group) {
</span><span class='line'>    print("background working")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>那么，如果有多个并发队列在同一个组中，我们徐亚它们完成了再继续:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>group.wait()</span></code></pre></td></tr></table></div></figure>


<h2>延迟执行</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 3.0) {
</span><span class='line'>    print("after!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Carthage管理ios依赖]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai/"/>
    <updated>2016-11-28T15:55:02+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/28/shi-yong-carthageguan-li-iosyi-lai</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/Carthage/Carthage.git">Carthage</a>官网已经针对cocopods和carthage进行了详细的说明：</p>

<!--more-->


<p>首先，cocoaPods会直接创建和修改项目的workspace配置，一切都是为了便捷，我们只需要修改pod文件并不需要过多的关心其它事情，CocoaPods创建的也是高度集成的项目。而Carthage的特点是灵活，耦合度不高，集成时不需要集成相应的project,不需要创建workspace,而仅仅需要依赖打包好的framework文件。</p>

<p>其次，CocoaPods相对来说功能要比Carthage多很多，在国内由于墙的原因，我们都改成了淘宝的源来更新CocoaPods,相信我，如果你不翻墙，很多东西不能用，更新不下来，版本错误等一系列原因会让你不得不放弃一起看起来非常好用的第三方库。而Carthage似乎只需要从github上下载项目即可，配置更是简单，使用的项目项目干干净净，所有的第三方库就像苹果原生的framework一样美好，从此你不再需要担心CocoaPods的库用不了，不用花大量时间去修复用CocoaPods打包时出现的各种问题了，如果你用过CocoaPods，当你开始使用Carthage的时候，你会爱上这个工具的。</p>

<h2>安装使用Carthage</h2>

<p>假如你的电脑上已经安装了Homebrew,打开终端，输入如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew update
</span><span class='line'>
</span><span class='line'>$ brew install carthage</span></code></pre></td></tr></table></div></figure>


<p>如果你不喜欢使用终端，也可以从网站<code>https://github.com/Carthage/Carthage/releases</code>下载最新版的Carthage.pkg来更新。</p>

<p>现在，你已经安装好了Carthage,接下来就是在你的项目中使用carthage了：</p>

<ol>
<li>通过终端进入到项目所在的文件夹</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd ~/Path/Project</span></code></pre></td></tr></table></div></figure>


<p>后面的路径替换成你的项目所在的路径</p>

<ol>
<li>创建一个空的carthage文件：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ vim Cartfile</span></code></pre></td></tr></table></div></figure>


<p>此时在你的项目文件夹里会创建一个名为Cartfile的文件</p>

<ol>
<li>在Cartfile文件里输入</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>github "Alamofire/Alamofire" ~&gt; 3.0
</span><span class='line'>
</span><span class='line'>github "SwiftyJSON/SwiftyJSON"</span></code></pre></td></tr></table></div></figure>


<p>上面仅仅是举个栗子
，如果您是用命令行打开的，按下ESC,输入 :wq，保存关闭当前窗口</p>

<h3>版本的含义</h3>

<p>~> 3.0 表示使用版本3.0以上但是低于4.0的最新版本，如3.5，3.7&hellip;</p>

<p>== 3.0表示使用3.0版本</p>

<p><code>&gt;=</code> 3.0表示使用3.0或者更高的版本
如果你没有指明版本号，则会自动使用最新的版本</p>

<ol>
<li>在终端执行命令</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ carthage update --platform iOS</span></code></pre></td></tr></table></div></figure>


<p>carthage会为你下载和编译所需要的第三方库，当命令执行完毕，在你的项目文件夹中会创建一个名为Carthage的文件夹</p>

<p>在 ~/Carthage/Build/iOS里会出现xxx.framework文件已经为你创建好了</p>

<ol>
<li>现在打开你的项目，点击Project,选择target,点击<code>+</code>,将刚才生成的framework文件拖到<code>Linked frameworks and Binaries</code>里；</li>
</ol>


<p>同样也要把生成的framework拖到<code>Embedded Binaries</code>中</p>

<h2>开始使用</h2>

<p>如果你已经导入framework成功了，然后使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import Alamofire
</span><span class='line'>
</span><span class='line'>import SwiftyJSON</span></code></pre></td></tr></table></div></figure>


<p>Please enjoy it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP TCP 和HTTP]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http/"/>
    <updated>2016-11-22T10:04:46+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/22/ip-tcp-he-http</id>
    <content type="html"><![CDATA[<p>当app和服务器进行通信的额时候，大多数情况下，都是采用http协议。http最初是为web浏览器而定制的，如果在浏览器输入 <code>http://www.baidu.com</code>。浏览器就会通过http协议和baidu所对应的服务器进行通信。</p>

<!--more-->


<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Application Layer -- e.g. HTTP
</span><span class='line'>----
</span><span class='line'>Transport Layer -- e.g. TCP
</span><span class='line'>----
</span><span class='line'>Internet Layer -- e.g. IP
</span><span class='line'>----
</span><span class='line'>Link Layer -- e.g. IEEE 802.2</span></code></pre></td></tr></table></div></figure>


<p>所谓的<a href="https://en.wikipedia.org/wiki/OSI_model">OSI(Open Systems Interconnnection),开放式系统互联</a>模型定义了七层结构。本文会关注应用层(application layer)传输层(transport layer)和网络层(internet layer),他们分别代表了典型的HTTP的应用的HTTP,TCP,以及IP.在ip之下的是数据连接和物理层级，比如像Ethernet的实现之类的东西</p>

<p>如上文所述，我们只关注应用层，传输层和网络层部分，更确切的说，着重探讨一种特殊的混合模式：基于IP的TCP,以及基于TCP实现的HTTP.这就是我们每天使用的app的基本网络配置。</p>

<p>通过本文，希望大家能够对HTTP工作原理有一个细致的了解，知道一些常见的HTTP问题产生的原因，从而能在实践中尽量避免这些问题的发生。</p>

<p>其实在互联网上传递数据的方式并不只是HTTP一种，HTTP之所以被广泛使用的原因是其非常稳定，易用，即便是防火墙一般也是允许HTTP协议穿透的。</p>

<p>接下来，我们从最低的一层谈起，说说IP网络协议。</p>

<h3>IP网络协议(IP_Internet Protocol)</h3>

<p>TCP/IP 中的Ip是<a href="https://en.wikipedia.org/wiki/Internet_Protocol">网络协议(Internet Protocol)</a>的缩写。从字面意思便知，它是互联网众多协议的基础。</p>

<p>IP实现了分组交换网络，在协议下，机器被叫做主机(host)，IP协议明确了host之间的资料包（数据包）的传输方式。</p>

<p>所谓数据包是指一段二进制的数据，其中包含了发送源主机和目标主机的信息。IP网络负责源主机和目标主机之间的数据包传输。IP协议的特点是best effort(尽力服务，其目标是提供有效服务并尽力传输)。这意味着，在传输过程中，数据包可能会丢失，也有可能被重复传送导致目标主机收到多个同样的数据包</p>

<p>IP网络中的主机都配有自己的地址，被称为IP地址。每个数据包中都包含了源主机和目标主机的IP地址，IP协议负责路径计算，即IP数据包在网络中的传输时，数据包所经过的灭一个主机几点都会读取数据包中的目标主机地址信息，以便选择朝着什么地方传输数据包</p>

<p>今天，绝大多数的数据包仍旧是IPv4的，每一个IPV4的地址的长度是32位的，常见采用dotted-decimal(点分十进制)表示法，具体形式如下：198.51.100.42</p>

<p>新的IPv6标准也正在逐渐推广中。它有更大的地址空间：长度为128位，这使得数据包在网络中传输中传输时的寻址更容易一些。另外，由于有更多的地址可以分配，注入网络地址转换等问题也迎刃而解。IPv6的表示形式为:八组十六进制数以冒号分割，比如：2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p>

<h2>IP Header</h2>

<p>一个ip数据包通常包含header（报头信息）和payload（有效载荷）</p>

<p>payload中的内容即是要传输的真正信息，而header承载的是与传输数据有关的元数据(metadata)</p>

<h3>IPV4 Header</h3>

<p>ipv4的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IPv4 Header Format
</span><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |IHL        |DSCP            |ECN  |Total Length                                   |
</span><span class='line'> 4        32     |Identification                                |Flags   |Fragment Offset                       |
</span><span class='line'> 8        64     |Time To Live           |Protocol              |Header Checksum                                |
</span><span class='line'>12        96     |Source IP Address                                                                             |
</span><span class='line'>16       128     |Destination IP Address                                                                        |
</span><span class='line'>20       160     |Options (if IHL &gt; 5)                                                                          |</span></code></pre></td></tr></table></div></figure>


<p>header长度为20字节（不包含极少用到的可选信息）</p>

<p>header信息中最关键的是源和目标IP地址，除此之外，版本信息是4，代表ipv4.protocol(协议区)代表payload采用的传输协议。TCP的协议号是6.Total Length(总长度区)表明了header加payload整个数据包的大小</p>

<h3>Ipv6 Header</h3>

<p>ipv6的地址长度为128位，IPv6的header信息内容如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Offsets  Octet    0                       1                       2                       3
</span><span class='line'>Octet    Bit      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31|
</span><span class='line'> 0         0     |Version    |Traffic Class         |Flow Label                                                 |
</span><span class='line'> 4        32     |Payload Length                                |Next Header            |Hop Limit              |
</span><span class='line'> 8        64     |Source Address                                                                                |
</span><span class='line'>12        96     |                                                                                              |
</span><span class='line'>16       128     |                                                                                              |
</span><span class='line'>20       160     |                                                                                              |
</span><span class='line'>24       192     |Destination Address                                                                           |
</span><span class='line'>28       224     |                                                                                              |
</span><span class='line'>32       256     |                                                                                              |
</span><span class='line'>36       288     |                                                                                              |</span></code></pre></td></tr></table></div></figure>


<p>Ipv6 header采用固定长度40字节。经过多年来对Ipv4使用的总结，如今Ipv6的header信息简化了很多。</p>

<p>除了源和目标地址这种必备信息外，IPv6提供专门的next header区域来指明紧跟header的数据是什么。也就是说，Ipv6允许在数据包中将header链接起来，每一个被链接的Ipv6 header 都会有一个next header 字段，直到到达实际的payload数据，比如说，当next header的值为6(TCP的协议号)时，数据包的其它信息就是tcp协议要传输的数据</p>

<h2>Fragmentation(数据分片)</h2>

<p>由于底部链路层对所传输的数据帧有最大长度限制，所以有时候IPV4需要对所传数据包进行分片。具体表现为，如果数据包尺寸超过了索要经过的数据链路层的最大传输限制，路由就会对数据包进行分片，当分片数据到达目标主机后，可以根据分片信息进行数据重组。当然，数据发送源有权决定路由是否启用对传输数据包进行分片，加入所传输的数据超过了输送限制，又禁止了路由分片，发送源会收到<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>的数据帧超长报告信息</p>

<p>在Ipv6中，如果数据包超限制，路由会直接丢弃数据包并且向发送源回传ICMP6的数据帧超长报告信息。源和目标两端会基于这个特性进行<a href="https://en.wikipedia.org/wiki/Path_MTU">路径MTU发现</a>，以此寻找两端之间最大传输单元所在的路由，找到MTU路由后，仅当上层数据包的最小payload确实超过了MTU,IPV6才会进行分片传输，对于IPV6下的tCp来说，这不会造成什么问题。</p>

<h2>TCP-传输控制协议(Transmission Control Protocol)</h2>

<p>TCP层位于IP层之上，是最受欢迎的因特网通讯协议之一，人们通常用TCP/IP来泛指整个因特网协议族。</p>

<p>刚刚提到，IP协议允许两个主机之间传送单一的数据包，为了保证对所传送数据包达到尽力服务的目的，最终的传输结果可能是数据包乱序，重复甚至丢包。</p>

<p>TCP是基于IP 层的协议。但是TCP是可靠地，有序的，有错误检查机制的基于字节流传输的协议。这样当两个设备上的应用通过TCP来传递数据的时候，总能够保证目标接收方收到的数据的顺序和内容与发送方所发出的是一致的。TCP做的这些事看起来很平常，但是比起IP层的粗犷处理方式已经是显著的进步了。</p>

<p>应用程序之间可以通过TCP建立链接，TCP建立的是双向连接，通信双方可以同时进行数据的传输。连接的双方都不需要操心数据是否分块，或者是否采用了尽力服务等。TCP会确保所传输的数据的正确性，即接受方收到的数据与发出方的数据一致。</p>

<p>HTTP是典型的TCP应用，用户浏览器(应用1)与web服务器(应用2)建立连接后，浏览器可以通过连接发送服务请求，web服务器可以通过同样的连接请求作出响应。</p>

<p>同一个host主机上可以有多个应用同时使用TCP协议。TCP用不同的端口来区分应用，作为连接的两端，发送源和接收目标分别拥有自己的IP地址和端口号，凭借这样一对IP地址和端口号，就可以唯一标识一个连接。</p>

<p>使用HTTPS的web服务器会监听443端口，浏览器作为发送源会启用一个临时端口结合自己的IP地址与目标服务器对应的端口和IP地址建立TCP连接。</p>

<p>TCP在IPv4和Ipv6上是无差别运行的。所以如果ipv4和protocol活IPv6的Next Header的协议号被设置为6，表示执行TCP协议。</p>

<h2>TCP Segments (TCP 报文段)</h2>

<p>主机之间传输的数据流一般会先被分块，再转为为TCP报文段，最终会生成IP数据包中的payload的载荷数据</p>

<p>每个TCP报文段都有header信息和对应的载荷payload.payload信息就是待传输的数据块。TCP报文段的header信息中主要包含的是源和目标端口号，至于说源和目标的IP地址信息则已经包含在IP header信息中了。</p>

<p>TCP的报文段header信息中还有报文序列号，确认号等其他一些用于管理连接的信息。</p>

<p>所谓序列号信息，其实就是为每个报文段分配的唯一编号，第一个报文段的序列号是随机的，比如1721092979，其后的每一个报文段的序列号都以此号为基础以此加1，1721092980，1721092981 等等。至于确认号，是目标端反馈给源的确认信息，通知源目前已经接到那些报文段了。由于TCP是双向的，所以数据和确认信息发送也都是双向的。</p>

<h2>TCP连接</h2>

<p>连接管理是TCP的核心功能之一，而且协议需要解决由于IP层采用不可靠传输引发的一系列复杂问题。下面会分别介绍TCP的连接简历，数据传输以及连接终止的详细过程。</p>

<p>TCP连接全过程的状态变化是复杂的，但是大多数情况下还是比较简单的。</p>

<h3>连接建立</h3>

<p>TCP连接都是简历在两个主机之间的。所以，每个连接建立过程中都存在两个角色：一端（例如web服务器）监听连接，另一端(例如应用)主动连接正在监听的一端(web服务器).服务器端的这种监听行为被称为passive open(被动打开)。客户端主动连接服务器的行为称为active open(主动打开)</p>

<p>TCP会通过三次握手来完成连接建立，具体过程是这样的：</p>

<ol>
<li>客户端首先向服务器端发送一个SYn包和一个随机序列号A</li>
<li>服务器端收到回回复客户端一个SYn_ACK包以及各一个确认号（用于确认收到SYN）A+1,同时再发送一个随机序列号B</li>
<li>客户端收到后会发送一个ACK包以及确认号（用于确认收到SYN-ACK）B+1和序列号A+1给服务端</li>
</ol>


<p>SYN是Synchronize sequence numbers（同步序列号）的缩写。两端在传递数据时，所传递的每个TCP报文段都有一个序列号。就是利用这种机制，TCP可以确保分块传输的数据包最终都已正确的个数和顺序抵达目标端。在正式传输开始之前，源和目标端需要同步确认第一个报文的序列号。</p>

<p>ACK 是acknowledgment(确认)的缩写。当某一端接到了报文包后，通过回传已报文序列号来确认接收到报文这件事。</p>

<p>运行如下语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -4 http://www.apple.com/contact/</span></code></pre></td></tr></table></div></figure>


<p>这是通过<code>curl</code>命令与www.apple.com 的 80端口创建一个TCPl连接</p>

<p>www.apple.com所在服务器23.63.125.15（注意，整个 IP 不是固定的）会监听80端口。我们自己的IP地址是<code>10.0.1.6</code>，启用的临时端口52181(这个端口是从可用端口中随机选择的)。利用tcpdump(1)输出的三次握手过程是这样的、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15
</span><span class='line'>18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0
</span><span class='line'>18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0
</span><span class='line'>18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里的信息量很大，下面要逐个分析一下：</p>

<p>最左边的是系统时间。当执行命令的时间是晚上18:31。后面的IP代表的是这些都是IP协议数据包。</p>

<p>接下来看这段10.0.1.6.52181 > 23.63.125.15.80，这一对是源和目标端的IP地址+端口。第一行和第三行是客户端发向服务端的信息，第二行是服务端发向客户端的。tcpdump会自动把端口号加到IP地址后头，比如 10.0.1.6.52181 表示 IP 地址为 10.0.1.6，端口号为 52181。</p>

<p><code>Flags</code>表示TCP报文段header信息中的一些缩写标识：<code>S</code>代表SYN,<code>.</code>代表ACK,<code>P</code>代表PUSH,F是FIN.还有一些其他的标识，这边就不罗列了。注意上面三行Flags中先是携带SYN,接着是SYN-ACK,最后是ACK,这就是三次握手确认的全过程。</p>

<p>另外，第一行中客户端发送了一个随机序列号1721092979（就是上文中所说的A）给服务器，第二行展示的是服务器回传给客户端的确认号<code>1721092980 (A+1)</code>和一个随机序列号 673593777 (B).最后在第三行，客户端将自己的确认号 673593778 (B+1) 发送给服务端.</p>

<h2>其他选项</h2>

<p>当然，在连接建立过程中还会配置一些其他信息。比如第一行中客户端发送的内容:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol]</span></code></pre></td></tr></table></div></figure>


<p>还有第二行服务端发送的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1]</span></code></pre></td></tr></table></div></figure>


<p>其中<code>TS val / ecr</code>是TCP用来创建RTT 往返时间(round-trip time)的。TS val 是发送方的时间戳，ECR 是相应应答时间戳，通常情况下就是发送方收到的最后时间戳。TCP以RTT作为其拥塞控制算法 (congestion-control algorithms) 的依据</p>

<p>连接的两端都发送 sackOK.这样会启用选择性确认(Selective Acknowledagement)机制，使连接双方能够确认收到的字节返回。一般情况下，确认机制只是确认接受方已收到的数据的字节总数。</p>

<p><code>mss</code>选项声明了最大报文长度，表示接收端希望接收的单个报文的最大长度。wscale是窗口放大因子。</p>

<h2>数据传输</h2>

<p>一旦建立了连接，双方就可以互发数据了。发送端所发出的每个报文段都有一个序列号，这个序列号与当下已传送的字节总数有关。接收端会针对已接收的数据包向源端发送确认报文，确认信息同样是由报文header所携带的ACK</p>

<p>假设现在传送的信息是除最后一个报文5字节外，其它都是10字节。具体是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>host A sends segment with seq 10
</span><span class='line'>host A sends segment with seq 20
</span><span class='line'>host A sends segment with seq 30    host B sends segment with ack 10
</span><span class='line'>host A sends segment with seq 35    host B sends segment with ack 20
</span><span class='line'>                                    host B sends segment with ack 30
</span><span class='line'>                                    host B sends segment with ack 35</span></code></pre></td></tr></table></div></figure>


<p>整个机制是双向运转的，A主机会持续的发送数据包。B收到数据包后会向A发送确认信息。A发送数据包的过程不需要等待B的确认。</p>

<p>TCP将流量控制和其它一系列复杂机制结合起来进行拥塞控制。需要处理以下问题：针对丢失的报文采用重发机制，同时还需要动态的调整发送报文的频率。</p>

<p>流量控制的原则是发送方发送数据的速度不能比接收方处理数据的速度快。接收方，也就是所谓的接收窗口会告知发送方自身接收窗口数据缓冲区的大小。从上面tcpdump的输出看，窗口大小是 <code>win 65535</code>,<code>wscale</code>（窗口放大因子）是4.这些数字的意思是说：<code>10.0.1.6</code>主机的接收窗口大小是4＊64 kB = 256 kB,<code>23.63.125.15</code>主机的<code>win</code>是<code>14480</code>,<code>wscale</code>是1，接收窗口约为14kb.总之，不管哪一方作为数据接收方，都会向对方通报自己的接收窗口的大小。</p>

<p>拥塞控制要更负责一些，所有拥塞控制的目标都是要计算出当前网络中数据传输的最佳速率。所谓最佳速率就是要达到一种微妙的平衡。一方面，是希望速度越快越好，另一方面，速度快意味着数据传输多，这样处理性能会打打打折甚至崩溃。而这种超负荷崩溃是分组交换网络的固有特点。当负载过大，数据包之间会产生拥塞，直接导致丢包率急速上升。</p>

<p>拥塞控制还需要充分考虑对流量的影响。发送方要时刻关注来自接收方的确认信息。要做到这点并不简单，有的时候还需要一定的妥协。要知道底部IP协议数据包是无序传输的，数据包会丢失也会重复。发送方需要评估RTT往返时间，然后基于RTT去确定是否收到了接收方的确认信息。重发数据包也有很大代价，除了连接延迟问题，网络的负载也会发生明显的波动。导致TCP需要不停的去适应当前网络情况。</p>

<p>更重要的是，TCP连接本身是易变的。除了数据传输，连接的两端还会不时的发送一些提醒和确认信息以便可以适当的调整状态来维持连接。</p>

<p>基于这种一直在相互协调中的连接关系，TCP连接往往会是短暂而低效的。在简历连接的初期，TCP协议算法还不能完全了解当前网络状况。而在连接将要结束的时候，反馈给发送方的信息又可能不充分，这样就很难对连接状况作出实时的合理的评估。</p>

<p>之前展示了客户单和服务端之间交换的三段报文，再看看关于连接的其它信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.150955 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [P.], seq 1721092980:1721093065, ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 85
</span><span class='line'>18:31:29.161213 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], ack 1721093065, win 7240, options [nop,nop,TS val 1433256633 ecr 743929773], length 0</span></code></pre></td></tr></table></div></figure>


<p>客户端<code>10.0.1.6</code>发送的第一段报文长度是85 bytes(http请求)。由于在上一个报文发送后没有收到来自服务端的信息，所以ACK确认号值不变。</p>

<p>服务端 <code>23.63.125.15</code>只是对接收客户端的数据进行确认回复，没有向客户端发送数据，所以length为0，由于当前连接是采用选择性确认，所以序列号和确认好之间的字节长度从1721092980到1721093065，也就是85 bytes.接收方发送的ACK确认号是1721093065,这代表目前已接收的数据确认累计到1721093065字节了。至于说为什么数字会如此之大，这要说道初次握手时发出的随机数，数字的范围和那个初始数字是相关的。</p>

<p>这种模式会一直持续到全部数据传送完成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.189335 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673593778:673595226, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190280 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673595226:673596674, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190350 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673596674, win 8101, options [nop,nop,TS val 743929811 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190597 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673596674:673598122, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190601 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673598122:673599570, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190614 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673599570:673601018, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190616 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673601018:673602466, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190617 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673602466:673603914, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190619 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673603914:673605362, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190621 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673605362:673606810, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.190679 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673599570, win 8011, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190683 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673602466, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190688 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 7830, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190703 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673605362, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190743 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673606810, win 8192, options [nop,nop,TS val 743929812 ecr 1433256660], length 0
</span><span class='line'>18:31:29.190870 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [.], seq 673606810:673608258, ack 1721093065, win 7240, options [nop,nop,TS val 1433256660 ecr 743929773], length 1448
</span><span class='line'>18:31:29.198582 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [P.], seq 673608258:673608401, ack 1721093065, win 7240, options [nop,nop,TS val 1433256670 ecr 743929811], length 143
</span><span class='line'>18:31:29.198672 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608401, win 8183, options [nop,nop,TS val 743929819 ecr 1433256660], length </span></code></pre></td></tr></table></div></figure>


<h2>终止连接</h2>

<p>最终连接会终止(或结束)，连接的每一端都会发送FIN标识给另一端来声明结束传输，接着另一端会对收到的FIN进行通知，当连接两端均发送完各自FIN和做出相应的确认后，连接将会彻底关闭：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>18:31:29.199029 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [F.], seq 1721093065, ack 673608401, win 8192, options [nop,nop,TS val 743929819 ecr 1433256660], length 0
</span><span class='line'>18:31:29.208416 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [F.], seq 673608401, ack 1721093066, win 7240, options [nop,nop,TS val 1433256680 ecr 743929819], length 0
</span><span class='line'>18:31:29.208493 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673608402, win 8192, options [nop,nop,TS val 743929828 ecr 1433256680], length 0</span></code></pre></td></tr></table></div></figure>


<p>这里值得注意的是第二行，<code>23.63.125.15</code>发送了FIN，同时在这个报文信息中还对第一行中的另一端发送的FIN予以ACK(以.代表)确认。</p>

<h2>HTTP-超文本传输协议（Hypertext Transfer Protocol）</h2>

<p>1989年，Tim Berners lee 在<a href="https://en.wikipedia.org/wiki/CERN">CERN</a>担任软件咨询师的时候，开发了一套程序，奠定了万维网的基础。HyperText Transform Protocol（超文本转移协议，即HTTP）,是用于从WWW服务器传输超文件到本地浏览器的传送协议。<a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a> 定义了今天普通使用的一个版本:HTTP 1.1</p>

<h3>请求与响应</h3>

<p>HTTP采用简单的请求和响应机制，在safari输入<code>http://www.apple.com</code>时，会向www.apple.com所在的服务器发送一个http请求。服务器会在对请求作出一个响应，将请求结果信息返回给Safari.</p>

<p>每一个请求都有一个对应的响应信息。请求和响应遵从同样的格式，第一行是请求行或者响应状态行，接下来是header信息，header信息之后会有一个空行。空行之后是body请求信息体</p>

<h3>一个简答请求</h3>

<p>当safari加载html页面<a href="http://www.objc.io/about.html">http://www.objc.io/about.html</a>的时候，先是发送HTTP请求到<code>www.objc.io</code>,请求的内容是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /about.html HTTP/1.1
</span><span class='line'>Host: www.objc.io
</span><span class='line'>Accept-Encoding: gzip, deflate
</span><span class='line'>Connection: keep-alive
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.74.9 (KHTML, like Gecko) Version/7.0.2 Safari/537.74.9
</span><span class='line'>Referer: http://www.objc.io/
</span><span class='line'>DNT: 1
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>第一样是请求行，它包含三部分信息：动作，资源信息，还有HTTP的版本</p>

<p>本例中，动作是GET,所谓动作也就是常说的HTTP请求方法， 资源信息表明所请求的资源。例子中的资源信息是 /about.html,这表示我们想get服务器的在/about.html位置中的文档。当前HTTP版本是HTTP/1.1</p>

<p>接下来10行是HTTP header信息。跟着是一行空行。例子中请求没有body信息。</p>

<p>header的作用是向服务器传递一些额外的辅助信息，它的内容比较宽泛，维基百科中又<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">常用HTTP header关键字</a>信息的清单。例子中的header信息:<code>Host: www.objc.io</code>表示告诉服务器，本次请求的服务器名称是什么。这样可以让同一个服务器处理针对多个域名的请求。</p>

<p>下面是一些常见的header信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</span><span class='line'>Accept-Language: en-us</span></code></pre></td></tr></table></div></figure>


<p>服务器可能具备返回多种媒体类型的能力，Accept表示safari希望接收的媒体格式类型，text/html是胡亮媒体，也被称为MIME类型或者是内容类型(Content-TYpes).<code>q=0.9</code>表示Safari对给定媒体类型的优先级要求。Accept_Lanaguage 代表Safari希望接收的自然语言清单。这回要求服务器尽可能的根据清单要求去匹配相应的语言。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Accept-Encoding: gzip, deflate</span></code></pre></td></tr></table></div></figure>


<p>通过这个header,Safari告诉服务器可以对响应boday做压缩处理，如果header信息中没有设置压缩标识，那么服务器就必须返回没有压缩过的信息。压缩可以大大减少数据的传输量，在文本信息(比如HTML)中尤为明显。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If-Modified-Since: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>If-None-Match: "a54907f38b306fe3ae4f32c003ddd507"</span></code></pre></td></tr></table></div></figure>


<p>这两行信息表明Safari已经对请求结果做过缓存，如果服务器上的请求内容在2月10号以后发生过变化或者是etag与<code>a54907f38b306fe3ae4f32c003ddd507</code>不匹配，这就表示请求结果与当前缓存信息不一致，需要服务器返回最新的请求结果。</p>

<p>user-agent 是告知服务器当前发送请求的客户端类型。</p>

<h3>一个简单响应</h3>

<p>作为上面的请求的响应，服务器的返回是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 304 Not Modified
</span><span class='line'>Connection: keep-alive
</span><span class='line'>Date: Mon, 03 Mar 2014 21:09:45 GMT
</span><span class='line'>Cache-Control: max-age=3600
</span><span class='line'>ETag: "a54907f38b306fe3ae4f32c003ddd507"
</span><span class='line'>Last-Modified: Mon, 10 Feb 2014 18:08:48 GMT
</span><span class='line'>Age: 6
</span><span class='line'>X-Cache: Hit from cloudfront
</span><span class='line'>Via: 1.1 eb67cb25620df959ba21a943fbc49ef6.cloudfront.net (CloudFront)
</span><span class='line'>X-Amz-Cf-Id: dDSBgR86EKBemW6el-pBI9kAnuYJEaPQYEqGmBnilD12CbixCuZYVQ==</span></code></pre></td></tr></table></div></figure>


<p>第一行是状态航，它包括HTTP版本，状态码(204)和状态信息</p>

<p>HTTP定义了一系列状态码，他们各有用途，本利中的304表示所请求的信息自上次访问以来没有变化</p>

<p>响应中没有包含body信息。也就说服务器通知客户端：你的版本已经是最新的了，可以直接使用当前缓存信息</p>

<h3>关闭缓存</h3>

<p>用curl 发送一个请求:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>% curl http://www.apple.com/hotnews/ &gt; /dev/null</span></code></pre></td></tr></table></div></figure>


<p><code>curl</code>没有使用本地缓存，整个请求会是这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET /hotnews/ HTTP/1.1
</span><span class='line'>User-Agent: curl/7.30.0
</span><span class='line'>Host: www.apple.com
</span><span class='line'>Accept: */*</span></code></pre></td></tr></table></div></figure>


<p>这个请求与之前Safari发的请求很类似，但是curl请求的header信息中没有<code>If-None-Match</code>,所以服务器必须将请求结果返回。</p>

<p>此处<code>curl</code>头信息中声明的<code>Accept: */*</code>表示可以接收任何媒体类型。</p>

<p>来自www.apple.com的响应：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HTTP/1.1 200 OK
</span><span class='line'>Server: Apache
</span><span class='line'>Content-Type: text/html; charset=UTF-8
</span><span class='line'>Cache-Control: max-age=424
</span><span class='line'>Expires: Mon, 03 Mar 2014 21:57:55 GMT
</span><span class='line'>Date: Mon, 03 Mar 2014 21:50:51 GMT
</span><span class='line'>Content-Length: 12342
</span><span class='line'>Connection: keep-alive
</span><span class='line'>
</span><span class='line'>&lt;!DOCTYPE html&gt;
</span><span class='line'>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US"&gt;
</span><span class='line'>&lt;head&gt;
</span><span class='line'>    &lt;meta charset="utf-8" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>后面还会有一些，现在收到的响应里body中包含了HTML文档信息</p>

<p>Apple服务器响应的状态码是200,这是标准的表示HTTP请求成功的状态码。</p>

<p>服务器同时还告知响应媒体类型是 <code>text/html</code>;字符集<code>charset=utf-t</code>；内容长度：<code>Content-length:12342</code>,还代表了body信息的大小</p>

<h2>HTTPS-安全的HTTP</h2>

<p><a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a>(安全传输层协议，TLS)是一种基于TCP的加密协议，它支持两件事情：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于TLS的HTTP请求就是HTTPS</p>

<p>用https去替代http,在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。</p>

<h3>TLS 1.2</h3>

<p>如果服务器支持的话，你应该讲<code>TLSMinmumSupportedProtocol</code>设置为<code>kTLSProtocol12</code>,以要求使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2"><code>TLS1.2</code></a>版本，这能有效的防御<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a></p>

<h2>证书锁定(Certificate Pinning)</h2>

<p>如果不确定数据接收方的身份，那么即便对所传输数据进行加密也没什么意义。服务器的证书可以表明服务器的身份，只允许好持有某个特定证书的一方建立连接，就是<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">证书锁定</a></p>

<p>如果一个客户端通过TLS和服务器建立连接，操作系统会验证服务器证书的有效性。当然，有很多手段可以绕开这个校验，最直接的是在iOS设备上安装证书并且将其设置为可信的，这种情况下，实施<a href="https://en.wikipedia.org/wiki/Certificate_pinning#Certificate_pinning">中间人攻击</a>也不是什么难事。</p>

<p>可以使用证书锁定来规避这种风险。当监理TLS连接后，应立即检查服务器的证书，不仅要验证证书的有效性，还需要确定证书和其持有者是否匹配。考到应用和服务器需要同时升级证书的要求，这种方式比较适合应用在访问自家服务器的情况下。</p>

<p>为了实现证书锁定，在建立连接的过程中需要对服务器进行信任检查，每当通过NSURLSession创建了连接，<code>NSUrlSession</code>的代理就会收到一个
<code>-URLSession:didReceiveChallenge:completionHandler:</code>的调用。传递的参数<code>NSURLAuthenticationChallenge</code>有一个属性<code>protectionSpace</code>，它是<code>NSURLProtectionSpace</code>的实例，它有一个<code>serverTrust</code>属性。</p>

<p><code>serverTrust</code>是一个<code>SecTrustRef</code>对象，<code>Security</code>框架提供了很多方法用于验证<code>SecTrustRef</code>。<code>AFNetworking</code>项目中的<code>AFSecurityPolicy</code>就是一个不错的使用。一如既往的提醒大家，如果要自己构建全验证相关的代码，请一定要认真做好代码审查，千万不要再出现诸如<code>goto fail</code>这类bug</p>

<h2>综合讨论</h2>

<p>现在大家多IP，TCP，和http的工作原理有了一定的了解了。下面说说还可以做些什么</p>

<h3>有效地使用连接</h3>

<p>TCP连接容易在两个时点出现问题：初始设置，以及通过连接传输的最后一部分报文</p>

<h3>建立连接</h3>

<p>连接设置可能会非常耗时，正如前文所说，TCPj建立连接的过程中需要进行三次握手，这个过程中本身没有太多的数据需要传递，但是，对于移动网络来说，从手机端向服务器端发送一个数据包普遍需要250ms,也就是四分之一秒。推及到三次握手，也就是说在还没有传送任何数据之前，光建立连接就花费了750ms</p>

<p>https的情况更夸张，由于Https是基于TLS的http,而http又基于TCP,TCP连接就要执行三次握手，然后到了TLS层还会再握手三次，估算一下，建立一个HTTPS连接的耗时只要是创建一个https连接的两倍。如果RTT时间是500ms(假设单程250ms)，HTTPS建立连接累计总耗时1.5秒</p>

<p>不管建立连接后传递多少数据，建立连接本身都太过耗时了。</p>

<p>另一个影响TCP连接的因素是传送大规模的数据。如果要在网络情况未知的条件下传送报文，TCP需要侦测当前网络的能力。换句话说，TCP得花费一定的事件去计算此网络最佳传输速率。上文提到过，TCP需要逐步调整以便找到最佳速度。这种算法成为<a href="https://en.wikipedia.org/wiki/Slow-start">慢启动</a>。还有一点值得注意，慢启动策略在那些数据链路层传输质量较差的网络环境中的表现更差，无线网络就是典型的例子</p>

<h3>结束连接</h3>

<p>另一个问题主要存在于数据传输的最后阶段。每当客户端发起HTTP请求某些资源的时候，服务器会持续的向客户端发送TCP报文数据，客户端收到数据后会给服务器反馈ACK报文数据，客户端收到数据后会给服务器反馈ACK确认信息。假如某个报文在传输过程中发生丢包，那么服务器也就不会收到该包的确认ACK.一旦服务器发现现有数据包没有ACK反馈，就会触发快速重传。</p>

<p>每当某个数据包丢失，数据接收方在收到下个数据包后发出的确认ACK与所接收的前一个数据包的确认ACK相同。那么数据发送方自然就会收到重复的ACK.除了报文丢失，还有很多网络状况会导致重复ACK的问题。一般情况下，如果数据发送方连续收到3个重复的ACK就会立即进行快速重发</p>

<p>这所导致的问题将发生在数据传输的收尾阶段。如果发送方完成数据发送，接受方自然会停止发送ACK确认。在最后四个报文传输的过程中，快速重发算法是没有办法处理这四个报文的数据包丢失问题的（以为不会收到三个相同的确认ACK,所以不能界定传输丢包），在常规的网络环境下，四个数据包相当于5.7kb的数据规模。总之，在这最后的5.7kb的传输过程中，快速重发机制是无效的。针对这种情况，TCP会启用其它机制来侦测丢包问题。对于这种情况，重传操作可能要消耗几秒钟去执行，这并不奇怪</p>

<h3>长连接和管线化</h3>

<p>HTTP有两种策略来解决这些问题，最简单的是<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP持久连接(persistent connection)</a>，也被称为长连接。具体就是,每当HTTP完成一组请求-响应后，还会继续复用相同的TCP连接。而HTTPS会复用同样的TLS连接：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>第二部就是利用了<a href="https://en.wikipedia.org/wiki/Http_pipelining">HTTP管线</a>处理，即允许客户端利用同样的连接并行发送多个请求，也就是说无需等待上一个请求的响应完成可以发下一个请求。这表示能同时处理请求和响应，请求处理的顺序采用先进先出的原则，响应结果会按照请求发出的顺序依次返回给客户端</p>

<p>稍微简化一下，看起来会是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>open connection
</span><span class='line'>client sends HTTP request 1 -&gt;
</span><span class='line'>client sends HTTP request 2 -&gt;
</span><span class='line'>client sends HTTP request 3 -&gt;
</span><span class='line'>client sends HTTP request 4 -&gt;
</span><span class='line'>                            &lt;- server sends HTTP response 1
</span><span class='line'>                            &lt;- server sends HTTP response 2
</span><span class='line'>                            &lt;- server sends HTTP response 3
</span><span class='line'>                            &lt;- server sends HTTP response 4
</span><span class='line'>close connection</span></code></pre></td></tr></table></div></figure>


<p>注意，服务器发出的响应是实时的，不会等到接收完全请求才处理。</p>

<p>可以利用这个特点来提升TCP的效率，只需要在简建立连接初始阶段执行握手，而后一直复用同样的连接。这样TCP就可以最大限度的利用带宽，此种情况下，拥塞控制也会随之提升。因为快速重复机制无法处理的最末四个报文丢失情况只会发生在使用本地连接的最后一个请求-响应中，而不是像之前那样每一个请求-响应都需要建立自己的连接，每个连接中都可能出现最后四个报文丢失的问题。</p>

<p>HTTP管线化对高网络延迟连接的通讯性能提升尤为显著，在你的iPhone没有通过wifi访问网络的时候，此类网络连接就属于高延迟范畴。实际上，有调差显示，在移动网络环境下，<a href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>的通讯性能并不优于HTTP管线。</p>

<p><a href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>指明，在与同一个服务器通讯的时候，如果启用了http管线，建议启用两个连接。按照说明所述，这样能获得最优的响应效率，能最大限度避免拥塞，增加更多的连接也不会再对性能有什么明显改善。</p>

<p>遗憾的是，还有相当多的服务器不支持管线话，由于这个原因，HTTP管线在<code>NSURlSession</code>中默认是关闭的，如果想要开启HTTP管线，需要将<code>NSURLSessionConfiguration</code>中的<code>HTTPShouldUsePipelining</code>设置为YES.另外，建议服务器最好还是支持管线化</p>

<h3>超时处理</h3>

<p>我们都有在网络不太好的情况下使用app的经历，很多app大概15s左右就会结束请求并且反馈一个超时信息，这种设计其实是很不好有的。应该给用户一个他们理解的友好提示，比如：“你好，现在网络状态不太好，你需要多等一会”。但是即便网络状况良好，只要连接还在，TCP都会保证将请求发出去并且会一直等待响应的返回，只是时间长短问题。</p>

<p>从另一个角度来说，在较慢的网络中，请求-响应的RTT时间可能会有17秒。如果15秒就决定终止请求，就算用户有足够的耐心，他们也没积水等到想要的操作结果，反过来，如果我们给出用户响应的提示信息，而他们又刚好愿意多等一会，用户可能会更喜欢使用这样的应用。</p>

<p>一直以来都有一种误解，用重发请求来解决上面的问题，注意，这不是问题的关键，因为TCP有自己的重复机制。</p>

<p>正确的处理方式应该是：没放发起一个请求的时候，同时启动一个10秒计时器，如果请求在10秒之内返回，就把计时器关掉。如果超过10秒，可以给用户一个提示：“网络不好请稍后”。我建议再给用户一个取消按钮，让他们可以自行选择等待还是取消请求，当然提示信息的具体内容和是否配备取消按钮，这个可以视各app的情况去决定。总而言之，开发者最好不要直接替用户做决定，比如直接终止他们的请求。</p>

<p>只要连接双方的IP地址是不变的，可用的，连接就一定是活跃的。如果把iPhone从wifi连接切换到3G网络，这样连接就会变得不可用，因为的IP地址发生了变化，基于原IP地址创建的路由自然是失效的。</p>

<h2>缓存</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveSwift入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men/"/>
    <updated>2016-11-16T10:29:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/16/reactiveswiftru-men</id>
    <content type="html"><![CDATA[<h2>Signal</h2>

<p>一个signal类型的实例，代表了一个有时序的并且可以被观察(类似订阅)的事件流。</p>

<p>信号通常被用来表示正在进行中的事件流，比如通知，用户输入等。用户（或者只要能造成事件的东西）产生的事件发送或者被接受，事件就被传递到信号上，并且被推送(push-Driven)到任何观察者哪里，并且所有观察者都是同时收到这些事件。</p>

<p>如果你想访问一系列的事件，就必须观察一个信号，观察一个信号并不会触发任何副作用，可以这样理解。信号是由生产者生产和推动的，消费者（观察者）是不会对事件的生命周期有任何影响。在观察一个信号时，发送了什么事件，只能对这个事件操作，因为信号是由时序的，不能随机的访问其他事件。</p>

<p>信号可以通过原函数去操作，比如filter,map,reduce,也可以同时操作多个信号如zip,这些原函数只在nextEvents生效（也就是对complete,failure等不生效）</p>

<p>在一个信号的生命周期里，可以发送无数次的NextEvents事件，直到他们被终结，类似compleye,Failed,InterRupper.终止事件没有数据值，所以他们必须被单独处理。</p>

<h2>Subscription</h2>

<p>一个信号通常被用来表示正在进行中的事件流，有时候他们被叫做热信号，这意味着订阅者可以错过一些在它订阅前发送的事件。订阅一个信号不会触发任何副作用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>20
</span><span class='line'>21
</span><span class='line'>22
</span><span class='line'>23
</span><span class='line'>24
</span><span class='line'>25
</span><span class='line'>26
</span><span class='line'>27
</span><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    // Signal.pipe is a way to manually control a signal. the returned observer can be used to send values to the signal
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nonerror&gt;.pipe()
</span><span class='line'>    let subscriber1 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, nonerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to the signal")
</span><span class='line'>    print("\(observer)")
</span><span class='line'>    signal.observe(subscriber1)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    // subscriber1 will receive the value
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    print("Subscriber 2 subscribes to the signal")
</span><span class='line'>    // Notice how nothing happens at this moment, i.e. subscriber2 does not receive the previously sent value
</span><span class='line'>    signal.observe(subscriber2)
</span><span class='line'>    print("Send value `20` on the signal")
</span><span class='line'>    // Notice that now, subscriber1 and subscriber2 will receive the value
</span><span class='line'>    observer.sendNext(20)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to the signal
</span><span class='line'>Observer&lt;int, nonerror&gt;(action: (Function))
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber 1 received 10
</span><span class='line'>Subscriber 2 subscribes to the signal
</span><span class='line'>Send value `20` on the signal
</span><span class='line'>Subscriber 1 received 20
</span><span class='line'>Subscriber 2 received 20&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>因为Swift有泛型的存在，这样的话我们可以把Signal当做任何数据类型的容器，而不是像OC中利用上帝类型Id，更加方便传递数据</p>

<p>首先我们通过Signal.pipe()创建了一个信号和一个观察者。</p>

<p>奇怪的是，在RACOC部分中，我们很少主动创建观察者，我们通常直接订阅信号就可以。</p>

<p>在Swift中，通过pipe创建的信号是个热信号，类似于OC中的RACSubject系列，在RACSubject继承自RACSiganl又继承RACStream，RACStream是一个Monad,它可以代表数据和数据的一系列的操作如map,flatterMap,bind</p>

<p>RACSubject又遵守了RACSubscriber协议，这个协议定义了可以发送数据的操作。</p>

<p>所以RACSubject即是一个信号，又是一个观察者。</p>

<p>在Swift部分的实现中，Signal并没有实现发送数据的方法。所以它需要一个内部的Observer去发送数据。所以它被pipe直接返回。</p>

<p>在外部我们需要自己实例化一个Observer观察者。去订阅事件。</p>

<p>可能在你查看Pipe的实现的时候并不好理解。把尾随闭包补全相对好理解点。</p>

<p>做个总结：</p>

<ul>
<li>RACOC中：RACSubject = RACSignal + RACSubscriper，在订阅的时候，订阅者被放在了RACSubject内部存放，我们只需要去关注订阅的block实现即可。</li>
<li>RACSwift中:Signal 仅仅就是一个信号，所以需要一个内部观察者去充当发送数据的工具。外部的订阅需要自己手动实例观察者</li>
<li>热信号：由于pipe方法返回的是热信号，所以一个订阅者会错过在订阅之前发送的事件
*</li>
</ul>


<h3>empty</h3>

<p>空信号直接发送一个interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptySignal = Signal&lt;int, nonerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, nonerror&gt;(
</span><span class='line'>    failed: { _ in print("error not called") },
</span><span class='line'>    completed: { print("completed not called") },
</span><span class='line'>    interrupted: { print("interrupted called") },
</span><span class='line'>    next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptySignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>interrupted called&lt;/int, nonerror&gt;&lt;/int, nonerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Never</h3>

<p>一个Never信号不会发送任何事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverSignal = Signal&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        interrupted: { print("interrupted not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverSignal.observe(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>uniqueValues唯一值</h3>

<p>仅从集合中发送一次相同事件&ndash;类似与arrayQueue变成了Setqueue</p>

<p>注意：这会造成被发送的值被保留下来，用于以后发送的时候来检查是否重复，你可以编写一个函数来过滤重复值，这样可以减少内存消耗。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>17
</span><span class='line'>18
</span><span class='line'>19
</span><span class='line'>scopedExample("`uniqueValues`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let uniqueSignal = signal.uniqueValues()
</span><span class='line'>    uniqueSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(5)
</span><span class='line'>}
</span><span class='line'>--- `uniqueValues` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2
</span><span class='line'>Subscriber received 3
</span><span class='line'>Subscriber received 4
</span><span class='line'>Subscriber received 5&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每一个发送的值转换成新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let mappedSignal = signal.map { $0 * 2 }
</span><span class='line'>    mappedSignal.observe(subscriber)
</span><span class='line'>    print("Send value `10` on the signal")
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>Send value `10` on the signal
</span><span class='line'>Subscriber received 20&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error值变成新的error值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7
</span><span class='line'>8
</span><span class='line'>9
</span><span class='line'>10
</span><span class='line'>11
</span><span class='line'>12
</span><span class='line'>13
</span><span class='line'>14
</span><span class='line'>15
</span><span class='line'>16
</span><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>        let userInfo = [NSLocalizedDescriptionKey: "??"]
</span><span class='line'>        let code = error.code + 10000
</span><span class='line'>        let mappedError = NSError(domain: "com.reactivecocoa.errordomain", code: code, userInfo: userInfo)
</span><span class='line'>    let (signal, observer) = Signal&lt;int, nserror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, nserror&gt;(failed: { print("Subscriber received error: \($0)") } )
</span><span class='line'>    let mappedErrorSignal = signal.mapError { (error:NSError) -&gt; NSError in
</span><span class='line'>        return mappedError
</span><span class='line'>    }
</span><span class='line'>    mappedErrorSignal.observe(subscriber)
</span><span class='line'>    print("Send error `NSError(domain: \"com.reactivecocoa.errordomain\", code: 4815, userInfo: nil)` on the signal")
</span><span class='line'>    observer.sendFailed(NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil))
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Send error `NSError(domain: "com.reactivecocoa.errordomain", code: 4815, userInfo: nil)` on the signal
</span><span class='line'>Subscriber received error: Error Domain=com.reactivecocoa.errordomain Code=14815 "??" UserInfo={NSLocalizedDescription=??}&lt;/int, nserror&gt;&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>用于过滤一些值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    // subscriber will only receive events with values greater than 12
</span><span class='line'>    let filteredSignal = signal.filter { $0 &gt; 12 ? true : false }
</span><span class='line'>    filteredSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(10)
</span><span class='line'>    observer.sendNext(11)
</span><span class='line'>    observer.sendNext(12)
</span><span class='line'>    observer.sendNext(13)
</span><span class='line'>    observer.sendNext(14)
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>Subscriber received 13
</span><span class='line'>Subscriber received 14&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>在发送的值为可选类型中：如果有值，把值解包，如果是nil丢弃掉</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int?, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int?` and observer is of type `Int`, given we're unwrapping
</span><span class='line'>    // non-`nil` values
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let ignoreNilSignal = signal.ignoreNil()
</span><span class='line'>    ignoreNilSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(nil)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 3&lt;/int, noerror&gt;&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num)只取前num此值得信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let subscriber = Observer&lt;int, noerror&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let takeSignal = signal.take(2)
</span><span class='line'>    takeSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>Subscriber received 1
</span><span class='line'>Subscriber received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect</h3>

<p>在发送complete事件之后，观察者会收到一个由之前事件组成的数组</p>

<p>注意：如果在发送complete事件的时候，没有任何事件发送，观察者会收到一个空的数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect`") {
</span><span class='line'>    let (signal, observer) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    // note that the signal is of type `Int` and observer is of type `[Int]` given we're "collecting"
</span><span class='line'>    // `Int` values for the lifetime of the signal
</span><span class='line'>    let subscriber = Observer&lt;[Int], NoError&gt;(next: { print("Subscriber received \($0)") } )
</span><span class='line'>    let collectSignal = signal.collect()
</span><span class='line'>    collectSignal.observe(subscriber)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    observer.sendCompleted()
</span><span class='line'>}
</span><span class='line'>--- `collect` ---
</span><span class='line'>Subscriber received [1, 2, 3, 4]&lt;/int, noerror&gt;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h2>SignalProducer</h2>

<p>一个信号发生器，是SignalProducer类型的实例，它可以创建信号(signals)并施加副作用（side effects）</p>

<p>信号发生器用来表示操作或者任务，比如网络请求，每一次对它的调用start()将会生成一个新的潜在操作，并允许调用者观察它的结果，还有一个startWithSignal()方法，会给出产生的信号，允许在必要的情况下监听多次。</p>

<p>根据start()方法的动作方式，被同一个信号发生器生成的信号可能会有不同的事件顺序或版本，甚至事件流完全不一样！和普通的信号不同，在观察者连接上之前，信号发生器不会开始工作（也就没有事件会生成），并且在每一个新的监听器连接上时其工作都会重新开始一个单独的工作流。</p>

<p>启动一个信号发生器会返回一个销毁器(disposable)，它可用来打断或取消被生成信号的工作</p>

<p>和信号一样，信号生成器可以通过map,filter等原函数操作，使用lift方法，所有信号的原函数可以被提升成为以信号生成器为对象的操作，除此以外，还有一些用来控制何时与如何启动信号生成器的原函数，比如times.</p>

<p>通过lift函数可以让热信号转变为冷信号。</p>

<h3>Subscription</h3>

<p>一个信号生成器代表了一种可以在需要的时候才被启动的操作（不像signal是自启动的），这种信号是冷信号，在刚开始这个信号的状态也为冷（未激活），既然是冷信号，那么就意味着这一个观察者不会错过任何被信号生成器发出的值。</p>

<p>补充：像signal是创建的时候状态为cold(理解为未激活)，被订阅时状态为hot(理解为激活)</p>

<p>但是冷信号和热信号与状态为冷热是两个不同的概念，冷信号会带来副作用，热信号不会</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("Subscription") {
</span><span class='line'>    let producer = SignalProducer&lt;int, noerror&gt; { observer, _ in
</span><span class='line'>        print("New subscription, starting operation")
</span><span class='line'>        observer.sendNext(1)
</span><span class='line'>        observer.sendNext(2)
</span><span class='line'>    }
</span><span class='line'>    let subscriber1 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 1 received \($0)") })
</span><span class='line'>    let subscriber2 = Observer&lt;int, noerror&gt;(next: { print("Subscriber 2 received \($0)") })
</span><span class='line'>    print("Subscriber 1 subscribes to producer")
</span><span class='line'>    producer.start(subscriber1)
</span><span class='line'>    print("Subscriber 2 subscribes to producer")
</span><span class='line'>    // Notice, how the producer will start the work again
</span><span class='line'>    producer.start(subscriber2)
</span><span class='line'>}
</span><span class='line'>--- Subscription ---
</span><span class='line'>Subscriber 1 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 1 received 1
</span><span class='line'>Subscriber 1 received 2
</span><span class='line'>Subscriber 2 subscribes to producer
</span><span class='line'>New subscription, starting operation
</span><span class='line'>Subscriber 2 received 1
</span><span class='line'>Subscriber 2 received 2&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>像不像是RACDynamicSignal的创建方式，这不过不同与Sinal的是，这里的发送信号的观察者是在内部通过Signal.pipe()生成的，不需要外部创建。</p>

<p>SignalProduce是冷信号，任何一个订阅者/观察者都不会错过任何事件</p>

<p>start方类似Signal的 signal.observe()方法，只不过Signal的方法只有一个作用，就是关联一个观察者，而SignalProduce的start方法还多了一个激活信号的功能</p>

<h3>Empty</h3>

<p>一个会立即调用complete事件的信号生成器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `empty`
</span><span class='line'> A producer for a Signal that will immediately complete without sending
</span><span class='line'> any values.
</span><span class='line'> */
</span><span class='line'>scopedExample("`empty`") {
</span><span class='line'>    let emptyProducer = SignalProducer&lt;int, noerror&gt;.empty
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed called") },
</span><span class='line'>        interrupted: { print("interrupted called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    emptyProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `empty` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>Signal调用的是interrup方法，暂时不知道为什么，可能是为了区分语义吧，Signal是有时序的，SignalProduce是没有时序的。</p>

<h3>Never</h3>

<p>一个什么都不会发送的信号器</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `never`
</span><span class='line'> A producer for a Signal that never sends any events to its observers.
</span><span class='line'> */
</span><span class='line'>scopedExample("`never`") {
</span><span class='line'>    let neverProducer = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>    let observer = Observer&lt;int, noerror&gt;(
</span><span class='line'>        failed: { _ in print("error not called") },
</span><span class='line'>        completed: { print("completed not called") },
</span><span class='line'>        next: { _ in print("next not called") }
</span><span class='line'>    )
</span><span class='line'>    neverProducer.start(observer)
</span><span class='line'>}
</span><span class='line'>--- `never` ---&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>buffer</h3>

<p>创建一个事件队列可以回放已经发送的事件</p>

<p>当一个值被发送的时候，它会被放进缓冲区内，如果缓冲区已经溢出，就会丢弃旧的值</p>

<p>这些被缓存的值将会被保留，直到这个信号被终结，当一个信号启动的时候，如果队列里没有任何值，所有被发送的新值都会被自动转发到观察者那里，直到管着着收到一个终止事件。</p>

<p>当一个终止事件被发送到队列中，观察者不会再收到任何值，并且这个事件不会被计算buffer的缓冲区大小，所以没有缓存的值都会被丢弃。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`buffer`") {
</span><span class='line'>    let (producer, observer) = SignalProducer&lt;int, noerror&gt;.buffer(2)
</span><span class='line'>    observer.sendNext(1)
</span><span class='line'>    observer.sendNext(2)
</span><span class='line'>    observer.sendNext(3)
</span><span class='line'>    var values: [Int] = []
</span><span class='line'>    producer.start { event in
</span><span class='line'>        switch event {
</span><span class='line'>        case let .Next(value):
</span><span class='line'>            values.append(value)
</span><span class='line'>        default:
</span><span class='line'>            break
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    print(values)
</span><span class='line'>    observer.sendNext(4)
</span><span class='line'>    print(values)
</span><span class='line'>    let subscriber = Observer&lt;int,noerror&gt;(next:{ bufferdValue in
</span><span class='line'>        print("\(bufferdValue)")
</span><span class='line'>    })
</span><span class='line'>    producer.start(subscriber)
</span><span class='line'>}
</span><span class='line'>--- `buffer` ---
</span><span class='line'>[2, 3]
</span><span class='line'>[2, 3, 4]
</span><span class='line'>3
</span><span class='line'>4&lt;/int,noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithSignal</h3>

<p>通过Producer返回一个Signal,当闭包调用时返回signal开始发送事件</p>

<p>闭包返回一个Disponsable，可以用来中断Signal或者完成</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithSignal`") {
</span><span class='line'>    var started = false
</span><span class='line'>    var value: Int?
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .on(next: {
</span><span class='line'>            value = $0
</span><span class='line'>        })
</span><span class='line'>        .startWithSignal { signal, disposable in
</span><span class='line'>            print(signal)
</span><span class='line'>            print(value) // nil
</span><span class='line'>        }
</span><span class='line'>    print(value)
</span><span class='line'>}
</span><span class='line'>--- `startWithSignal` ---
</span><span class='line'>ReactiveCocoa.Signal&lt;swift.int, result.noerror&gt;
</span><span class='line'>nil
</span><span class='line'>Optional(42)&lt;/swift.int, result.noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithNext</h3>

<p>通过信号生成器创建一个信号，并且给这个信号内部直接构建一个观察者，在指定的闭包中会直接订阅next事件。</p>

<p>返回一个Disposable,可以中断这个信号，中断之后这个闭包不会再被调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithNext`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithNext` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个订阅只能接受next事件</p>

<h3>startWithCompleted</h3>

<p>同startWithNext，只不过只能接受complete事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithCompleted`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 42)
</span><span class='line'>        .startWithCompleted {
</span><span class='line'>            print("completed called")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithCompleted` ---
</span><span class='line'>completed called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithFailed</h3>

<p>同startWithNext， 只不过只能接受Failer事件事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithFailed`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "example", code: 42, userInfo: nil))
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `startWithFailed` ---
</span><span class='line'>Error Domain=example Code=42 "(null)"&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>startWithInterrupted</h3>

<p>同startWithNext,只不过只能接受interrupted事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`startWithInterrupted`") {
</span><span class='line'>    let disposable = SignalProducer&lt;int, noerror&gt;.never
</span><span class='line'>        .startWithInterrupted {
</span><span class='line'>            print("interrupted called")
</span><span class='line'>        }
</span><span class='line'>    disposable.dispose()
</span><span class='line'>}
</span><span class='line'>--- `startWithInterrupted` ---
</span><span class='line'>interrupted called&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>lift</h3>

<p>这个相对难理解点，大致类似于RAC_OC部分中的bind函数，monad中bind函数</p>

<p>可以理解为所有的原函数都是通过lift去实现的，借用中间信号来实现一系列的信号变换</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`lift`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    let transform: Signal&lt;int, noerror&gt; -&gt; Signal&lt;int, noerror&gt; = { signal in
</span><span class='line'>        counter = 42
</span><span class='line'>        return signal
</span><span class='line'>    }
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 0)
</span><span class='line'>        .lift(transform)
</span><span class='line'>        .startWithNext { _ in
</span><span class='line'>            print(counter)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `lift` ---
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>map</h3>

<p>把每个值都转换为新的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`map`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(value: 1)
</span><span class='line'>        .map { $0 + 41 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `map` ---
</span><span class='line'>42&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>mapError</h3>

<p>把收到的error转换为新的error</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`mapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "mapError", code: 42, userInfo: nil))
</span><span class='line'>        .mapError { Error.Example($0.description) }
</span><span class='line'>        .startWithFailed { error in
</span><span class='line'>            print(error)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `mapError` ---
</span><span class='line'>Example("Error Domain=mapError Code=42 \"(null)\"")&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>filter</h3>

<p>过滤不符合条件的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`filter`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .filter { $0 &gt; 3}
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `filter` ---
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>take</h3>

<p>take(num) 只取前几次的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`take`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .take(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `take` ---
</span><span class='line'>1
</span><span class='line'>2&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>observeOn</h3>

<p>在指定调度器上分发事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `observeOn`
</span><span class='line'> Forwards all events onto the given scheduler, instead of whichever
</span><span class='line'> scheduler they originally arrived upon.
</span><span class='line'> */
</span><span class='line'>scopedExample("`observeOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let completion = { print("is main thread? \(NSThread.currentThread().isMainThread)") }
</span><span class='line'>    if #available(OSX 10.10, *) {
</span><span class='line'>    baseProducer
</span><span class='line'>        .observeOn(QueueScheduler(qos: QOS_CLASS_DEFAULT, name: "test"))
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>    }
</span><span class='line'>    baseProducer
</span><span class='line'>        .startWithCompleted(completion)
</span><span class='line'>}
</span><span class='line'>--- `observeOn` ---
</span><span class='line'>is main thread? true&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h2>collect</h2>

<p>在发送完成的时候将一系列的值聚合为一个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect()`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect()` ---
</span><span class='line'>[1, 2, 3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(count:)</h3>

<p>在发送数据的时候（不需要发送complete）的时候将一系列的值聚合为数组，数组的长度为count,如果有很多数据，将会返回多个数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(count:)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>        observer.sendNext(5)
</span><span class='line'>//            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect(count: 2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(count:)` ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>collect(predicate:) matching values inclusively</h3>

<p>通过谓词将一系列的值聚合为一个数组，注意在发送complete时候，如果前面只剩下一个值，就不需要聚合（因为没有其它元素和最后一个元素聚合），直接返回一个只有一个元素的数组。如果没有数据则返回一个空数组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values inclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>//            observer.sendNext(1)
</span><span class='line'>//            observer.sendNext(2)
</span><span class='line'>//            observer.sendNext(3)
</span><span class='line'>//            observer.sendNext(4)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values in values.reduce(0, combine: +) == 3 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values inclusively ---
</span><span class='line'>[]&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<p>尝试打开注释看看会有什么结果</p>

<h3>collect(predicate:) matching values exclusively</h3>

<p>和上一个不同的是，如果谓词成功就把之前的聚合在一起，可以理解为把成功的界限当做分隔符</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`collect(predicate:)` matching values exclusively") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt; { observer, disposable in
</span><span class='line'>            observer.sendNext(1)
</span><span class='line'>            observer.sendNext(2)
</span><span class='line'>            observer.sendNext(3)
</span><span class='line'>            observer.sendNext(4)
</span><span class='line'>            observer.sendNext(5)
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .collect { values, next in next == 3 || next == 5  }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `collect(predicate:)` matching values exclusively ---
</span><span class='line'>[1, 2]
</span><span class='line'>[3, 4] // 3满足了条件所以被分开
</span><span class='line'>[5] // 5也是&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>combineLatestWith</h3>

<p>将第一个信号生成器的values和被聚合信号生成器的最后一个值聚合为一个元组</p>

<p>新产生的信号生成器不会发送任何值，只是转发，任何一个原来的信号被中断，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combineLatestWith`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let producer2 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>    producer1
</span><span class='line'>        .combineLatestWith(producer2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combineLatestWith` ---
</span><span class='line'>(1, 2)
</span><span class='line'>(2, 2)
</span><span class='line'>(3, 2)
</span><span class='line'>(4, 2)&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skip</h3>

<p>skip（num），跳过num此发送的事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skip`") {
</span><span class='line'>    let producer1 = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    producer1
</span><span class='line'>        .skip(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skip` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>materialize</h3>

<p>将被发送的值(value)编程Event,允许他们被修改。还句话说，允许他们被修改，把一个值变成一个Monad</p>

<p>当收到一个complete或者Failure事件，这个新的信号生成器，会发送事件并且结束。当收到一个interrupted事件，这个新的信号生成器也会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`materialize`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .materialize()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `materialize` ---
</span><span class='line'>NEXT 1
</span><span class='line'>NEXT 2
</span><span class='line'>NEXT 3
</span><span class='line'>NEXT 4
</span><span class='line'>COMPLETED
</span><span class='line'>// 注意 value  如果不做materialize就是Int类型</span></code></pre></td></tr></table></div></figure>


<h3>sampleOn</h3>

<p>当sampler（被操作的信号生成器）发送任何事件的时候，都转发原来信号生成器的最后一个值</p>

<p>如果当一个sampler启动时，当前的值没有被观察者，没有任何事情发生</p>

<p>新产生的信号生成器从源信号生成器哪里发送数据，如果两个信号生成器任何一个complete或者interrupt,新产生的都会中断</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/*:
</span><span class='line'> ### `sampleOn`
</span><span class='line'> Forwards the latest value from `self` whenever `sampler` sends a Next
</span><span class='line'> event.
</span><span class='line'> If `sampler` fires before a value has been observed on `self`, nothing
</span><span class='line'> happens.
</span><span class='line'> Returns a producer that will send values from `self`, sampled (possibly
</span><span class='line'> multiple times) by `sampler`, then complete once both input producers have
</span><span class='line'> completed, or interrupt if either input producer is interrupted.
</span><span class='line'> */
</span><span class='line'>scopedExample("`sampleOn`") {
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let sampledOnProducer = SignalProducer&lt;int, noerror&gt;(values: [ 1, 2 ])
</span><span class='line'>        .map { _ in () }
</span><span class='line'>    let newProduce = baseProducer
</span><span class='line'>        .sampleOn(sampledOnProducer)
</span><span class='line'>      newProduce  .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `sampleOn` ---
</span><span class='line'>4
</span><span class='line'>4&lt;/int, noerror&gt;&lt;/int, noerror&gt;
</span><span class='line'>sampler发送的2次值都被变换成baseProduce 的comlete前的最后一个值</span></code></pre></td></tr></table></div></figure>


<h3>combinePrevious</h3>

<p>向前合并，没法送一个值就结合历史发送数据的最后一个构造成一个新的元组返回。在第一个发送时由于没有历史数据，所以combinePrevious传递了一个默认值。当做第一次的合并。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`combinePrevious`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .combinePrevious(42)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `combinePrevious` ---
</span><span class='line'>(42, 1) // 第一次没有历史记录默认值是42
</span><span class='line'>(1, 2) // 第二次默认记录是1
</span><span class='line'>(2, 3)
</span><span class='line'>(3, 4)&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>scan</h3>

<p>类似reduce,将值聚合为一个新的值，每次聚合都保留结果作为下次的默认值，首次需给出默认值</p>

<p>每次聚合都会发送这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`scan`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .scan(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `scan` ---
</span><span class='line'>1
</span><span class='line'>3
</span><span class='line'>6
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>reduce</h3>

<p>和scan类似，区别为reduce只发送聚合后的值并且立即结束</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`reduce`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .reduce(0, +)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `reduce` ---
</span><span class='line'>10&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>skipRepeats</h3>

<p>跳过表达式里返回true的值，第一个值不会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipRepeats` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>4
</span><span class='line'>1</span></code></pre></td></tr></table></div></figure>


<h3>skipWhile</h3>

<p>对每个值都去做判断，知道返回false,之前的值会被跳过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`skipWhile`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 3, 3, 3, 3, 1, 2, 3, 4 ])
</span><span class='line'>        .skipWhile { $0 &gt; 2 }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `skipWhile` ---
</span><span class='line'>1  // 到1 返回false  之前的值被忽略掉
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeUntilReplacement</h3>

<p>在被替换的信号发生器发送信号之后，发送被替换的信号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeUntilReplacement`") {
</span><span class='line'>    let (replacementSignal, incomingReplacementObserver) = Signal&lt;int, noerror&gt;.pipe()
</span><span class='line'>    let baseProducer = SignalProducer&lt;int, noerror&gt; { incomingObserver, _ in
</span><span class='line'>        incomingObserver.sendNext(1)
</span><span class='line'>        incomingObserver.sendNext(2)
</span><span class='line'>        incomingObserver.sendNext(3)
</span><span class='line'>// 下面被替换的信号生成器发送了事件，之后就不再发送baseProducer的事件了
</span><span class='line'>// 相当于被替换了
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>        incomingObserver.sendNext(4)
</span><span class='line'>        incomingReplacementObserver.sendNext(42)
</span><span class='line'>    }
</span><span class='line'>    let producer = baseProducer.takeUntilReplacement(replacementSignal)
</span><span class='line'>    producer.startWithNext { value in
</span><span class='line'>        print(value)
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>--- `takeUntilReplacement` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>42
</span><span class='line'>42&lt;/int, noerror&gt;&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>takeLast</h3>

<p>在发送complete事件后只取count此数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`takeLast`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .takeLast(2)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>只取了2次数据
</span><span class='line'>--- `takeLast` ---
</span><span class='line'>3
</span><span class='line'>4&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>ignoreNil</h3>

<p>如果发送的事件是可选类型，解包这些可选类型，并且丢弃nil值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`ignoreNil`") {
</span><span class='line'>    SignalProducer&lt;int?, noerror&gt;(values: [ nil, 1, 2, nil, 3, 4, nil ])
</span><span class='line'>        .ignoreNil()
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `ignoreNil` ---
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4&lt;/int?, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>zipWith</h3>

<p>压缩信号生成器，只有再两个信号都有数据发送之后，新的信号生成器才会发送数据</p>

<p>新的数据被组合为元组</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`zipWith`") {
</span><span class='line'>    let baseProducer = SignalProducer(values: [ 1, 2, 3, 4 ])
</span><span class='line'>    let zippedProducer = SignalProducer(values: [ 42, 43 ])
</span><span class='line'>    baseProducer
</span><span class='line'>        .zipWith(zippedProducer)
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print("\(value)")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `zipWith` ---
</span><span class='line'>(1, 42)
</span><span class='line'>(2, 43)</span></code></pre></td></tr></table></div></figure>


<p>后面应为第二个没有数据了，所以不会再聚合了</p>

<h3>times</h3>

<p>time(count)重复发送count数据，每次重复必须上次发送完成事件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`times`") {
</span><span class='line'>    var counter = 0
</span><span class='line'>    SignalProducer&lt;(), NoError&gt; { observer, disposable in
</span><span class='line'>            counter += 1
</span><span class='line'>            observer.sendCompleted()
</span><span class='line'>        }
</span><span class='line'>        .times(42)
</span><span class='line'>        .start()
</span><span class='line'>    print(counter)
</span><span class='line'>}
</span><span class='line'>--- `times` ---
</span><span class='line'>42</span></code></pre></td></tr></table></div></figure>


<h3>retry</h3>

<p>如果收到失败事件重试retry(count)次</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`retry`") {
</span><span class='line'>    var tries = 0
</span><span class='line'>    SignalProducer&lt;int, nserror&gt; { observer, disposable in
</span><span class='line'>            if tries == 0 {
</span><span class='line'>                tries += 1
</span><span class='line'>                observer.sendFailed(NSError(domain: "retry", code: 0, userInfo: nil))
</span><span class='line'>            } else {
</span><span class='line'>                observer.sendNext(42)
</span><span class='line'>                observer.sendCompleted()
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        .retry(1)
</span><span class='line'>        .startWithResult { result in
</span><span class='line'>            print(result)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `retry` ---
</span><span class='line'>.Success(42)&lt;/int, nserror&gt;</span></code></pre></td></tr></table></div></figure>


<p>当第一个信号发送complete时，第二个信号被替换成信号发送线路上，如果有任何失败事件，后面的就替换失败。</p>

<p>第一个信号发送的所有事件都会被忽略</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160726/1469505056118233.png" alt="1" /></p>

<h3>flatMap</h3>

<p>将收到的每个事件都映射为新的Product,然后摊平，如果原来的producer发送失败，新产生也得立即失败</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMap(.Latest)`") {
</span><span class='line'>    SignalProducer&lt;int, noerror&gt;(values: [ 1, 2, 3, 4 ])
</span><span class='line'>        .flatMap(.Latest) { SignalProducer(value: $0 + 3) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMap(.Latest)` ---
</span><span class='line'>4
</span><span class='line'>5
</span><span class='line'>6
</span><span class='line'>7&lt;/int, noerror&gt;</span></code></pre></td></tr></table></div></figure>


<h3>flatMapError</h3>

<p>把收到的failer事件映射为新的Producer,并且摊平它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scopedExample("`flatMapError`") {
</span><span class='line'>    SignalProducer&lt;int, nserror&gt;(error: NSError(domain: "flatMapError", code: 42, userInfo: nil))
</span><span class='line'>        .flatMapError { SignalProducer&lt;int, noerror&gt;(value: $0.code) }
</span><span class='line'>        .startWithNext { value in
</span><span class='line'>            print(value)
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>--- `flatMapError` ---</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Package Manager入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men/"/>
    <updated>2016-11-11T14:09:18+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/11/swift-package-managerru-men</id>
    <content type="html"><![CDATA[<p>大部分语言都有官方的代码分配解决方案，幸好苹果也在开发替代<a href="https://cocoapods.org/">Cocoapods</a>和<a href="https://github.com/Carthage/Carthage">Carthage</a>的管理工具，<a href="https://swift.org/package-manager/#conceptual-overview">Swift Package Manager</a>(Swift包管理器，下面我们简称SPM)就是一个用来管理Swift代码的分配的官方工具，它为Swift编译系统集成了自动进行下载，编译和连接依赖的过程</p>

<p>目前，SPM还处于早起阶段，现在仅仅支持OS X和linux系统，尚不支持Ios,watchOS以及tvOS平台，但未来很大希望会支持上述平台。</p>

<h2>概念概述</h2>

<p>在swift中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外那些部分是代码是可以被访问控制的。</p>

<p>一个程序可以将它所有代码聚合到一个模块中，也可以将它作为依赖关系导入到其他模块，除了少量系统提供的模块，像OS X中的Darwin或者 Linux中的Glibc等大多数依赖需要代码被下载或者内置才能被使用。</p>

<p>当你将编写额解决待定问题的代码独立成一个模块时，这段代码可以在其他情况下呗重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的app或者一个天气的app里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。</p>

<p>一个包由Swift源文件和一个清单文件组成，这个清单文件称为<code>Package.swift</code>,定义包或者它的内容使用<code>PackageDescription</code>模块。</p>

<p>一个包邮一个或者多个目标，每个目标制定一个铲平并且可能声明一个后者多个依赖。</p>

<p>一个目标可能构建一个库或者一个可执行文件作为其产品。库是包含可以被其它Swift代码导入的模块。可执行文件是一段可以被操作系统运行的程序</p>

<p>目标依赖是指保重代码必须添加的模块。依赖由包资源的绝对或者相对URL和一些可以被使用的包的版本要求所组成。包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成一个依赖的相关图。包管理器下载和编译所需要满足整个依赖相关图的一切。</p>

<h2>开源Swift入门</h2>

<ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85Swift">下载和安装Swift</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8REPL">使用REPL</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">使用编译系统</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95%E5%99%A8">使用LLDB调试器</a></li>
</ul>


<p>关于使用REPL和LLDB调试器的内容具体可以参阅官方文档<a href="https://swift.org/getting-started/#using-the-repl">使用REPL</a>和<a href="https://swift.org/getting-started/#using-the-lldb-debugger">使用LLDB调试器</a></p>

<h2><a name = "下载和安装Swift"></a>下载和安装Swift</h2>

<p>刚开始下载和安装swift需要下载并安装编译器和其它必备组件，进入到 <a href="https://swift.org/download/#releases">https://swift.org/download/#releases</a>按目标平台的说明进行。</p>

<p>下载完成后，点击按步骤安装就可以</p>

<p>在OS X上下载工具链的默认地址是:<code>/Library/Developer/Toolchains</code>.接着，我们可以输入以下命令导出编译路径:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>首先需要安装clang:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install clang</span></code></pre></td></tr></table></div></figure>


<p>如果你在Linux上安装的Swift工具链在系统根目录以外的目录，你需要使用你安装Swift的实际路径来运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ export PATH=/path/to/Swift/usr/bin:"${PATH}"</span></code></pre></td></tr></table></div></figure>


<p>导出路径之后，你可以通过输入 swift 命令并传入 &ndash;version 标志来校验你是否运行了 Swift 的预期版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift --version
</span><span class='line'>Apple Swift version 3.0-dev (LLVM ..., Clang ..., Swift ...)</span></code></pre></td></tr></table></div></figure>


<p>在版本号的后缀 -dev 用来表明它是一个开发的编译，而不是一个发布的版本</p>

<h2><a name = "使用REPL"></a>使用REPL</h2>

<h2><a name = "使用编译系统"></a>使用编译系统</h2>

<p>Swift编译系统为编译库，可执行文件和不同工程之间共享代码提供了基本的约定。</p>

<p>创建一个新的Swift包，首先创建并进入到一个新的目录命令为Hello:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Hello
</span><span class='line'>$ cd Hello</span></code></pre></td></tr></table></div></figure>


<p>每个包在其根目录下都必须拥有一个命名为<code>Package.swift</code>清单文件，如果清单文件为空，那包管理器将会使用常规默认的方式来编译包，创建一个空的清空文件使用命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ touch Package.swift</span></code></pre></td></tr></table></div></figure>


<p>当使用默认方式时，包管理器预计将包含在Source/子目录下的所有源代码。创建方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir Sources</span></code></pre></td></tr></table></div></figure>


<h3>编译可执行文件</h3>

<p>默认方式下，目录中包含一个文件称为<code>main.swift</code>将会将文件编译成与包名称相同的二进制可执行文件。</p>

<p>在这个例子中，包将生成一个可以输出<code>hello world</code>的可执行文件为 <em>hello</em></p>

<p>在<em>Source/</em>目录下创建一个命名为<code>main.swift</code>的文件，并使用你喜欢的任意一种编译器输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>print("Hello, world!")</span></code></pre></td></tr></table></div></figure>


<p>返回到 Hello 目录中，通过运行 swift build 命令来编译包：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build</span></code></pre></td></tr></table></div></figure>


<p>当命令完成之后，编译产品将会出现在 .build 目录中。通过如下命令运行 Hello 程序:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ .build/debug/Hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<p>下一步，让我们在新的资源文件里定义一个新的方法 <code>sayHello(_:)</code>然后直接用<code>print(_:)</code>替换执行调用的内容。</p>

<h3>多了源文件协作</h3>

<p>在<code>Sources/</code>目录下创建一个新文件命名为<code>Greeter.swift</code>然后输入如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sayHello(name: String) {
</span><span class='line'>  print("Hello, \(name)!")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>sayHello(_:)</code>方法带一个单一的字符串参数，然后在前面打印一个"hello",后面跟着函数参数单词"World".</p>

<p>现在打开<code>main.swift</code>，然后替换原来的内容为下面代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if Process.arguments.count != 2 {
</span><span class='line'>    print("Usage: hello NAME")
</span><span class='line'>} else {
</span><span class='line'>    let name = Process.arguments[1]
</span><span class='line'>    sayHello(name)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>跟之前的硬编码不同，<code>main.swift</code>现在从命令行参数中读取。替代之前直接调用<code>print(_:)</code>，<code>main.swift</code>现在调用<code>sayHello(_:)</code>方法，因为这个方法是<code>Hello</code>模块的一部分，所以不需要使用到<code>import</code>语句。</p>

<p>运行<code>swift build</code>并尝试<code>Hello</code>的新版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/Hello 'whoami'</span></code></pre></td></tr></table></div></figure>


<p>目前为止，你已经能够运用开源Swift来运行一些你想要的程序了。接下来我们就可以进入正题开始入手SPM.</p>

<h3>快速入门实例</h3>

<p>在本章节中，我们简单地学会了编译一个"`Hello world"程序。</p>

<p>为了了解SPM究竟能做什么，我们来看一下下面这个由4个独立的包组成的例子:</p>

<ul>
<li><a href="https://github.com/marklin2012/O2PlayingCard.git">O2PlayingCard</a>-定义了O2PlayingCard ， O2Suit ， O2Rank ， 3个类型</li>
<li><a href="https://github.com/marklin2012/O2FisherYates.git">O2FisherYates</a>-定义了 shuffle() 和 shuffleInPlace() 方法实现的扩展</li>
<li><a href="https://github.com/marklin2012/O2DeckOfPlayingCards.git">O2DeckOfPlayingCards</a>-定义了一个 O2Deck 类型对 O2PlayingCard 值得数据进行洗牌和抽牌。</li>
<li><a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer</a>-定义了一个用来创建 O2DeckOfPlayingCards 进行洗牌和抽出前10个卡片的可执行文件。</li>
</ul>


<p>你可以从<a href="https://github.com/marklin2012/O2Dealer.git">O2Dealer from GitHub </a>编译并运行完整例子，然后运行如下命令:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd O2Dealer
</span><span class='line'>$ swift build
</span><span class='line'>$ .build/debug/O2Dealer</span></code></pre></td></tr></table></div></figure>


<h3>创建一个库包</h3>

<p>我们将从创建一个代表一副标准的52张扑克牌的模块开始。 O2PlayingCard 模块定义了 由 O2Suit 枚举值（Clubs, Diamonds, Hearts, spades）和 O2Rank 枚举值（Ace, Two, Three, …, Jack, Queen, King）组成的 O2PlayingCard 类。各个类的核心代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum O2Rank : Int {
</span><span class='line'>    case Ace = 1
</span><span class='line'>    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
</span><span class='line'>    case Jack, Queen, King
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public enum O2Suit: String {
</span><span class='line'>    case Spades, Hearts, Diamonds, Clubs
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public struct O2PlayingCard {
</span><span class='line'>    let rank: O2Rank
</span><span class='line'>    let suit: O2Suit
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，一个包包括位于Source/的源文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2PlayingCard
</span><span class='line'>├── Sources
</span><span class='line'>│   ├── O2PlayingCard.swift
</span><span class='line'>│   ├── O2Rank.swift
</span><span class='line'>│   └── O2Suit.swift
</span><span class='line'>└── Package.swift</span></code></pre></td></tr></table></div></figure>


<p>由于<code>O2PlayingCard</code>模块并不会生成可执行文件，这里应该成为库。库表示被编译成一个可以被其它包导入的模块的包，默认情况下，库模块公开所有位于<code>Sources/</code>目录下的源代码中声明的公共类型的方法。</p>

<p>运行 swift build 开始启动 Swift 编译的过程。如果一切进行顺利，将会在 .build/debug 目录下生成 O2PlayingCard.build 目录。</p>

<p>接下来，我们在<code>Package.swift</code>文件中定义包名，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>  name: "O2PlayingCard"
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>然后我们只要将<code>O2PlayingCard</code>提交到Github上，并且给他发布一个Release版本即可完成该库包，这里可以自己手动添加一个<code>.gitignore</code>文件，忽略掉<code>/.build</code>，因为我们的包是不需要包括生成的编译结果的内容的。</p>

<h2>使用编译配置语句</h2>

<p>下一个即将编译的模块是<code>O2FisherYates</code>.跟之前<code>O2PlayingCard</code>有所不同，该模块没有定义新的类，取而代之的是该模块拓展了一个已经存在的特殊的<code>CollectionType</code>和<code>MutableCollectionType</code>接口协议，用来添加<code>shuffle()</code>方法和对应的<code>shuffleInPlace()</code>方法。</p>

<p>在 OS X 中，系统模块是 Darwin , 提供的函数是 arc4random_uniform(_:) 。在 Linux 中， 系统模块是 Glibc ， 提供的函数是 random() ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#if os(Linux)
</span><span class='line'>  import Glibc
</span><span class='line'>#else
</span><span class='line'>  import Darwin.C
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>public extension Collection {
</span><span class='line'>  func shuffle() -&gt; [Generator.Element] {
</span><span class='line'>    var array = Array(self)
</span><span class='line'>    array.shuffleInPlace()
</span><span class='line'>    
</span><span class='line'>    return array
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public extension MutableCollection where Index == Int {
</span><span class='line'>  mutating func shuffleInPlace() {
</span><span class='line'>    guard count &gt; 1 else { return }
</span><span class='line'>    v 
</span><span class='line'>    for i in 0..&lt;count - 1 {
</span><span class='line'>      #if os(Linux)
</span><span class='line'>        let j = Int(random() % (count - i)) + i
</span><span class='line'>      #else
</span><span class='line'>        let j = Int(arc4random_uniform(UInt32(count - i))) + i
</span><span class='line'>      #endif
</span><span class='line'>      guard i != j else { continue }
</span><span class='line'>      swap(&self[i], &self[j])
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>剩下的步骤和前面的类似，编译通过后上传到GitHub,发布Release版本。</p>

<h3>导入依赖</h3>

<p><code>O2DeckOfPlayingCards</code>包把前两个包聚合到一起：它定义了一个<code>O2PlayingCard</code>数组中使用<code>O2FisherYates</code>的<code>shuffle()</code>方法的Deck类型。</p>

<p>为了使用 O2FisherYates 和 O2PlayingCards 模块， O2DeckOfPlayingCards 包必须在 Package.Swift 清单中将上述模块声明为依赖。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import PackageDescription
</span><span class='line'>
</span><span class='line'>let package = Package(
</span><span class='line'>    name: "O2DeckOfPlayingCards",
</span><span class='line'>    dependencies: [
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2PlayingCard.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>        .Package(url: "https://github.com/marklin2012/O2FisherYates.git",
</span><span class='line'>                 majorVersion: 1),
</span><span class='line'>    ]
</span><span class='line'>)</span></code></pre></td></tr></table></div></figure>


<p>每个依赖都需要指定一个源URL和版本号，源URL是指允许当前用户解析到对应的Git仓库。版本号遵循 <a href="http://semver.org/lang/zh-CN/">语义化版本号 2.0.0</a> 的约定,用来决定检出或者使用哪个Git标签版本来建立依赖。对于<code>FisherYates</code>和<code>PlayingCard</code>这两个依赖来说， 最新的将要被使用的主版本号为1.</p>

<p>当你运行<code>swift build</code>命令时，包管理器将会下载所有的依赖，并将它们编译成静态库，再把它们链接到包模块中。这样将会使<code>O2DeckOfPlayingCards</code>可以访问依赖import语句的模块的公共成员</p>

<p>你可以看到这些资源被下载到你工程根目录的 Packages 目录下，并且会生成编译产品在你工程根目录的 .build 目录下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>O2DeckOfPlayingcards
</span><span class='line'>├── .build
</span><span class='line'>│   └── debug
</span><span class='line'>│       ├── O2DeckOfPlayingCards.build
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftdoc
</span><span class='line'>│       ├── O2DeckOfPlayingCards.swiftmodule
</span><span class='line'>│       ├── O2FisherYates.build
</span><span class='line'>│       ├── O2FisherYates.swiftdoc
</span><span class='line'>│       ├── O2FisherYates.swiftmodule
</span><span class='line'>│       ├── O2PlayingCard.build
</span><span class='line'>│       ├── O2PlayingCard.swiftdoc
</span><span class='line'>│       └── O2PlayingCard.swiftmodule
</span><span class='line'>└── Packages
</span><span class='line'>    └── O2FisherYates-1.0.0
</span><span class='line'>    │   ├── Package.swift
</span><span class='line'>    │   ├── README.md
</span><span class='line'>    │   └── Sources
</span><span class='line'>    └── O2Playingcard-1.0.1
</span><span class='line'>        ├── Package.swift
</span><span class='line'>        ├── README.md
</span><span class='line'>        └── Sources</span></code></pre></td></tr></table></div></figure>


<p><code>Package</code>目录包含了被复制的包依赖的所有仓库，这样将使你能修改源代码并直接推送这些修改到它们的源，而不需要再对每个包在单独进行复制。</p>

<p>Swift是一门先进的语言，SPM的社区也在不断地完善中。在swift开源之后，我们很容可以看到它的潜力，看来掌握这门语言必将是一个大趋势。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的热修复]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong/"/>
    <updated>2016-11-07T16:46:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/07/ioszhong-de-re-qi-dong</id>
    <content type="html"><![CDATA[<h2>背景需求</h2>

<h3>为什么我们需要热修复</h3>

<ul>
<li>工作中容易犯错，bug难以避免</li>
<li>开发和测试人力有限</li>
<li>苹果AppStore审核周期太长，一旦出现严重bug难以快速上线新版本</li>
</ul>


<h2>JSPatch简介</h2>

<p>JSPatch诞生于2015年5月，最初是腾讯广研高级ios开发@bang的人格项目。它能够使用JavaScripit调用Objective-C的原声接口，从而动态植入代码来替换旧代码，以实现修复线上bug.</p>

<h2>JSPatch与wax对比</h2>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3d1af75ebfe7de01.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最关键的是JSpath可实现方法粒度的线上代码替换，能修复一切代码引起的bug.而Wax无法实现。</p>

<h2>JSPatch实现原理</h2>

<h3>基础原理</h3>

<p>Objective-C是动态语言，具有运行时特性，该特性可通过类名称和方法名的字符换获取该类和该方法，并实例化调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class class = NSClassFromString(“UIViewController");
</span><span class='line'>id viewController = [[class alloc] init];  
</span><span class='line'>SEL selector = NSSelectorFromString(“viewDidLoad");
</span><span class='line'>[viewController performSelector:selector];</span></code></pre></td></tr></table></div></figure>


<p>也可以替换某个类的方法为新的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void newViewDidLoad(id slf, SEL sel) {}
</span><span class='line'>class_replaceMethod(class, selector, newViewDidLoad, @"");</span></code></pre></td></tr></table></div></figure>


<p>还可以注册一个类，为类添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Class cls = objc_allocateClassPair(superCls, "JPObject", 0);
</span><span class='line'>objc_registerClassPair(cls);
</span><span class='line'>class_addMethod(cls, selector, implement, typedesc);</span></code></pre></td></tr></table></div></figure>


<h3>JavaScript调用</h3>

<p>我们可以用JavaScript对象定义一个Objective-C类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  __isCls: 1,
</span><span class='line'>  __clsName: "UIView"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在OC执行JS脚本前，通过正则把所有方法调用都改成__c()函数，再执行这个JS脚本，做到了类似OC/Lua/Ruby等的消息转发机制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIView.alloc().init()
</span><span class='line'>-&gt;
</span><span class='line'>UIView.__c('alloc')().__c('init')()</span></code></pre></td></tr></table></div></figure>


<p>给JS对象基类Object的prototype加上c成员，这样所有对象都可以调用到c,根据当前对象类型判断进行不同操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Object.prototype.__c = function(methodName) {
</span><span class='line'>  if (!this.__obj && !this.__clsName) return this[methodName].bind(this);
</span><span class='line'>  var self = this
</span><span class='line'>  return function(){
</span><span class='line'>    var args = Array.prototype.slice.call(arguments)
</span><span class='line'>    return _methodFunc(self.__obj, self.__clsName, methodName, args, self.__isSuper)
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>互传消息</h2>

<p>JS和OC是通过JavaScriptCore互传消息的。OC端在启动JSPatch引擎会创建一个JSContext实例，JSContext是js代码的执行环境，可以给JSContext添加方法。JS通过调用JSContext定义的方法把数据传给OC,OC通过返回值传回给JS.调用这种方法，它的参数/返回值 javaScripotCore都会自动转换，OC里的NSArray,NSdictionary
,NSString,NSNumber,NSBlock会分别转为JS端的数组/对象/字符串/数字/函数类型  对于一个自定义ID对象，JavaScriptCore会把这个自定义对象的指针传给JS,这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象声明周期的管理，如果JS有变量引用时，这个OC对象引用计数就加1，JS变量的引用释放了就减一，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。</p>

<h2>方法替换</h2>

<ol>
<li>把UIViewContrller的 <code>-viewWillAppear:</code>方法通过<code>class_replaceMethod()</code>接口指向<code>_objc_msgForward</code>,这是一个全局IMP,OC调用方法不存在时都会转发到这个IMP上，这里直接把方法替换成这个IMP,这样调用这个方法时就会走到<code>-forwardInvocation:</code></li>
<li>为UIViewController添加<code>-ORIGviewWillAppear:</code>和<code>-_JPviewWillAppear:</code>两个方法，前者指向原来的IMP实现，后者是新的实现，稍后会在这个实现里回调JS函数</li>
<li>改写UIViewController的<code>-forwardInvocation:</code>方法为自定义实现。一旦OC里调用UIViewController的<code>-viewWillAppear:</code>方法，经过上面的处理会把这个调用转发到<code>forwardInvocation:</code>，这时已经组装好了一个NSInvocation,包含了这个调用的参数。在这里把参数从NSInvocation反解出来，待着参数调用删除新增加的方法<code>-JPviewWillAppear:</code>,在这个新方法里获取到参数传给JS,调用JS的实现函数，整个调用过程就结束了，整个过程图示如下：</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-d079409a185f394c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>最后一个问题，我们把UIViewController的<code>-forwardInvocation:</code>方法的实现给替换掉了，如果程序里挣得有用到这个方法对消息进行转发，原来的逻辑怎么办？首先我们在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现了做个判断，如果转发的方法是我们想改写的，就走我们的逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程</p>

<h2>JSPatch代码示例</h2>

<p>jspatch在oc上的调用十分简单</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { 
</span><span class='line'>[JPEngine startEngine]; 
</span><span class='line'>NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@"demo" ofType:@"js"]; 
</span><span class='line'>NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; 
</span><span class='line'>[JPEngine evaluateScript:script];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>一个JavaScript修复Objective-C的bug的示例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@implementation JPTableViewController
</span><span class='line'>
</span><span class='line'>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>  NSString *content = self.dataSource[[indexPath row]];  //可能会超出数组范围导致crash
</span><span class='line'>  JPViewController *ctrl = [[JPViewController alloc] initWithContent:content];
</span><span class='line'>  [self.navigationController pushViewController:ctrl];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上述代码中取数组元素出可能会超出数组范围导致crash.如果在项目里引用了JSPatch,就可以发JS脚本修复这个bug:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defineClass("JPTableViewController", {
</span><span class='line'>  tableView_didSelectRowAtIndexPath: function(tableView, indexPath) {
</span><span class='line'>    var row = indexPath.row()
</span><span class='line'>    if (self.dataSource().length &gt; row) {  //加上判断越界的逻辑
</span><span class='line'>      var content = self.dataArr()[row];
</span><span class='line'>      var ctrl = JPViewController.alloc().initWithContent(content);
</span><span class='line'>      self.navigationController().pushViewController(ctrl);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}, {})</span></code></pre></td></tr></table></div></figure>


<h2>热修复的解决方案</h2>

<ol>
<li><p>版本更新策略</p></li>
<li><p>考虑到下一个提交的App版本已经修复了上一个版本的bug,所以不同的App版本对应的补丁肯定也不同，同一个App版本下，可以出现递增的补丁版本</p></li>
<li>补丁为全量更新，即最新的版本补丁包括旧版的补丁的内容，更新后新版补丁覆盖旧版补丁</li>
<li>补丁分为可选补丁和必选补丁，必选补丁用于重大bug的修复，如果不更新必须补丁则App无法继续使用。如下图2中，补丁版本v1234对应各自版本的用户，补丁v3为必须更新，补丁v1,v2,v4为可选补丁，则v1,v2必须更新到v4才可使用；而v3的哟过户可先使用，同事后台静默更新到v4</li>
</ol>


<h2>安全策略</h2>

<p>安全问题在于JS脚本可能被中间人攻击替换代码。可采取一下三种方法</p>

<ol>
<li>对称加密： 如zip的加密压缩，Aes等加密算法。优点是简单，缺点是安全性低，易被破解。若客户端被反编译，密码字段泄露，则完全破解。</li>
<li><a href="HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82">HTTPS:%E4%BC%98%E7%82%B9%E6%98%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98%EF%BC%8C%E8%AF%81%E4%B9%A6%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E7%BC%BA%E7%82%B9%E6%98%AF%E9%83%A8%E7%BD%B2%E9%BA%BB%E7%83%A6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AC%E6%9D%A5%E5%B0%B1%E6%94%AF%E6%8C%81Https,%E4%BD%BF%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E4%B8%8D%E9%94%99%E7%9A%84%E9%80%89%E6%8B%A9%E3%80%82</a></li>
<li>RSA校验：安全性高，部署简单</li>
</ol>


<p><img src="http://upload-images.jianshu.io/upload_images/611240-14723080a9823ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<p>详细校验步骤如下：</p>

<ol>
<li>服务器计算出脚本文件的MD5值，作为这个文件的数字签名</li>
<li>服务器通过私钥加密算出的MD5值，得到一个加密后的md5值</li>
<li>把脚本文件和加密后的md5值一起发给客户端</li>
<li>客户端拿到加密后的md5值，通过保存在客户端的公钥解密</li>
<li>客户端计算脚本文件的md5值</li>
<li>对比第 4/5 步的两个md5值(分别是客户端和服务器端计算出来的MD5值)，若相等则通过校验</li>
</ol>


<h2>客户端策略</h2>

<p>客户端具体策略如下图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/611240-3f5d0d89e0b3833d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1" /></p>

<ol>
<li>用户打开App时，同步进行本地补丁的加载</li>
<li>用户打开App时，后台进程发起异步网络请求，获取服务器中当前App版本所对应的最新补丁版本和必须的补丁版本</li>
<li>获取补丁版本的请求回来后，跟本地的补丁版本进行对比</li>
<li>如果本地补丁版本小于必须版本，则提示用户，展示下载补丁界面，进行进程同步的补丁下载。下载完成后重新加载App和最新补丁，再进入App</li>
<li>如果本地补丁版本不小于必须版本，但小于最新版本，则进入App,不影响用户操作。同时进行后台进程异步静默下载，下载后补丁保存在本地，下次App启动时再加载最新补丁。</li>
<li>如果版本为最新，则进入App</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中常见的面试题二]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er/"/>
    <updated>2016-11-04T20:22:42+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/04/ioszhong-chang-jian-de-mian-shi-ti-er</id>
    <content type="html"><![CDATA[<h2>如何进行真机调试</h2>

<ol>
<li>首先需要钥匙串创建一个钥匙(key)</li>
<li>将钥匙串上传到官网，获取ios Development证书</li>
<li>创建APP Id即我们应用程序中的BundleId</li>
<li>添加Device ID 即 UDID;</li>
<li>通过勾选前面所创建的证书：App ID, Deveice id</li>
<li>生成mobileProvision文件</li>
<li>先决条件：申请开发者账号 99美刀</li>
</ol>


<!--more-->


<h2>APP发布上架流程</h2>

<ol>
<li>登录苹果开发者网站</li>
<li>下载安装发布证书</li>
<li>选择发布证书，使用Archive编译发布包，用Xcode将代码上传到服务器</li>
<li>等待审核</li>
<li>生成ipa->菜单栏->Product->Archive</li>
</ol>


<h2>如何发送通知</h2>

<ul>
<li>一种是Apple自己提供的通知服务（APNS服务器），一种是用第三方推送机制</li>
<li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器请求deviceToken,并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用</li>
<li>推送信息内容，总容量不超过256个字节</li>
<li>iOSSDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示</li>
</ul>


<p>优点：不论应用是否开启，都会发送到手机端</p>

<p>缺点：消息推送机制是苹果服务器端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；</p>

<ul>
<li>第三方推送机制,普遍使用Socket机制来实现，几乎可以达到即时发送到目标用户手机端，适用于即时通讯类应用。</li>
</ul>


<p>优点：实时的，取决于心跳包的节凑</p>

<p>缺点：IOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用</p>

<h2>网络七层协议</h2>

<ul>
<li>应用层：

<ol>
<li>用户接口，应用程序</li>
<li>Application典型设备:网关；</li>
<li>典型协议，标准和应用：TELNET,FTP,HTTP</li>
</ol>
</li>
<li>表示层：

<ol>
<li>数据表示，压缩和加密presentation</li>
<li>典型设备:网关</li>
<li>典型协议，标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG</li>
<li>表示层相当于一个东西的表示，表示的一些协议，比如图片，声音和视频MPEG</li>
</ol>
</li>
<li>会话层：

<ol>
<li>会话的建立和结束；</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</li>
</ol>
</li>
<li>传输层：

<ol>
<li>主要功能：端到端控制Transport;</li>
<li>典型设备：网关；</li>
<li>典型协议，标准和应用：TCP，UDP，spx</li>
</ol>
</li>
<li>网络层：

<ol>
<li>主要功能：路由，寻址Network</li>
<li>典型设备:路由器</li>
<li>典型协议，标准和应用：IP,IPX,APPLETALK,ICMP</li>
</ol>
</li>
<li><p>数据链路层：</p>

<ol>
<li>主要功能：保证无差错的疏忽链路 data link;</li>
<li>典型设备：交换机，网桥，网卡</li>
<li>典型协议，标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li>
</ol>
</li>
<li>物理层：

<ol>
<li>主要功能：传输比特流Physical</li>
<li>典型设备：集线器，中继器</li>
<li>典型协议，标准和应用：V.35、EIA/TIA-232.</li>
</ol>
</li>
</ul>


<h2>对NSUserDefualts的理解</h2>

<ul>
<li>NSUserDefaults：系统提供的一种存储数据的方式，主要用户保存少量的数据，默认存储到library下的Preferences文件夹</li>
</ul>


<h2>LayoutSubViews在什么时候被调用</h2>

<p>当View本身的frame改变时，会调用这个方法</p>

<h2>单例模式理解与使用</h2>

<ul>
<li>单例模式是一种常用的设计模式，单利模式是一个类在系统中只有一个实例对象。通过全局的一个入口点对这个实例对象进行访问</li>
<li>iOS中单例模式的实现方式一般分为两种：非ARC和ARC+GCD</li>
</ul>


<h2>对沙盒的理解</h2>

<ul>
<li><p>每个ios应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，及时在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录，苹果对沙盒有几条限制：</p></li>
<li><p>应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序沙盒</p></li>
<li>应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中</li>
<li>苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；</li>
<li>沙盒目录里有三个文件夹：Documents——存储应用程序的数据文件，存储用户数据或其他定期备份的信息；Library下有两个文件夹，Caches存储应用程序再次启动所需的信息，
Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；
temp存放临时文件即应用程序再次启动不需要的文件</li>
</ul>


<h2>对瀑布流的理解</h2>

<ul>
<li>首先图片的宽度都是一样的

<ol>
<li>将图片等比例压缩，让图片不变形</li>
<li>计算图片最低应该摆放的位置，那一列低就放在哪</li>
<li>进行最优排列，在ScrollView的基础上添加两个tableView,然后将之前所计算的scrollView的高度通过tableView展示出来</li>
</ol>
</li>
<li>如何使用两个TableView产生联动：将两个TableView的滚动事件禁止掉，最外层的ScrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableview.</li>
</ul>


<h2>ViewController 的loadView,viewDidLoad,viewDidUnload 分别是在什么时候调用的？</h2>

<ul>
<li>viewDidLoad在View从nib文件初始化时调用，loadView在controller的View为nil时调用</li>
<li>此方法在编程实现view时调用，View控制器默认会注册memory warning notification,当view controller的任何View没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release，如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。</li>
</ul>


<h2>@synthesize、@dynamic的理解</h2>

<ul>
<li>@synthesize 是系统自动生成getter和setter属性声明；@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明</li>
<li>@dynamic是开发者自己提供相应的属性声明，@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter,对于读写属性需要提供setter和getter,查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。</li>
</ul>


<p>主要使用在CoreData的实现NSManagedObject子类时使用，由Core Data框架在程序运行动态生成子类属性</p>

<h2>Frame和bounds有什么不同？</h2>

<ul>
<li>frame指的是：该View在父view坐标系统中的位置和大小（参照点是父亲的坐标系统）</li>
<li>bounds指的是：该View在本身坐标系统中的位置和大小（参照点是本身坐标系统）</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-3.png" alt="1" /></p>

<h2>iOS中的响应者链的工作原理</h2>

<ul>
<li>每一个应用有一个响应者链，我们的视图结构是一个N叉树（一个视图可以有多个子视图，一个子视图同一时刻只有一个父亲视图），而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点</li>
<li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追溯出一条链，那么对于这个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶子节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发</li>
</ul>


<h2>Property属性的修饰符的作用</h2>

<ul>
<li>getter=getName、setter=setName：设置setter与getter的方法名；</li>
<li>readwrite,readonly:设置可供访问的级别</li>
<li>assign:方法直接赋值，不进行任何retain操作，为了解决原类型与循环引用问题</li>
<li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序</li>
<li>copy:其setter方法进行copy操作，与retain 处理流程一样，先对旧值release,再copy出新的对象，retaincount为1,这是为了减少对上下文的依赖而引入的机制</li>
<li>nonatomic:非原子性访问，不加同步，多线程并发访问会提供性能。注意，如果不加此属性，则默认是两个访问方法都是原子型事务访问</li>
</ul>


<h2>对Run Loop的理解</h2>

<ul>
<li>RUNLOOP，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程，主线程执行完即时任务时会继续等待接收事件而不退出，非主线程同城来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li>
<li>每一个线程都有其对应的RunLoop,只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动</li>
<li>在一个单独的线程中，如果需要在处理完某个人物后不退出，继续等待接收事件，则需要启用RunLoop</li>
<li>NSRunLoop提供了一个添加NStimer的方法，可以指定Mode,如果要让任何情况下都回调，则需要设置Mode为Common模式</li>
<li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载方式，如果我们没有东东调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop,也就不会去加载，更不会创建</li>
</ul>


<h2>XIB与Storyboards的优缺点</h2>

<p>优点:</p>

<ul>
<li><p>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类</p></li>
<li><p>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。</p></li>
</ul>


<p><em>缺点:</em></p>

<ul>
<li>XIB:需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li>
<li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li>
</ul>


<h2>队列和多线程的使用原理</h2>

<p>在iOS中队列分为以下几种：</p>

<ul>
<li>串行队列：队列中的任务只会顺序执行</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("...", DISPATCH_QUEUE_SERIAL);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>并行队列：对垒中的任务通常会并发执行：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_queue_create("......",DISPATCH_QUEUE_CONCURRENT);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>全局队列：是系统的，直接拿过来(get)用就可以，与并行队列类似：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>主队列：每一个应用程序对应唯一主队列，直接GET就行，在多线程开发中，使用祝队列更新UI：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t q = dispatch_get_main_queue();
</span></code></pre></td></tr></table></div></figure>


<p>如图：
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/1771779-da221054beb5cbb4.png" alt="1" />
 </p>

<h2>内存的使用和优化的注意事项</h2>

<ul>
<li>重用问题：如UITableViewCells,UICollectionViewCells, UITableViewHeaderFooterViews设置正确的reuseIdentifier,充分重用；</li>
<li>尽量把views设置为不透明，当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能</li>
<li>不要使用太复杂的XIB/StroyBoard;载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用，那些相比纯代码写的延迟加载，性能及内存就差了很多</li>
<li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出搞笑代码的基础，比如，数组：有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。存储键值对，用键来查找比较快。集合：无需的一组值，用值来查找很快，插入/删除很快；</li>
<li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li>
<li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载</li>
<li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储</li>
<li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉。重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建</li>
<li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li>
<li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li>
</ul>


<h2>UIViewController的完整生命周期</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[ViewController initWithNibName:bundle:]；
</span><span class='line'>-[ViewController init]；
</span><span class='line'>-[ViewController loadView]；
</span><span class='line'>-[ViewController viewDidLoad]；
</span><span class='line'>-[ViewController viewWillDisappear:]；
</span><span class='line'>-[ViewController viewWillAppear:]；
</span><span class='line'>-[ViewController viewDidAppear:]；
</span><span class='line'>-[ViewController viewDidDisappear:]；</span></code></pre></td></tr></table></div></figure>


<h2>UIImageView添加圆角</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>imgView.layer.cornerRadius = 10;// 这一行代码是很消耗性能的imgView.clipsToBounds = YES;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><em>这是离屏渲染（off-screen-rendering），消耗性能的</em></li>
<li>扩展:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UIImage *)imageWithCornerRadius:(CGFloat)radius {
</span><span class='line'>CGRect rect = (CGRect){0.f, 0.f, self.size};
</span><span class='line'>
</span><span class='line'>UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale);CGContextAddPath(UIGraphicsGetCurrentContext(),
</span><span class='line'> [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);CGContextClip(UIGraphicsGetCurrentContext());
</span><span class='line'>
</span><span class='line'>[self drawInRect:rect];
</span><span class='line'>UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
</span><span class='line'>UIGraphicsEndImageContext();
</span><span class='line'>
</span><span class='line'>return image;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中常见的面试题及答案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an/"/>
    <updated>2016-11-03T17:50:01+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/11/03/ioszhong-chang-jian-de-mian-shi-ti-ji-da-an</id>
    <content type="html"><![CDATA[<h2>ios中深拷贝和浅拷贝</h2>

<p>在ios开发中，经常涉及到深拷贝和浅拷贝的问题，针对深拷贝和浅拷贝，为了方便大家的理解，专门总结如下:</p>

<!--more-->


<ul>
<li>理解1</li>
</ul>


<p>浅拷贝是拷贝操作后，并没有进行真正的复制，而是另一个指针也指向了同一个地址。深拷贝，拷贝操作后，是真正的复制了一份，另一个指针指向了拷贝后的地址。如下图：A代表原有的指针，B代表拷贝的指针。（图一为浅拷贝，图二为深拷贝）</p>

<p><img src="http://img.blog.csdn.net/20141218004439540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="1" /></p>

<p><img src="http://img.blog.csdn.net/20141218004554327?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NkbkFhcm9u/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="2" /></p>

<p>从上图中可以看到，浅拷贝（浅复制）中如果其中A指针改变了所指向的地址的内容，那么B指针也指向了被修改的内容，如果有些地方用到B指针，即便A指向的内容发生变化，也不希望B收到影响，则需要用深拷贝，真正复制一份A指向的内容，B指向复制后的值，这样即使A指向的内容变化了，B也不会产生影响。好比：浅复制好比你的影子，你完蛋，你的影子也完蛋。深复制好比你和你的克隆人，你完蛋，你的克隆人依然活着。</p>

<ul>
<li>理解2</li>
</ul>


<p>深拷贝和浅拷贝的本质是地址相同，就是浅拷贝，地址不同就是深拷贝。</p>

<p>iOS开发过程中，大体上会区分为对象和容器两个概念，对象的copy是浅拷贝，mutableCopy是深拷贝。容器也参照如上方法，但是需要记住，容器的包含对象的拷贝,无论使用copy,还是mutableCopy都将是浅拷贝，想要实现对象的深拷贝，必须自己提供拷贝的方法。</p>

<ul>
<li>理解3</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
</span><span class='line'> NSMutableArray *array1=[array copy];        
</span><span class='line'>[array1 addObject:@"three"];  </span></code></pre></td></tr></table></div></figure>


<p>//这段代码是错误的，array1通过copy进行的是浅拷贝，即并没有真正复制array，而是也指向了array,此时array是不可变数组，无法进行新数据的添加</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *array=[NSArray arrayWithObjects:@"one",@"two", nil];       
</span><span class='line'>NSMutableArray *array2=[array mutableCopy];        
</span><span class='line'>[array2 addObject:@"three"];  </span></code></pre></td></tr></table></div></figure>


<p>这段代码是正确的，array2通过mutableCopy进行的是深拷贝，即把array真正复制了一份，并且复制后，变味了NSMutableArray,此时array2是可变数组，可以添加数据</p>

<blockquote><p>注意点:<em>(1)</em> 当使用mutableCopy时，不管源对象是否可变，副本是可变的，并且实现真正意义上的拷贝。当我们使用copy一个可变对象时，副本对象是不可变的。</p>

<p><em>(2)</em>要想实现对象的自定义拷贝，必须实现NSCopying,NSMutableCopying协议，实现该协议的copyWithZone方法和mutableCopyWithZone方法。深拷贝和浅拷贝的区别就在于copyWithZone方法的实现。</p></blockquote>

<h2>NSString属性什么时候用copy,什么时候用Strong?</h2>

<p>我们定义一个类，并且为其声明两个字符串属性，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface TestStringClass ()
</span><span class='line'>@property (nonatomic, strong) NSString *strongString;
</span><span class='line'>@property (nonatomic, copy) NSString *copyedString;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>上面的代码声明了两个字符串属性，其中一个内存特性是strong,一个是copy.下面我们来看看它们的区别。</p>

<p>首先，我们用一个不可变字符串来为这两个属性赋值,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)test {
</span><span class='line'>    NSString *string = [NSString stringWithFormat:@"abc"];
</span><span class='line'>    self.strongString = string;
</span><span class='line'>    self.copyedString = string;
</span><span class='line'>    NSLog(@"origin string: %p, %p", string, &string);
</span><span class='line'>    NSLog(@"strong string: %p, %p", _strongString, &_strongString);
</span><span class='line'>    NSLog(@"copy string: %p, %p", _copyedString, &_copyedString);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>输出结果为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>origin string: 0x7fe441592e20, 0x7fff57519a48
</span><span class='line'>strong string: 0x7fe441592e20, 0x7fe44159e1f8
</span><span class='line'>copy string: 0x7fe441592e20, 0x7fe44159e200</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，这种情况下，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string执行的地址，如果我们换做MRC环境，打印string的引用计数的话，会看到其引用计数是3,即String操作和copy做做都使原字符串对象的引用计数值+1.</p>

<p>接下来，我们把string由不可变改为可变对象，看看会是什么结果，即将下面这一句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *string = [NSString stringWithFormat:@"abc"];</span></code></pre></td></tr></table></div></figure>


<p>改成:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableString *string = [NSMutableString stringWithFormat:@"abc"];</span></code></pre></td></tr></table></div></figure>


<p>其输出结果为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>origin string: 0x7ff5f2e33c90, 0x7fff59937a48
</span><span class='line'>strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8
</span><span class='line'>copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</span></code></pre></td></tr></table></div></figure>


<p>可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让<em>copyedString对象指向这个字符串，在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而</em>copyedString的引用计数是1</p>

<p>此时，我们如果去修改string字符串的话，可以看到：因为<em>strongString和string都是指向同一个对象，所以</em>strongString的值会跟随者改变（需要注意的是，此时 <em>strongString 的类型实际上是NSmutableString,而不是NSString）而</em>copyedString指向的是另一个对象，所以并不会改变。</p>

<h3>结论</h3>

<p>由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的StrongString指针指向一个可变字符串是OK的。</p>

<p>而上面的例子可以看得出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是Strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>

<p>当源字符串是NSMUtableSring时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生了一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString,而不是NSMutableString,因此其实不可变的。</p>

<p>这里还有一个性能问题，即在源字符串是NSMutableString,strong是单纯的增加对象的引用计数，而copy操作是智行了一次深拷贝，所以性能上会有所差异，而如果源字符串是NSString时，则没有这个问题。</p>

<h2>OC的理解和特性</h2>

<ul>
<li>OC 作为一门面向对象的语言，自然具有面向对象的语言特性：封装，继承，多台，它既有静态语言的特性（如C++），又有动态语言的效率（动态绑定，动态加载）。总体来讲，OC确实是一门不错的编程语言</li>
<li><p>OC具有相当多的动态特性，表现为三个方面：动态类型（Dynamic typing）,动态绑定(Dynamic binding)和动态加载(Dynamic loading).动态-必须运行时（run time）才会做的事情</p></li>
<li><p>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单说就是id类型，事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛，静态类型是强类型，而动态类型属于弱类型，运行时决定接受者</p></li>
<li>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对对那个的属性和响应消息也被完全确定。</li>
<li>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retain设备上加载@2x的图片，而在老一些的普通苹果设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类</li>
</ul>


<h2>简述内存管理的基本原则</h2>

<ul>
<li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建活引用一个对象的时候，需要向它发送alloc,copy,retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制(MRC)</li>
<li>目前：ios5之后引用自动管理机制-自动引用计数（ARC），管理机制和手动机制一样，只是不再需要调用retain,release,autorelease,它编译时的特性，当你使用arc时，在适当位置插入release和 autorelease;它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针比那两指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动设置为nil</li>
<li>如果使用alloc,copy(mutableCopy)或者retain一个对象时，你就有义务向它发送一条release或者autorelease消息，其它方法创建的对象，不需要由你来管理内存。</li>
<li>向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池子中每个对象发送一条release消息，以此来释放对象</li>
<li>向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法，释放该对象和对象本身所拥有的实例。</li>
</ul>


<h2>其它注意事项</h2>

<ul>
<li>如果一个对象有一个<em>Strong类型的指针指向着，找个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil.如果一个指针被指向nil,那么它原来指向的对象就被释放了，当一个视图控制器被释放时，它内部的全部指针会被指向nil.&ldquo;不管是全局变量还是局部变量用</em>Strong描述就行&rdquo;</li>
<li>局部变量：出了作用域，指针会被设置为nil</li>
<li>方法内部创建对象，外部使用需要添加_autorelease</li>
<li>连线的时候，用_weak描述</li>
<li>代理使用unsafe_unretained就相当于assign</li>
<li>block中为了避免循环引用问题，使用_weak描述</li>
<li>声明属性时，不要以new开头，如果非要以new开头命名属性的名字，需要自己定制get方法名，如</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(getter=theString) NSString * newString;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果要使用自动释放池，用@autoreleasepool{}</li>
<li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成Core Foundation中的变量需要交换管理权</li>
<li>在非ARC工程中采用ARC去编译某些类:<code>-fobjc-arc</code></li>
<li>在ARC工程下采用非ARC去比哪一某些类:<code>-fno-fobjc-arc</code></li>
</ul>


<h2>如何理解MVC设计模式</h2>

<p>mvc是一种架构模式，M表示Model，V表示视图View,C表示控制器Controller:
* Model负责存储，定义，操作数据
* View用来展示数据，和用户进行交互
* Controller是Model和View的协调者，Controller把MOdel中的数据拿过来给View用，Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，Model也要与Controller进行通信，这个时候要用Notification和KVO,这个方式就像一个广播一样，Model刚发送信号，Contrller设置坚挺接受信号，当有数据更新时就发信号给Controller,Model和View不能直接进行通信，这样会违背MVC设计模式</p>

<h2>如何理解MVVM设计模式</h2>

<ul>
<li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其它业务逻辑处理极好的地方，说白了，就是把原来ViewCOntroller层的业务逻辑和页面逻辑等剥离出来放到ViewModel层</li>
<li>View层，就是ViewController层，它的任务就是从ViewModel层获取数据，然后显示</li>
</ul>


<h2>Objective-C 中是否支持垃圾回收机制？</h2>

<ul>
<li>OC是支持垃圾回收机制的,但是Apple的移动终端中，是不支持GC的，Mac桌面系统开发中是支持的。</li>
<li>移动端开发是支持ARC的，ARC是在ios5之后推出的新技术，它与GC机制是不同的，我们在编写代码时，不需要想对象发送release或者autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release消息，ARC的特点是自动引用计数简化了内存管理的难度</li>
</ul>


<h2>ARC下Assign和weak的区别</h2>

<p>weak比assign对了一个功能就是当属性所指向的对象消失的时候（也就是内存引用计数为0）会自动赋值nil,这个再向weak修饰的属性发送消息就不会导致野指针操作crash.</p>

<p>在arc模式下编程时，指针变量一定要用weak修饰，只有基本数据类型和结构体需要用assign，例如delegate,一定要用weak修饰。</p>

<ul>
<li>区别：如果用weak声明的变量在栈中就会自动清空，赋值为nil，如果用assign声明的变量在栈中可能不会自动赋值为nil,就会造成野指针错误</li>
</ul>


<h2>协议的基本概念和协议中方法默认什么类型</h2>

<p>OC中的协议是一个方法列表。它的特点是可以被任何类使用（实现），但它并不是类，自身不会实现这样方法，而是有其它人来实现协议，经常用来实现委托对象，如果一个类采用了一个协议，那么它必须实现协议中必须需要实现的方法，在协议中的方法默认是必须实现的（@required）,添加关键字@optional,表明一旦采用该协议，这些可选的方法是可以不实现的</p>

<h2>简述类目Category的有点和缺点</h2>

<h3>优点</h3>

<ul>
<li>不需要通过增加子类而增加现有类的行为或方法，且类目中的方法与原始类方法基本没有区别：</li>
<li>通过类目可以将庞大的一个类的方法进行划分，从而便于代码的日后的维护，更新及提高代码的阅读性</li>
</ul>


<h3>缺点</h3>

<ul>
<li>无法向类目中添加实例变量，如果需要添加实例变量，只能通过定义子类的方式</li>
<li>类目中的方法与原始类以及父类方法相比具有更高优先级，如果覆盖弗雷的方法，可能导致super消息的断裂，因此，最好不要覆盖原始类中的方法。</li>
</ul>


<h2>循环引用产生额原因，以及解决方法</h2>

<ul>
<li>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减去1.对象A的销毁依赖于对象B的销毁，同事对象B销毁也依赖于对象A的销毁，从而形成了循环引用，此时，即使外界没有任何指针访问它，它也无法释放。
<img src="http://devstorepic.qiniudn.com/FvDA-QQdrUBpndLKOmJgy6-vqM0F" alt="2" /></li>
</ul>


<p>对个对象之间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：</p>

<p><img src="http://devstorepic.qiniudn.com/Fk4cV48OjN9tUl-lDiU_ap5WWGUl" alt="1" /></p>

<h3>解决方法</h3>

<ul>
<li>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，让对象回收</li>
<li>使用weak声明</li>
</ul>


<h2>键路径(keyPath),键值编码(KVC),键值观察(KVO)</h2>

<h3>键路径</h3>

<ul>
<li>在一个给定的实体中，同一个属性的所有值具有相同的数据类型</li>
<li>键-值编码技术用于进行这样的查找-它是一种间接访问对象属性的机制。键路径是一个由点做分隔符组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的，接下来每个键的值也是相对于前面的性质</li>
<li><p>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相关对象的特定属性</p>

<h3>键值编码KVC</h3></li>
<li><p>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取的方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</p></li>
<li>KVC的缺点：一旦使用KVC，你的编译器无法检查出错误，即不会对设置的键，键路径进行错误检查，且执行效率要地域合成存取器方法和自定的setter和getter方法，因为使用KVC键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量

<h3>键值观察KVO</h3></li>
<li>键值观察机制是一种能使的对象获取到其他对象属性变化的通知，极大的简化了代码</li>
<li>实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到，因此，KVC是KVO的基础</li>
</ul>


<h3>Demo</h3>

<p>比如我自定义一个Button</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self addObserver:self forKeyPath:@"highlighted" options:0 context:nil]; #pragma mark KVO 
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { 
</span><span class='line'>     if ([keyPath isEqualToString:@"highlighted"] ) { 
</span><span class='line'>      [self setNeedsDisplay]; } 
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和KVC机制的道理是一样的。</p>

<h3>KVC机制通过key找到value的原理</h3>

<ul>
<li>当通过KVC调用对象时，比如：<code>[self valueForKey:@”someKey”]</code>,程序会自动视图通过下面几种不同的方式解析这个调用。</li>
<li>首先查找对象是否带有somekey这个方法，如果没找到，会继续查找对象是否带有somekey这个实例变量，如果还没有找到，程序会继续视图调用<code>-(id) valueForUndefinedKey:</code>这个方法，如果这个方法还是没有被实现的话，程序会抛出一个<code>NSUndefinedKeyException</code>错误</li>
<li>补充：KVC在查找方法的时候，不仅会超照somekey这个方法，还会查找getsomeKey这个方法，前面加一个get,或者<em>someKey以</em>getsomeKey这几种形式，同时，查找实例变量的时候也会不仅仅查找somekey这个变量，也会查找_someKey这个变量是否存在</li>
<li>设计<code>valueForUndefinedKey</code>方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li>
</ul>


<h2>在Objective-C中如何实现KVO</h2>

<ul>
<li>注册观察者（注意：观察者和被观察者不会被保留也不会被释放）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 
</span><span class='line'>options:(NSKeyValueObservingOptions)options 
</span><span class='line'>context:(void *)context;
</span><span class='line'>
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath 
</span><span class='line'>ofObject:(id)object change:(NSDictionary *)change   context:(void *)context;
</span><span class='line'>
</span><span class='line'>- (void)removeObserver:(NSObject *)observer 
</span><span class='line'>forKeyPath:(NSString *)keyPath;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>KVO 中谁要监听谁注册，然后响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性都是通过NSString来查找，编译器不会检错和补位，全部取决于自己</li>
</ul>


<h2>代理的作用</h2>

<ul>
<li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性</li>
<li>改变或传递控制链，允许一个类在某些特定时刻通知到其他类，而不需要获取到哪些类的指针，可以减少框架的复杂度</li>
<li>另外一点，代理可以理解为java中回调监听机制的一种类似</li>
<li>代理的属性常常是assign的原因：防止循环引用，以至于对象无法得到正确的释放</li>
</ul>


<h2>NSNotification、Block、Delegate和KVO的区别</h2>

<ul>
<li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知</li>
<li>效率：Delegate比NSNotification高</li>
<li>Delegate和Block一般是一对一的通信</li>
<li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信</li>
<li>Block:Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate;</li>
</ul>


<h2>Objective-C中可修改和不可修改类型</h2>

<ul>
<li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改</li>
<li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不变的，而后者可以添加修改等，可以动态申请的内存空间</li>
</ul>


<h2>当我们调用一个静态方法时，需要对对象进行release吗？</h2>

<p>不需要，静态方法（类方法）创建一个对象时，对象已被放入自动释放池。在自定释放池被释放时，很有可能被销毁</p>

<h2>当我们释放我们的对象时，为什么需要调用[super dealloc]方法，它的位置又是如何的呢？</h2>

<ul>
<li>因为子类的某些实例是继承自父类的，因此需要调用<code>[super dealloc]</code>方法，来释放父类拥有的实例，其实也就是子类本身的，一般来说我们优先释放子类拥有的实例，最后释放父类所拥有的实例</li>
</ul>


<h2>对谓词的认识</h2>

<ul>
<li>Cocoa中提供乐意一个<code>NSPredicate</code>类，该类主要用于指定过滤器的条件，每一个对象通过谓词进行筛选，判断条件是否匹配</li>
</ul>


<h2>static，self，super关键字的作用</h2>

<ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配了一次，因此其值在下次调用时扔维持上次的值</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问</li>
<li>在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明</li>
<li>在类中的static成员变量属于整个类所拥有过，对类的所有对象只有一份拷贝</li>
<li>self：当前消息的接受者</li>
<li>super：向父类发送消息</li>
</ul>


<h2>include与#import的区别、#import 与@class 的区别</h2>

<ul>
<li>include和#import其效果相同，都是查询勒种定义的行为</li>
<li>import不会引起交叉编译，确保头文件只会被导入一次</li>
<li>@class的表明，只定义了类的名称，而具体类的行为是未知的，一般用于.h文件</li>
<li>@class比#import编译效率更高</li>
<li>此外@class和#import的主要区别在于解决引用死锁的问题</li>
</ul>


<h2>@public、@protected、@private @ fileprivate, open 它们的含义与作用</h2>

<ul>
<li>@public:对象的实例变量的作用域在任意地方都可以被访问</li>
<li>@protected:对象的实例变量作用域在本类和子类都可以被访问到</li>
<li>@private：实例变量的作用域只能在本类中访问</li>
</ul>


<h3>fileprivate</h3>

<p>在原有的swift中的private其实并不是真正的私有，如果一个变量定义为private,在同一个文件中的其他类依然是可以访问到的。这个场景在使用extension的时候很明显</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class User {
</span><span class='line'>    private var name = "private"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension User{
</span><span class='line'>    var accessPrivate: String {
</span><span class='line'>        return name
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样带来了两个问题：</p>

<ul>
<li>当我们标记为private时，意思为真的私有还是文件内共享呢？</li>
<li>当我们如果意图为真正的私有时，必须保证这个类或者结构体在一个单独的文件内，否则可能同文件里其它的代码访问到</li>
</ul>


<p>由此，在swift3中，新增加了一个<code>fileprivate</code>来显示表明，这个元素的访问权限为文件内私有，过去的private对应现在的fileprivate,现在private则是真正的私有，离开了这个类或者结构体的作用域外面就无法访问到</p>

<h3>open</h3>

<p>open则是弥补public语义上的不足。
现在public有两层含义:</p>

<ul>
<li>这个元素可以在其他作用域被访问</li>
<li>这个元素可以在其他作用域被继承或者ovrride</li>
</ul>


<p>继承是一件危险的事情，尤其对于一个framework或者module的设计者而言，在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者ovrride都是可控制的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改，这个对应的就是final.</p>

<p>final的问题在于标记之后，在任何地方都不能被ovrride,而对于lib的设计者而言，希望得到的是在module内可以ovrride,在被import到其他地方后其他用户使用的时候不能被ovrride.</p>

<p>这就是<code>open</code>产生的初衷，通过open和public标记区别一个元素在其他module中是只能被访问还是可以被ovrride.</p>

<p>例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// ModuleA:
</span><span class='line'>
</span><span class='line'>// 这个类在ModuleA的范围外是不能被继承的，只能被访问
</span><span class='line'>public class NonSubclassableParentClass {
</span><span class='line'>
</span><span class='line'>    public func foo() {}
</span><span class='line'>
</span><span class='line'>    // 这是错误的写法，因为class已经不能被继承，
</span><span class='line'>    // 所以他的方法的访问权限不能大于类的访问权限
</span><span class='line'>    open func bar() {}
</span><span class='line'>
</span><span class='line'>    // final的含义保持不变
</span><span class='line'>    public final func baz() {}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 在ModuleA的范围外可以被继承
</span><span class='line'>open class SubclassableParentClass {
</span><span class='line'>    // 这个属性在ModuleA的范围外不能被override
</span><span class='line'>    public var size : Int
</span><span class='line'>
</span><span class='line'>    // 这个方法在ModuleA的范围外不能被override
</span><span class='line'>    public func foo() {}
</span><span class='line'>
</span><span class='line'>    // 这个方法在任何地方都可以被override
</span><span class='line'>    open func bar() {}
</span><span class='line'>
</span><span class='line'>    ///final的含义保持不变
</span><span class='line'>    public final func baz() {}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/// final的含义保持不变
</span><span class='line'>public final class FinalClass { }
</span><span class='line'>/// ModuleB:
</span><span class='line'>
</span><span class='line'>import ModuleA
</span><span class='line'>
</span><span class='line'>// 这个写法是错误的，编译会失败
</span><span class='line'>// 因为NonSubclassableParentClass类访问权限标记的是public，只能被访问不能被继承
</span><span class='line'>class SubclassA : NonSubclassableParentClass { }
</span><span class='line'>
</span><span class='line'>// 这样写法可以通过，因为SubclassableParentClass访问权限为 `open`.
</span><span class='line'>class SubclassB : SubclassableParentClass {
</span><span class='line'>
</span><span class='line'>    // 这样写也会编译失败
</span><span class='line'>    // 因为这个方法在SubclassableParentClass 中的权限为public，不是`open'.
</span><span class='line'>    override func foo() { }
</span><span class='line'>
</span><span class='line'>    // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写
</span><span class='line'>    // 这里不需要再声明为open，因为这个类是internal的
</span><span class='line'>    override func bar() { }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassC : SubclassableParentClass {
</span><span class='line'>    // 这种写法会编译失败，因为这个类已经标记为open
</span><span class='line'>    // 这个方法override是一个open的方法，则也需要表明访问权限
</span><span class='line'>    override func bar() { } 
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassD : SubclassableParentClass {
</span><span class='line'>    // 正确的写法，方法也需要标记为open
</span><span class='line'>    open override func bar() { }    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>open class SubclassE : SubclassableParentClass {
</span><span class='line'>    // 也可以显式的指出这个方法不能在被override
</span><span class='line'>    public final override func bar() { }    
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>现在的访问权限则依次为:open,public,internal,fileprivate,private.</p>

<h2>iOS开发中数据持久性有哪几种？</h2>

<p>数据存储的核心都是写文件</p>

<ul>
<li>属性列表：只有NSString,NSArray,NSdictionary,NSdata可以writeToFile;存储依旧是plist文件，plist文件可以存储7种数据类型：array,dictionary,string,bool,data,date,number</li>
<li>对象序列化（对象归档）:对象序列化通过序列化的形式，键值关系存储到本地，转化为二进制刘，通过runtime实现自动化归档/解档，实现NSCoding协议必须实现的两个方法:</li>
<li>编码(对象序列化):把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData,可以存储到本地</li>
<li>解码:(对象反序列化)把二进制数据转化为本来的类型</li>
<li>SqlLite数据库：大量有规律的数据使用数据库</li>
<li>CoreData:通过管理对象进行增删改查操作。它不是一个数据库，不仅可以使用SqlLite数据库来保持数据，也可以使用其他方式来存储数据，如:XML</li>
</ul>


<h3><em>CoreData介绍</em></h3>

<ul>
<li>CoreData是面向对象的API，COreData是ios中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础</li>
<li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理，对象关系管理和持久化等方面相关的问题</li>
<li>大多数情况下，我们引用CoreData作为持久化数据的解决方法，并利用它作为持久护士数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转为数据，保存到SQL中，然后将保存后的数据还原成OC对象</li>
</ul>


<h3><em>CoreData的特征:</em></h3>

<ul>
<li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量</li>
<li>将对象数据存储在SQLite数据已获得性能优化</li>
<li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删改查</li>
<li>管理 undo/redo操作</li>
<li>检查托管对象的属性值是否正确</li>
</ul>


<h3><em>CoreData的6个成员对象</em></h3>

<ol>
<li>NSManageObject：被管理的数据记录Managed Object Model是描述应用程序数据模型，这个模型包含实体(Entity),特性(Property)，读取请求(Fetch Request)等</li>
<li>NSManageObjectContext：管理对象的上下文，持久化存储模型对象，参与数据对象进行各种操作的全过程，并检测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI</li>
<li>NSPersistentStoreCoordinator：连接数据库的Persistent Store Coordinator,相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集</li>
<li>NSManagedObjectModel：被管理的数据模型，数据结构</li>
<li>NSFetchRequest：数据请求</li>
<li>NSEntityDescription：表格实体结构，还需知道. xcdatamodel文件编译后为<code>.momd</code>或者<code>.mom</code>文件。</li>
</ol>


<h3>Core Data 的功能</h3>

<ul>
<li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系</li>
<li>自动验证属性值</li>
<li>支持跟踪修改和撤销操作</li>
<li>关系维护，CoreData管理数据的关系传播，包括维护对象之间的一致性</li>
<li>在内存上和界面上分组，过滤，组织数据</li>
<li>自动支持对象存储在外部数据仓库的功能</li>
<li>创建复杂请求：无需动手写SQL语句，在获取请求(Fetch request)中关联 NSPredicate,NSPredicated支持基本功能，想关子查询和其它高级的sql特性。它支持正确的Unicode编码，区域感知查询，排序和正则表达式</li>
<li>延迟操作：CoreData使用懒加载方式减少内存负载，还支持部分实体化延迟加载和复制队形的数据共享机制</li>
<li>合并策略：COreData内置版本跟踪和乐观锁来支持多用户写入冲突的解决，其中，乐观锁就是对局冲突进行检测，若冲突就返回冲突的信息</li>
<li>数据迁移：CoreData的Schema Migration工具尅简化对应数据库结构变化的任务，在某些情况下允许你执行高效率的数据库原地迁移工作</li>
<li>可选择针对程序Controller层的集成，来支持UI的显示同步core data在iphone os之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS上我们用Cocoa提供的绑定机制来完成的</li>
</ul>


<h2>对象可以被Copy的条件</h2>

<p>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝分为不可变拷贝和可变拷贝，</p>

<ul>
<li>NSCopying协议方法为:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)copyWithZone:(NSZone *)zone {
</span><span class='line'> MyObject *copy = [[[self class] allocWithZone: zone] init]; copy.username = [self.username copyWithZone:zone]; return copy;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>在某个方法中 self.name = <em>name，name = </em>name 它 们有区别吗,为什么?</h2>

<ul>
<li>前者是存在内存管理的setter方法赋值，它会对_name对象进行保留或者拷贝操作</li>
<li>后者是普通赋值</li>
<li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写setter方法来执行某些额外的工作，比如说，外部传一个模型过来，那么我会直接重写setter方法，当模型传来时，也就意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI</li>
</ul>


<h2>解释self=[super init]方法</h2>

<ul>
<li>容错处理，当父类初始化失败，会返回一个nil,表示初始化事变，由于继承的关系，子类是需要拥有父类的实例和行为，因此，我们必须先初始化父类，然后再初始化子类</li>
</ul>


<h2>定义属性时,什么时候用 assign、retain、copy 以及它们的之间的区别</h2>

<ul>
<li>assign:普工赋值，一般常用于基本数据类型，常见委托设计模式，一次来防止循环引用（我们成为弱引用）</li>
<li>retain:保留计数，获得到了对象的所有权，引用计数在原有的基础上加1</li>
<li>copy:一般认为，是在内存中重新开辟了一个新的内存空间，用来存储新的对象，和原来的对象是两个不同的地址，引用计数分别1.当时当copy对象为不可变对象时，那么copy的作用相当于retain,因此，这样可以节约内存空间</li>
</ul>


<h3>堆和栈的区别</h3>

<ul>
<li>栈区(stack)由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等，栈是由低地址扩展的数据结构，是以一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的</li>
<li>堆区（heap）：一般是由程序员分配释放，弱程序员不释放，程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活</li>
<li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使的程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不能有一个内存块从栈中间弹出</li>
<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配是由alloc函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现</li>
<li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆是C/C++函数库提供的，它的机制是很复杂的</li>
<li>全局区(静态区)(static):全局变量和静态变量的存储是放在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放</li>
<li>文字常量区：常量字符串就是存放在这里的额，程序结束后由系统释放</li>
<li>程序代码区：存放函数体的二进制代码</li>
</ul>


<h2>怎样使用performSelector传入3个以上的参数，其中一个为结构体</h2>

<ul>
<li>因为系统提供的performSelector的API中，并没有提供三个参数，因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型，我们只能通过对象放入结构作为属性来传过去了。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (id)performSelector:(SEL)aSelector; 
</span><span class='line'> - (id)performSelector:(SEL)aSelector withObject:(id)object; 
</span><span class='line'> - (id)performSelector:(SEL)aSelector withObject:
</span><span class='line'>    (id)object1 withObject:(id)object2;</span></code></pre></td></tr></table></div></figure>


<p>具体实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef struct HYBStruct {
</span><span class='line'>int a;
</span><span class='line'>int b;
</span><span class='line'>} *my_struct;
</span><span class='line'>@interface HYBObject : NSObject
</span><span class='line'>@property (nonatomic, assign) my_struct arg3;
</span><span class='line'>@property (nonatomic, copy)  NSString *arg1;
</span><span class='line'>@property (nonatomic, copy) NSString *arg2;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>@implementation HYBObject
</span><span class='line'>
</span><span class='line'>// 在堆上分配的内存，我们要手动释放掉- (void)dealloc {
</span><span class='line'>free(self.arg3);
</span><span class='line'>
</span><span class='line'>}@end</span></code></pre></td></tr></table></div></figure>


<p>测试:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>my_struct str = (my_struct)(malloc(sizeof(my_struct)));
</span><span class='line'>str-&gt;a = 1;
</span><span class='line'>str-&gt;b = 2;
</span><span class='line'>HYBObject *obj = [[HYBObject alloc] init];
</span><span class='line'>obj.arg1 = @"arg1";
</span><span class='line'>obj.arg2 = @"arg2";
</span><span class='line'>obj.arg3 = str; 
</span><span class='line'>[self performSelector:@selector(call:) withObject:obj]; 
</span><span class='line'>// 在回调时得到正确的数据的- (void)call:(HYBObject *)obj { NSLog(@"%d %d", obj.arg3-&gt;a, obj.arg3-&gt;b);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>UITableViewCell有个UIlabel,显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</h2>

<p>这是否刷新取决于timer加入到run loop中的mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p>

<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView 滑动时切换到该Mode</li>
<li>UIInitializationRunLoopMode：run loop启动时，会切换到该Mode</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）:Mode集合苹果公开提供的Mode有两个：</li>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
<li>在编程中，如果我们把一个NStimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候，ScrollView滚动的过程中会因为mode的切换，而导致NSTimer将不再被调度，当我们滚动的时候，也希望不调度，那就应该使用该模式。
但是，我们希望在滚动的时候，定时器也要回调，那就应该使用common mode</li>
</ul>


<h2>对于单元格重用的理解</h2>

<ul>
<li>当cell滑动屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外划入屏幕内部时，从重用队列中找看有没有可重用的单元格，若有，就直接用，没有就重新创建一个</li>
</ul>


<h2>解决Cell重用的问题</h2>

<ul>
<li>UITableview通过重用单元格来达到节省内存的额目的，通过为每个单元格制定一个重用标识（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的Id，对于简单的表格，一个标识符就够了</li>
<li>如一个TableView中又10个单元格，但屏幕最多显示4个，实际上iPHone只为其分配了4个单元格的内存，没有分配10个，当关东单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的格式为屏幕最大显示数，当有新的cell进入屏幕时，会随你调用已经滚出屏幕的cell所占的内存，这就是cell的重用</li>
<li>对于多变的自定义cell,这种重用机制会导致内容出错，为解决这种出错的方法，把原来的</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString]
</span><span class='line'>修改为：UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];</span></code></pre></td></tr></table></div></figure>


<p>这样就解决掉cell重用机制导致的问题，但是数据量多的情况，会有性能问题</p>

<h2>有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？</h2>

<p>对于这4个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务a */ });
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务b */ });
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务c */ }); 
</span><span class='line'>dispatch_group_async(group, queue, ^{ /*任务d */ }); 
</span><span class='line'>dispatch_group_notify(group,dispatch_get_main_queue(), ^{ // 在a、b、c、d异步执行完成后，会回调这里});
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当然，我们还可以使用非常老套的方法来处理，通过4个变量来标识a,b,c,d四个人物是否完成，然后在runloop中让其等待，当完成时才退出runloop.但是这样做会让后面的代码得不到执行，直到Runloop执行完成</li>
<li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。</li>
</ul>


<h2>使用block有什么好处？使用NSTimer写出一个使用block显示（在UIlabel上）秒表的代码</h2>

<ul>
<li>代码紧凑，传值，回调都很方便，省去了写代理的很多代码</li>
<li>NSTimer封装成block</li>
<li>实现方法:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0
</span><span class='line'>                              repeats:YES
</span><span class='line'>                             callback:^() {
</span><span class='line'>  weakSelf.secondsLabel.text = ...
</span><span class='line'>}
</span><span class='line'>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]</span></code></pre></td></tr></table></div></figure>


<h2>线程和进程的区别和联系？</h2>

<ul>
<li>一个程序至少要有进程，一个进程至少要有一个线程</li>
<li>进程：资源分配的最小独立单元，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位</li>
<li>线程：进程下的一个分支，是进程的实体，是CPU调度和分派的基本单元，它是比进程更小的能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一点在运行中不可少的资源（程序计数器，一组寄存器，栈）但是它可与同属一个进程的其他线程共享进程所拥有的全部资源</li>
<li>进程和线程的主要差别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于这个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源比较大，效率要差一些</li>
<li>但对于一些要求同事进行并且又要共享某些变量的并发造作，只能用线程，不能用进程</li>
</ul>


<h2>多线程编程</h2>

<ul>
<li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中，线程同步：多个线程同事访问一个数据会出问题，NSlock,线程同步块，@synchronized(self){}。</li>
<li>NSOperationQueue操作队列（不需要考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation, BSBlockOperation，自定义Operaton.创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到队列中时，默认会调用main方法。</li>
<li>GCD（<code>Grand Central Dispatch</code>）宏大的中央调度，串行队列，并发队列，主线程队列</li>
<li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个</li>
<li>串行和并行：串行是多个任务按照一定的顺序执行，并行是多个任务同事执行</li>
<li>代码是在分线程执行，在主线程刷新UI</li>
</ul>


<h3>多线程编程是防止主线程堵塞，增加运行效率的最佳方法</h3>

<ul>
<li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法</li>
<li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个想成管理器可以并行运行的线程数量等</li>
<li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径</li>
<li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力</li>
</ul>


<h2>定时器与线程的区别：</h2>

<ul>
<li>定时器：可以执行多次，默认在主线程中</li>
<li>线程：只能执行一次</li>
</ul>


<h2>Apple设备尺寸和编程尺寸</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-0.png" alt="1" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-1.png" alt="2" />
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161104-2.png" alt="3" /></p>

<h2>TCP和UPD的区别和联系</h2>

<ul>
<li>TCP为传输控制层协议，为面向连接，可靠地，点到点的通信</li>
<li>UPD为用户数据报协议，非连接的不可靠的点到多点的通信</li>
<li>TCP侧重可靠传输，UPD侧重于快速传输</li>
</ul>


<h2>TCP连接的三次握手</h2>

<ul>
<li>第一次握手：客户端发送syn包到服务器，并进入SYN_SEND状态，等待服务器确认</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN,同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN_ACK包，向服务器发送确认包ACK,此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态</li>
</ul>


<h2>Scoket连接和HTTP连接的区别:</h2>

<ul>
<li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Scoket是对TCP/IP协议的封装，scoket本身并不是协议，而是一个调用接口(API)，通过Socket,我们才能使用TCP/IP协议</li>
<li>HTTP连接:短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPHone主要类NSURLSession</li>
<li>Socket连接：长连接，客户端跟服务器端直接使用Scoket进行连接，没有规定连接后断开，因此客户端和服务器保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8k</li>
</ul>


<h2>http协议的特点，关于http请求Get和Post的区别</h2>

<p>Get和post的区别：</p>

<ul>
<li>HTTP超文本传输协议，是短链接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开，Http是一个属于应用层面面向对象的协议，http有两类报文：请求报文和响应报文</li>
<li>http请求报文：一个http请求报文由请求行，请求头部，空行和请求数据4部分组成</li>
<li>http响应报文：由三部分组成：状态航，消息报头，响应正文</li>
<li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有的参数都拼接在地址后面），不适合传输大量数据，长度有限制，为1024个字节</li>
<li>Post请求：参数在请求数据区放着，相对Get更安全，并且数据大小没有限制，把提交的数据放置在HTTP包的包体中</li>
<li>GET提交的数据会在地址栏显示出来，而Post请求，地址栏不会改变</li>
</ul>


<p><em>传输数据的大小 ：</em>
* Get提交时，传输数据就会受到URL长度限制，Post由于不是通过URL传值，理论上不受限制</p>

<p><em>安全性：</em></p>

<ul>
<li>Post的安全性要比Get的安全性高；</li>
<li>通过Get提交数据，用户名和密码将明文出现在URL上，比如登录界面有可能被浏览器缓存</li>
<li>HTTPS：安全超文本传输协议(Secure Hypertext Transfer Protocol),它是一个安全通信通道，基于http 开发，用于客户计算机和服务器之间交换信息，使用安全套接字(SSI)进行信息交换，即HTTP的安全版</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义UICollectionViewLayout]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout/"/>
    <updated>2016-10-28T14:34:50+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/28/zi-ding-yi-uicollectionviewlayout</id>
    <content type="html"><![CDATA[<p>UICollectionView，自从ios6之后就被引入到开发中，现在已经变成了最流程的UI元素之一，它最吸引人的特性就是将数据和布局进行分离，依靠分离的数据元素去处理布局，这个布局对象是决定占位元素和视图的元素。</p>

<!--more-->


<p>你可能已经习惯了默认的flow layout布局，它是一个默认实现的被UIKit,它是由基本的表格布局组成的。当然你也可以自定义布局，你可以按照自己的喜好来对视图进行重排。自定义布局是非常强大和灵活的。</p>

<p>通过本章，你将学会如何自定义的布局，怎么去计算layout Attributes,怎么去处理动态的cell。</p>

<h2>Getting Started</h2>

<p><a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Pinterest-starterproject.zip">Download the started project</a>，下载后打开</p>

<p>编译运行，效果如图：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_starter_project.png" alt="1" /></p>

<h2>创建自定义的布局类</h2>

<p>你第一步就是创建一个自定义的布局类，UICollectionView有一个抽象类是<code>UIcollectionViewLayout</code>,它定义了你的Collection View 的每个cell的属性集合-<code>UICollectionViewLayoutAttributes</code>，它包含了你的CollectionView中每个item的属性，比如frame,透明度等</p>

<p>创建一个类继承自<code>UICollectionViewLayout</code>,确保选中的是swift语言，然后创建。</p>

<p>下一步，在你的storyboard中配置下你的自定义布局对象类。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_select_collection_view.png" alt="1" /></p>

<p>然后打开<code>Attributes Inspector</code>面板，选中<code>Custom</code>，在下一个<code>class</code>框中选中你刚才创建的新类<code>PinterestLayout</code>：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/storyboard_change_layout.png" alt="1" /></p>

<p>好了，编译运行：</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/build_and_run_empty_collection.png" alt="3" /></p>

<p>why?</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/meme-nopictures.jpg" alt="1" /></p>

<p>不要慌张！因为你还没有在自定义布局类中写入方法，所以这里什么都不显示。</p>

<h2>核心布局对象</h2>

<p>让我们先看看Collection View的布局调用流程，当Collection View 需要显示一些布局信息的时候，它会询问layout object 去提供一些防范去实现。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2015/05/layout-lifecycle.png" alt="1" /></p>

<p>你自定义的布局必须实现如下方法:</p>

<ul>
<li><code>prepareLayout()</code>，在cell将要进入屏幕的时候，这个方法将会被调用，这是一个机会当你去准备展示和计算CollectionView size和坐标的地方</li>
<li><code>collectionViewContentSize()</code>：在这个方法中，你将会返回CollectionView的高度和宽度-不仅仅是可视的内容，Collection View 将会用这些信息去配置ScrollView的内容尺寸</li>
<li><code>layoutAttributesForElementsInRect(_:):</code>在这个方法中，你需要返回所有的嵌套在矩形区域中的布局属性，你将要返回一个包含<code>UICollectionViewLayoutAttributes</code>属性的集合</li>
</ul>


<p>ok，现在你知道需要去实现什么方法了-但是如何去计算attributes？</p>

<h2>计算布局属性</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UICollectionView 新特性]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing/"/>
    <updated>2016-10-24T10:35:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/24/ios10-uicollectionview-xin-te-xing</id>
    <content type="html"><![CDATA[<p>关于ios 10 UIcolelctionView的新特性，主要还是体现在如下三个方面</p>

<ol>
<li>顺滑的滑动体验</li>
<li>针对self=sizing的改进</li>
<li>Interactive recording重排</li>
</ol>


<!--more-->


<p>这个功能在iOS9的时候介绍过了，苹果在iOS10的API里面大大增强了这一个功能</p>

<h2>目录</h2>

<h3><a href="#1">UICollectionViewCell顺滑的滑动体验</a></h3>

<h3><a href="#2">UICollectionViewCell的预加载</a></h3>

<h3><a href="#3">UITableViewCell的预加载</a></h3>

<h3><a href="#4">针对self-sizing的改进</a></h3>

<h3><a href="#5">Interactive Recordering</a></h3>

<h3><a href="#6">UIRefreshControl的改进</a></h3>

<h2><a name="1"></a>UICollectionViewCell顺滑的滑动体验</h2>

<p>众所周知，iOS设备已良好的用户体验赢得了广大的用户群，iOS系统在用户点击屏幕会立即做出响应。而且很大一部分的操作是来自用户的滑动操作，所以滑动的顺滑性是使用用户沉浸在App中享受的必要条件，接下来我们就谈谈iOS10中增加了那些新特性。</p>

<p>我们先来看一下之前UIcollectionView的体验，假设我们每个cell都是简单的蓝色，实际开发app中，cell会比较复杂，我们先生成100cell.当用户滑动不是很快的时候，还感觉不出来卡顿，当用户大幅度滑动，整个UIcollectionView的卡顿就很明显了。如果整个cell的dataSource又是从网络加载的，那就更加卡顿了，如果如下图</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784344928825.gif" alt="1" /></p>

<p>如果这种app上架，用户使用过后，很可能就直接给1星评价了，但是为什么会造成这种问题呢？我们来分析一下，我们模拟一下系统是如果处理重用机制的，效果如下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784355209022.gif" alt="2" /></p>

<p>在上图中，我们可以看出，当cell准备进入屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了。而且更重要的是，在屏幕外面等待加载的cell是整整一行！这一行的cell都已经加载完数据。这是UICollectionView在用户大幅度滑动时卡顿的根本原因。用专业术语来说就是掉帧</p>

<p>接下来我们来详细说说掉帧的问题</p>

<p>当今的用户是很挑剔的，用户需要一个很顺滑的体验，只要有一点卡顿，很可能一言不合就卸载app了。要想用户感觉不到卡顿，那么我们的app就必须达到每秒60帧，用数学换算一下就是每帧16毫秒就必须刷新一次。</p>

<p>我们用图标来分析一下掉帧的问题，下面会出现两种不同的帧</p>

<ul>
<li>第一种情况，下图是当用户轻微的上下小幅度滑动，这个时候每个cell的加载压力都不打，ios针对这种情况，已经做了很好的优化了，所以用户感觉不到任何卡顿，这种情况下不会掉帧，用户也希望能使用如此顺滑的app</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784433822879.jpg" alt="1" /></p>

<ul>
<li>第二种情况，当用户大幅度滑动，每个cell加载的压力很大， 也许需要网络请求，也许需要读取数据库，而且每次都加载一行cell出来，这样每个cell的加载时间都增加了，加载一行的总时间也就大大增加了，如下图所示，这样，不仅仅当前帧在加载cell，总的时间还会挤压到下一帧的时间里面去。这种情况下，用户就感觉到卡顿了。</li>
</ul>


<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784459878847.jpg" alt="2" /></p>

<p>我们换种方式在说明一下2种情况下掉帧的情况。我们用下图的标准来衡量一下上面2中情况。下图分为2部分，上面红色的区域，就是表示掉帧的区域，因为高于16ms。红色和绿色区域的分界线就在16ms处，Y轴我们表示的是CPU在主线程中花费的时间，X轴表示对额就是在用户滑动中发生的刷新事件。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784491910972.jpg" alt="1" /></p>

<p>针对上述掉帧的情况，绘制出实验数据，如下图，值得我们关注的是，曲线是很曲折的，非常的不平滑，当用户大幅度滑动的时候，峰值超过了16 ms ，当用户慢速滑动的时候，帧率又能保持在比较顺滑的区域，处于绿色区域内的cell加载压力都是很小的。这就是时而掉帧时而顺滑的场景。这种场景下，用户体验是很糟糕的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784519648239.jpg" alt="2" /></p>

<p>那怎么解决这个问题呢？我们来看下图：</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784547235875.jpg" alt="2" /></p>

<p>上图中的曲线我们看着就很平缓了，而且这种情况也不会出现掉帧的情况了，每个滑动中的时间都能达到60帧了，这是怎样做到的呢？因为把每个cell的加载事件都评分了，每个cell不会再出现很忙和很闲的两个极端，这样我们就取消了之前的波峰和波谷。从而让该曲线达到了近乎水平的直线。</p>

<p>如何让每个cell都分摊加载任务的压力？这就要谈到新的cell的生命周期了。</p>

<p>先来看看老的UICollectionViewCell的声明周期，当用户滑动屏幕，屏幕外有一个cell准备加载显示进来。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784605179969.jpg" alt="1" />
这个时候我们把这个cell从reuse队列里面拿出来，然后调用<code>prepareForReuse</code>方法。这个方法就给了cell时间，用来重置cell,重置转台，刷新cell,加载新数据。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784613342397.jpg" alt="2" /></p>

<p>再滑动，我们就会调用<code>cellForItemAtIndexPath</code>方法了，这个方法里面就是我们开发者自定义的填充cell的方式了。这里会填充data model,然后赋值给cell,再把cell返回给iOS系统。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784643684182.jpg" alt="1" /></p>

<p>当cell马上要进入屏幕的时候，就会调用willDisplayCell的方法，这个方法给了我们app最后一次机会，为cell进入屏幕做最后的准备工作。执行完willDisplayCell之后，cell就进入屏幕了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784674667370.jpg" alt="2" /></p>

<p>当cell完全离开屏幕之后，就会调用<code>didEndDisplayingCell</code>方法，以上就是在iOS10之前的整个UICollectionViewCell的生命周期。</p>

<p>接下来我们看看iOS10 的UICollectionViewCell的生命周期是怎么样的。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784919171617.jpg" alt="1" /></p>

<p>这里还是和iOS9一样的。当用户滑动UICollectionView的时候，需要一个cell,我们就从reuse队列中拿出一个cell，并调用<code>prepareForReuse</code>方法，注意调用这个方法的时间，当cell还没有进入屏幕的时候，就已经提前调用这个方法了。注意对比和iOS9的区别，iOS9是在cell上边缘马上进入屏幕的时候才调用方法， 而这里，cell整个生命周期都被提前了，提前到cell还在设备外面的时候。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467784950618167.jpg" alt="2" /></p>

<p>这里还是和之前一样，在<code>cellForItemAtIndexPath</code>中创建cell，填充数据，刷新状态等操作，注意，这里的生命周期也比iOS9提前了。</p>

<p>用户继续滑动，这个时候就有不同了。</p>

<p>这个时候我们并不去调用<code>willDisplayCell</code>方法了，这里遵循的原则是，何时去显示，何时再去调用<code>willDisplayCell</code>.</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785001420508.jpg" alt="1" /></p>

<p>当cell要马上就需要显示的时候，我们再调用<code>willDisplayCell</code>方法。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785009176155.jpg" alt="2" /></p>

<p>当整个cell要从UICollectionView的可见区域消失的时候，这个时候回调用<code>didEndDisplayingCell</code>方法，接下来发生的事情和iOS9一样，cell会进入重用队列中。</p>

<p>如果用户想要显示某个cell,在iOS9中，cell只能从重用队列里面取出，再次走一遍生命周期，并调用<code>cellForItemAtIndexPath</code>去创建或者生成一个cell.</p>

<p>在iOS10当中，系统会把cell保持一段时间，在iOS中，如果用户把cell滑出屏幕后，如果突然又想回来，这个时候cell并不需要再走一遍生命周期了，只需要直接调用<code>willDisplayCell</code>就可以了。cell就又会重新出现在屏幕中了。这就是iOS10的整个UICollectionView的生命周期</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785140434098.jpg" alt="1" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785147242971.jpg" alt="2" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785156440182.jpg" alt="3" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785162269537.jpg" alt="4" /></p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785168247905.jpg" alt="5" /></p>

<p>上面说的iOS10里面的场景同样适用于多列的情况，这时我们每次只加载一个cell,而不是每次加载一行的cell.当第一个cell准备好之后再叫第二个cell准备。当2个cell都准本号之后，接着我们再调用<code>willDisplayCell</code>给每个cell,发送完这个消息之后，cell就会出现在屏幕上了。</p>

<p>这虽然看起来是一个很小的改动，但是这小小的改动就提升了很多用户体验</p>

<p>让我们来看看上述的改动对滑动的影响！</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785199429168.gif">1</a></p>

<p>滑动比iOS9流畅很多，这里可以看到整个过程都很平缓，不卡顿。</p>

<p>还是和iOS9一样，我们来模拟一下系统是如果加载cell的情况。</p>

<p><a href="http://cc.cocimg.com/api/uploads/20160706/1467785382812684.gif">2</a></p>

<p>我们可以很明显的的看到，iOS系统是一个一个的加载cell的，一个cell加载完之后再去加载下一个cell,这里和iOS9的有很大的不同，ios9是记载整整一行的cell</p>

<p>这是因为我们用了新的UICollectionViewCell的生命周期，整个App完全没有加一行代码，现在iOS10是丝滑般的体验，是在是太棒了。</p>

<h2><a name = "2"></a>UICollectionViewCell的Pre-Fetching预加载</h2>

<p>当我们编译iOS10的APP的时候，这个Pre-Fetching默认是enable的。当然，如果有一些原因导致你必须用到iOS10之前的老的生命周期，你只需要给collectioView加入新的<code>isPrefetchingEnabled</code>属性即可。如果你不想用到<code>Pre-Fetching</code>，那么把这个属性变成false即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>collectionView.isPrefetchingEnabled = false</span></code></pre></td></tr></table></div></figure>


<p>为了最佳实践一下这个新特性，我们先改变一下我们加载cell的方式，我们把很重的读取数据的操作，所有内容的创建都放到<code>cellForItemAtIndexPath</code>方法里面去完成。保证我们在<code>willDisplayCell</code>和<code>didEndDisplayCell</code>这两个方法里面基本不做其他事情。最后，保证<code>cellForItemAtIndexPath</code>加载的cell都不是从重用队列里面拿出来的。</p>

<p>如果这个时候你用ios10编译出你的app,那么非常顺滑的用户体验就会自动的优化出来</p>

<p>UICollectionView的流畅滑动解决了，那么在UICollectionViewCell在加载的时候所花费的时候，怎么解决呢？</p>

<p>UICollectionViewCell加载的时候取决于DataMOdel,DataMOdel很可能回去加载图片，来自于网络或者来自于本地的数据库，这些操作大多数都是异步操作，为了使data加载更快，iOS10引入了新的Apil来解决这个问题。</p>

<p>UICollectionView有两个小伙伴，那就是dataSource和delegate,在iOS10中，将会迎来第三个小伙伴，这个小伙伴就是<code>prefetchDataSource</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol UICollectionViewDataSourcePrefetching {
</span><span class='line'>    func collectionView(_ collectionView: UICollectionView,
</span><span class='line'>                        prefetchItemsAt indexPaths: [NSIndexPath])
</span><span class='line'>    optional func collectionView(_ collectionView: UICollectionView,
</span><span class='line'>                                 cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])
</span><span class='line'>}
</span><span class='line'>class UICollectionView : UIScrollView {
</span><span class='line'>    weak var prefetchDataSource: UICollectionViewDataSourcePrefetching?
</span><span class='line'>    var isPrefetchingEnabled: Bool
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个协议连只有一个必须要实现的方法-<code>ColletionView prefetchItemsAt indexPaths</code>，这个方法会在<code>prefetchDataSource</code>里面被调用，用来给你异步的预加载数据的。indexPaths数组是有序的，就是接下来item接收数据的顺序，让我们model异步处理数据更加方便。</p>

<p>在这个协议里面患有第二个方法<code>CollectionView cancelPrefetcingForItemsAt indexPaths</code>，不过这个方法是可选的，我们可以利用这个方法来处理在滑动中取消或者降低提前加载数据的优先级。</p>

<p>值得说明的是，新增加的这个小伙伴<code>prefetchDataSource</code>，并不能取代原来的读取数据的方法，这个预加载仅仅只是辅助加载数据，并不能删除原来我们读取数据的方法。</p>

<p>至此，我们来看看从文章开始到现在，UICollectionView的性能提升了多少，我们还是用掉帧的方法来看看UICollectionView的性能。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785413182613.jpg" alt="1" /></p>

<p>上面是iOS9 UICollectionView的性能，很明显的看见，波峰波谷很明显，并且还掉了8帧，有明显的卡顿现象。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785449871270.jpg" alt="2" />
上图是iOS10 UICollectionView的性能，我们可以明显的看到，经过ios10的优化，整个曲线很明显的平缓了一些，没有极端的波峰掉帧现象。但是依旧存在少量的波峰快到了16ms分界线了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785482131029.jpg" alt="1" /></p>

<p>上图是iOS10 + pre-Fetching Api之后的性能，已经优化的效果很明显了，整条曲线基本上都水平了。近乎完美，但是还是能发现有个别波峰特别高，波峰特别高的地方就是那个cell加载压力大， 时间花的比较长导致的。接下来我们继续优化！</p>

<p>先来总结一下使用Pre-Fetching API 需要注意的地方。</p>

<ul>
<li>在我们使用Pre-Fetching API的时候，我们一定要保证整个预加载过程都放在后台线程中进行。合理使用GCD和NSOperationQueue处理好多线程</li>
<li>请切记，Pre-Fetching API 是一种自适应的技术，何为自适应技术呢？当我们滑动速度很慢的时候，在这种“安静”的时期，Pre-Fetching API会默默的再后台预加载数据，但是一旦我们快速滑动，我们需要频繁的刷新，我们不会去执行pre-fetching API</li>
<li>最后，用<code>cancelPrefetchingAPI</code>去迎合用户的滑动动作的变换，比如说用户在快速滑动发现了有趣的感兴趣的事情，这个时候停下来，甚至快速反向滑动了，或者点击了事件，进去看详情了，这些时刻我们都应该开启<code>cancelPrefetchingAPI</code></li>
</ul>


<p>综合所述，Pre-Fetching API对于提高UICOllectionView的性能提升是很有帮助的，而且并不需要加入太多的代码，加入少量的代码就可以获得巨大的额性能提升！</p>

<h2><a name="3"></a>UITableViewCell的Pre-Fetching预加载</h2>

<p>在iOS10中，UITableViewCell也跟着UICollectionView一起得到了性能的提升，一样拥有了Pre-Fetching API</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol UITableViewDataSourcePrefetching {
</span><span class='line'>    func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [NSIndexPath])
</span><span class='line'>    optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:
</span><span class='line'>                            [NSIndexPath])
</span><span class='line'>}
</span><span class='line'>class UITableView : UIScrollView {
</span><span class='line'>    weak var prefetchDataSource: UITableViewDataSourcePrefetching?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里和上面的UICollectionView一样，会调用<code>TableView prefetchRowsAt indexPaths</code>方法，indexPaths还是一个有序数字，顺序就是列表上可见的顺序，第二个可选的API还是<code>TableView cancelPrefetchingForRowsAt indexPaths</code>，和之前的提到的一样，也是用来取消预加载的，性能的提升和UIcollectionView一样的，对于UITableView 的性能提升很大！</p>

<h2><a name="4"></a>针对self-sizing的改进</h2>

<p>self-sizing API 第一次被引入是在ios8中，然而现在在iOS10中得到了一些改进。</p>

<p>在UICollectionView中有个固定的类，叫UICollectionViewFlowlayout,iOS已经在这个类中完全支持了self-sizing.为了能开启这一特性，需要我们开发者为一些不能为0的 CGSize的cell设置一下estimated item size.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout.estimatedItemSize = CGSize(width:50,height:50)</span></code></pre></td></tr></table></div></figure>


<p>这会告诉UICOllectionView我们想要开启动态计算内容的布局。</p>

<p>至今，我们有三种方法来动态的布局：</p>

<ul>
<li>第一种方法是使用autolayout，当我们合理的加入约束，当cell加载的时候，就会根据内容动态的加载布局</li>
<li>第二种方法，如果你不想使用autolayout的方法，想更加手动的控制它，那么我们就需要重写sizeThatFits()方法</li>
<li>第三种方法，终极的方法是重写<code>preferredLayoutAttributesFittingAttributes()</code>方法，在这个方法里面不仅仅可以提供size的信息，更可以得到alpha和transform的信息。</li>
</ul>


<p>所以想指定cell的大小，就可以用上面的三个方法之一</p>

<p>但是实际的操作中，我们可以发现，有时候设置一个合适的estimated item size，对于我们来说是很困难的事情，如果flow layout可以用数学的方法动态的计算布局，而不是根据我们给的size去布局，那回事很酷的事情。</p>

<p>iOS10中就引入了新的API来解决上述问题。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize</span></code></pre></td></tr></table></div></figure>


<p>对于开发者，我们需要做的事情，仅仅就是设置好flow layout,然后给<code>estimatedItemSize</code>设定一个新的常数，最后<code>UICollectionViewFlowLayout</code>就会自动计算高度了。</p>

<p>系统会自动计算好所有的布局，包括已经定下来的size的cell,并且还会动态的给出接下来的cell的大小的预测。</p>

<p>接下来看2个例子就可以很明显看出iOS10针对self-sizing的改进了。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785547586106.gif" alt="1" />
上图可以看到，iOS 9的布局是针对单个cell计算的，当改变了单个cell,其它的cell依旧没有变化，还是需要重新计算</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785653922069.gif" alt="2" /></p>

<p>这里例子就可以很明显的看出差别了，当我们改变了第一个cell的size之后，系统会自动计算出所有的cell的size，并且每一行，每一个section的size都会被动态的计算出来，并且刷新界面！</p>

<p>以上就是iOS 10 针对 self-sizing的改进。</p>

<h2><a name="5"></a>Interactive Reordering</h2>

<p>谈到重新排列，这是我们就需要类比一下UITableview了，UICollectioNView重新排列就如同UITableview把cell上下移动，只不过UITableView的重新排列是针对垂直方向的。</p>

<p>在IOS 9 中，引入了UICollectionView的Interactive Reordering，在今年的iOS 10中，又加入了新的API</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785697559422.gif" alt="1" /></p>

<p>在上图中，我们可以看到，我们即使任意拖动cell,整个界面也会重新排列，并且我们改变了cell的大小，整个UICollectionView也会重新动态的布局。</p>

<p>我们先来看看iOS 9 里面的API</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UICollectionView : UIScrollView {
</span><span class='line'>    func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&gt; Bool
</span><span class='line'>    func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint)
</span><span class='line'>    func endInteractiveMovement()
</span><span class='line'>    func cancelInteractiveMovement()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>要想开启interactive movement,我们就需要调用<code>beginInteractiveMovementForItem()</code>方法，其中indexPath代表了我们将要移动的cell.接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作，这时我们就需要调用<code>updateInteractiveMovementTargetPosition()</code>方法，我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用<code>endInteractiveMovement()</code>方法。UICollectionView就会放下cell,处理完整个layout，此时你也可以重新刷新model或者处理数据model.如果中间突然手势取消了，那么这个时候就应该调用<code>cancelInteractiveMovement()</code>方法，如果我们重新把cell对应一圈之后有放回原位了，其实就是取消了移动，那这个时候就应该在<code>cancelInteractiveMovement()</code>方法里面不用取刷新data Source.</p>

<p>在iOS10中，如果你使用UICollectionViewController,那么这个重排对于你来说更加简单、</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class UICollectionViewController : UIViewController {
</span><span class='line'>    var installsStandardGestureForInteractiveMovement: Bool
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你只需要把installsStandardGestureForInteractiveMovement这个属性设置为true就可以了。CollectionViewController会自动为你加入手势，并且自定为你调用上面的方法。</p>

<p>以上就是去年ios 9 为我们增加的API</p>

<p>今年的ios 10 新加入的API是在iOS9的基础上增加了翻页的功能。</p>

<p>UICollectionView继承自UIScrollView,所以只需要你做的是把 isPagingEnable设置为true，即可开启分页的功能。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>collectionView.isPagingEnabled = true</span></code></pre></td></tr></table></div></figure>


<p>开启分页之前:
<img src="http://cc.cocimg.com/api/uploads/20160706/1467785741500789.gif" alt="1" /></p>

<p>开启分页之后就长这样子:</p>

<p><img src="http://cc.cocimg.com/api/uploads/20160706/1467785759631412.gif" alt="2" /></p>

<p>每次移动一次就会以页为单位的翻页、</p>

<h2><a name="6"></a>UIRefreshControl的改进</h2>

<p>UIRefreshControl现在可以直接在CollectionView里面使用了，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController.因为现在RefreshCOntrol成为了ScrollView的一个属性了。</p>

<p>UIRefreshControl的使用方法很简单，就三步:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let refreshControl = UIRefreshControl()
</span><span class='line'>refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)),
</span><span class='line'>                         for: .valueChanged)
</span><span class='line'>collectionView.refreshControl = refreshControl</span></code></pre></td></tr></table></div></figure>


<p>先创建一个refreshCOntroler,再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性就可以了。</p>

<h2>Summary</h2>

<ul>
<li>UICollectionview cell Pre-fetching预加载的机制</li>
<li>UICollectionView And UITableView prefetch DataSource新增的API</li>
<li>针对self-sizing cell改进</li>
<li>Interactive recordering 重排</li>
</ul>


<p>最后，原来有些地方用到 AsyncDispatchKit优化的UICollectioView速度的，现在可以考虑不用第三方库了，系统自带的方法可以解决一般性的卡顿问题了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios10 UserNotifications]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications/"/>
    <updated>2016-10-17T09:53:08+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/17/ios10-usernotifications</id>
    <content type="html"><![CDATA[<p>ios10以前杂乱的和通知相关的API都被统一了，现在开发者可以使用独立的UserNotificaitons.framework来集中管理和使用iOS系统中通知的功能。在此基础上，Apple还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知UI等一系列功能。</p>

<!--more-->


<p>对于开发者来说，想比较于之前版本，iOS10提供了一套非常易用通知处理接口，是SDK的一次重大重构，而之前的绝大部分通知相关API都已经被标为弃用(deprecated)</p>

<p>您可以在WWDC16的 <a href="https://developer.apple.com/videos/play/wwdc2016/707/">introducaion to Notifications</a>和<a href="https://developer.apple.com/videos/play/wwdc2016/708/">Advanced Notifications</a>这两个Session中找到详细信息；另外也不要忘了参考<a href="https://developer.apple.com/reference/usernotifications">UserNotifications官方文档</a></p>

<h2>UserNOtifications框架解析</h2>

<h3>基本流程</h3>

<p>iOS10中通知相关的操作遵循下面的流程:</p>

<p><code>审核和注册</code>-><code>创建和发起</code>-><code>展示和处理</code></p>

<p>首先你需要向用户请求推送权限，然后发送通知。对于发送出的通知，如果你的应用位于后台或者没有运行的话，系统将通过用户允许的方法（弹窗，横幅，或者是在通知中心）进行展示。如果你的应用已经位于前台正在运行，你可以自行决定要不要显示这个通知。最后，如果你希望用户点击通知能有打开应用以外的额外功能的话，你也需要进行处理。</p>

<h2>权限申请</h2>

<p>iOS8之前，本地推送和远程推送（Remote Notificaiton）是区分对待的，应用只需要在进行远程推送是获取用户同意。iOS8对这一行为进行了规范，因为无论是本地推送还是远程推送，其实在用户看来表现是一致的，都是打断用户的行为。因此从iOS8开始，这两种通知都需要申请权限。ios10里进一步消除了本地通知和推送通知的区别。向用户申请通知权限非常简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {
</span><span class='line'>    granted, error in
</span><span class='line'>    if granted {
</span><span class='line'>        // 用户允许进行通知
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，在使用UN开头的API的时候，不要忘记导入<code>UserNotifications</code>框架：</p>

<p><code>import UserNotifications</code></p>

<p>第一次调用这个方法时，会弹出一个系统弹窗.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-0.png" alt="1" /></p>

<p>要注意的是，一旦用户拒绝了这个请求，再次调用该方法时也不会进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知，而这往往是不可能的。因此，在合适的是偶弹出请求窗，在请求权限前预先进行说明，而不是直接粗暴地在启动的时候就进行弹窗，会是更明智的选择。</p>

<h2>远程推送</h2>

<p>一旦用户同意后，你就可以再应用中发送本地通知了。不过如果你通过服务器发送远程通知的话，还需要多一个获取用户token的操作，你的服务器可以使用这个token将用向Apple push Notification的服务器提交请求，然后APNS通过token识别设备和应用，将通知推给用户。</p>

<p>提交token请求和获得token的回调是现在"唯一"不在新框架中的API,我们使用<code>UIApplication</code>的<code>registerForRemoteNotifications</code>来注册远程通知，在<code>AppDelegate</code>的<code>application(_:didRegisterForRemoteNotificationsWithDeviceToken)</code>中获取用户token:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 向 APNs 请求 token：
</span><span class='line'>UIApplication.shared.registerForRemoteNotifications()
</span><span class='line'>
</span><span class='line'>// AppDelegate.swift
</span><span class='line'> func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
</span><span class='line'>    let tokenString = deviceToken.hexString
</span><span class='line'>    print("Get Push token: \(tokenString)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>获取得到的<code>deviceToken</code>是一个<code>Data</code>类型，为了方便使用和传递，我们一般会选择将它转换为一个字符串。swift3中可以使用下面的<code>data</code>扩展来构造适合传递给Apple的字符串：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Data {
</span><span class='line'>    var hexString: String {
</span><span class='line'>        return withUnsafeBytes {(bytes: UnsafePointer&lt;UInt8&gt;) -&gt; String in
</span><span class='line'>            let buffer = UnsafeBufferPointer(start: bytes, count: count)
</span><span class='line'>            return buffer.map {String(format: "%02hhx", $0)}.reduce("", { $0 + $1 })
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>权限设置</h3>

<p>用户可以再系统设置中修改你的应用的通知权限，除了打开和关闭全部通知权限外，用户也可以限制你的应用智能进行某种形式的通知显示，比如值允许横幅而不允许弹窗及通知中心显示灯。一般来说你不应该对用户的选择进行干涉，但是如果你的应用确实需要某种特定场景的推送的话，你可以对当前用户进行的设置进行检查:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UNUserNotificationCenter.current().getNotificationSettings {
</span><span class='line'>    settings in 
</span><span class='line'>    print(settings.authorizationStatus) // .authorized | .denied | .notDetermined
</span><span class='line'>    print(settings.badgeSetting) // .enabled | .disabled | .notSupported
</span><span class='line'>    // etc...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>发送通知</h2>

<p>UserNOtifications中对通知进行了统一。我们通过通知的内容（<code>UNNotificaitonsContent</code>）,发送的时机<code>UNNotifiationTrigger</code>以及一个发送通知的<code>String</code>类型的标识符，来生成一个<code>UNNotificationRequest</code>类型的发送请求。最后，我们将这个请求添加到<code>UNUserNotificationCenter.current()</code>中，就可以等待通知到达了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1. 创建通知内容
</span><span class='line'>let content = UNMutableNotificationContent()
</span><span class='line'>content.title = "Time Interval Notification"
</span><span class='line'>content.body = "My first notification"
</span><span class='line'>
</span><span class='line'>// 2. 创建发送触发
</span><span class='line'>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)
</span><span class='line'>
</span><span class='line'>// 3. 发送请求标识符
</span><span class='line'>let requestIdentifier = "com.onevcat.usernotification.myFirstNotification"
</span><span class='line'>
</span><span class='line'>// 4. 创建一个发送请求
</span><span class='line'>let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)
</span><span class='line'>
</span><span class='line'>// 将请求添加到发送中心
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error == nil {
</span><span class='line'>        print("Time Interval Notification scheduled: \(requestIdentifier)")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>iOS10中通知不仅支持简单的一行文字，你还可以添加<code>title</code>和 <code>subtitle</code>,来用粗体字的形式强调通知的目的。对于远程推送，iOS10之前一般只含有消息的推送；payload是这样的：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":"Test",
</span><span class='line'>    "sound":"default",
</span><span class='line'>    "badge":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果我们想要加入<code>title</code>和<code>subtitle</code>的话，则需要将<code>alert</code>从字符串换为字典，新的payload是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"I am title",
</span><span class='line'>      "subtitle":"I am subtitle",
</span><span class='line'>      "body":"I am body"
</span><span class='line'>    },
</span><span class='line'>    "sound":"default",
</span><span class='line'>    "badge":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好消息是，后一种字典的方法其实在iOS8.2的时候就已经存在了，虽然当时<code>title</code>只是用在Apple Watch上的，但是设置好<code>body</code>的话在iOS上还是可以显示的，所以针对iOS10添加标题时是可以保证向前兼容的。</p>

<p>另外，如果要进行本地化对应，在设置这些内容文本时，本地可以使用<code>String.localizedUserNotificationString(forKey: "your_key", arguments: [])</code>的方式来从<code>Localizable.strings</code>文件中取出本地化字符串，而远程推送的话，也可以再payload的alert中使用<code>loc-key</code>或者<code>title-loc-key</code>来进行指定</p>

<ol>
<li><p>触发器是只对本地通知而言的，远程推送的通知的话默认会在收到后立即显示。现在<code>UserNotifications</code>框架中提供了三种触发器，分别是：在一定时间后触发<code>UNTimeIntervalNotificationTrigger</code>,在某月某日某时触发<code>UNCalendarNotificationTrigger</code>,以及在用户进入或者离开某个区域时触发<code>UNLocationNotificationTrigger</code></p></li>
<li><p>请求标识符可以用来区分不同的通知请求，在将一个通知请求提交后，通过特定的API我们能够使用这个标识符来取消或者更新这个通知。我们将在稍后提到具体方法</p></li>
<li><p>在新版本的通知框架中，Apple借用了一部分网络请求的概念，我们组织并发送一个通知请求，然后将这个请求提交给<code>UNUserNotificationCenter</code>进行处理。我们会在delegate中接收到这个通知请求对应的responst,另外我们也有机会再应用的extension中对request进行处理</p></li>
</ol>


<p>在提交请求后，我们锁屏或者将应用切到后台，并等待设定的时间后，就能看到我们的通知出现在通知中心或者屏幕横幅了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-1.png" alt="1" /></p>

<h2>取消和更新</h2>

<p>在创建通知请求时，我们已经制定了标识符。这个标识符可以用来管理通知，在iOS10之前，我们很难取消掉某一个特定的通知，也不能主动移除或者更新已经展示的通知。</p>

<p>iOS10中，UserNotifications框架提供了一系列管理通知的API,你可以做到:</p>

<ul>
<li>取消还未展示的通知</li>
<li>更新还未展示的通知</li>
<li>移除已经展示过的通知</li>
<li>更新已经展示过的通知</li>
</ul>


<p>其中关键就是创建请求时使用同样的标识符：</p>

<p>比如，从通知中心移除一个展示过得通知：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
</span><span class='line'>let identifier = "com.onevcat.usernotification.notificationWillBeRemovedAfterDisplayed"
</span><span class='line'>let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
</span><span class='line'>
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error != nil {
</span><span class='line'>        print("Notification request added: \(identifier)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>delay(4) {
</span><span class='line'>    print("Notification request removed: \(identifier)")
</span><span class='line'>    UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [identifier])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>类似的，我们可以使用<code>removePendingNotificationRequests</code>，来取消还未展示的通知请求。对于更新通知，不论是否已经展示，都和一开始添加请求时一样，再次将请求提交给<code>UNUserNotificationCenter</code>即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// let request: UNNotificationRequest = ...
</span><span class='line'>UNUserNotificationCenter.current().add(request) { error in
</span><span class='line'>    if error != nil {
</span><span class='line'>        print("Notification request added: \(identifier)")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>delay(2) {
</span><span class='line'>    let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
</span><span class='line'>
</span><span class='line'>    // Add new request with the same identifier to update a notification.
</span><span class='line'>    let newRequest = UNNotificationRequest(identifier: identifier, content:newContent, trigger: newTrigger)
</span><span class='line'>    UNUserNotificationCenter.current().add(newRequest) { error in
</span><span class='line'>        if error != nil {
</span><span class='line'>            print("Notification request updated: \(identifier)")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>远程推送可以进行通知的更新，在使用Provider API向APNS提交请求时，在HTTP2的header中<code>apns-collapse-id</code>key的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新</p>

<h2>处理通知</h2>

<h3>应用内展示通知</h3>

<p>现在系统可以在应用处于后台或者退出的时候向用户展示通知了。不过，当应用处于前台时，收到的通知是无法进行展示的。如果我们希望在应用内也能显示通知的话，需要额外的工作。</p>

<p><code>UNUserNotificationCenterDelegate</code>提供了两个方法，分别对应如何在应用内展示通知，和收到通知响应时要如何处理的工作。我们可以实现这个借口中的对应方法来在应用内展示通知：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NotificationHandler: NSObject, UNUserNotificationCenterDelegate {
</span><span class='line'>    func userNotificationCenter(_ center: UNUserNotificationCenter, 
</span><span class='line'>                       willPresent notification: UNNotification, 
</span><span class='line'>                       withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) 
</span><span class='line'>    {
</span><span class='line'>        completionHandler([.alert, .sound])
</span><span class='line'>
</span><span class='line'>        // 如果不想显示某个通知，可以直接用空 options 调用 completionHandler:
</span><span class='line'>        // completionHandler([])
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>实现后，将<code>NotificationHandler</code>的实例赋值给<code>UNUserNotificationCenter</code>的<code>delegate</code>属性就可以了。没有特殊理由的话，AppDelegate的<code>application(_:didFinishLaunchingWithOptions:)</code>就是一个不错的选择：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class AppDelegate: UIResponder, UIApplicationDelegate {
</span><span class='line'>    let notificationHandler = NotificationHandler()
</span><span class='line'>    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
</span><span class='line'>        UNUserNotificationCenter.current().delegate = notificationHandler
</span><span class='line'>        return true
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>对通知进行响应</h2>

<p><code>UNUserNotificationCenterDelegate</code>中还有一个方法,<code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>这个代理方法会在用户与你推送的通知进行交互时被调用，包括用户通过通知打开了你的应用，或者点击或者触发了某个Action。因为涉及到打开应用的行为，所以事先了这个方法的delegate必须在<code>applicationDidFinishLaunching:</code>返回前就完成设置，这也是我们之前推荐将<code>NotificationHandler</code>今早进行赋值的理由。</p>

<p>一个最简单的事先自然什么也不错，直接告诉系统你已经完成了所有工作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>    completionHandler()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在该方法里，我们将获取到这个推送请求对应的response,<code>UNNotificationResponse</code>是一个几乎包括了通知的所有信息的对象，从中我们可以再次获取到<code>userInfo</code>中的信息:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>    if let name = response.notification.request.content.userInfo["name"] as? String {
</span><span class='line'>        print("I know it's you! \(name)")
</span><span class='line'>    }
</span><span class='line'>    completionHandler()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更好的消息是，远程推送的payload内的内容也会出现在这个<code>userInfo</code>中，这样一来，不论是本地推送还是远程推送，处理的路径得到了统一。通过<code>userInfo</code>的内容来决定页面跳转或者是进行其他操作，都会有很大空间。</p>

<h2>Actionable通知发送和处理</h2>

<h3>注册Category</h3>

<p>iOS8和9中Apple引入了可以交互的通知，这是通过将一簇action放到了一个category中，将这个category进行注册，最后在发送通知时将通知的category设置为要使用的category来实现的。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-2.png" alt="1" /></p>

<p>注册一个category非常容易：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private func registerNotificationCategory() {
</span><span class='line'>    let saySomethingCategory: UNNotificationCategory = {
</span><span class='line'>        // 1
</span><span class='line'>        let inputAction = UNTextInputNotificationAction(
</span><span class='line'>            identifier: "action.input",
</span><span class='line'>            title: "Input",
</span><span class='line'>            options: [.foreground],
</span><span class='line'>            textInputButtonTitle: "Send",
</span><span class='line'>            textInputPlaceholder: "What do you want to say...")
</span><span class='line'>
</span><span class='line'>        // 2
</span><span class='line'>        let goodbyeAction = UNNotificationAction(
</span><span class='line'>            identifier: "action.goodbye",
</span><span class='line'>            title: "Goodbye",
</span><span class='line'>            options: [.foreground])
</span><span class='line'>
</span><span class='line'>        let cancelAction = UNNotificationAction(
</span><span class='line'>            identifier: "action.cancel",
</span><span class='line'>            title: "Cancel",
</span><span class='line'>            options: [.destructive])
</span><span class='line'>
</span><span class='line'>        // 3
</span><span class='line'>        return UNNotificationCategory(identifier:"saySomethingCategory", actions: [inputAction, goodbyeAction, cancelAction], intentIdentifiers: [], options: [.customDismissAction])
</span><span class='line'>    }()
</span><span class='line'>
</span><span class='line'>    UNUserNotificationCenter.current().setNotificationCategories([saySomethingCategory])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>UNTextInputNotificationAction</code>代表一个输入文本的action,你可以自定义框的按钮title和placeholder,你稍后会使用<code>identifier</code>来对action进行区分。</li>
<li>普通的<code>UNNotificationAction</code>对应标准的按钮</li>
<li>为category指定一个<code>identifier</code>,我们将在实际发送通知的时候用这个标识符进行设置，这样系统就知道对应哪个category了。</li>
</ol>


<p>当然，不要忘了在程序启动时调用这个方法进行注册</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
</span><span class='line'>    registerNotificationCategory()
</span><span class='line'>    UNUserNotificationCenter.current().delegate = notificationHandler
</span><span class='line'>    return true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>发送一个带有action的通知</h3>

<p>在完成category注册后，发送一个actionable通知就非常简单了，只需要在创建<code>UNNotificationContent</code>时把<code>categoryIdentifier</code>设置为需要的categoryId即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>content.categoryIdentifier = "saySomethingCategory"</span></code></pre></td></tr></table></div></figure>


<p>尝试展示这个通知，在下拉或者使用3D touch展开通知后，就可以看到对应的action了：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-3.png" alt="1" /></p>

<p>远程推送也可以使用category,只需要在payload中添加<code>category</code>字段，并指定预先定义的category id 就可以了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":"Please say something",
</span><span class='line'>    "category":"saySomething"
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>处理actionable通知</h3>

<p>和普通的通知并无二致力，actionable通知也会走到<code>didReceive</code>的delegate方法，我们通过request中包含的<code>categoryIdentifier</code>和response里的<code>actionIdentifier</code>就可以轻易判定是那个通知的那个操作被执行了。对于<code>UNTextInputNotificationAction</code>触发的response,直接将它转换为一个<code>UNTextInputNotificationResponse</code>，就可以拿到其中的用户输入了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) {
</span><span class='line'>
</span><span class='line'>    if let category = UserNotificationCategoryType(rawValue: response.notification.request.content.categoryIdentifier) {
</span><span class='line'>        switch category {
</span><span class='line'>        case .saySomething:
</span><span class='line'>            handleSaySomthing(response: response)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    completionHandler()
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private func handleSaySomthing(response: UNNotificationResponse) {
</span><span class='line'>    let text: String
</span><span class='line'>
</span><span class='line'>    if let actionType = SaySomethingCategoryAction(rawValue: response.actionIdentifier) {
</span><span class='line'>        switch actionType {
</span><span class='line'>        case .input: text = (response as! UNTextInputNotificationResponse).userText
</span><span class='line'>        case .goodbye: text = "Goodbye"
</span><span class='line'>        case .none: text = ""
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>        // Only tap or clear. (You will not receive this callback when user clear your notification unless you set .customDismissAction as the option of category)
</span><span class='line'>        text = ""
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if !text.isEmpty {
</span><span class='line'>        UIAlertController.showConfirmAlertFromTopViewController(message: "You just said \(text)")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码先判断通知响应是否属于<code>saySomething</code>，然后从用户输入或者是选择中提取字符串，并且弹出一个alert作为响应结果。当然，更多请苦情下我们会发送一个网络请求，或者是根据用户操作更新一些UI等。</p>

<h2>Notificiaton Extension</h2>

<p>iOS10中添加了很多extention,作为应用与系统整合的入口。与通知相关的extension有两个：Service Extension和Content Extension.前者可以让我们有机会在收到远程推送的通知后，展示之前对通知内容进行修改：后者可以用来自定义通知视图的样式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-extensions.png" alt="1" /></p>

<h3>截取并修改通知内容</h3>

<p><code>NotificationService</code>的模板已经为我们进行了基本的实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class NotificationService: UNNotificationServiceExtension {
</span><span class='line'>
</span><span class='line'>    var contentHandler: ((UNNotificationContent) -&gt; Void)?
</span><span class='line'>    var bestAttemptContent: UNMutableNotificationContent?
</span><span class='line'>
</span><span class='line'>    // 1
</span><span class='line'>    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {
</span><span class='line'>        self.contentHandler = contentHandler
</span><span class='line'>        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
</span><span class='line'>
</span><span class='line'>        if let bestAttemptContent = bestAttemptContent {
</span><span class='line'>            if request.identifier == "mutableContent" {
</span><span class='line'>                bestAttemptContent.body = "\(bestAttemptContent.body), Andrew"
</span><span class='line'>            }
</span><span class='line'>            contentHandler(bestAttemptContent)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // 2
</span><span class='line'>    override func serviceExtensionTimeWillExpire() {
</span><span class='line'>        // Called just before the extension will be terminated by the system.
</span><span class='line'>        // Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.
</span><span class='line'>        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
</span><span class='line'>            contentHandler(bestAttemptContent)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>didReceive:</code>方法中有一个等待发送的通知请求，我们通过修改这个请求中的content内容，然后在限制的时间内将修改后的内容调用通过<code>contentHandler</code>返还给系统，就可以显示这个修改过得通知了</li>
<li>在一定时间内没有调用<code>contentHandler</code>的话，系统会调用这个方法，来告诉你大限已到。你可以选择什么都不做，这样的话系统将当做什么都没发生，简单地显示原来的通知，可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用<code>contentHandler</code>来显示一个变更"中途"的通知</li>
</ol>


<p>Service Extentsion现在只对远程推送的通知起效，你可以在推送payload中增加一个<code>mutable-content</code>的值为1的项来启用内容修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"Greetings",
</span><span class='line'>      "body":"Long time no see"
</span><span class='line'>    },
</span><span class='line'>    "mutable-content":1
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个payload的推送得到的结果就是推送的内容+“Andrew”</p>

<p>使用在本机截取推送并替换内容的方式，可以完成端到端(end-to-end)的推送加密。你在服务器推送payload中加入加密过得文本，在客户端接到通知后使用预先定义或者获取过得秘钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>

<h2>在通知中展示图片/视频</h2>

<p>相比于旧版本的通知，iOS10中另一个亮眼功能室多媒体的推送，开发者现在可以在通知中嵌入图片或者视频，这极大丰富了推送内容的可读性和趣味性。</p>

<p>为本地通知添加多媒体内容十分简单，只需要通过本地磁盘上的文件URL创建一个<code>UNNotificationAttachment</code>对象，然后将这个对象放到数组中赋值给<code>content</code>的<code>attachments</code>属性就行了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let content = UNMutableNotificationContent()
</span><span class='line'>content.title = "Image Notification"
</span><span class='line'>content.body = "Show me an image!"
</span><span class='line'>
</span><span class='line'>if let imageURL = Bundle.main.url(forResource: "image", withExtension: "jpg"),
</span><span class='line'>   let attachment = try? UNNotificationAttachment(identifier: "imageAttachment", url: imageURL, options: nil)
</span><span class='line'>{
</span><span class='line'>    content.attachments = [attachment]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在显示时，横幅或者弹窗将附带设置的图片，使用3D Touch pop通知或者下拉通知显示详细内容时，图片也会被放大显示：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20161017-4.png" alt="2" /></p>

<p>除了图片之外，通知还支持音频以及视频。你可以将MP3或者MP4这样的文件提供给系统来在通知中进行展示和播放，不过，这些文件都有尺寸的限制，比如图片不能超过5MB,视频不能超过50MB,不过对于一般的能在通知中展示的内容来说，这个尺寸应该是绰绰有余了。关于支持的文件格式和尺寸，可以在文档中进行确认。在创建<code>UNNotificationAttachment</code>时，如果遇到了不支持的格式，SDK也会抛出错误。</p>

<p>通过远程推送的方式，你也可以显示图片等多媒体内容，这要借助于上一节所提到的通过<code>Notification Service Extension</code>来修改涂松通知内容的技术。一般做法是，我们在推送payload中指定需要加载的图片资源地址，这个地址可以是应用bundle内已经存在的资源，也可以是网络的资源。不过因为在创建<code>UNNotificationAttachment</code>时偶们只能使用本地资源，所以如果多媒体还不在本地的话，我们需要先将其下载到本地，在完成<code>UNNotificationAttachment</code>创建后，我们就可以和本地通知一样，将它设置给<code>attachments</code>属性，然后调用<code>contentHandler</code>了。</p>

<p>简单的实例 payload如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "aps":{
</span><span class='line'>    "alert":{
</span><span class='line'>      "title":"Image Notification",
</span><span class='line'>      "body":"Show me an image from web!"
</span><span class='line'>    },
</span><span class='line'>    "mutable-content":1
</span><span class='line'>  },
</span><span class='line'>  "image": "https://onevcat.com/assets/images/background-cover.jpg"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>mutable-content</code>表示偶们会在接收到通知时对内容进行更改，<code>image</code>指明了目标图片的地址。</p>

<p>在<code>NotificationService</code>里，加入如下代码来下载图片，并将其保存到磁盘缓存中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {
</span><span class='line'>    let task = URLSession.shared.dataTask(with: url, completionHandler: {
</span><span class='line'>        data, res, error in
</span><span class='line'>
</span><span class='line'>        var localURL: URL? = nil
</span><span class='line'>
</span><span class='line'>        if let data = data {
</span><span class='line'>            let ext = (url.absoluteString as NSString).pathExtension
</span><span class='line'>            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)
</span><span class='line'>            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)
</span><span class='line'>
</span><span class='line'>            if let _ = try? data.write(to: url) {
</span><span class='line'>                localURL = url
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        handler(localURL)
</span><span class='line'>    })
</span><span class='line'>
</span><span class='line'>    task.resume()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后再<code>didReceive:</code>中，接收到这类通知时提取图片地址，下载，并生成attachment,进行通知展示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let imageURLString = bestAttemptContent.userInfo["image"] as? String,
</span><span class='line'>   let URL = URL(string: imageURLString)
</span><span class='line'>{
</span><span class='line'>    downloadAndSave(url: URL) { localURL in
</span><span class='line'>        if let localURL = localURL {
</span><span class='line'>            do {
</span><span class='line'>                let attachment = try UNNotificationAttachment(identifier: "image_downloaded", url: localURL, options: nil)
</span><span class='line'>                bestAttemptContent.attachments = [attachment]
</span><span class='line'>            } catch {
</span><span class='line'>                print(error)
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        contentHandler(bestAttemptContent)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>关于在通知中展示图案品或者视频，有几点想补充说明：</p>

<ol>
<li><code>UNNotificationContent</code>的<code>attachments</code>虽然是一个数组，但是系统只会展示第一个attachmen对象的内容。不过你依然可以发送多个<code>attachments</code>,然后再要展示的时候再重新安排他们的顺序，以显示最符合情景的图片或者视频。另外，你也可能会在自定义通知展示UI时用到多个<code>attachment</code>,我们接下来一节中会看到一个相关的例子。</li>
<li>在当前iOS10中，<code>serviceExtensionTimeWillExpire</code>被条用之前，你有30秒时间来处理和更改通知内容，对于一般的图片来说，这个时间是足够的，但是如果你推送的体积较大的视频内容，用户又恰巧在糟糕的网络环境的话，很有可能无法及时下载完成。</li>
<li>如果你想在远程推送来的通知中显示应用bundle内的资源的话，要注意extension的bundle和app main bundle并不是一回事，你可以选择将图片资源放到extension bundle中，也可以选择放在main bundle里，总之，你需要保证能够获取到正确的，并且你具有读取权限的url</li>
<li>系统在创建<code>attachement</code>时会根据提供的url后缀确定文件类型，如果没有后缀，或者后缀无法不正确的话，你可以在创建时通过<code>UNNotificationAttachmentOptionsTypeHintKey</code>来<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachmentoptionstypehintkey">指定资源类型</a></li>
<li>如果使用的图片和视频文件不在你的bundle内部，它们将被移动到系统的负责通知的文件夹下，然后当同志被移除后删除。如果媒体文件在bundle内部，它们将被负责到通知文件夹下。每个应用能使用的媒体文件大小总和是有限制，超过限制后创建<code>attachment</code>时将抛出异常。可能的所有错误可以再<code>UNError</code>中找到</li>
<li>你可以访问一个已经创建的<code>attachment</code>的内容，但是要注意权限问题，可以使用<code>startAccessingSecurityScopedResource</code>来暂时获取以创建的<code>attachment</code>的访问权限。比如：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let content = notification.request.content
</span><span class='line'>if let attachment = content.attachments.first {  
</span><span class='line'>    if attachment.url.startAccessingSecurityScopedResource() {  
</span><span class='line'>        eventImage.image = UIImage(contentsOfFile: attachment.url.path!)  
</span><span class='line'>        attachment.url.stopAccessingSecurityScopedResource()  
</span><span class='line'>    }  
</span><span class='line'>}  </span></code></pre></td></tr></table></div></figure>


<h2>自定义通知视图样式</h2>

<p>ioS10 SDK 新加的另一个<code>Content Extension</code>可以用来自定义通知的详细页面的视图，新建一个<code>Notification Content Extension</code>,Xcode为我们准备的模板中包含了一个实现了<code>UNNotificationContentExtension</code>的<code>UIViewController</code>子类。这个extension中有个一必须实现的方法<code>didReceive(_:)</code>,在系统需要显示自定义样式的通知详情视图时，这个方法将被调用，你需要在其中配置你的UI.而UI本身可以通过这个extension中的<code>MainInterface.storyboard</code>来进行定义。自定义UI的通知是和通知category绑定的，我们需要在<code>extension</code>的info.plist里指定这个通知样式所对应的category标识符：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/notification-content-info.png" alt="1" /></p>

<p>系统在接收到通知后会先查找有没有能够处理这类通知的content extension,如果存在，那么就交给extensionl来进行处理，另外，在构建UI时，我们可以通过Info.plist控制通知详细视图的尺寸，以及是否显示原始的通知。关于Content Extension中的info.plist的key,可以在<a href="https://developer.apple.com/reference/usernotificationsui/unnotificationcontentextension">这个文档</a>中找到详细信息。</p>

<p>虽然我们可以使用包括按钮在内的各种UI，但是系统不允许我们队这些UI进行交互，点击通知视图UI本身会将我们导航到应用中，不过我们可以通过action的方式来对自定义UI进行更新。<code>UNNotificationContentExtension</code>为我们提供了一个可选方法<code>didReceive(_:completionHandler:)</code>，它会在用户选择了某个action时被调用，你有机会在这里更新通知的UI，如果有UI更新，那么在方法的<code>completionHandler</code>中，开发者可以选择传递<code>. doNotDismiss</code>来保持通知继续呗显示。如果没有继续显示的必要，可以选择<code>. dismissAndForwardAction</code>或者<code>. dismiss</code>，前者将把通知的action继续传递给应用的<code>UNUserNotificationCenterDelegate</code>中的<code>userNotificationCenter(:didReceive:withCompletionHandler)</code>，而后者将直接解散这个通知</p>

<p>如果你的自定义UI包含视频等，你还可以实现<code>UNNotificationContentExtension</code>里的<code>media</code>开头的一系列属性，它将为你提供一些视频播放的控件和相关方法。</p>

<h2>总结</h2>

<p>iOS10 SDk中对通知这块进行了IOS系统发布以来最大的一次重构，很多"老朋友"都被标记为了 deprecated:</p>

<h2>iOS10中被标记弃用的API</h2>

<ul>
<li>UILocalNotification</li>
<li>UIMutableUserNotificationAction</li>
<li>UIMutableUserNotificationCategory</li>
<li>UIUserNotificationAction</li>
<li>UIUserNotificationCategory</li>
<li>UIUserNotificationSettings</li>
<li>handleActionWithIdentifier:forLocalNotification:</li>
<li>handleActionWithIdentifier:forRemoteNotification:</li>
<li>didReceiveLocalNotification:withCompletion:</li>
<li>didReceiveRemoteNotification:withCompletion:</li>
</ul>


<p>等一系列在<code>UIKIT</code>中的发送和处理通知的类型及方法</p>

<p>相比较于iOS早期时代的API,新的APi展现了高度的模块化和统一特性，易用性也非常好，是一套更加先进的API,如果有可能，特别是如果你的应用是重度依赖通知特性的话，直接从iOS10开始可以让你充分使用在新同志体系的各种特性。</p>

<p>虽然原来的API都被标为弃用了，但是如果需要支持iOS10之前系统的话，你还是需要使用原来的API,我们可以使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if #available(iOS 10.0, *) {
</span><span class='line'>    // Use UserNotification
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>的方式来对iOS10进行新通知的适配，并让iOS10的用户享受到新通知带来的便利特性，然后在将来版本升级到只支持iOS10以上时再移除掉所有被启用的代码。对于优化和梳理通知相关代码来说，新API对代码设计和祖上上带来的好处足以弥补适配上的麻烦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配iOS10]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10/"/>
    <updated>2016-10-10T11:03:06+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/10/10/gua-pei-ios10</id>
    <content type="html"><![CDATA[<h2>UICOllecitonViewCell的优化</h2>

<p>在ios10之前，UIcollectionView上面如果有大量的Cell,当用户活动很快的时候，整个UIcollectionView有很卡顿，为什么会造成这样的问题，这里涉及到iOS系统的重用机制，当cell准备加载进到屏幕的时候，整个cell都已经加载完成，等待在屏幕外面了，也就是整整一行cell都已经加载完毕，这就是造成卡顿的主要原因，专业术语叫掉帧</p>

<!--more-->


<p>iOS10之前的UIcollectionViewCell的生命周期是这样的:</p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这个方法里面，可以重置cell的状态，加载新的数据</li>
<li>继续欢动，就会调用cellForItemAtIndexPath方法，在这个方法里面给cell赋值模型，然后返回给系统</li>
<li>当cell马上进去屏幕的时候，就会调用willDispalyCell方法，在这个方法里面我们还可以修改cell,为进入屏幕做最后的准备工作</li>
<li>执行完willDisplayCell方法后，cell就进去屏幕了，当cell完全离开屏幕之后，会调用didEndDisplayingCell方法</li>
</ol>


<p><em>ios 10 UIcollectionViewCell的生命周期是这样的</em></p>

<ol>
<li>用户滑动屏幕，屏幕外有一个cell准备加载进来，把cell从reusr队列拿出来，然后调用prepareForReuse方法，在这里当cell还没有进去屏幕的时候，就已经提前调用这个方法了，对比之前的区别就是cell的上边缘拿上进去屏幕的时候就会调用该方法，而ios10提前到cell还在屏幕外面的时候就调用</li>
<li>在cellForItemAtIndexPath中创建cell,填充数据，刷新状态等操作，相比之前也提前了</li>
<li>用户继续滑动的话，当cell马上就需要显示的时候我们再调用willDisplayCell方法，原则就是：何时需要显示，何时再去调用willDisplayCell方法</li>
<li>当cell完全离开屏幕以后，会调用didEndDispalyingCell方法，跟之前一样，cell会进入重用队列</li>
</ol>


<p>在ios10之前，cell只能从重用队列里面取出，再走一遍生命周期，并调用cellForItemAtIndexPath创建或者生成一个cell.</p>

<p>在ios10中，系统cell会保存一段时间，也就是说当用户把cell滑出屏幕以后，如果又滑动回来，cell不用再走一遍生命周期了，只需要调用willDisplayCell方法就可以重现出现在屏幕中了。</p>

<h2>ios10新增加的Pre-Fetching预加载</h2>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时间，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<p>这个是为了降低UIcollectionViewCell在加载的时候所花费的时候，在iOS10中，除了数据源协议和代理协议外，新增加了一个UIcollectionViewDataSourcePrefetching协议，这个协议里面定义了两个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAtIndexPaths:(NSArray *)indexPaths NS_AVAILABLE_IOS(10_0);
</span><span class='line'>
</span><span class='line'>- (void)collectionView:(UICollectionView *)collectionView cancelPrefetchingForItemsAtIndexPaths:(NSArray *)indexPaths  NS_AVAILABLE_IOS(10_0);</span></code></pre></td></tr></table></div></figure>


<p>在CollectionView prefetchItemAt indexPaths这个方法是异步预加载数据的，当中的indexPaths数组是有序的，就是Item接收数据的顺序：
ColletionView cancelPrefetchingForItemsAt indexPaths这个方法是可选的，可以用来处理在滑动中取消或者降低提前加载数据的优先级。
这个协议并不能代替之前读取数据的方法，仅仅是辅助加载数据</p>

<h2>UIRefreshControl的使用</h2>

<p>在iOS10中，UIRefreshControl 可以直接在UIcollectionView和UITableView中使用，并且脱离了UITableViewController，现在RefreshControl是UIScrollView的一个属性。</p>

<p>使用方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIRefreshControl *refreshControl = [[UIRefreshControl alloc] init];
</span><span class='line'>  [refreshControl addTarget:self action:@selector(loadData) forControlEvents:UIControlEventValueChanged];
</span><span class='line'>    collectionView.refreshControl = refreshControl;</span></code></pre></td></tr></table></div></figure>


<h2>关于ATS的问题</h2>

<p>WWDC2015提出的ATS(App Transport Security)是Apple在推进网络通讯安全的一个重要的方式，在iOS9中，默认情况下非HTTPS的网络访问是被禁止的。当然，因为这样的推进影响面非常广，作为缓冲，我们可以在info.plist中添加<code>NSAppTransportSecurity</code>字典并且将<code>NSAllowsArbitraryLoads</code>设置为<code>YES</code>来禁用ATS.相信大家已经对这个非常熟悉了。</p>

<p>不过在WWDC2016中，Apple表示将继续在ios10和macOS 10.12里收紧对普通http的访问限制。从2017年一月一日起，所有的提交的app默认是不允许使用<code>NSAllowsArbitraryLoads</code>来绕过ATS限制的，也就是说，我们最好保证app的所有的网络请求都是HTTPS加密的，否则可能会在应用审核时遇到麻烦。</p>

<ol>
<li>默认情况下你的app可以访问加密足够强（TLS v1.2以上，AES-128和SHA-2）的HTTPS内容，这对所有的网络请求都有效，包括<code>NSURLSession</code>,<code>UIWebview</code>以及<code>WkWebView</code>等</li>
<li>你依然可以添加<code>NSAllowsArbitraryLoads</code>为<code>YES</code>来禁用ATS,不过如果你这么做的话，需要在提交app时进行说明，为什么需要访问非HTTPS的内容，一般来说，可能类似浏览器类的app比较容易能通过</li>
<li>相比于使用<code>NSAllowsArbitraryLoads</code>将全部HTTP内容放开，选择使用<code>NSExceptionDomains</code>来针对特定的域名开放HTTP应该要相对容易过审核。“需要访问的域名是第三方服务器,他们没有进行HTTPS对应”，会是审核时的一个可选理由，但是这应该只需要针对特定域名，而非全面开放，如果访问的是自己的服务器的话，可能这个理由会无法通过</li>
<li>对于网页浏览和视频播放的行为，iOS10中新加入了<code>NSAllowsArbitraryLoadsInWebContent</code>键，通过将它设置为<code>YES</code>，可以让你的app中的<code>WKWebView</code>和使用<code>AVFoundation</code>播放的在线视频不受ATS的限制。这也应该是绝大多数使用了相关特性的app的选择。但是坏消息是这个键在ios9中并不会起到作用</li>
</ol>


<p>总结：对于API请求，基本上必须使用HTTPS的，特别是如果你们自己可以管理服务器的话，可能需要后端的同学尽快升级到HTTPS.如果你的app只支持iOS10,并且有用户可以自由输入网址进行浏览的功能，或者是在线视频音频播放功能的话，简单地加入<code>NSAllowsArbitraryLoadsInWebContent</code>并且将组件换成<code>WKWebKit</code>或者<code>AVFoundation</code>就可以了。如果你还需要支持ios9,并且需要访问网页和视频的话，可能只能开启<code>NSAllowsArbitraryLoads</code>然后提交的时候进行说明，并且看Apple审核员的脸色决定让不让通过了。除了<code>WKWebKit</code>以外，另外一个访问网页的选择是使用<code>SFSafariViewController</code>。因为其实<code>SFSafariViewController</code>就是一个独立于App的Safari进程，所以它完全不受ATS限制</p>

<p>另外，当<code>NSAllowsArbitraryLoads</code>和<code>NSAllowsArbitraryLoadsInWebContent</code>同时存在时，根据系统不同，表现的行为也会不一样，简单说，ios9只看<code>NSAllowsArbitraryLoads</code>,而ios10会先看<code>NSAllowsArbitraryLoadsInWebContent</code>.在ios10中，要是<code>NSAllowsArbitraryLoadsInWebContent</code>存在的话，就忽略掉<code>NSAllowsArbitraryLoads</code>,如果它不存在，则遵循<code>NSAllowsArbitraryLoads</code>的设定。</p>
]]></content>
  </entry>
  
</feed>
