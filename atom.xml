<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-04-19T21:53:36+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/hello-world/"/>
    <updated>2016-04-19T17:24:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/hello-world</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中的多任务]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu/"/>
    <updated>2016-04-19T10:17:49+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsynDisplayKit入门篇]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/"/>
    <updated>2016-04-15T10:22:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>FaceBook的Paper团队给我们开源了一个很棒的库:<a href="https://github.com/facebook/AsyncDisplayKit">AsynDisplayKit</a>,这个库能让你通过将图像解码，布局以及渲染操作都放到后台线程处理，从而带来了快速响应的用户界面，也就是说不再会因为界面卡顿尔阻断用户交互。</p>

<!--more-->


<p>例如，对于非常复杂的界面，你可以使用 AsyncDisplayKit构建它而得到一种如丝般顺滑的，60帧每秒的滑动体验。而平常的UIkit优化就不太可能克服这样的性能挑战。</p>

<p>从本教程中，你将从一个初始项目开始，它主要有一个UICollectionView的滑动问题，而使用AysncDisplayKit将大大提供其滑动性能。一路上，你将学会如何在旧项目上使用AsyncDisplaykit.</p>

<blockquote><p><em>注意</em>，在本教程之前，你应该熟悉 Swift,Core Animation以及Core Graphics.</p></blockquote>

<h2>开始</h2>

<p>开始之前，请先看看<a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/">AsyncDisplayKit介绍</a>,对它有个简要的概念，知道它是解决什么问题的。</p>

<p>准备好了，就下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/04/Layers-Start.zip">开始项目</a>,你需要至少Xcode6.1和iosSDK 8.1来编译它，如果用最新Xcode打开，swift语法需要做下转换和修改，请自行解决这些兼容问题.</p>

<p>你要研究的项目是由UICollectionView制作的卡片式界面来描述不同的雨林动物，每张信息卡上包含了一个图片，名字以及一个队雨林动物的描述，卡片的背景图是主图片的模糊感，视觉上设计的效果保证了文字的清晰可读。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20141124/1416797117122129.png" alt="logo" />
在Xcode中，打开初始项目的 Layers.xcworkspace。</p>

<p>在本教程里，请遵循以下原则以体会AsyncDisplayKit的那些十分吸引人的好处。</p>

<p>将应用运行到真机上，在模拟器上很难看出性能改善。</p>

<p>应用是通用的，但在ipad上看起来最好。</p>

<p>最后，要真正感谢这个库为你所有的事情，请尽量在最旧的ios8.1的设备上去运行该应用，第三代的ipad最好，因为它随让是视网膜屏，但是运行的不是很快。</p>

<p>运行该项目，效果如下:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt="logo" /></p>

<p>试着滑动CollectionVie并注意那可怜的帧率，在第三代ipad上，帧率只有15-20FPS，实在丢掉太多帧了，在本教程的最后，你能在60 FPS的帧率下滑动它.</p>

<blockquote><p><em>注意</em>
你所看到的图像都是在App的asset目录里，并不是从网络里获取的。</p></blockquote>

<p>在一个旧项目中使用AsyncDisplayKit前，你应该通过Instruments测量你的UI的性能，这样才能有一个基准线以便对比改动的效果。</p>

<p>最重要的是，你要知道是CPU-绑定，还是GPU-绑定，也就是说是CPU还是GPU拉低了应用的帧率，这个信息会告诉你该充分利用AsyncDisplayKit的那个特性以优化应用的性能。</p>

<p>如果你有时间，看看之前提到的WWDC2012 session 或在真实的设备上使用Instruments来评估初始项目的时间曲线。滑动性能是CPU-绑定的，你能猜到是什么原因导致了 CollectionView 丢掉了这么多帧吗?</p>

<h2>为项目准备好使用 AsyncDisplayKit</h2>

<p>在旧项目里使用AsyncDisplayKit，总结起来就是使用 Display Node 层级结构替换视图层级结构或Layer树，各种Display Node是AsyncDisplayKit的关键所在，它们位于视图之上，而且是线程安全的，也就是说之前在主线程才能执行的任务现在也可以在非主线程中执行。这就是减少主线程的工作量以执行其它操作，例如处理触摸事件，或如下本应用的情况下，处理CollectionView的滑动。</p>

<p>这就意味着在本教程里，你的第一步是移除视图层级结构。</p>

<h3>移除视图的层次结构</h3>

<p>打开 RainForestCardCell.Swift并删除awakeFromNib() 中所有的 addSubview(&hellip;.)调用，然后得到如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'>  contentView.layer.borderColor =
</span><span class='line'>    UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>  contentView.layer.borderWidth = 1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，替换LayoutSubviews()的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再讲configureCellDisplayWithCardInfo(cardInfo:)的内容替换如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>删除RainforestCardCell的所有视图属性，只留一个如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后编译运行，你看的的是黑洞洞的一片:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt="logo" /></p>

<p>现在所有的cell都空了，滑动起来就很顺滑，你的目标是保证之后添加完各个Node之后，依然顺滑如初。</p>

<h3>添加一个占位图</h3>

<p>打开RainforestCardCell.swift,给RainforestCardCell添加一个可选的 CALayer变量，名为placeholderLayer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要一个占位图是因为显示会异步完成，如果这个过程需要一些时间，那用户就会看到空的cell 。就如同如果你要从网络上获取图像，那么就需要用占位图来填充Cell,这能让你的用户知道内容还没准备好。随让在我们这种情况下，你是在后台线程绘制而不是从网络上下载。</p>

<p>在awakeFromNib()里，删除contentView的border设置，再创建并配置一个placeholderLayer.将其添加到cell的contentview的layer上，现在这个方法如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer = CALayer()
</span><span class='line'>  placeholderLayer.contents = UIImage(named: "cardPlaceholder")!.CGImage
</span><span class='line'>  placeholderLayer.contentsGravity = kCAGravityCenter
</span><span class='line'>  placeholderLayer.contentsScale = UIScreen.mainScreen().scale
</span><span class='line'>  placeholderLayer.backgroundColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 1).CGColor
</span><span class='line'>  contentView.layer.addSublayer(placeholderLayer)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在layoutSubviews()里，你需要布局placeholderLayer.替换这个方法为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译并运行，你从虚无的边缘回来了:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt="logo" /></p>

<p>普通的CALayer不是由UIview支持的，当它们改变frame时，默认会有隐式动画，这就是你看到layer在布局放大时，要修复这个问题，改动layoutSubviews()如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  CATransaction.begin()
</span><span class='line'>  CATransaction.setValue(kCFBooleanTrue, forKey: kCATransactionDisableActions)
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>  CATransaction.commit()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，问题解决了。</p>

<p>现在占位图不会乱动，不再动画它们的frame了。</p>

<h2>第一个Node</h2>

<p>重建App的第一步就是给每一个UICollectionView cell 添加一个背景图片的Node,步骤如下:</p>

<ol>
<li>创建，布局并添加一个图像Node到UICollectionView cell</li>
<li>处理cell重用Node和它们的layer</li>
<li>模糊图像Node</li>
</ol>


<p>但在做之前，打开 Layers-Bridging-Header.h 并导入 AsyncDisplayKit :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</span><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>这会让所有的Swift文件都能访问AsyncDisplayKit类库。</p>

<p>编译一下，确保没有错误</p>

<p>现在，我们来看看Collectin View的祖成:</p>

<ul>
<li>View Controller: RainforestViewController没有什么花哨的东西，它只是为所有的雨林卡片获取一个数据数组，并为UIcollectioNView实现DataSource.事实上，你不需要花太多时间在这个上</li>
<li>DataSource:大部分时间都将花在Cell类的RainforestCardCell上，ViewController出队每个cell，并将雨林卡片的数据用configureCellDisplayWithCardInfo(cardInfo:) 传给它。cell就使用这个数据来配置自身.</li>
<li>Cell: 在configureCellDisplayWithCardInfo(cardInfo:)里，cell创建，配置，布局以及添加Node到它自己身上。这就意味着每次ViewController出队一个cell,这个cell就会创建并添加它自己一个新的Node层级结构</li>
</ul>


<p>如果你使用View而不是Node，那么这样做对于性能来说就不是最佳策略。但因为你可以异步的创建，配置以及布局，而且Node也是异步地绘制，所以这不会是一个问题。真正的难点是在cell准备重用时取消任何在进行额异步操作并移除旧的node.</p>

<p>然而，在实际生产中，你最好使用ASRangeController来缓存你的Node,这样你就不用每次在cell重用时重建它的Node层级结构，ASRangeController超出了本教程的范围。</p>

<p>OK，动手!</p>

<h3>添加背景图片Node</h3>

<p>现在你要走一遍用Node配置cell的过程，一次一步：
打开RainforestCardCell.swift 并替换configureCellDisplayWithCardInfo(cardInfo:) 为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个ASImageNode常量，叫做backgroundImageNode.</p>

<p>AsyncDisplayKit带有好几种Node类型，包括ASImageNode，用于显示图片。它相当于UIImageView,除了ASImageNode是默认异步的解码图片。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这让backgroundImageNode变为layer支持的Node.</p>

<p>Node可由UIview支持或CALayer支持，当node需要处理事件时（例如触摸事件），你就要使用UIView支持的Node.如果你不需要处理事件，只需要显示一下内容，那使用Layer支持的Node会更加轻量，因此可以获得一个小的性能提升。</p>

<p>因为本教程的APP不需要处理事件，所以你可以让所有的Node都设置为Layer支持的。在上面的代码中，由于backgroundImageNode为Layer支持的。AsyncDisplayKit会创建一个CALayer用于雨林动物图像内容的显示.</p>

<p>继续在 configureCellDisplayWithCardInfo(cardInfo:)添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>这里使用FrameCalculator为backgroundImageNode布局.</p>

<p>FrameCalculator是一个帮助类，负责给每个Node布局。注意所有的东西都是手动布局的，没有使用AutoLayout约束。<strong>如果你需要构建自适应布局或者本地化驱动的布局，那就要注意，因为你不能给Node添加约束</strong></p>

<p>接下来，添加如下代码到configureCellDisplayWithCardInfo(cardInfo:)底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layer and Wrap Up Section
</span><span class='line'>self.contentView.layer.addSublayer(backgroundImageNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>这句将backgroundImageNode的layer添加到cell ContentView的layer上。</p>

<blockquote><p><strong>注意</strong>
AsyncDisplayKit会为backgroundImageNode创建一个Layer.然而，你必须要将Node放到某个Layer树中才能在屏幕上显示，这个Node会异步地绘制，所以直到绘制完成，它的内容都不会显示，尽管它的Layer已经在一个Layer树中。</p></blockquote>

<p>从技术的角度来说，layer一直都存在。但渲染图像是异步进行的。layer初始化时没有内容，一旦渲染完成，layer的contents就会更新为包含图像的内容。</p>

<p>在这个点，cell的contentView的layer将会包含两个Sublayer:一个占位图和Node的layer。在node完成绘制前，只有占位图会显示。</p>

<p>注意到configureCellDisplayWithCardInfo(cardInfo:)会在每次cell出队时被调用。每次cell被回收，这个逻辑会添加一个新的sublayer到cell的contentview layer上。不要担心，你很快会解决这个问题。</p>

<p>回到RainforestCardCell.swift开头，给RainforestCardCell添加一个ASImageNode变量存为属性backgroundImageNode，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要这个属性是因为必须要有某个东西将backgroundImageNode的引用保留住，否则ARC就会将其释放，也就不会有任何东西显示出来了&ndash;即使Node的在一个layer树中，你依然需要保留Node.</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:)底部的Node Layer and Wrap Up Section ,设置cell新的backgroundImageNode为之前的backgroundImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>下面是完整的configureCellDisplayWithCardInfo(cardInfo:) 方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>  backgroundImageNode.layerBacked = true
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layout Section
</span><span class='line'>  backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layer and Wrap Up Section
</span><span class='line'>  self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>  self.backgroundImageNode = backgroundImageNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，观察AsyncDisplaytKit是如何异步地使用图像设置Layer的Contents的。这能让你在CPU还在绘制layer的内容的同事上下滑动页面。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>如果你运行在旧设备上，注意图像是如何弹出到位置&ndash;这是爆米花效果，但不总是让人喜欢。本教程的最后一节将会搞定这个不令人愉快的弹出效果，给你展示图像如何弹入弹出，如同摇滚巨星。</p>

<p>如同之前所讨论的，新的Node会在每次cell被重用时创建，这并不理想，因为这意味着新的Layer会在每次cell被重用时加入。</p>

<p>如果你想看看Sublayer堆积太多的影响，那就不停的滑上滑下，然后加断点打印出cell的contentview的Layer的sublayers属性。你会看到很多layer,这不好.</p>

<h2>处理cell重用</h2>

<p>继续RainforestCardCell.swift,给RainforestCardCell 添加一个contentLayer的CALayer属性，这个属性也是一个可选类型:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你将使用此属性去移除Cell的ContentView的Layer树中旧的Node Layer.虽然你可以简单地保留Node并访问其Layer属性，但上面的写法更加明确。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 结尾：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.contentLayer = backgroundImageNode.layer</span></code></pre></td></tr></table></div></figure>


<p>这句让backgroundImageNode的Layer保留到contentLayer属性。</p>

<p>替换prepareForReuse()的实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'>  backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为AsyncDisplaytKit能够异步地绘制Node,所以Node让你能预防从头绘制或取消任何在进行的绘制。无论是你需要预防或取消绘制，都可将preventOrcancelDisplay设置为true,如上面的代码所示，在本来中，你要在cell被重用前取消任何正在进行的绘制活动.</p>

<p>接下来，添加如下代码到prepareForReuse（）尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer?.removeFromSuperlayer()</span></code></pre></td></tr></table></div></figure>


<p>这将contentLayer从其SuperLayer(也就是contentview的Layer)中移除.</p>

<p>每次一个cell被回收时，这个代码就移除Node的旧Layer,因而解决了堆积问题。所以在任何时间，你的Node最多只有两个sublayer:占位图和Node的Layer.</p>

<p>接下来添加如下代码到prepareForReuse()尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer = nil
</span><span class='line'>backgroundImageNode = nil</span></code></pre></td></tr></table></div></figure>


<p>这确保cell释放它们的引用，这样如有必要，ARC才好做清理工作。</p>

<p>编译运行，这次，没有sublayer会堆积的问题，且所有不必要的绘制都将被取消.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>是时候来点模糊效果了!
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/asyncscroll.png" alt="blue" /></p>

<h2>模糊图像</h2>

<p>要实现模糊图像，你要添加一个额外的步骤到图像Node的显示过程里。</p>

<p>继续RainforestCardCell.swift ,在configureCellDisplayWithCardInfo(cardInfo:) 的设置backgroundImageNode.layerBacked 的后面，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'>  if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>    30,
</span><span class='line'>    tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>    saturationDeltaFactor: 1.8,
</span><span class='line'>    maskImage: nil, 
</span><span class='line'>    didCancel:{ return false }) {
</span><span class='line'>      return blurredImage
</span><span class='line'>  } else {
</span><span class='line'>    return image
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ASImageNode的imageModificationBlock给你一个积水在显示之前去处理底层的图像，这是非常实用的功能，它让你对图像Node做一些操作，例如添加滤镜等。</p>

<p>在上面的代码中，你使用imageModificationBlock来为cell的背景图像应用模糊效果。关键点就是图像Node将会绘制它的内容并在后台执行这个闭包，而主线程依然顺滑流畅。这个闭包接受原始的UIImage并返回一个修改过的UIimage.</p>

<p>上面的代码使用了UIImage的模糊category,它由Apple在WWDC2013提供。使用了Accelerate framework 在CPU上模糊图像。因为模糊会消耗很多时间和内存，这个版本的category被修改为包含了取消机制。这个模糊方法将定期调用didCancel闭包来决定是否应该停止模糊。</p>

<p>现在，上面的代码给didCancel简单地返回false,之后你可以重写didCancel闭包.</p>

<blockquote><p><em>注意</em>
还记得第一次运行APP时collectionView那可怜的滑动效果吗？模糊方法阻塞了主线程。通过使用AsyncDisplayKit将模糊放入后台线程，你就大幅度地提高了CollectionView的滑动性能。简直天壤之别。</p></blockquote>

<p>编译并运行，观察模糊效果:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="lgo" />
注意你可以非常流畅的滑动页面了</p>

<p>当Collectionview出队一个cell时，一个模糊操作将开始后台线程，当用户快速滑动时，CollectionView会重用每个cell多次，并开始许多模糊操作。我们的目标是在cell准备重用时取消正在进行中的模糊操作。</p>

<p>你已经在prepareForReuse()里取消了Node的绘制操作，但一旦控制被移交给处理你图像修改的闭包，那就是你的责任来处理Node的preventOrCancelDisplay的设置。</p>

<h2>取消模糊操作</h2>

<p>要取消进行中的模糊操作，你需要实现模糊方法的didCancel闭包.</p>

<p>添加一个捕获列表到imageModificationBlock以捕捉一个backgroundImageNode的weak引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>   ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你需啊哟weak引用来避免闭包和图像Node之间的循环引用问题。你将使用这个weak  backgroundImageNode 来确定是否要取消模糊操作。</p>

<p>是时候构建模糊取消碧波啊了。添加如下代码到imageModificationBlock:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  let didCancelBlur: () -&gt; Bool = {
</span><span class='line'>    var isCancelled = true
</span><span class='line'>    // 1
</span><span class='line'>    if let strongBackgroundImageNode = backgroundImageNode {
</span><span class='line'>      // 2
</span><span class='line'>      let isCancelledClosure = {
</span><span class='line'>        isCancelled = strongBackgroundImageNode.preventOrCancelDisplay
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      // 3
</span><span class='line'>      if NSThread.isMainThread() {
</span><span class='line'>        isCancelledClosure()
</span><span class='line'>      } else {
</span><span class='line'>        dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    return isCancelled
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这些代码：</p>

<ol>
<li>得到backgroundImageNode的Strong引用，准备其干活。如果backgroundImageNode在本次运行时小时，那么isCancelled将保持为true,然后模糊操作会被取消，如果没有Node需要显示，自然没有必要继续模糊操作。</li>
<li>在此你将操作取消检查包在闭包里，因为一旦Node创建它的Layer或View，那就只能在主线程访问Node的属性。由于你需要访问preventOrCancelDisplay，所以你必须在主线程检查。</li>
<li>最后，确保isCancelledClosure是在主线程进行，无论是在主线程直接运行，还是不再主线程而通过dispatch_sync来调度。它必须是一个同步的调度，因为我们需要闭包完成，并在didCancelblue闭包返回之前设置isCancelled.</li>
</ol>


<p>在调用applyBlurWithRadius(&hellip;)中，修改传递给didCancel的参数，替换一直返回false的闭包为你刚才定义并保留在didCancelBlur的闭包。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>  30,
</span><span class='line'>  tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>  saturationDeltaFactor: 1.8,
</span><span class='line'>  maskImage: nil,
</span><span class='line'>  didCancel: didCancelBlur) {
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你看你不会注意到太多差别，但现在任何在cell离开屏幕时还未完成的模糊都会被取消了。这就意味着设备比之前做的更少。你可能观察到轻微的性能提升，特别是在较慢的设备如第三代iPad上运行。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<p>你的卡片需要内容，通过下面四个小节，你将学会:</p>

<ul>
<li>创建一个容器Node,它将所有的SubNode绘制到一个单独的CALayer里</li>
<li>构建一个Node层次结构</li>
<li>创建一个自定义的ASDispalyNode子类，并在后台构建并布局Node层次结构</li>
</ul>


<p>做完这些，你就会得到一个看起来和添加AsyncDisplayKit之前一样的APP，但有着黄油版顺滑的滑动体验。</p>

<h2>栅格化的容器Node</h2>

<p>直到现在，你一直在操作cell内的一个单独的Node，接下来，你将创建一个容器Node，它会包含所有卡片内容。</p>

<h3>添加一个容器Node</h3>

<p>继续 RainforestCardCell.swift,在 configureCellDisplayWithCardInfo(cardInfo:) 的backgroundImageNode.imageModificationBlock后面以及Node Layout Section前面添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Container Node Creation Section
</span><span class='line'>let containerNode = ASDisplayNode()
</span><span class='line'>containerNode.layerBacked = true
</span><span class='line'>containerNode.shouldRasterizeDescendants = true
</span><span class='line'>containerNode.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>containerNode.borderWidth = 1</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做containerNode的ASDisplayNode常量。注意这个容器的shouldRasterizeDescendants,这是一个关于节点如何工作的提示以及一个如何让它们工作的更好的机会.</p>

<p>如单词<code>descendants (子孙)</code>所暗示的，你可以创建 AsyncDisplayKit Node的层次结构或树，就如你可以创建Core Animation Layer 的层次结构一样。例如，如果你有一个都是Layer支持的Node层级结构，那么AsyncDisplaykit将会为每个Node创建一个分离的CALayer,Layer层次结构将会和Node层级结构一样，如同镜像。</p>

<p>这听起来很熟悉：它类似于当你使用UIkit时，Layer层次结构镜像于View层次结构。然而，这个Layer的栈有一些不同的效果。</p>

<p>首先，因为是异步渲染，你就不会看到每个layer一个接一个的显示，当AsyncDisplayKit绘制完成每个layer，它马上制作layer的显示内容，所以如果你有一个layer的绘制比其他layer耗时更长，那么它将会在它们之后显示。用户会看到零碎的layer组件，这个过程通常是不可见的，因为Core Animation会在显示任何东西之前重绘所有必须的Layer。</p>

<p>第二，有需要Layer能够引起性能问题。每个CALayer都需要一个支持存储来保存它的像素位图和内容。同样，CoreAnimation必须将每个Layer通过XPC发给渲染服务器。最后，渲染服务器可能需要重绘一些Layer以复合它们，例如在混合layer时，总的来说，更多的Layer意味着CoreAnimation更多的工作。所以限制layer使用的数量有许多不同的好处。</p>

<p>为了解决这个问题，AsyncDisplayKit有一个方便的特性，它允许你绘制一个Node层次结构到一个单独的Layer容器里。这就是shouldRasterizeDescendants所做的，当你设置它，那在完成素有的subnode的绘制之前，ASDisplayNode将不会设置Layer的Contents。</p>

<p>所以在之前的步骤里，设置容器Node的shouldRasterizeDescendants为true有两个好处:</p>

<ol>
<li>它确保卡片一次显示所有的Node，如同旧的同步绘制</li>
<li>而且它通过栅格化Layer栈为单个Layer并较少未来的合成而提高了效率</li>
</ol>


<p>不足之处是，由于你将所有的layer放入了一个位图，你就不能再之后单独动画某个Node了。</p>

<p>接下来，在 Container Node Creation Section后，添加backgroundImageNode为containerNode的subnode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em>
添加Node的顺序很重要，就如同subview和sublayer,最先添加的Node会被之后添加的阻挡显示</p></blockquote>

<p>替换 Node Layout Section 的第一行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>containerNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>最后，使用FrameCalculator布局backgroundImageNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForBackgroundImage(
</span><span class='line'>  containerBounds: containerNode.bounds)</span></code></pre></td></tr></table></div></figure>


<p>这设置backgroundImageNode填满整个containerNode.</p>

<p>你几乎完成了新的Node层次结构，但首先你需要正确地设置Layer层次结构，因为容器Node现在是根。</p>

<h3>管理容器Node的Layer</h3>

<p>在Node Layer and Wrap Up Section，将backgroundImageNode的Layer添加到containerNode的layer上，而不是containerView的Layer上:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentView.layer.addSublayer(containerNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>删除下面的backgroundImageNode保留:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>因为cell只需要单独保留容器Node,所以你要移除backgroundImageNode属性。</p>

<p>不再设置cell的contentLayer属性为backgroundImageNode的Layer,现在将其设置为containerNode的layer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentLayer = backgroundImageNode.layer
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentLayer = containerNode.layer</span></code></pre></td></tr></table></div></figure>


<p>给RainforestCardCell添加一个可选的ASDisplayNode实例存储为属性containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>记住你需要保留你自己的Node，如果你不怎么做它们就会被立即释放。</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:)，在Node Layer and Wrap Up Section 最后，设置containerNode属性为containerNode常量:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>编译运行，模糊的图形将会再次显示！但还有最后一件事要去改变，因为现在有了新的Node层次结构，回忆之前cell重用时你将图像停止显示。现在你需要让整个Node层次结构停止显示。</p>

<h3>在新的Node层次结构上处理cell重用</h3>

<p>继续RainforestCardCell.swift ，在prepareForReuse()里，替换设置backgroundImageNode.preventOrCancelDisplay 为在 containerNode 上调用 recursiveSetPreventOrCancelDisplay(&hellip;) 并传递 true：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'> 
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你要取消整个Node层次结构的绘制，就使用 recursiveSetPreventOrCancelDisplay()。这个方法将会设置这个node以及所有子Node的preventOrCancelDisplay属性，无论true或false。</p>

<p>接下来，依然在prepareForReuse(),用设置containerNode为nil替换设置backgroundImageNode为nil:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  ...
</span><span class='line'>  contentLayer = nil
</span><span class='line'>
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode = nil
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>移除RainforestCardCell的backgroundImageNode属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  // var backgroundImageNode: ASImageNode? ///&lt; REMOVE THIS LINE
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，这个APP就如之前一样，但现在你的图像Node在容器Node内，而重用依然和它应有的方式一样.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<h2>cell内容</h2>

<p>目前为止你有了一个Node层级结构，但容器内还只有一个Node&ndash;图像Node.现在是时候设置Node层次结构去复制在添加AsyncDisplayKit之前时应用的视图层次结构了。这意味着添加text和一个未模糊的特征图像。</p>

<h3>添加特征图像</h3>

<p>我们要添加特征图像了，它是一个未模糊的图像，显示在卡片的顶部。</p>

<p>打开RainforestCardCell.swift ，并找到configureCellDisplayWithCardInfo(cardInfo:).在Node Creation Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let featureImageNode = ASImageNode()
</span><span class='line'>featureImageNode.layerBacked = true
</span><span class='line'>featureImageNode.contentMode = .ScaleAspectFit
</span><span class='line'>featureImageNode.image = image</span></code></pre></td></tr></table></div></figure>


<p>这会创建并配置一个叫做featureImageNode的ASImageNode常量。它被设置为Layer支持的，放大以适用，并设置显示图像，这次不需要模糊。</p>

<p>在Node Hierarchy Section的最后，添加featureImageNode为containerNode的subNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(featureImageNode)
</span></code></pre></td></tr></table></div></figure>


<p>你正在用更多Node填充容器哦!</p>

<p>在Node Layout Section中，使用FrameCalculator布局featureImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>featureImageNode.frame = FrameCalculator.frameForFeatureImage(
</span><span class='line'>  featureImageSize: image.size,
</span><span class='line'>  containerFrameWidth: containerNode.frame.size.width)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你就会看到特征图像在卡片的顶部出现，位于模糊图像的上方，注意特征图像和模糊图像是如何在同一时间跳出。这是你之前添加的shouldRasterizeDescendants在起作用.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0015.png" alt="logo" /></p>

<h2>添加Title文本</h2>

<p>接下来添加文字Label,以显示动物的名字和描述，首先来添加动物名字吧。</p>

<p>继续configureCellDisplayWithCardInfo(cardInfo:),找到Node Creation Section。添加下列代码到这节尾部，就在创建featureImageNode之后：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode = ASTextNode()
</span><span class='line'>titleTextNode.layerBacked = true
</span><span class='line'>titleTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(cardInfo.name)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做titleTextNode的AsTextNode常量。</p>

<p>ASTextNode是另一个AsyncDisplayKit提供的Node子类，其用于显示文本。他是一个具有UIlabel效果的Node.它接受一个attributedString,由TextKit支持，有许多特性如文本链接，要学到更多关于这个Node的功能，去看ASTextNode.h吧。</p>

<p>初始羡慕包含一个NSAttributedString的扩展，它提供了一个工厂方法去生成一个属性字符串用于Title和Description文本以显示在雨林卡片上。上面的代码使用了这个扩展的attributedStringForTitleText(&hellip;) 方法。</p>

<p>现在在Node Hierarchy Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>这就添加了titleTextNode到Node层次结构里，它将位于特征图像和背景图像智商，因为它在它们之后添加。</p>

<p>在Node Layout Section底部添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame = FrameCalculator.frameForTitleText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>一样使用FrameCalculator布局titleTextNode,就像backgroundImageNode和featureImageNode那样。</p>

<p>编译运行，你就有了一个title显示在特征图像的顶部。再次说明，Label只会在整个Cell准备好渲染时才渲染。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0017.png" alt="logo" /></p>

<h2>添加Description文本</h2>

<p>添加一个有着Description文本的Node和添加Title文本的Node类似.</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:),在 Node Creation Section 最后，添加如下代码。就在之前创建titleTextNode的语句之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let descriptionTextNode = ASTextNode()
</span><span class='line'>descriptionTextNode.layerBacked = true
</span><span class='line'>descriptionTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>descriptionTextNode.attributedString = 
</span><span class='line'>  NSAttributedString.attributedStringForDescriptionText(cardInfo.description)</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做descriptionTextNode的AStextNode实例。</p>

<p>在 Node Hierarchy Section最后，添加descriptionTextNode到containerNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>在 Node Layout Section,一样使用FrameCalculator布局descriptionTextNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>descriptionTextNode.frame = FrameCalculator.frameForDescriptionText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，现在你能看到Description文本了。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0018.png" alt="logo" /></p>

<h2>自定义Node子类</h2>

<p>目前为止，你使用了ASImageNode和AStextNode,但有些时候你需要自己定义Node,就如同某些时候在传统的UIKit编程里你需要自己的View一样。</p>

<h3>创建梯度Node类</h3>

<p>接下来，你将给GradientView.swift 添加Core Graphics 代码来构建一个自定义的梯度Display Node,这回被用于创建一个绘制梯度的自定义Node.梯度图会显示在特征图像的地步以便让Title看起来更加明显。</p>

<p>打开Layers-Bridging-Header.h，并添加如下代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>需要这一步是因为这个类没有包含在主头文件中，你在子类化任何ASDisplayNode或者_ASDisplayLayer时都需要访问这个类。</p>

<p>菜单 File\New\File… 。选择 iOS\Source\Cocoa Touch Class 。命名类为 GradientNode 并使其作为 ASDisplayNode 的子类。选择 Swift 语言并点击 Next 。保存文件再打开 GradientNode.swift 。</p>

<p>添加如下方法到这个类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如同Uiview或者CALayer,你可以子类化ASDisplayNode去做自定义绘制。你可以使用如同用于UIView的Layer或单独的CALayer的绘制代码，这取决于客户Node如何配置Node.查看ASDisplayNode+Subclasses.h 获取更多关于子类化 ASDisplayNode 的信息。</p>

<p>进一步，ASDisplayNode的绘制方法比在UIView和CALayer里接受更多参数，给你提供方法少做工作，更有效率。</p>

<p>要为你的自定义DisplayNode填充内容，你需要实现来自<em>ASDisplayLayerDelegate协议的drawRect(&hellip;) 或 displayWithParameters(&hellip;)。在继续之前，看看 </em>ASDisplayLayer.h 得到这个方法和它们参数的信息。搜索_ASDisplayLayerDelegate。重点看看头文件注释里关于drawRect(..)的描述。</p>

<p>因为梯度图位于特征图的上方，使用Core Graphics 绘制，所以你需要使用drawRect.</p>

<p>打开GradientView.swift 并拷贝drawRect(&hellip;)的内容到GradientNode.swift 的drawRect(&hellip;)，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>  let myContext = UIGraphicsGetCurrentContext()
</span><span class='line'>  CGContextSaveGState(myContext)
</span><span class='line'>  CGContextClipToRect(myContext, bounds)
</span><span class='line'>
</span><span class='line'>  let componentCount: UInt = 2
</span><span class='line'>  let locations: [CGFloat] = [0.0, 1.0]
</span><span class='line'>  let components: [CGFloat] = [0.0, 0.0, 0.0, 1.0,
</span><span class='line'>    0.0, 0.0, 0.0, 0.0]
</span><span class='line'>  let myColorSpace = CGColorSpaceCreateDeviceRGB()
</span><span class='line'>  let myGradient = CGGradientCreateWithColorComponents(myColorSpace, components,
</span><span class='line'>    locations, componentCount)
</span><span class='line'>
</span><span class='line'>  let myStartPoint = CGPoint(x: bounds.midX, y: bounds.maxY)
</span><span class='line'>  let myEndPoint = CGPoint(x: bounds.midX, y: bounds.midY)
</span><span class='line'>  CGContextDrawLinearGradient(myContext, myGradient, myStartPoint,
</span><span class='line'>    myEndPoint, UInt32(kCGGradientDrawsAfterEndLocation))
</span><span class='line'>
</span><span class='line'>  CGContextRestoreGState(myContext)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后删除GradientView.swift,确保编译没有错误</p>

<h3>添加梯度Node</h3>

<p>打开RainforestCardCell.swift并找到configureCellDisplayWithCardInfo(cardInfo:)，在Node Creation Section底部，添加如下代码，就在创建descriptionTextNode的代码之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let gradientNode = GradientNode()
</span><span class='line'>gradientNode.opaque = false
</span><span class='line'>gradientNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做gradientNode的GradientNode常量。</p>

<p>在Node Hierarchy Section，在添加featureImageNode那样下面，添加gradientNode到containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)
</span><span class='line'>containerNode.addSubnode(featureImageNode)
</span><span class='line'>containerNode.addSubnode(gradientNode) ///&lt; ADD THIS LINE
</span><span class='line'>containerNode.addSubnode(titleTextNode)
</span><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>梯度Node需要这个位置才能在特征图之后，Title之下。</p>

<p>然后添加如下代码到Node Layout Section底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gradientNode.frame = FrameCalculator.frameForGradient(
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你将看到梯度在特征图的底部，title确实看的更清楚了</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>爆米花特效</h2>

<p>如之前提到的，cell的Node内容会在完成绘制时“弹出”，这不是很理想，所以让我们继续，以修复这个问题，但首先，更加深入AsyncDisplayKit以看看它是怎么工作的。</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:) 的Container Node Creation Section，关闭容器Node的shouldRasterizeDescendants：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = false</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你会注意到现在容器层次结构里不同的Node一个接一个的弹出。你会看到文字弹出然后是特征图，然后是模糊背景图。</p>

<p>当shouldRasterizeDescendants关闭后，AsyncDisplayKit就不是绘制一个容器Layer了，它会创建一个镜像卡片Node层次结构的Layer数。记得爆米花特效存在是因为每个Layer都在它绘制结束后立即出现，而某些Layer比另外一个花费更多时间在绘制上。</p>

<p>这不是我们所需要的，但它描述了AsyncDisplayKit的工作方式，我们不想要这个行为，所以还是将shouldRasterizeDescendants打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = true</span></code></pre></td></tr></table></div></figure>


<h2>在后台构造Node</h2>

<p>除了异步的绘制，使用AsyncDisplayKit,你同样可以异步地创建，配置以及布局。深呼吸一下，接下来开始做事情。</p>

<h3>创建一个Node构造操作(OPeration)</h3>

<p>你要讲Node层次结构的构造包装到一个NSOperation中，这样做很棒，因为这个操作能很容易的在不同的操作队列中执行，包括后台队列。</p>

<p>打开RainforestCardCell.swift ，然后添加如下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func nodeConstructionOperationWithCardInfo(cardInfo: RainforestCardInfo, image: UIImage) -&gt; NSOperation {
</span><span class='line'>  let nodeConstructionOperation = NSBlockOperation()
</span><span class='line'>  nodeConstructionOperation.addExecutionBlock { 
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>  return nodeConstructionOperation
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>绘制并不是唯一会拖慢主线程的操作，对于复杂的屏幕，布局计算也有可能变得昂退。目前为止，本教程当前状态的项目，一个缓慢的Node布局会引起Collectionview丢帧。</p>

<p>60FPS意味着你有大约17ms的时间让你的cell准备好显示，否则一个或者多个帧就会被丢掉。这在Table view和 collection view有很复杂的cell时时非常常见的，滑动时丢帧就是这个原因。</p>

<p>AsyncDisplayKit前来救援</p>

<p>你将使用上面的nodeConstructionOperation将所有Node层次结构以及布局从主线程剥离并放入后台NSOperatonQueue，进一步确保Collection view能尽量以接近60 fps的帧率滑动。</p>

<blockquote><p><em>注意</em>
你可以在后台访问并设置Node的属性，但只能在Node的Layer或View被创建之前，也就是当你第一次访问Node的Layer或View属性时。</p></blockquote>

<p>一旦Node的Layer或View被创建，你必须在主线程才能访问和设置Node的属性，因为Node将会转发这些调用到它的Layer或View.如果你得到一个崩溃log说“Incorrect display node thread affinity”,那就意味着在创建Node的Layer或View之后，你依然尝试在后台访问或设置Node的属性。</p>

<p>修改nodeConstructionOperation 操作Block的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nodeConstructionOperation.addExecutionBlock {
</span><span class='line'>  [weak self, unowned nodeConstructionOperation] in
</span><span class='line'>  if nodeConstructionOperation.cancelled {
</span><span class='line'>    return
</span><span class='line'>  }
</span><span class='line'>  if let strongSelf = self {
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个操作运行时，cell可能已经被释放了，在那种情况下，你不需要做任何工作。类似的，如果操作被取消了，那一样也没有工作要做了。</p>

<p>之所以对nodeConstructionOperation使用 unowner无主引用是为了避免在操作和执行必要之间产生循环引用。</p>

<p>现在找到configureCellDisplayWithCardInfo(cardInfo:)。将任何在Image Size Section之后的代码移动到nodeConstructionOperation的执行闭包里，将代码放在strongSelf的条件语句里，即 TODO的位置，之后configureCellDisplayWithCardInfo(cardInfo:)将开起来如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>目前，你会有一些编译错误，这是因为操作Block里的self是weak引用，因此是可选的。但你有一个self的strong引用，因为代码在可选绑定语句内。所以替换错误的几行成下面的样子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>strongSelf.contentLayer = containerNode.layer
</span><span class='line'>strongSelf.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>最后，添加如下代码到你刚改动的三行之下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.setNeedsDisplay()</span></code></pre></td></tr></table></div></figure>


<p>编译确保没有错误。如果你现在运行，那么之后占位图会显示，因为Node的创建操作还没有实际使用。让我们来添加它</p>

<h3>使用Node创建操作</h3>

<p>打开 RainforestCardCell.swift 并添加如下属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  var nodeConstructionOperation: NSOperation? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就添加了一个叫做nodeConstructionOperation可选属性。
当Cell准备回收时，你会使用这个属性取消Node的构造。这会在用户非常快速地滑动Collection View时发生，特别是如果布局还需要一些计算时间的话。</p>

<p>在prepareForReuse()添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let operation = nodeConstructionOperation {
</span><span class='line'>    operation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  contentLayer = nil
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就在cell重用时取消了操作，所以如果Node创建还没完成，它也不会完成。</p>

<p>现在找到 configureCellDisplayWithCardInfo(cardInfo:) ,并添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let oldNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    oldNodeConstructionOperation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个Cell现在会在它准备重用并开始配置时，取消任何进行中的 Node构造操作。这确保了操作被取消，即使cell在准备重用前就被重新配置。</p>

<p>在主线程运行</p>

<p>AsyncDisplayKit允许你在非主线程做许多工作。但当它要面对UIKit和CoreAnimation时，你还是需要在主线程做。目前为止，你从主线程移走了所有的Node创建，但还有一件事需要被放在主线程&ndash;即设置coreAnimation的Layer层次结构。</p>

<p>在RainforestCardCell.swift里，找到nodeConstructionOperationWithCardInfo(cardInfo:image:) 并替换Node Layer and Wrap Up Section 为如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>dispatch_async(dispatch_get_main_queue()) { [weak nodeConstructionOperation] in
</span><span class='line'>  if let strongNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    // 2
</span><span class='line'>    if strongNodeConstructionOperation.cancelled {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 3
</span><span class='line'>    if strongSelf.nodeConstructionOperation !== strongNodeConstructionOperation {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 4
</span><span class='line'>    if containerNode.preventOrCancelDisplay {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 5
</span><span class='line'>    //MARK: Node Layer and Wrap Up Section
</span><span class='line'>    strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>    containerNode.setNeedsDisplay()
</span><span class='line'>    strongSelf.contentLayer = containerNode.layer
</span><span class='line'>    strongSelf.containerNode = containerNode
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面描述一下:</p>

<ol>
<li>回忆当Node的Layer属性被第一个访问时，所有的Layer会被创建。这就是为何你必须运行Node Layer并在主线程包装小节，因此代码访问Node的Layer.</li>
<li>操作被检查以确定是否在添加Layer之前就已经取消了。在操作完成前，cell被重用或者重新配置，就很可能出现这样的情况，那你就不应该添加Layer了。</li>
<li>作为一个保险，确保Node当前的nodeConstructionOperation和调度闭包的操作是同一个NSOperation</li>
<li>如果containerNode的preventOrCancel是true就立即返回。如果构造操作完成，但node的绘制还没有被取消，你依然不想Node的layer现在在cell里</li>
<li>最后，添加Node的Layer到层次结构中，如果必要，这就创建Layer.</li>
</ol>


<p>编译确保没有错误</p>

<h3>开始Node创建操作</h3>

<p>你依然没有实际创建和开始操作，让我们开始吧</p>

<p>继续在RainforestCardCell.swift里，改变configureCellDisplayWithCardInfo(cardInfo:) 的方法签名为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(
</span><span class='line'>  cardInfo: RainforestCardInfo,
</span><span class='line'>  nodeConstructionQueue: NSOperationQueue)</span></code></pre></td></tr></table></div></figure>


<p>这里添加了一个新的参数nodeConstructionQueue.它就是一个用于Node创建操作入队的NSOperationQueue.</p>

<p>在func configureCellDisplayWithCardInfo(
  cardInfo: RainforestCardInfo,
  nodeConstructionQueue: NSOperationQueue) 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let newNodeConstructionOperation = nodeConstructionOperationWithCardInfo(cardInfo, image: image)
</span><span class='line'>nodeConstructionOperation = newNodeConstructionOperation
</span><span class='line'>nodeConstructionQueue.addOperation(newNodeConstructionOperation)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个Node构造操作，将其保留在nodeConstructionOperation属性，并将其添加到传入的队列。</p>

<p>最后打开 RainforestViewController.swift ，给RainforestViewController添加一个叫做nodeConstructionQueue 的初始化为常量的属性，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestViewController: UICollectionViewController {
</span><span class='line'>  let rainforestCardsInfo = getAllCardInfo()
</span><span class='line'>  let nodeConstructionQueue = NSOperationQueue() ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，在collectionView(collectionView:cellForItemAtIndexPath indexPath:)里，传递View Controller的 nodeConstructionQueue到 configureCellDisplayWithCardInfo(cardInfo:nodeConstructionQueue:) ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.configureCellDisplayWithCardInfo(cardInfo, nodeConstructionQueue: nodeConstructionQueue)</span></code></pre></td></tr></table></div></figure>


<p>cell将会创建一个新的Node构造操作并将其添加到ViewControler的操作队列里并发运行。记住在cell出队时就会创建一个新的Node层次结构。这并不理想，但足够好。如果你要缓存Node的重用，看看ASRangeController 吧</p>

<p>OK，编译运行，你讲看到和之前一样的效果，但现在布局和渲染都没在主线程执行了，牛！我打赌你从来没有想过你看到这一天你所做的事情，这就是AsyncDisplayKit的威力。你可以将更多不需要再主线程操作从主线程中移除，这将给主线程更多机会处理和用户的交互，让你的App摸起来如黄油般顺滑</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>淡入Cell</h2>

<p>在这个就简短的章节，你将会学到:</p>

<ul>
<li>用自定义的Display Layer子类来支持Node</li>
<li>触发Node Layer的隐式动画</li>
</ul>


<p>这将会确保你的移除爆米花特效并最终带来良好的淡入动画</p>

<p>创建一个新的Layer子类.</p>

<p>菜单 File\New\File… ，选择 iOS\Source\Cocoa Touch Class 并单击Next.命名类为AnimatedContentsDisplayLayer并使其作为_ASDisplayLayer子类。选择 Swift语言并单击Next.最后保存并打开AnimatedContentsDisplayLayer.swift .</p>

<p>现在添加如下方法到类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func actionForKey(event: String!) -&gt; CAAction! {
</span><span class='line'>  if let action = super.actionForKey(event) {
</span><span class='line'>    return action
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  if event == "contents" && contents == nil {
</span><span class='line'>    let transition = CATransition()
</span><span class='line'>    transition.duration = 0.6
</span><span class='line'>    transition.type = kCATransitionFade
</span><span class='line'>    return transition
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Layer有一个contents属性，它告诉系统为这个Layer绘制什么，AsyncDisplayKit通过在后台渲染contents并最后在主线程设置contents</p>

<p>这个代码将会添加一个过渡动画，这样contents就会淡入到View中，你可以在Apple的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html">Core Animation Prgramming Guide</a>找到更多关于隐式Layer动画</p>

<p>打开 RainforestCardCell.swift。在nodeConstructionOperationWithCardInfo(cardInfo:image:) 里，在Container Node Creation Section开头，改动如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// REPLACE THIS LINE...
</span><span class='line'>// let containerNode = ASDisplayNode()
</span><span class='line'>// ...WITH THIS LINE:
</span><span class='line'>let containerNode = ASDisplayNode(layerClass: AnimatedContentsDisplayLayer.self)</span></code></pre></td></tr></table></div></figure>


<p>这会告诉容器Node使用AnimatedContentsDisplayLayer实例作为其支持Layer,因此自动带来淡入效果</p>

<blockquote><p><em>注意</em>
只有_ASDisplayLayer的子类才能被异步地绘制</p></blockquote>

<p>编译运行，你讲看到容器Node会在其绘制好之后淡入.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0023.png" alt="logo" /></p>

<h2>完整工程</h2>

<p><a href="https://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Layers-Finished-7.3.zip">完整工程</a>请在这里下载!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过一个Demo详解UIStackView]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-%5B%3F%5D-ge-demoxiang-jie-uistackview/"/>
    <updated>2016-04-04T19:48:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-[?]-ge-demoxiang-jie-uistackview</id>
    <content type="html"><![CDATA[<p><a href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/">在上一个章节</a>我们已经介绍了什么是UIStackView了，其实它更类似于Android开发中的LinerLayer排版技术。</p>

<p>这一章节，我们通过一个完整的例子来讲解UIStackView的用法</p>

<!--more-->


<h2>开始</h2>

<p>下下载这个<a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip">开始工程</a>,下载完毕后，用Iphone6 模拟器运行起来，你将会看到一个度假旅游的列表</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/01-table-view-is-now-correct_750x1334-281x500.png" alt="logo" />
点击第一行cell,咋看，这个视图没有什么问题，但是你仔细观察，就会发现有几个问题:</p>

<ol>
<li>看视图的下面的那一排按钮，它们中间都有一定间隙规则布局，但是它们并没有适配整个屏幕的布局，看着挺丑的，临时转换屏幕landscape orientation,通过 <code>Command-left</code></li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt="logo" /></p>

<ol>
<li>在详情页面，点击hidden按钮，它成功地隐藏了文字，但是下面的内容并没有顶上去，中间一片空白
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/03-hide-weather-issue_750x1334-281x500.png" alt="logo" /></li>
</ol>


<p>现在你已经有几点好的建议去提升app的体验，现在让我们开始切入这个工程</p>

<p>打开Main.storyboard然后找到 <code>Spot Info View Controller</code>,这里有一些颜色在stackView中。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/04-colorful-scene-in-storyboard_504x636-396x500.png" alt="logo" /></p>

<p>这些标签和按钮已经有几种不同颜色的背景色，但是在运行时他们的背景色就是透明的，在这个storyboard中，他们仅仅是为了帮助你展示stackView是怎么改变属性影响嵌套的子视图</p>

<p>你不需要做这些，但是从另一个观点来说你实际上喜欢去看看这些背景色当运行程序的时候，你能临时做些改变在SpotInfoViewController的viewDidLoad()中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Clear background colors from labels and buttons
</span><span class='line'>for view in backgroundColoredViews {
</span><span class='line'>  view.backgroundColor = UIColor.clearColor()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，其它标签都有占位符文字说明，他们仅仅是为了让你区分哪些是和后台连接的。哪些是描述什么内容的。例如<code>&lt;whyVisitLabel&gt;</code>是连接</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@IBOutlet weak var whyVisitLabel: UILabel!</span></code></pre></td></tr></table></div></figure>


<p>另外一个需要注意的是在这个storyboard中不是默认的 600 x 600,当你使用SizeClass的时候。</p>

<p>SizeClass总是可用的，但是初始化Navigation Controller 默认是总是iPhone 4-inch在模拟器下，这个是容易的在storyboard中，这个模拟器在启动的时候是不受影响的，这个视图将会动态适应不同的设备。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/05-simulated-metrics-iphone-4-inch_639x173.png" alt="logo" /></p>

<h2>你的第一个StackView</h2>

<p>第一件事是你将通过一个stackView修复最下面一排按钮的间距，一个stackView能描述在不不同轴向的布局（横向坐标和纵向坐标），其中之一就是子视图之间的距离设置。</p>

<p>幸运的是，修改已经存在的View在一个stackView中并不复杂，选中 <code>Spot Info View Controller</code>底部的所有按钮</p>

<p>检查这三个按钮是不是都选择上了，打开左边的控件面板查看，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/08-verify-button-selection_360x90.png" alt="logo" /></p>

<p>一旦选中了，在storyboard的右下角点击new Stack button
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/09-stack_button_outlined_148x52.png" alt="logo" /></p>

<p>这个按钮将会变成嵌入式的在stackView中</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/10-bottom-row-is-now-in-stack-view_640x100.png" alt="logo" /></p>

<p>这些按钮看起来不是平滑的，稍后我们将会修复</p>

<p>当这个stackView开始嵌套这些按钮的时候，我们将要添加自动布局给这个stackView</p>

<p>当你嵌套一个视图在一个stackView中，这个视图的任何约束都会被移除，例如，在嵌套到stackView之钱，在最前面的那个按钮<code>Submit Rating</code>有个垂直距离的约束和<code>Rating:</code>label之间:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/11-prior-constraint_420x90.png" alt="logo" /></p>

<p>点击<code>Submit Rating</code>按钮去看看是否还有这个约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/12-no-more-constraints_400x80.png" alt="logo" /></p>

<p>为了给stackView添加约束，首先你必须选中它，一个简单的方式去选择这个stackView在outline View:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" />
另外一种方式是按住 shift&amp;Right-click 在你想选择的视图上，或者按钮 <code>control</code>+<code>shift</code>+<code>左键点击</code>在你想要选择的视图上，你将会看到一个菜单视图，供你选择。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt="logo" /></p>

<p>现在，点击pin按钮在自动布局的工具条上  去 添加约束。</p>

<p>首先检查Constrain to margins，然后添加下载的约束:</p>

<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 0
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/17-bottom-stack-view-constraints_264x364.png" alt="logo" /></p>

<p>现在，这个stackVeiw是正确的尺寸，但是它有一点拉伸第一个按钮，因为它要去利用多余的空间。</p>

<p>stackView有个<code>distribution</code>属性来决定子视图的布局，当前，它是fill,这意味着包含的子视图都会完全填充stackview剩下的空间，为了修补这个，这个stackView将要展开其中的一个子视图去填补这个多余的空间</p>

<p>然而，你并不期望这个按钮完全填充stackView，你想让他们占用相同的空间。</p>

<p>选中这个stackView,然后修改它的属性<code>Distribution</code>从<code>Fill</code>到<code>Equal Spacing:</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/19-change-distribution-to-equal-spacing_640x148.png" alt="logo" /></p>

<p>现在编译运行，点击这个cell.旋转屏幕，你将会看到底部的按钮平分在屏幕的底部，是不是很酷呢!
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt="logo" /></p>

<p>如果不使用stackView来解决这个问题，你不得不使用sapce views，在没两个按钮之间，你的加入等比宽度的约束。很是麻烦。
它看起来像是下面这样，这中间的space View看起来有点灰色</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/21-alternate-solution-1_346x76.png" alt="logo" /></p>

<p>这个问题还是不是很大在一个storyboard中，但是很多视图都是动态的，这就不是一个简单的任务了，在运行时去增加一个按钮或者隐藏一个按钮，因为需要去调节视图和约束之间的关系。</p>

<p>为了在一个stack view中隐藏一个视图，你不得不设置子视图的hidden属性为true.现在你将要修复之前说过的那个问题，就是当点击 hidden之后，文字消失，下面的多余空间要顶上去。</p>

<h2>转换Sections</h2>

<p>你将要转换所有的section用stack view中，这将要确保你容易的完成你的任务，下一步你将要转换 rating section.</p>

<h3>Rating section</h3>

<p>定位到你刚才的页面，然后选择<code>RATING</code>标签和 星星的视图：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/22-select-rating-label-and-stars-label_640x74.png" alt="logo" />
然后点击 stack按钮让其嵌套在一个stackView中。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/23-after-clicking-stack-button_640x74.png" alt="logo" />
 现在，点击PIN按钮，添加下面三个属性:</p>

<pre><code class="`"> Top: 20, Leading: 0, Bottom: 20
</code></pre>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/24-add-second-stack-view-constraints_264x171.png" alt="logo" /></p>

<p> 现在切换到<code>Attributes inspector</code>，设置 spacing为8:
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/25-set-spacing-to-8_259x87.png" alt="logo" /></p>

<p> 这时，你看到视图上的两个控件之间已经有些间距了，
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/26-stars-label-weirdly-stretched_640x85.png" alt="logo" />
 有时候，xcode可能提示你stackview的位置是不正确的，但是这些警告将会消失，当你更新其它控件的时候，你通常可以忽略他们。</p>

<p>为了证明这个，改变 <code>Alignment</code>从<code>Fill</code>到<code>Top</code>然后再改为Fill,你将会看到这个stars 标签变成正确的位置了。</p>

<p>编译运行你的app,一切看起来还是和从前一样.</p>

<h2>取消嵌套一个Stack View</h2>

<p>在你深入学习之前，去进行一些"急救"训练，有时，你会发现你的视图上有一个你不再需要的stackview,或许你为了练习而导致的事故。</p>

<p>幸运的是，这里有容易的方式去移除一个嵌套的view从stack view中。</p>

<p>首先，你最好选择你想要删除的stack view,按住<code>Option</code>键，然后点击 <code>stack</code>按钮，点击 <code>Unembed</code>菜单就可以了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/28-how-to-unembed_186x71.png" alt="logo" /></p>

<h2>你的第一个垂直Stack view</h2>

<p>现在，你将要创建一个垂直的stack view,选中<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/29-select-why-visit-labels_640x90.png" alt="logo" />
Xcode将会正确的推断出这个视图将会需要一个垂直的stack view,点击<code>Stack</code>按钮去嵌套它们到一个stack view中。</p>

<p>当stack view添加成功之后，嵌套的视图的约束将会给删除，当前的这个stack view没有任何约束，所以它会适配子视图中最大尺寸的。</p>

<p>当这个stack view选中的时候，点击 Pin按钮，设置如下属性:
Top, Leading and Trailing 都为0</p>

<p>然后，点击dropdown在右下角，然后选择<code>WEATHER (current distance = 20):</code></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/31-dont-select-nearest-neighbor-constraint_463x417.png" alt="logo" /></p>

<p>最后，添加这4个约束，你将会看到如下结果：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/32-why-visit-stack-view-stretched_640x90.png" alt="logo" />
现在你有两个一个展开的stackview,它的右边界是定位到了视图的右边界，然而，这下面的标签依然是同样宽的，你将要修复它通过stack view的<code>alignment</code>属性</p>

<h2>Alignment属性</h2>

<p>这个alignment属性决定了stack view在其轴向上的布局方式，可能是Fill,Leading,Center和Trailing.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/33-horizontal-and-vertical-alignment_594x171.png" alt="logo" /></p>

<p>在垂直的stackview中，选择不同的属性，将会看到不同的布局:</p>

<p>Fill:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/34-alignment-fill_640x64.png" alt="logo" /></p>

<p>Leading:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/35-alignment-leading_640x64.png" alt="logo" /></p>

<p>Center:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/36-alignment-center_640x64.png" alt="lgo" /></p>

<p>Trailing:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/37-alignment-trailing_640x64.png" alt="lgo" /></p>

<p>当你测试完每个属性值后，最后设置成Fill</p>

<p>编译运行程序看起来是OK的，特别需要指出的是，<code>Fill</code>意味着你想要所有的视图都是完全占用空间在其轴向上，这将引起<code>WHY VISIT</code>标签去展开它到右边缘。</p>

<p>但是如果你只想下面的label张开到右边缘，此时该怎么做呢?</p>

<h2>转换"what to see"模块</h2>

<p>这个转换和上面的那个很相似，介绍如下:</p>

<ol>
<li>首先，选择<code>WHAT TO SEE</code>标签和<code>&lt;whatToSeeLabel&gt;</code></li>
<li>点击<code>Stack</code>按钮</li>
<li>点击<code>Pin</code>按钮</li>
<li>设置<code>margins</code>约束，添加下面4个约束</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<ol>
<li>设置stack view的Alignment为FIll</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/39-after-what-to-see-section_640x308.png" alt="logo" />
编译运行你的工程，验证页面是不是看起来和之前一样。</p>

<p>剩下就是这个<code>weather</code>模块了</p>

<h2>转换weather模块</h2>

<p>这个weather模块比其他几个稍微复杂一些，因为它包含了一个hidden按钮</p>

<p>一种方法是你将会创建一个最近的stacview通过嵌套<code>WEATHER</code>标签和<code>Hide</code>按钮在一个水平的stackview中，然后嵌套水平的stackview和<code>&lt;weatherInfoLabel&gt;</code>到一个垂直的stackview中。</p>

<p>看起来你像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/40-weather-stack-in-stack_640x92.png" alt="lgo" /></p>

<p>点击<code>Stack</code>按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/43-weather-click-stack-button_640x92.png" alt="logo" /></p>

<p>然后点击 Pin按钮，设置margin约束,设置如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<p>设置 stack view的Alignment为Fill
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/44-weather-alignment-fill_640x92.png" alt="logo" /></p>

<p>你需要一个在hide按钮和<code>WEATHER</code>标签的右边加一个约束，因为<code>WEATHER</code>标签被加到了stack view中，它的所有约束都被自动去掉了.</p>

<p>然后，你希望底部的<code>&lt;weatherInfoLabel&gt;</code>去填充整个stack view.</p>

<p>你可以完成这个通过把<code>WEATHER</code>嵌套进一个垂直的stack view中，记住垂直stackview可以设置alignment为 .Leading,假如stack view是拉伸的超出了它固有的边界，它包含的子视图将会到达它的边界。</p>

<p>选择<code>WEATHER</code>标签通过document outline，或者通过<code>Control-Shift-click</code>方法:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/45-select-just-the-weather-label_640x92.png" alt="logo" /></p>

<p>点击 stack按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/46-weather-in-horizontal-stack_640x92.png" alt="lgo" /></p>

<p>设置Alignment为Leading,然后确保axis是垂直方向:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/47-vertical-and-leading_640x92.png" alt="log" /></p>

<p>完美！你已经完成了外部的stackview平铺，在嵌套的stackView中去填充它的宽度，但是内部的stackview允许这个标签去保持它原有的宽度。</p>

<p>编译运行，为什么hide按钮现在飘到上面去了呢？
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/48-hide-label-incorrect-position_750x573-419x320.png" alt="dlo" /></p>

<p>它是因为当你嵌套<code>WEATHER</code>标签到一个stackview中时，它的所有和hide按钮相关的约束都被移除掉了。</p>

<p>现在你需要给hide按钮和<code>WEATHER</code>标签之间增加新的约束,按住<code>control-drag</code>从Hide按钮拖向<code>WEATHER</code>标签:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/49-drag-to-weather-label_380x94.png" alt="logo" /></p>

<p>添加两个约束:</p>

<ol>
<li>Horizontal Spacing</li>
<li>Baseline</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/50-add-multiple-constraints_380x224.png" alt="logo" />
编译运行，这个Hide按钮看起来正常了。</p>

<p>现在所有的模块都是在唯一的stackview中了，你把他们全部都嵌套进了stackview中。</p>

<h2>设置第一级Stack view</h2>

<p>点击 <code>command</code> 然后选择所有的5个顶级的stackview在 outline view中
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/52-select-all-stack-views-in-outline_640x260.png" alt="log" /></p>

<p>然后点击stack按钮：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/53-stack-all-the-views_640x185.png" alt="lgo" /></p>

<p>点击Pin按钮，设置约束属性:
全部都设置成0.然后设置Spacing为20, Alignment为Fill,你的storyboard看起来像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt="g" /></p>

<p>编译运行，此时你的 hide按钮又跑偏了，和之前设置的一样，需要把hide和<code>WEATHER</code>重新建立约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/56-add-constraints-to-button-again_380x223.png" alt="d" /></p>

<p>编译运行，此时hide按钮在正确的位置上了。</p>

<h2>重新布局视图</h2>

<p>现在所有的的模块都在顶级的stackview中，你现在可以更改<code>what to see</code>模块的位置，比如和<code>weather</code>模块的位置进行互换。</p>

<p>选择<code>middle stack view</code>从outline view然后拖拽它和weather的那个stackview进行互换，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/57-drag-and-drop-to-reposition-section_639x130.png" alt="log" /></p>

<p>此时，<code>weather</code>模块是第三个模块，但是这个 hide按钮不是在stackview中，它不会被移动。</p>

<p>选中 Hide按钮 :
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/58-hide-button-not-moved_640x130.png" alt="logo" />
然后点击<code>Resolve Auto Layout Issues</code>在自动布局的菜单上点击 update frame:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/59-resolve-auto-layout-issues_356x269.png" alt="logo" /></p>

<h2>Size class based configuration</h2>

<p>最后，你能把你注意力集中到之前的任务清单上，在加载模式中，垂直空间是昂贵的，所以你想让stackview中的模块靠近些，为了做到这些，你将要使用size classes去设置顶部stackview的空间从20修改成10.</p>

<p>选中顶部的stackview然后点击小小的<code>+</code>号，设置spacing:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/61-select-plus-button_260x120.png" alt="log" /></p>

<p>选择 Any Width > Compact Height:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/62-anywidth-compact-height_403x108.png" alt="lgo" /></p>

<p>然后设置Spacing 为10,在 new wAny hC文本框中:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/63-set-spacing-to-10_260x160.png" alt="lgo" /></p>

<h2>动画</h2>

<p>打开SpotInfoViewController.swift文件，然后找到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code>方法</p>

<p>你将要替换这一行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>weatherInfoLabel.hidden = shouldHideWeatherInfo</span></code></pre></td></tr></table></div></figure>


<p>改成如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if animated {
</span><span class='line'>  UIView.animateWithDuration(0.3) {
</span><span class='line'>    self.weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>  }
</span><span class='line'>} else {
</span><span class='line'>  weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，点击<code>hide</code>和<code>show</code>按钮，会不会感觉出来有点动画效果呢?</p>

<p>在stackview中增加动画效果也是很容易的，比如hidden, alignment, distribution, spacing，甚至axis。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip">完整工程</a></p>

<p>希望能够帮到你~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIStackView介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/"/>
    <updated>2016-04-04T15:47:37+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao</id>
    <content type="html"><![CDATA[<p>UIStackView类提供了一个高效的接口用于平铺一行或一列的视图组合.Stack视图使你的依靠自动布局的能力，创建用户接口使得可以动态的调整设备的朝向，屏幕尺寸以及任何可用范围内的变化。Stack视图管理着所有它的 arrageedSubviews属性中视图的布局，这些视图根据它们在arrangedSubviews数组中的顺序沿着stack视图的轴向排列，精确的布局变量根据Stack视图的 axixs,distribution,allignment,spcing,和其它属性决定。</p>

<!--more-->


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/130054395519774.png" alt="logo" /></p>

<p>使用 Stack视图，打开一个你希望编辑的storyboard,从对象库中拖出一个Horizontal Stack View或者Vertical Stack View,并放置到你希望的位置上，下一步，将控件或视图拖拽到stack中，如果需要你可以继续添加视图或者控件给指定的statck.Interface buider将根据stack内容自动调节尺寸，你可以通过修改尚需经面板中stack视图的属性调整statck的外观.</p>

<h2>Stack视图与自动布局</h2>

<p>Stack视图使用自动布局来定位和控制其管理的视图的尺寸，stack视图沿着它的轴向拼凑第一个和最后一个被管理的视图，使其便捷平齐。对一个月水平stack视图，这意味着第一个被管理的视图的左边界是与stack的左边界对齐的，并且最后一个被管理的视图右边界与stack右边界是平齐的。对于垂直stack,上边界和下边界格式对齐的。如果你设置了stack视图的 <code>layoutMarginsRelativeArrangement</code>为YES,stack视图将使用相关的边距与其内容对齐，而不是边界。</p>

<p>对于除去<code>UIStackViewDistributionFillEqually</code>分布以外的分布方式，stack视图使用被管理视图的<code>intrinsicContentSize</code>属性来计算沿着stack轴向的视图尺寸，<code>UIStackViewDistributionFillEqually</code>分布将调节所有被管理视图的在stack轴向上拥有相同尺寸，以填充stack视图。如果可能，stack视图将拉伸所有被管理的视图，来匹配其在stack轴向上最长的原有尺寸。</p>

<p>对于除去<code>UIStackViewAlignmentFill</code>对齐以外的对齐方式，stack视图使用其管理的视图的<code>intrinsicContentSize</code>属性来计算视图垂直于stack轴向的尺寸。<code>UIStackViewAlignmentFill</code>重新调节了所有其管理的视图，使这些视图填充stack视图垂直于其轴向空间。如果可能，stack视图将拉伸所有管理的视图来匹配其垂直于stack轴向的最大固有尺寸。</p>

<h2>定位和调整Stack视图尺寸</h2>

<p>当stack视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位stack视图，通常情况下，这意味着需要皮凑至少两个边界相邻的stack来定义它的位置，没有额外约束的情况下，系统会为stack视图计算一个尺寸来适应其内容:</p>

<ul>
<li>沿着stack视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和</li>
<li>垂直于stack视图轴向，其适应尺寸等于其管理的视图中最大视图的尺寸</li>
<li>如果stack视图的<code>layoutMarginsRelativeArrangement</code>为YES,stack视图的适应尺寸会包括边距空间</li>
</ul>


<p>你可以提供额外的约束来具体说明stack视图的高度，宽度或者两者兼有，在这些情况下，stack视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据stack视图的属性获得。可以通过查看<code>UIStackViewDistribution</code>和<code>UIStackViewAlignment</code>枚举，已获得一个完整的stack视图。</p>

<p>你也可以根据stack视图的第一条或最后一条基线定位它，而不是使用顶部，底部或者中心Y值，类似于stack视图的适应尺寸，这些基线都是基于stack视图的内容计算得到的</p>

<ul>
<li><p>一个水平的stack视图调用 <code>viewForFirstBaselineLayout</code>方法或者 <code>viewForLastBaselineLayout</code>方法时返回它最高的视图。如果最高的视图也是一个stack视图，那么其返回的将是在嵌套的stack视图上调用<code>viewForFirstBaselineLayout</code>方法或者<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
<li><p>一个垂直的stack视图当调用 <code>viewForFirstBaselineLayout</code>方法时返回的是其管理的第一个视图，当调用<code>viewForLastBaselineLayout</code>方法时返回的是其管理的最后一个视图。如果这两个视图之一也是stack视图，那么其返回的将是在嵌套的stack视图上对应调用<code>viewForFirstBaselineLayout</code>方法或<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
</ul>


<blockquote><p><em>注意</em>
基线对齐方式只作用于那些高度匹配其原本内容高度的视图，如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。</p></blockquote>

<h2>通过Stack视图布局</h2>

<p>这有一些通用方法用于stack视图。这个清单是要高亮一些有用的实例来显示 stack视图的灵活性，目前这还不是一个完整的清单。</p>

<ul>
<li>只是定义位置. 你可以通过固定两个与其父视图相邻的边界来定义stack视图的位置。在这里，stack视图的尺寸将根据其管理的视图在两个维度上自由扩展。</li>
</ul>


<p>举个例子，在Figure 1中，stack视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基准线。这对于相对于其本身左对齐的stack视图内容是有效的。</p>

<p>Figure1定义位置
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" /></p>

<ul>
<li>定义沿着 stack视图轴向的尺寸。这里，你固定了沿着stack视图轴向相对于其父视图的两个边界，定义了stack视图沿着其轴向的尺寸。你将需要固定其它边界中的一个来定义stack视图的位置。stack视图将沿着其轴向改变尺寸和位置来填充定义的空间:然而，未固定的边界将根据其管理的最大视图的尺寸自动移动。</li>
</ul>


<p>举例Figure 2,stack视图的左，上，右边界都已经相对于其父视图固定了。使用<code>UIStackViewDistributionFill</code>分布是的其内容重设尺寸来填充它的高度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。</p>

<p>Figure2定义沿着stack视图轴向的尺寸</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/140059516762099.png" alt="logo" /></p>

<ul>
<li>定义垂直于stack视图轴向的尺寸。这类似于上一个实例，但是你固定了垂直于stack视图轴向的连个边界和沿着轴向的一个边界。这使得stack视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了
<code>UIStackViewDistributionFillEqually</code>分布，被管理的视图将跟根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其stack视图的对齐模式在其定义的范围内平铺。</li>
</ul>


<p>举例，Figure3展示了一个包含了四个标签和一个按钮的垂直stack视图。这个stack视图使用了8个点的间隙和<code>UIStackViewAlignmentCenter</code>对齐方式。stack视图的高度将根据stack内部元素的增减而增大或回缩。</p>

<p>FIgure3.定义垂直于stack视图轴向的尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140110013482874.png" alt="logo" /></p>

<ul>
<li>同时定义stack视图的位置和尺寸。这里你固定了stack视图的所有四个边界。stack视图将在提供的范围之内平铺其内容，举例，Figure4展示了一个所有四个边界都相对于其父视图固定的垂直stack视图。通过使用<code>UIStackViewAlignmentCenter</code>对齐方式和<code>UIStackViewDistributionFill</code>分布方式，stack视图确保其内容将水平和垂直居中填充屏幕，然后，获得想要的布局需要两个额外的步骤，默认情况下，stack视图会垂直拉伸标签而不是图片，要缩放图片控件，就要降低其内容紧凑优先级到低于标签，额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit.增加一个图片视图月stack视图间相等约束将有助于确保图片将被缩放来填充可用范围。</li>
</ul>


<p>Figure 4.同时定义stack视图的位置和尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140122324105787.png" alt="logog" /></p>

<h2>管理stack视图的展现</h2>

<p>UistackView是UIview的非渲染型子类。它没提供其自由的任何用户接口，相反地，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如backgroundCOlor)在stack视图上是无效的。类似的，你无法重写layerClass,drawRect等方法。</p>

<p>这里有一系列的属性来定义stack视图如何平铺其内容。</p>

<ul>
<li>axis(轴向)属性决定了stack的朝向，只有垂直和水平</li>
<li>distributin(分布)属性决定了其管理的视图在沿着其轴向上的布局</li>
<li>alignment(对齐)属性决定了其管理的视图在垂直于其轴向上的布局</li>
<li>spacing(空隙)属性决定了其管理的视图间的最小间隙</li>
<li>baselineRelativeArragement 属性决定了其视图间的垂直间隙是否根据基线测量得到</li>
<li>layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距</li>
</ul>


<p>通常情况下，你会使用一个stack视图来布局小数量的视图，你可以通过在其他stack视图上嵌套多个stack视图的方式创建更加复杂的视图层次结构。举例：Figure5展示乐意个包含两个水平stack视图的垂直stack视图。每一个水平stack视图各包含一个标签和一个文本框.</p>

<p>Figure 5.Stack 视图的嵌套
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140146204108925.png" alt="logo" /></p>

<p>你也可以通过增加被管理的视图的额外约束来完备的吊接一个被管理视图的展现，举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度，或者你可以定义一个长宽比。当平铺其内容时，stack视图将使用这些约束。举例来说，在Figure4中，当图片被压缩时，图片视图的一个长宽比约束被强行赋予了一个长宽比数。</p>

<blockquote><p><strong>注意</strong>
当给一个stack视图内的视图增加约束时要特别注意避免传入冲突，作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容的尺寸，那么你可以安全的在这个维度上增加约束</p></blockquote>

<h2>维护其惯例的视图与子视图之间的统一性</h2>

<p>Stack视图确保它的arragedSubveiws属性将一直是其 subviews属性的子集合。明确的说，stack视图强制实施了以下规定:</p>

<ul>
<li>无论何时stack视图增加了一个视图到它的arrangedSubviews数组，其也将把这个视图作为子视图增加，如果还未增加的话。</li>
<li>无论何时一个子视图从stack视图中移除，那么stack视图也将从从arrangedSubviews数组中移除.</li>
<li>从arrangedSubviews移除一个视图并不会将其作为姿势图移除。stack视图将不再管理改视图的尺寸和位置，但是该视图扔将是视图结构的一部分，并且当其可见的狂下仍会被渲染到屏幕上。</li>
</ul>


<p>当arrangedSubviews数组一直包含着subviews数组的自己和，这些数组间的顺序仍然是独立的。</p>

<ul>
<li>arrangedSubviews数组的顺序定义了展现在stack中的视图的顺序。对于水平stack视图，这些视图将以阅读顺序平铺，即最小索引的视图在较大索引视图的左侧。对于垂直stack视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。</li>
<li>subviews数组中的顺序定义了子视图在z轴上的顺序。如果视图重叠，有较小索引的子视图将出现在有家多音的子视图后方。</li>
</ul>


<h2>动态改变stack视图内容</h2>

<p>当视图被加入，移除或插入arrangedSubviews数组时，或当一个被管理的子视图的hidden属性改变时，stack视图都会自动更新它的布局。</p>

<p>Oc代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>firstView.hidden = YES;</span></code></pre></td></tr></table></div></figure>


<p>swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>firstView.hidden = true</span></code></pre></td></tr></table></div></figure>


<p>stack视图也会自动响应其任何属性的改变。举例，你可以更新stack视图的axis属性来动态改变朝向</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if (self.stackView.axis == UILayoutConstraintAxisHorizontal) {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisVertical;
</span><span class='line'>}else {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisHorizontal;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if stackView.axis == .Horizontal {
</span><span class='line'>    stackView.axis = .Vertical
</span><span class='line'>}else {
</span><span class='line'>    stackView.axis = .Horizontal
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于被管理的子视图的hidden属性的变化和stack视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画的方式展现。</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>[UIView animateWithDuration:0.25 animations:^{
</span><span class='line'>    UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>    firstView.hidden = YES;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>UIView.animateWithDuration(0.25) { () -&gt; Void in
</span><span class='line'>    let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>    firstView.hidden = true}</span></code></pre></td></tr></table></div></figure>


<h2>常用方法</h2>

<h3>创建Stack视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- initWithArrangedSubviews:  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>管理安排的子视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- addArrangedSubview: (New in iOS 9.0)
</span><span class='line'>  arrangedSubviews Property (New in iOS 9.0)
</span><span class='line'>- insertArrangedSubview:atIndex: (New in iOS 9.0)
</span><span class='line'>- removeArrangedSubview: (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>设置布局</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alignment Property  (New in iOS 9.0)
</span><span class='line'>axis Property  (New in iOS 9.0)
</span><span class='line'>baselineRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>distribution Property  (New in iOS 9.0)
</span><span class='line'>layoutMarginsRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>spacing Property  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>常量</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIStackViewDistribution
</span><span class='line'>UIStackViewAlignment</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解RunLoop]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/"/>
    <updated>2016-03-29T17:29:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loop() {
</span><span class='line'>    initialize();
</span><span class='line'>    do {
</span><span class='line'>        var message = get_next_message();
</span><span class='line'>        process_message(message);
</span><span class='line'>    } while (message != quit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
</span><span class='line'>static CFMutableDictionaryRef loopsDic;
</span><span class='line'>/// 访问 loopsDic 时的锁
</span><span class='line'>static CFSpinLock_t loopsLock;
</span><span class='line'>  
</span><span class='line'>/// 获取一个 pthread 对应的 RunLoop。
</span><span class='line'>CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
</span><span class='line'>    OSSpinLockLock(&loopsLock);
</span><span class='line'>     
</span><span class='line'>    if (!loopsDic) {
</span><span class='line'>        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
</span><span class='line'>        loopsDic = CFDictionaryCreateMutable();
</span><span class='line'>        CFRunLoopRef mainLoop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    /// 直接从 Dictionary 里获取。
</span><span class='line'>    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
</span><span class='line'>     
</span><span class='line'>    if (!loop) {
</span><span class='line'>        /// 取不到时，创建一个
</span><span class='line'>        loop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, thread, loop);
</span><span class='line'>        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
</span><span class='line'>        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    OSSpinLockUnLock(&loopsLock);
</span><span class='line'>    return loop;
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetMain() {
</span><span class='line'>    return _CFRunLoopGet(pthread_main_thread_np());
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetCurrent() {
</span><span class='line'>    return _CFRunLoopGet(pthread_self());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
</span><span class='line'>    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
</span><span class='line'>    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
</span><span class='line'>    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
</span><span class='line'>    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
</span><span class='line'>    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
</span><span class='line'>    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __CFRunLoopMode {
</span><span class='line'>    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
</span><span class='line'>    CFMutableSetRef _sources0;    // Set
</span><span class='line'>    CFMutableSetRef _sources1;    // Set
</span><span class='line'>    CFMutableArrayRef _observers; // Array
</span><span class='line'>    CFMutableArrayRef _timers;    // Array
</span><span class='line'>    ...
</span><span class='line'>};
</span><span class='line'>  
</span><span class='line'>struct __CFRunLoop {
</span><span class='line'>    CFMutableSetRef _commonModes;     // Set
</span><span class='line'>    CFMutableSetRef _commonModeItems; // Set
</span><span class='line'>    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
</span><span class='line'>    CFMutableSetRef _modes;           // Set
</span><span class='line'>    ...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
</span><span class='line'>CFRunLoopRunInMode(CFStringRef modeName, ...);</span></code></pre></td></tr></table></div></figure>


<p>Mode暴露的管理Mode Item的有下面几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</span><span class='line'>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoop {
</span><span class='line'>    current mode = kCFRunLoopDefaultMode
</span><span class='line'>    common modes = {
</span><span class='line'>        UITrackingRunLoopMode
</span><span class='line'>        kCFRunLoopDefaultMode
</span><span class='line'>    }
</span><span class='line'>  
</span><span class='line'>    common mode items = {
</span><span class='line'>  
</span><span class='line'>        // source0 (manual)
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = _UIApplicationHandleEventQueue}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventSignalCallback }}
</span><span class='line'>        CFRunLoopSource {order = 0, {
</span><span class='line'>            callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>  
</span><span class='line'>        // source1 (mach port)
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 17923}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 12039}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 16647}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 2407,
</span><span class='line'>            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1c03,
</span><span class='line'>            callout = __IOHIDEventSystemClientAvailabilityCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1b03,
</span><span class='line'>            callout = __IOHIDEventSystemClientQueueCallback}}
</span><span class='line'>        CFRunLoopSource {order = 1, {port = 1903,
</span><span class='line'>            callout = __IOMIGMachPortPortCallback}}
</span><span class='line'>  
</span><span class='line'>        // Ovserver
</span><span class='line'>        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
</span><span class='line'>            callout = _UIGestureRecognizerUpdateObserver}
</span><span class='line'>        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _afterCACommitHandler}
</span><span class='line'>        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>  
</span><span class='line'>        // Timer
</span><span class='line'>        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
</span><span class='line'>            next fire date = 453098071 (-4421.76019 @ 96223387169499),
</span><span class='line'>            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
</span><span class='line'>    },
</span><span class='line'>  
</span><span class='line'>    modes ＝ {
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = 0, {
</span><span class='line'>                    callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = {
</span><span class='line'>                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
</span><span class='line'>                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>            )},
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventSignalCallback}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventCallback}}
</span><span class='line'>            },
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>         
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = (null),
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    /// 1. 通知Observers，即将进入RunLoop
</span><span class='line'>    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
</span><span class='line'>    do {
</span><span class='line'>  
</span><span class='line'>        /// 2. 通知 Observers: 即将触发 Timer 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
</span><span class='line'>        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 4. 触发 Source0 (非基于port的) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 6. 通知Observers，即将进入休眠
</span><span class='line'>        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 7. sleep to wait msg.
</span><span class='line'>        mach_msg() -&gt; mach_msg_trap();
</span><span class='line'>         
</span><span class='line'>  
</span><span class='line'>        /// 8. 通知Observers，线程被唤醒
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被Timer唤醒的，回调Timer
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
</span><span class='line'>        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>    } while (...);
</span><span class='line'>  
</span><span class='line'>    /// 10. 通知Observers，即将退出RunLoop
</span><span class='line'>    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFSocket
</span><span class='line'>CFNetwork       -&gt;ASIHttpRequest
</span><span class='line'>NSURLConnection -&gt;AFNetworking
</span><span class='line'>NSURLSession    -&gt;AFNetworking2, Alamofire</span></code></pre></td></tr></table></div></figure>


<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        [[NSThread currentThread] setName:@"AFNetworking"];
</span><span class='line'>        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
</span><span class='line'>        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
</span><span class='line'>        [runLoop run];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>+ (NSThread *)networkRequestThread {
</span><span class='line'>    static NSThread *_networkRequestThread = nil;
</span><span class='line'>    static dispatch_once_t oncePredicate;
</span><span class='line'>    dispatch_once(&oncePredicate, ^{
</span><span class='line'>        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
</span><span class='line'>        [_networkRequestThread start];
</span><span class='line'>    });
</span><span class='line'>    return _networkRequestThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start {
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    if ([self isCancelled]) {
</span><span class='line'>        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    } else if ([self isReady]) {
</span><span class='line'>        self.state = AFOperationExecutingState;
</span><span class='line'>        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    }
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUrlSession详解]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie/"/>
    <updated>2016-03-27T18:48:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie</id>
    <content type="html"><![CDATA[<p>NSUrlSession是NSUrlConnection的替代品。</p>

<p>NSUrlConennection指的是一组构成 Foundation框架中URL加载系统的相互关联的组件:NSURLRequest,NSUrlResponse,NSURlProtocol等,在协商发送一个请求到服务器的过程中，该服务器可发出验证质询，这可以由共享的cookie，证书存储（credential storage）或通过连接委托自动处理。必要的时候，为了无缝地改变装载行为，传出请求也可以被注册的NSURLProtocol对象截获.</p>

<!--more-->


<p>不管怎样，考虑到NSURLConnection作为一个网络基础架构，成千上万的Cocoa和Cocoa Touch应用程序从中获益，它已经表现得相当好。但是，这些年来，iPhone和iPad新兴的用例，特别是有一些已经向NSURLConnection的几个核心设想提出了挑战，对其重构已经迫在眉睫。</p>

<p>在2013年的WWDC上，Apple揭开了NSURLConnection继任者的面纱：NSURLSession.</p>

<p>与NSUrlConnection类似，除了同名类 NSUrlsession,NSUrlSession指的是一组相互依赖的类，NSURlSession包括与之前相同的组件，例如NSUrlRequest,NSURLCatch等等。
　　</p>

<h2>NSURlconenction 与 NSSession的不同</h2>

<p>　　与NSUrlConnection相比，NSUrlSession最直接的改善就是提供了配置每个回话的缓存，协议，cookie和证书策略(credential policies),甚至跨应用程序共享它们的能力。这使得框架的网络基础架构和部分应用程序独立工作，而不会相互干扰，每一个NSUrlSession对象都是根据一个NSURlSessionConfiguration初始化的，
　　
　　</p>

<p>该NSURlSessionConfiguration指定了上面提到的策略，一级一系列为了提高移动设备性能而专门添加的新选项。</p>

<p>NSUrlSession的另一个重要组成部分就是会话任务，它负责处理数据的加载，以及客户端与服务器之间的文件和数据的上传和下载。</p>

<h2>NSURLSession简介</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="logo" /></p>

<p>NSURLsession关键对象负责接收和发送http请求，创建NSURlSessionConfiguration,这里有三种方式:</p>

<ul>
<li><code>defaultSessionConfiguration</code>创建一个默认的配置文件，用户可以存储缓存，创建证书和缓存cookie等</li>
<li><code>ephemeralSessionConfiguration</code>和默认配置文件很相似，除了它可以在内存中存储之外，它更像是一个私有的session</li>
<li><code>backgroundSessionConfiguration</code>这个配置文件支持上传和下载任务在后台。当程序挂起或者被终止之后任务可以继续执行。</li>
</ul>


<p><code>NSURLSessionConfiguration</code>依然可以让你配置session的属性，比如设置超时时间，缓存策略和http请求头等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration">这里</a>有完整的配置文档。</p>

<p><code>NSURLSessionTask</code>是一个抽象的任务符号,一个session创建一个任务，它不仅可以请求数据，还可以上传和下载。</p>

<p>这里有三种类型的任务：</p>

<ul>
<li><code>NSURLSessionDataTask</code>：用这个任务可以发送http请求，从而从服务器得到返回的数据</li>
<li><code>NSURLSessionUploadTask</code>：用这个任务可以从本地硬盘上往服务器上传文件，一般是HTTP post请求或者PUT请求.</li>
<li><code>NSURLSessionDownloadTask</code>:用这个任务可以从远程服务器上下载文件</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="logo" /></p>

<p>你可以挂起，回滚和取消任务，<code>NSURLSessionDownloadTask</code>还有一个特性就是支持断点下载。</p>

<p>一般来讲, NSURLSession 有两种方式返回数据：</p>

<ol>
<li>利用completion handler,当任务完成之后，不管是成功返回还是产生错误；</li>
<li>还有一种就是利用NSSession的代理，依然可以捕获到返回的数据;</li>
</ol>


<h2>编写实例Demo</h2>

<p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip">启动工程在这里下载</a>,</p>

<p>开始做一个 在Itunes搜索歌曲，通过<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">Itunes API</a>下载歌曲的这么个小工程，支持暂停，下载功能。</p>

<p>下完工程，运行效果如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt="itunes" /></p>

<h3>开始编写代码</h3>

<p>你可以添加代码去查询itunes中的歌曲，通过查找 Itunes search Api.</p>

<p>在<code>SearchViewController.swift</code>文件中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
</span><span class='line'>// 2
</span><span class='line'>var dataTask: NSURLSessionDataTask?</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做了如下工作:</p>

<ol>
<li>用默认的配置文件创建NSURLSession</li>
<li>你定义了一个<code>NSURLSessionDataTask</code>变量，用它发送http请求，这个任务将会被重复初始化和重复利用在用户创建一个新查询的时候</li>
</ol>


<p>现在，替换<code>searchBarSearchButtonClicked(_:)</code>里面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func searchBarSearchButtonClicked(searchBar: UISearchBar) {
</span><span class='line'>  dismissKeyboard()
</span><span class='line'> 
</span><span class='line'>  if !searchBar.text!.isEmpty {
</span><span class='line'>    // 1
</span><span class='line'>    if dataTask != nil {
</span><span class='line'>      dataTask?.cancel()
</span><span class='line'>    }
</span><span class='line'>    // 2
</span><span class='line'>    UIApplication.sharedApplication().networkActivityIndicatorVisible = true
</span><span class='line'>    // 3
</span><span class='line'>    let expectedCharSet = NSCharacterSet.URLQueryAllowedCharacterSet()
</span><span class='line'>    let searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!
</span><span class='line'>    // 4
</span><span class='line'>    let url = NSURL(string: "https://itunes.apple.com/search?media=music&entity=song&term=\(searchTerm)")
</span><span class='line'>    // 5
</span><span class='line'>    dataTask = defaultSession.dataTaskWithURL(url!) {
</span><span class='line'>      data, response, error in
</span><span class='line'>      // 6
</span><span class='line'>      dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>        UIApplication.sharedApplication().networkActivityIndicatorVisible = false
</span><span class='line'>      }
</span><span class='line'>      // 7
</span><span class='line'>      if let error = error {
</span><span class='line'>        print(error.localizedDescription)
</span><span class='line'>      } else if let httpResponse = response as? NSHTTPURLResponse {
</span><span class='line'>        if httpResponse.statusCode == 200 {
</span><span class='line'>          self.updateSearchResults(data)
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    // 8
</span><span class='line'>    dataTask?.resume()
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>运行后代码如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160401-1.png" alt="logo" /></p>

<p>如果出现错误<code>An SSL error has occurred and a secure connection to the server cannot be made.</code></p>

<p>请在info.plist中配置，在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为 YES</p>

<p>上面的代码步骤意义如下:</p>

<ol>
<li>检查用户每一次查询，dataTask是否已经初始化，如果没有，则取消该任务</li>
<li>设置的状态栏上的转子运行起来，证明数据正在请求当中</li>
<li>当用户输入查询参数之前，调用 请求字符串的<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>,确保是一个正确的URL.　(这个 text 的类型是 String ，常用于搜索功能，在  URL 中包含被搜的关键字，如果不处理搜中文或者带空格的英文会直接崩溃);</li>
<li>下一步创建一个NSURL用上面的（安全的）字符串，使用GET请求去调用Itunes Search API</li>
<li>从创建的Session中，你初始化<code>NSURLSessionDataTask</code>去处理http请求，这个<code>NSURLSessionDataTask</code>任务使用completion handler （回调函数）去响应服务器返回的数据</li>
<li>异步调用主线程，在主线程上隐藏网络请求的转子</li>
<li>如果http请求是成功的，你可以调用<code>updateSearchResults(_:)</code>来刷新表格数据，返回数据是NSData类型的，需要在updateSearchResults方法中进行处理</li>
<li>所有任务默认是挂起状态，需要你调用 <code>resume()</code>去启动任务</li>
</ol>


<h2>下载</h2>

<p>看着搜索到的歌曲，感觉页面不错，但是如果我们能够通过点击 download,然后把歌曲下载到本地是不是更爽呢?下一步让我实现这个功能点.</p>

<p>用多线程实现下载是容易的。首先你要创建一个新的文件命名为 <code>Download.swift</code>. 打开这个文件，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Download: NSObject {
</span><span class='line'> 
</span><span class='line'>  var url: String
</span><span class='line'>  var isDownloading = false
</span><span class='line'>  var progress: Float = 0.0
</span><span class='line'> 
</span><span class='line'>  var downloadTask: NSURLSessionDownloadTask?
</span><span class='line'>  var resumeData: NSData?
</span><span class='line'> 
</span><span class='line'>  init(url: String) {
</span><span class='line'>    self.url = url
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>属性说明如下:</p>

<ul>
<li>URL:下载文件的url地址，它也扮演着唯一的标识符在下载过程中</li>
<li>isDownloading:是否正在下载或暂停</li>
<li>progress : 下载的进度,[0-1]</li>
<li>downloadTask: NSURLSessionDownloadTask下载任务</li>
<li>resumeData:当你暂停一个下载任务时，它负责存储此时的数据量；如果后台服务器支持的话，当用户再次点击继续下载，它会从这里开始继续下载这个文件，俗称 断点下载</li>
</ul>


<p>切换到 <code>SearchViewController.swift</code>，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var activeDownloads = [String: Download]()</span></code></pre></td></tr></table></div></figure>


<h2>创建下载任务</h2>

<p>准备工作做得差不多了，现在你只需实现下载，首先你要创建一个session去实现下载任务.</p>

<p>在 <code>SearchViewController.swift</code>文件中，在<code>viewDidLoad():</code>之前添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var downloadsSession: NSURLSession = {
</span><span class='line'>  let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span><span class='line'>  let session = NSURLSession(configuration: configuration, delegate: self, delegateQueue: nil)
</span><span class='line'>  return session
</span><span class='line'>}()</span></code></pre></td></tr></table></div></figure>


<p>这里初始化了一个session,用默认的配置文件，去处理所有的下载任务，你也可以指定delegate,这将会使你收到 <code>NSURLSession</code>的代理调用，这个是很有用的，它能有效的跟踪下载任务下载的进度和是否下载完成等。</p>

<p>设置代理的队列是nil,会促使session创建一个操作队列，默认的去调用代理方法和回调方法.</p>

<p>在创建<code>downloadsSession</code>属性的时候，我们加了<code>lazy</code>特性，这会让你延迟加载这个session直到你需要它的时候，更重要的是，它会通过<code>self</code>作为代理参数去初始化，假如<code>self</code>还没有初始化。</p>

<p>在<code>SearchViewController.swift</code>文件中，找到空的<code>NSURLSessionDownloadDelegate</code>并且扩展如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDownloadDelegate {
</span><span class='line'>  func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>    print("Finished downloading.")
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>NSURLSessionDownloadDelegate</code>定义了代理方法你需要去实现，在你使用 NSURLSession 下载任务的时候，这个唯一的不是可选的代理方法是 <code>URLSession(_:downloadTask:didFinishDownloadingToURL:),</code>,当下载完成的时候，将会执行这个代理方法，打印简答的一句话.</p>

<p>在<code>SearchViewController.swift</code>文件中，替换<code>startDownload(_:)</code>这个方法的代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func startDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl, url =  NSURL(string: urlString) {
</span><span class='line'>    // 1
</span><span class='line'>    let download = Download(url: urlString)
</span><span class='line'>    // 2
</span><span class='line'>    download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>    // 3
</span><span class='line'>    download.downloadTask!.resume()
</span><span class='line'>    // 4
</span><span class='line'>    download.isDownloading = true
</span><span class='line'>    // 5
</span><span class='line'>    activeDownloads[download.url] = download
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你点击 <code>Download</code>按钮的时候，你将会调用<code>startDownload(_:)</code>函数去执行下载命令，上面的代码执行的步骤如下:</p>

<ol>
<li>你用URL去初始化一个DownLoad对象</li>
<li>使用上面的NSURL和downloadsSession去初始化<code>NSURLSessionDownloadTask</code></li>
<li>调用resume()去启动一个下载任务</li>
<li>设置下载标识 为true</li>
<li>最后，你把下载的URL作为key,download对象作为值放到一个字典中</li>
</ol>


<p>编译运行你的项目，查询出来的歌曲中，点击 Download按钮，你将会看到一个消息打印在控制台。
<code>Finished downloading.</code></p>

<h2>保存&amp;播放</h2>

<p>当下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>提供了一个URL存储临时文件路径，你的工作就是移动它到你程序的沙盒当中，在这个方法返回之前。当然，这个过程当中你需要删除全局字典中正在下载的download对象，并且更新表格.</p>

<p>你需要添加一个Helper方法简化这个操作，在<code>SearchViewController.swift</code>中，添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func trackIndexForDownloadTask(downloadTask: NSURLSessionDownloadTask) -&gt; Int? {
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    for (index, track) in searchResults.enumerate() {
</span><span class='line'>      if url == track.previewUrl! {
</span><span class='line'>        return index
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法仅仅返回 当前的URL在 searchResults集合中的索引，下一步，替换 URLSession(_:downloadTask:didFinishDownloadingToURL:) 中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>  // 1
</span><span class='line'>  if let originalURL = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>    destinationURL = localFilePathForUrl(originalURL) {
</span><span class='line'> 
</span><span class='line'>    print(destinationURL)
</span><span class='line'> 
</span><span class='line'>    // 2
</span><span class='line'>    let fileManager = NSFileManager.defaultManager()
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.removeItemAtURL(destinationURL)
</span><span class='line'>    } catch {
</span><span class='line'>      // Non-fatal: file probably doesn't exist
</span><span class='line'>    }
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.copyItemAtURL(location, toURL: destinationURL)
</span><span class='line'>    } catch let error as NSError {
</span><span class='line'>      print("Could not copy file to disk: \(error.localizedDescription)")
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // 3
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    activeDownloads[url] = nil
</span><span class='line'>    // 4
</span><span class='line'>    if let trackIndex = trackIndexForDownloadTask(downloadTask) {
</span><span class='line'>      dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>        self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: trackIndex, inSection: 0)], withRowAnimation: .None)
</span><span class='line'>      })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的事情如下:</p>

<ol>
<li>定义了两个变量，<code>originalURL</code>请求路径的url,<code>destinationURL</code>变量则是通过<code>localFilePathForUrl(_:)</code>方法生成的，该方法会获取当前程序的沙盒路径再追加 传递的URL的最后一个后缀(/)的路径作为返回的参数。作为目标文件夹的路径</li>
<li>使用NSFileManager,在开始拷贝文件之前，先删除目标文件夹下的文件，如果存在的话。然后进行拷贝从本地拷贝到目标文件夹</li>
<li>删除download从全局的download字典中</li>
<li>最后刷新表格对应的哪一行</li>
</ol>


<p>编译运行你的工程，点击搜索然后选中一行进行下载，当下载完成时候，在控制台会打印一行信息,下载的目标路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file:///Users/Andrew/Library/Developer/CoreSimulator/Devices/875165C2-FA55-4884-96AE-A7C8E3223C12/data/Containers/Data/Application/52B47648-04A2-4C26-8BCF-F41D2C76CA21/Documents/mzm.gyadmzom.aac.p.m4a</span></code></pre></td></tr></table></div></figure>


<p>这时下载按钮将会消失，再次点击表格的对应的那行，将会弹出一个 MPMoviePlayerViewController,开始播放音频.</p>

<h2>监视下载进度</h2>

<p>当然，现在你还没有监视下载的进度条，为了提高用户体验，你将要改变你的App去监听下载的进度在每个cell中。</p>

<p>在SearchViewController.swift文件中,找到 <code>NSURLSessionDownloadDelegate</code>的扩展，然后添加如下的代理方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
</span><span class='line'> 
</span><span class='line'>    // 1
</span><span class='line'>    if let downloadUrl = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>      download = activeDownloads[downloadUrl] {
</span><span class='line'>      // 2
</span><span class='line'>      download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
</span><span class='line'>      // 3
</span><span class='line'>      let totalSize = NSByteCountFormatter.stringFromByteCount(totalBytesExpectedToWrite, countStyle: NSByteCountFormatterCountStyle.Binary)
</span><span class='line'>      // 4
</span><span class='line'>      if let trackIndex = trackIndexForDownloadTask(downloadTask), let trackCell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: trackIndex, inSection: 0)) as? TrackCell {
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          trackCell.progressView.progress = download.progress
</span><span class='line'>          trackCell.progressLabel.text =  String(format: "%.1f%% of %@",  download.progress * 100, totalSize)
</span><span class='line'>        })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过这个代理方法做的工作如下:</p>

<ol>
<li>使用提供的 downloadTask 找到URL属性，然后从全局激活的下载字典中查找 DownLoad对象</li>
<li>这个方法将会返回总的字节数和已经写入的字节数，你可以利用这个两个值算出当前的下载进度并且实时更新进度条。</li>
<li>NSByteCountFormatter 将会把字节数转化成人类能够看懂的文件大小，有将会使用这个字符串去显示下载的文件大小和百分比</li>
<li>最后，你将要定位到这个Cell,在主线程中更新进度条和显示的百分比</li>
</ol>


<p>下一步，你将要配置这个cell属性去显示进度条</p>

<p>找到下面的代码在 <code>tableView(_:cellForRowAtIndexPath:):</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let downloaded = localFileExistsForTrack(track)</span></code></pre></td></tr></table></div></figure>


<p>添加如下代码在这行的上面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var showDownloadControls = false
</span><span class='line'>if let download = activeDownloads[track.previewUrl!] {
</span><span class='line'>  showDownloadControls = true
</span><span class='line'> 
</span><span class='line'>  cell.progressView.progress = download.progress
</span><span class='line'>  cell.progressLabel.text = (download.isDownloading) ? "Downloading..." : "Paused"
</span><span class='line'>}
</span><span class='line'>cell.progressView.hidden = !showDownloadControls
</span><span class='line'>cell.progressLabel.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>为了跟踪正在下载的歌曲，你将要设置 showDownloadControls为true,否则，你将要设置为false.你将要显示这进度条和文字。</p>

<p>为了暂停任务，显示"Paused"状态，否则，显示 “Downloading&hellip;.”
最后，替换这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded</span></code></pre></td></tr></table></div></figure>


<p>使用下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded || showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>到这，你可以告诉表格是否隐藏下载按钮。</p>

<p>编译运行你的工程，点击下载按钮，你将要看到一个进度条和下载的进度，以及下载的百分比。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-17-at-11.02.03-pm-480x78.png" alt="logo" /></p>

<p>OK,你做到了!😀</p>

<h2>暂停 恢复  取消下载任务</h2>

<p>假如我需要暂停一个任务，或者取消任务？此时该怎么做呢？</p>

<p>在这个章节，你将要实现暂停，恢复，取消任务操作。</p>

<p>你将要开始编写代码，通过允许用户去取消一个正在激活的任务
替换 <code>cancelDownload(_:)</code> 使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func cancelDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      download.downloadTask?.cancel()
</span><span class='line'>      activeDownloads[urlString] = nil
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了取消任务，你可以从全局激活的字典中取出Download对象，然后调用它的 cancel() 方法，执行取消命令，然后在全局字典中移除它</p>

<p>暂停任务和取消任务非常类似，不同点在于当你暂停一个任务的时候，会产生恢复数据，它包含了足够多的信息去恢复下载数据，当然后台服务器必须要支持这个特性才能完全实现断点下载功能.</p>

<blockquote><p><strong>注意</strong>
你能恢复一个下载任务在一定的控制条件下，例如，从你第一下请求下载开始，这个下载资源就不能再改变了。想要更详细的控制条件，请参考苹果的 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDownloadTask_class/index.html#//apple_ref/occ/instm/NSURLSessionDownloadTask/cancelByProducingResumeData:">官方文档</a></p></blockquote>

<p>现在，替换 <code>pauseDownload(_:)</code>使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func pauseDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if(download.isDownloading) {
</span><span class='line'>        download.downloadTask?.cancelByProducingResumeData { data in
</span><span class='line'>          if data != nil {
</span><span class='line'>            download.resumeData = data
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>        download.isDownloading = false
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个关键字是不同的 cancelByProducingResumeData(_:) 替代了 cancel(),你检索这个恢复的数据从这个方法cancelByProducingResumeData提供的回调函数中，并且把恢复的数据保存到Download的resumeData属性中。并且设置isDownloading=false</p>

<p>下面替换<code>resumeDownload(_:)</code>用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func resumeDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if let resumeData = download.resumeData {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      } else if let url = NSURL(string: download.url) {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户恢复一个下载任务时，你检查下当前的Download对象 恢复数据的属性是否有值，如果有值，你将会创建一个新的下载任务通过 <code>downloadTaskWithResumeData(_:)</code>和一个恢复数据的参数，启动<code>resume()</code>恢复数据的命令;如果这个 恢复数据的属性是空的或者其他一些原因，你将要用URL创建一个新的下载任务，启动它.</p>

<p>在上面的案例中，你设置这个isDownloading为true,表明任务正在进行.</p>

<p>还有一件事件要做就是设置这三个函数的工作属性，你需要在cell中显示 或者隐藏 <code>暂停</code>，<code>取消</code>和<code>继续下载</code>按钮。</p>

<p>找到 <code>tableView(_:cellForRowAtIndexPath:)</code>然后找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let download = activeDownloads[track.previewUrl!] {</span></code></pre></td></tr></table></div></figure>


<p>然后添加下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let title = (download.isDownloading) ? "Pause" : "Resume"
</span><span class='line'>cell.pauseButton.setTitle(title, forState: UIControlState.Normal)</span></code></pre></td></tr></table></div></figure>


<p>暂停和继续下载按钮共用一个按钮。</p>

<p>下一步，添加下面的代码在 <code>tableView(_:cellForRowAtIndexPath:)</code>结尾:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.pauseButton.hidden = !showDownloadControls
</span><span class='line'>cell.cancelButton.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>当下载任务激活的时候，这里仅仅把按钮显示出来。</p>

<p>编译运行你的工程，下载几个歌曲试试，你可以暂停，继续下载，取消 下载任务。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="logo" /></p>

<h2>支持后台下载</h2>

<p>你的App现在看来已经很不错了，但是还有一个问题，是否支持后台任务下载:当你的程序进入后台模式或者因为别的原因意外终止了，后台任务是否能继续下载?</p>

<p>假如你的App不再运行了，那它怎么能继续工作呢？这儿有一个守护进程在App运行之外，去管理后台任务下载；它发送一个适当的代理方法通知给app让其任务下载继续，当这个app正在下载的时候突然退出，这个任务将要继续下载。</p>

<p>当任务完成的时候，这个守护进程将要重新加载在后台模式中，这个重新加载app将要重新连接这同样的session.收到相关的完成的代理消息并且执行一些要求的动作，比如持久化下载的文件到硬盘上等。</p>

<blockquote><p><em>注意</em>
如果你强制退出app通过app switche，这个系统将要取消所有后台下载的任务，并且不会再视图重启这个app</p></blockquote>

<p>仍然在SearchViewController.swift这个文件中，在初始化 <code>downloadsSession</code>的地方，找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span></code></pre></td></tr></table></div></figure>


<p>替换成下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("bgSessionConfiguration")</span></code></pre></td></tr></table></div></figure>


<p>替换默认的session配置文件，指定一个特殊的后台session配置文件，注意你设置了唯一的ID为这个session,这会允许你引用并且重新连接同样的后台session.</p>

<p>下一步，在 viewDidLoad()中，增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_ = self.downloadsSession</span></code></pre></td></tr></table></div></figure>


<p>调用懒加载属性<code>downloadsSession</code>,确保应用程序确实创建了一个后台session 的SearchViewController的实例。</p>

<p>当一个后台任务完成的时候，这个App不再运行，这个app将会重新运行到后台进程中，你需要去处理你的app的一些代理方法.</p>

<p>切换到 AppDelegate.swift,添加下面的代码在类的顶部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var backgroundSessionCompletionHandler: (() -&gt; Void)?</span></code></pre></td></tr></table></div></figure>


<p>下一步，添加如下代码在AppDelegate.swift:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) {
</span><span class='line'>  backgroundSessionCompletionHandler = completionHandler
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>提供一个completionHandler作为一个变量在你的App代理方法中，等会会用到。</p>

<p>application(_:handleEventsForBackgroundURLSession:)会唤醒这个App处理完成这个后台任务，你需要去处理两个事情：</p>

<ul>
<li>首先，通过代理方法用这个App去重新连接这个后台session,一旦你创建并且每次使用后台session时，SearchViewController就会被实例化，你已经重新连接了.</li>
<li>第二，你需要去捕获完成的回调方法，在完成的回调函数中，更新你的UI,然后告诉系统你的App已经工作完毕使用后台任务的session.</li>
</ul>


<p>但是什么时候你将会调用完成的回调函数呢？
<code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>将会是一个好的选择，它是NSURLSessionDelegate的一个代理方法，当所有的任务在后台session中完成的时候。</p>

<p>实现下面的扩展在<code>SearchViewController.swift</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDelegate {
</span><span class='line'> 
</span><span class='line'>  func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
</span><span class='line'>    if let appDelegate = UIApplication.sharedApplication().delegate as? AppDelegate {
</span><span class='line'>      if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
</span><span class='line'>        appDelegate.backgroundSessionCompletionHandler = nil
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          completionHandler()
</span><span class='line'>        })
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码仅仅抓取了在APPDelegate中存储的回调函数，并且在主线中调用它.</p>

<p>编译运行你的工程，开始几个下载之后迅速按在home键，使得下载任务进入后台，等几十秒你的下载任务将会完成，然后双击home,关闭当前程序。</p>

<p>下载任务将会完成并且他们将会更新显示状态。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt="logo" /></p>

<p>OK，这个demo已经完备了。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程从 <a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip">这里</a></p>

<p>更多资源</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/">苹果的官方文档</a></li>
<li><a href="https://github.com/Alamofire/Alamofire">AlamoFire</a>是Swift中非常流行的第三方框架，可以学习一下.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue简单介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao/"/>
    <updated>2016-03-26T08:11:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao</id>
    <content type="html"><![CDATA[<p>在iOS中有两种方式来实现多线程:NSOperation和GCD.
其中GCD是基于C的底层的API,而NSOperation则是GCD实现的Object-c的API,随让NSOPeration是基于GCD实现的，但是并不意味着它是一个GCD的重复版本，相反，我们可以用NSOperation轻易的实现一些GCD要写大量代码的事情，因此，NSOperation是被推荐使用的.</p>

<!--more-->


<h2>为什么优先使用NSOperationQuere,而不是GCD</h2>

<p>你可能写过这样的网络请求的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(_Queue, ^{  
</span><span class='line'>    //请求数据 
</span><span class='line'>    NSData *data = [NSData dataWithContentURL:[NSURL URLWithString:@"http://domain.com/a.png"]]; 
</span><span class='line'>    dispatch_async(dispatch_get_main_queue(), ^{ 
</span><span class='line'>        [self refreshViews:data];
</span><span class='line'>     });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>这段代码是可以正常工作的，但是有一个很大的缺点，就是<em>这个任务是无法取消的</em></p>

<p><code>dataWithContentURL:</code>是同步拉取数据，它会一直阻塞主线程，直到所有的数据返回之后；这个期间，并发队列就需要为其它任务新建线程，这样可能导致性能下降问题。因此我们不推荐这种写法来从网络上拉取数据。</p>

<p>操作队列是有GCD提供的一个队列模型的Coco对象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了更加方便的功能。NSOperation相对GCD来说有以下优点:</p>

<ul>
<li>提供了GCD中不那么容易复制的有用特性</li>
<li>可以很方便的取消一个NSOperation的执行</li>
<li>可以容易的添加任务的依赖关系</li>
<li>提供了任务的状态:isExecting,isFinished
*</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue就是一个线程队列，可以吧 <code>NSOperation</code>加入到队列中，可以取消或者执行完队列中所有的 <code>NSOperation</code>,我们可以通过<code>maxConcurrentOperationCount</code>属性来控制并发任务的数量，当设置为1时，就是一个串行队列。</p>

<h2>NSOperation</h2>

<p>它是创建线程的对象，系统已经默认提供了<code>NSBlockOperaton</code>和<code>NSInvocationOperation</code>.你也可以实现自己的子类，通过重写
<code>main</code>或者<code>start</code>方法来自定义nsoperation</p>

<p>使用<code>main</code>方法非常简单，不需要管理一些状态属性,当main方法返回的时候，这个operation就执行结束了，所以一般用来执行同步任务。</p>

<p>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么重写<code>start</code>方法，但是注意，在这种情况下，你必须手动的管理操作的状态，只有发送isFinished的KVO消息时，才认为是operaiton结束。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>@implementation YourOperation
</span><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = YES;
</span><span class='line'>    // 任务代码 ...
</span><span class='line'>}
</span><span class='line'>- (void)finish //异步回调
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = NO;
</span><span class='line'>    self.isFinished = YES;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><em>当实现了<code>start</code>方法时，默认就会执行start方法，而不执行main方法</em>，为了让操作队列捕获到做的改变，需要将状态的属性配合KVO的方式实现，如果你不使用它们默认的sette来进行设置的话，就需要在合适的时候手动发送KVO消息。</p>

<p>需要手动管理的状态有:</p>

<ol>
<li>isExecuting  代表任务正在进行中</li>
<li>isFinished   代表任务已经执行完成</li>
<li>isCanceled  代表任务已经取消</li>
</ol>


<p>手动发送KVo消息，通知状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self willChangeValueForKey:@"isCancelled"];
</span><span class='line'>_isCancelled = YES;
</span><span class='line'>[self didChangeValueForKey:@"isCancelled"];</span></code></pre></td></tr></table></div></figure>


<p>为了能使用队列所提供的取消功能，你需要在长时间操作中不时地检查isCanceled属性，比如在一个长的循环中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)main
</span><span class='line'>{
</span><span class='line'>    while (notDone && !self.isCancelled) {
</span><span class='line'>        // 任务处理
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>简单使用</h2>

<p>NSOperaiton和NSOperationQueue实现多线程的步骤:</p>

<ol>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装放到一条新线程中执行</li>
</ol>


<p>NSOperation是个抽象类，并不具备封装操作的能力，必须实现它的子类。</p>

<h3>NSInvocationOperation子类</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建操作对象，封装要执行的任务
</span><span class='line'>//NSInvocationOperation   封装操作
</span><span class='line'>    NSInvocationOperation *operation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];
</span><span class='line'>    
</span><span class='line'>    //执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>一旦执行操作，就会调用target的test方法</p>

<p>操作对象默认在主线程中执行，只有添加到列队中才会开启新的线程，即默认情况下，如果操作没有放到队列queue中，都是同步执行，只有将NSoperation放到一个NSOperationQueue中，才会异步执行.</p>

<h2>NSBlockOoperaiton</h2>

<p>创建对象和添加操作:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>    NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        //......
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //添加操作
</span><span class='line'>    [operation addExecutionBlock:^{
</span><span class='line'>        //....
</span><span class='line'>    }];</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>     NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>    
</span><span class='line'>     //添加操作
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation1------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>         NSLog(@"NSBlockOperation2------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     //开启执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>只要NSBlockOperation封装的操作数>1，就会异步操作。</p>

<h2>NSOperationQueue</h2>

<p>NSOperationQueue可以调用start方法来执行任务，但默认是同步执行的。
如果将NSOperation添加到NSOperationQueue中，系统就会自动异步执行NSOPeration中的操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "YYViewController.h"
</span><span class='line'>
</span><span class='line'>@interface YYViewController ()
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation YYViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    //创建NSInvocationOperation对象，封装操作
</span><span class='line'>    NSInvocationOperation *operation1=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test1) object:nil];
</span><span class='line'>    NSInvocationOperation *operation2=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test2) object:nil];
</span><span class='line'>    //创建对象，封装操作
</span><span class='line'>    NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--1----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    [operation3 addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--2----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //创建NSOperationQueue
</span><span class='line'>    NSOperationQueue * queue=[[NSOperationQueue alloc]init];
</span><span class='line'>    //把操作添加到队列中
</span><span class='line'>    [queue addOperation:operation1];
</span><span class='line'>    [queue addOperation:operation2];
</span><span class='line'>    [queue addOperation:operation3];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test1
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test1--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test2
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test2--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>系统自动将NSOperationqueue中的NSOPeration对象取出，将其封装的操作放到一条新的线程中执行，
上面的代码一共有4个任务，operation1和operation2分别有一个任务，operation3有两个任务，一共4个任务，开启了4条线程。</p>

<p>这些任务是并行执行的。</p>

<blockquote><p><strong>提示</strong>
队列的取出时有顺序的，与打印结果并不矛盾，这就好比赛跑，起跑的顺序是A,B,C，但是到达终点的顺序就不一样是 A B  C了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-泛型]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing/"/>
    <updated>2016-03-24T10:11:56+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing</id>
    <content type="html"><![CDATA[<p>泛型代码可以让你编写使用自定义需求以及任意类型的灵活可冲中的函数和类型，它可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>

<!--more-->


<p>泛型是swift的强大特性之一，许多swift标准库是通过泛型代码构建的。事实上，泛型的使用贯穿饿了正本语言手册，只是你可能没有发现而已。例如,swift的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可以创建一个<code>String</code>数组，甚至可以是任意其它Swift类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>

<h2>泛型所解决的问题</h2>

<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个<code>Int</code>值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数使用输入输出函数(<code>inout</code>)来交换<code>a</code>和<code>b</code>的值。</p>

<p><code>swapTwoInts(_:_:)</code>函数交换<code>b</code>的原始值到<code>a</code>,并交换<code>a</code>的原始值到<code>b</code>,你可以调用这个函数交换两个<code>Int</code>变量的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// 打印 “someInt is now 107, and anotherInt is now 3”</span></code></pre></td></tr></table></div></figure>


<p>诚然，<code>swapTwoInts(_:_:)</code>函数挺有用，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>值或者<code>Double</code>值，就不能不写更多的函数，例如<code>swapTwoStrings(_:_:)</code>和<code>swapTwoDoubles(_:_:)</code>,如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoStrings(inout a: String, inout _ b: String) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func swapTwoDoubles(inout a: Double, inout _ b: Double) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可能注意到<code>swapTwoInts(_:_:) 和 swapTwoDoubles(_:_:)</code>,的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 int,String,Double.</p>

<p>在实际的应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p>

<blockquote><p><em>注意</em>
在上面的三个函数中，<code>a</code>和<code>b</code>类型相同，如果<code>a</code>和<code>b</code>类型不同，那他们俩就不能交换值。Swift是类型安全的语言，所以不会允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互换值。视图这样做将导致编译错误。</p></blockquote>

<h2>泛型函数</h2>

<p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面三个函数的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoValues&lt;T&gt;(inout a:T,inout _ b:T){
</span><span class='line'> let temporaryA=a;
</span><span class='line'> a=b;
</span><span class='line'> b= temporaryA;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>swapTwoValues(_:_:)</code>的函数主体和<code>swapTwoInts(_:_:)</code>函数是一样的。他们只在第一行有所不同，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int)
</span><span class='line'>func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)</span></code></pre></td></tr></table></div></figure>


<p>这个函数的泛型版本使用了占位类型名(在这里用字母<code>T</code>来表示)来代替实际的类型名(例如<code>Int</code>,<code>String</code>或者<code>Double</code>).占位类型名没有指明<code>T</code>必须是什么类型，但是它指明了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>,而不论<code>T</code>代表什么类型，只有<code>swapTwoValues(_:_:)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型。</p>

<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名(T),而且使用尖括号括起来的(<code>&lt;T&gt;</code>).这个尖括号告诉Swift那个<code>T</code>是<code>swapTwoValues(_:_:)</code>函数定义的一个占位类型名，因此swift不会去查找名为<code>T</code>的实际类型。</p>

<p>swapTwoValues(<em>:</em>:) 函数现在可以像 swapTwoInts(<em>:</em>:) 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code>函数调用时，<code>T</code>所代表的类型都会由传入的值的类型判断出来.</p>

<p>在下面的两个例子中，<code>T</code>分别代表<code>Int</code>和<code>String</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoValues(&someInt, &anotherInt)
</span><span class='line'>// someInt is now 107, and anotherInt is now 3
</span><span class='line'>
</span><span class='line'>var someString = "hello"
</span><span class='line'>var anotherString = "world"
</span><span class='line'>swapTwoValues(&someString, &anotherString)
</span><span class='line'>// someString is now "world", and anotherString is now "hello"</span></code></pre></td></tr></table></div></figure>


<h2>类型参数</h2>

<p>在上面的<code>swapTwoValues(_:_:)</code>例子中，占位类型<code>T</code>是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来(<T>).</p>

<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型，或者作为函数的返回类型，还可以用作函数主题中的注释类型。在这些情况下，类型参数在函数调用时被实际类型所代替。</p>

<h2>命名类型参数</h2>

<p>在大多数情况下，类型参数具有一个描述性名字，例如<code>Dictionary&lt;Key,Value&gt;</code>中的key和value,以及<code>Array&lt;Element&gt;</code>中的<code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当他们之间的关系没有意义时，通常使用单一的字母来命名，例如<code>T</code>,<code>U</code>,<code>V</code>，正如上面演示的<code>swapTwoValues(_:_:)</code>函数中的<code>T</code>一样.</p>

<h2>泛型类型</h2>

<p>除了泛型函数，Swift还允许你定义泛型类型。这些自定义类，结构体和枚举可以适用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>

<p>这部分内容将向你展示如何编写一个名为<code>stack</code>（栈）的泛型集合类型。栈是一系列值的有序集合，如<code>Array</code>类型，但它比Swift的array类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素，称为入栈。同样滴，栈也只能从末端移除元素。</p>

<p>下面展示了一个如何编写一个非泛型版本的栈，在这种情况下是<code>Int</code>型的栈.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStack {
</span><span class='line'>    var items=[Int]()
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个结构体在栈中使用一个名为<code>items</code>的<code>array</code>属性来存储值。<code>Stack</code>提供了两个方法:<code>push(_:)</code>和<code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为<code>mutating</code>，因为他们需要修改结构体的<code>items</code>数组。</p>

<p>上面的<code>IntStack</code>结构体只能用于Int类型，不过可以定义一个泛型的<code>Stack</code>结构体，从而能够处理任意类型的值。</p>

<p>下面是相同代码的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;Element&gt; {
</span><span class='line'>    var items=[Element]();
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Element){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Element{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，<code>Stack</code>基本上和<code>IntStack</code>相同，只是占位类型参数<code>Element</code>代替了实际的<code>Int</code>类型。这种类型参数包裹在一对尖括号里(<code>&lt;Element&gt;</code>)，紧跟在结构体名后面、</p>

<p><code>Element</code>为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体定义中通过<code>Element</code>来引用。在这种情况下，<code>Element</code>在如下三个地方被用作占位符:</p>

<ul>
<li>创建 items 属性，使用<code>Element</code>类型的空数组进行初始化</li>
<li>执行<code>psh(_:)</code>方法的单一参数<code>item</code>的类型必须是<code>Element</code>类型</li>
<li>指定<code>pop()</code>方法的返回值类型必须是<code>Element</code>类型.</li>
</ul>


<p>由于<code>stack</code>是泛型类型，因此可以用来创建Swift中任意有效类型的栈，如同<code>Array</code>和<code>Dictionary</code>.</p>

<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例。例如，要创建一个<code>String</code>类型的栈，可以写成<code>Stack&lt;String&gt;</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'>stackOfStrings.push("cuatro")
</span><span class='line'>// 栈中现在有 4 个字符串</span></code></pre></td></tr></table></div></figure>


<p>移除并返回栈顶部的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let fromTheTop = stackOfStrings.pop()
</span><span class='line'>// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></code></pre></td></tr></table></div></figure>


<h2>扩展一个泛型类型</h2>

<p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型的参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<p>下面的例子扩展了泛型类型<code>Stack</code>，为其添加了一个名为<code>topItem</code>的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Stack{
</span><span class='line'>    var topItem:Element?{
</span><span class='line'>        return items.isEmpty ? nil:items[items.count];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>topItem</code>属性会返回一个<code>Element</code>类型的可选值。当栈为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>items</code>数组中的最后一个元素.</p>

<p>注意，这个扩展并没有定义一个类型参数列表。相反地，<code>Stack</code>类型已有的类型参数名<code>Element</code>，被用在扩展中表示计算型属性<code>topItem</code>的可选类型，<code>topItem</code>现在可以用来访问任意<code>Stack</code>实例的顶端元素而不是移除它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let topItem = stackOfStrings.topItem {
</span><span class='line'>    print("The top item on the stack is \(topItem).")
</span><span class='line'>}
</span><span class='line'>// 打印 “The top item on the stack is tres.”</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>类型约束</h2>

<p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须集成自特定类，或者符合一个特定的协议或者协议组合。</p>

<p>例如,Swift的<code>Dictionary</code>类型对字典的键的类型做了限制，在字典的描述中，字典的键必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希的，是为了便于检查字典是否已经包含了某个特定键的值。如无此要求，Dictionary将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中指定键的值。</p>

<p>这个要求强制加上了一个类型约束作用域<code>Dictionary</code>的键类型上，其键类型必须符合<code>Hashable</code>协议，这是swift标准库中定义的一个特定协议。所有的swfit基本类型(String,Int,Double)默认都是可哈希的。</p>

<p>当你创建自定义反省类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的。</p>

<h2>类型约束语法</h2>

<p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分割，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
</span><span class='line'>    // 这里是泛型函数的函数体部分
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的这个函数有两个类型参数。第一个类型是参数<code>T</code>,有一个要求<code>T</code>必须是<code>SomeClass</code>自雷的类型约束；第二个类型参数<code>U</code>,有一个要求<code>U</code>必须符合<code>someProtocol</code>协议的类型约束.</p>

<h2>类型约束实践</h2>

<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数的功能在<code>String</code>值的数组中查找指定<code>String</code>值的索引。弱查找到匹配的字符串，<code>findStringIndex(_:_:)</code>函数返回该字符串在数组中的索引值，反之则返回<code>nil</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findStringIndex(array: [String], _ valueToFind: String) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数可以用于查找字符串数组中的某个字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
</span><span class='line'>if let foundIndex = findStringIndex(strings, "llama") {
</span><span class='line'>    print("The index of llama is \(foundIndex)")
</span><span class='line'>}
</span><span class='line'>// 打印 “The index of llama is 2”</span></code></pre></td></tr></table></div></figure>


<p>如果只能查找字符串在数组中的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex(_:_:)</code>,用占位类型<code>T</code>代替<code>String</code>类型。</p>

<p>下面展示了<code>findStringIndex(_:_:)</code>函数的泛型版本<code>findIndex(_:_:)</code>.请注意这个函数仍然返回<code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到一个可选值。需要提醒的是，这个函数无法通过编译，原因例子后面说明:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>func findIndex&lt;T&gt;(array:[T], valueToField:T)-&gt;Int?{
</span><span class='line'>    for (index, value)in array.enumerate(){
</span><span class='line'>        if value == valueToField{
</span><span class='line'>            return index;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即<code>if vlaue == valueToField</code>。不是所有的Swift类型都可以用等号(==)进行比较。例如，如果你创建一个你自己的类活结构体表示一个复杂的数据模型，那么Swift无法猜到对于这个类或者结构体而言 “相等”意味着什么。正因为如此，这部分代码无法保证适用于每个可能的类型<code>T</code>,当你试图编译这部分代码的时候会出现相应的错误。</p>

<p>不过所有的这些并不会让我们无从下手。Swift标准库中定义了一个<code>Equatable</code>协议，该协议要求任何符合该协议的类型必须实现等式符号(==),从而对符合该协议的类型的任意两个值进行比较。所有的Swift标准类型自动支持Equatable协议。</p>

<p>任何<code>Equatable</code>类型都可以安全地使用在<code>findIndex(_:_:)</code>函数中，因为其保证支持等式操作符。为了说明事实，当你定义一个函数时，你可以定义一个<code>Equatable</code>类型约束作为类型参数定义的一部分:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>findIndex(_:_:)</code>中的这个单一类型参数协作<code>T:Equatable</code>，也就意味着<code>任何符合Equatable</code>协议的<code>T</code>类型。</p>

<p>findIndex函数现在可以成功编译了。并且可以作用于任何符合<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
</span><span class='line'>// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中
</span><span class='line'>let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
</span><span class='line'>// stringIndex 类型为 Int?，其值为 2</span></code></pre></td></tr></table></div></figure>


<h2>关联类型</h2>

<p>下面例子定义了一个<code>Container</code>协议，该协议定义了关联类型<code>ItemType</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Container{
</span><span class='line'>   typealias ItemType
</span><span class='line'>    mutating func append(item:ItemType)
</span><span class='line'>    
</span><span class='line'>    var count:Int{get}
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;ItemType{get}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><code>Container</code>协议定义了三个任何采纳协议的类型必须提供的功能：</p>

<ul>
<li>必须可以通过<code>append</code>方法添加一个新元素到容器里。</li>
<li>必须可以通过<code>count</code>属性获取容易中元素的数量，并返回一个Int</li>
<li>必须可以通过接受<code>Int</code>索引值的下标检索到每一个元素</li>
</ul>


<p>这个协议没有指定容易中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳<code>Container</code>协议的类型必须是提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>

<p>任何采纳<code>Container</code>协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素类型。</p>

<p>为了定义这三个条件，<code>Container</code>协议需要在不知道容易中元素具体类型的情况下引用这种类型。</p>

<p><code>Container</code>协议声明了一个关联类型<code>ItemType</code>，协作<code>typealias Itemtype</code>.这个协议无法定义<code>ItemType</code>是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code>别名提供了一种方式来引用<code>Container</code>中元素的类型，并将之用于<code>append</code>方法和下标，从而保证任何<code>Container</code>的预期行为都能够被执行。</p>

<p>下面采用复合<code>Container</code>协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStackContainer:Container {
</span><span class='line'>    var items:[Int]
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>     items.append(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //Container协议的实现部分
</span><span class='line'>    typealias ItemType=Int
</span><span class='line'>    
</span><span class='line'>    mutating func append(item: ItemType) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var count:Int{
</span><span class='line'>      return items.count
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;Int{
</span><span class='line'>        return items[i];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>IntStackContainer</code>结构体实现了<code>Container</code>协议的三个要求，其原有功能也不会和这些要求冲突。</p>

<p>此外，<code>IntStackContainer</code>指定 ItemType为Int类型，即<code>typealias ItemType = Int</code>，从而将<code>Container</code>协议中抽象的<code>ItemType</code>类型转为具体的<code>Int</code>类型。</p>

<h2>通过扩展一个存在的类型来指定关联类型</h2>

<p>Swift的<code>Array</code>已经提供了<code>append(_:_:)</code>方法，一个<code>count</code>属性，以及一个接受<code>Int</code>型索引值的可用来检索数组元素的下标。这三个功能都符合<code>Container</code>协议的要求，也就意味着你可以扩展<code>Array</code>去符合<code>Container</code>协议，只需简单滴声明<code>Array</code>采纳该协议即可。你可以通过一个空扩展来实现这点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Array:Container{}</span></code></pre></td></tr></table></div></figure>


<p>如何上面的泛型<code>Stack</code>结构一样，array的<code>append(_:)</code>方法和下标确保了Swift可以推断出<code>ItemType</code>的类型，定义了这个扩展后，你可以将任意<code>Array</code>当做<code>Container</code>来使用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-可选链]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/22/swift-ke-xuan-lian/"/>
    <updated>2016-03-22T09:35:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/22/swift-ke-xuan-lian</id>
    <content type="html"><![CDATA[<p>可选链式调用(Optional Chaining)是一种可以在当前值可能为<code>nil</code>的可选值上请求和调用属性，方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值为nil,那么调用将返回<code>nil</code>.多个调用可以连接在一起形成一个链，如果其中任何一个点为<code>nil</code>,整个调用链就会失败，即返回nil.</p>

<!--more-->


<h2>使用可选链式调用代替强制展开</h2>

<p>通过在想调用的属性，方法，下标的可选值后面放一个问号(?),可以定义一个可选链，这一点很像在可选值后面加一个(!)来强制展开它的值。它们的主要区别在于当可选值为空时，可选链式就会调用失败，然而强制展开就会触发运行时错误。</p>

<p>为了反映可选链时调用可以在空值(nil)上调用的事实，不论这个调用的属性，方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链时调用是否成功，如果调用有返回值则说明调用成功，返回 <code>nil</code>则说明调用失败。</p>

<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是<code>Int</code>类型，则会变成<code>Int?</code>类型。</p>

<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>

<p>首先定义两个类<code>Person</code>和<code>Residence</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence:Residence?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Residence {
</span><span class='line'>    var numberOfRooms=1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Residence</code>有一个<code>Int</code>类型的属性<code>numberOfRooms</code>,其默认是值是1，<code>Person</code>具有一个可选的<code>residence</code>属性，其类型为<code>Residence?</code></p>

<p>如果创建一个新的<code>Person</code>实例，因为它的<code>residence</code>属性是可选的，<code>john</code>属性将初始化为<code>nil</code>:</p>

<pre><code>let john=Person()
</code></pre>

<p>如果使用叹号(!)强制展开获得这个<code>john</code>的<code>Residence</code>属性中的<code>numberofRooms</code>值，会触发运行时错误，因为这时<code>residence</code>没有可以展开的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let roomCount = john.residence!.numberOfRooms
</span><span class='line'>// 这会引发运行时错误</span></code></pre></td></tr></table></div></figure>


<p><code>john.residence</code>为非nil值的时候，上面的调用会成功，并且把<code>roomCount</code>设置为<code>Int</code>类型的房间数量，正如上面所提到的，当<code>residence</code>为<code>nil</code>的时候上面这段代码会触发运行时错误。</p>

<p>可选链时调用提供了另一种访问<code>numberOfRooms</code>的方式，使用问号(?)来代替原来的叹号(!)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>在<code>residence</code>后面添加问号之后，Swift就会在<code>residence</code>不为nil的情况下访问<code>numberOfRooms</code>.</p>

<p>因为访问<code>numberOfRooms</code>又看呢过失败，可选链式调用会返回<code>Int?</code>类型，或称为'可选的Int'。如上例所示，当<code>residence</code>为<code>nil</code>的时候，可选的<code>Int</code>将会为<code>nil</code>,表明无法访问<code>numberOfRooms</code>。访问成功时，可选的<code>Int</code>值会通过可选绑定展开，并复制给非可选类型的<code>roomCount</code>常量。</p>

<p>要注意的是，及时<code>numberOfRooms</code>是非可选的<code>Int</code>时，这一点也成立。只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回一个<code>Int?</code>而不是<code>Int</code>.</p>

<p>可以将一个<code>Residence</code>的实例赋值给<code>john.residence</code>，这样它就不在是<code>nil</code>了:</p>

<pre><code>john.residence=Residenc();
</code></pre>

<p>john.residence现在包含一个实际的<code>Residence</code>实例，而不再是<code>nil</code>.如果你试图使用先前的可选链式调用访问<code>numberOfRooms</code>，它现在将返回值为1的<code>Int?</code>类型的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's residence has 1 room(s).”</span></code></pre></td></tr></table></div></figure>


<h2>可选链式调用定义模型类</h2>

<p>通过使用可选链式调用可以调用多层属性，方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性，方法和下标。</p>

<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在<code>person</code>和<code>Residence</code>的基础上增加了<code>Room</code>类和<code>Address</code>类，一级相关的属性，方法和下标.</p>

<p><code>Person</code>类的定义基本保持不变:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Residence类比之前复杂些。增加了一个名为<code>Rooms</code>的变量属性，该属性被初始化为<code>[Room]</code>类型的空数组:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Residence {
</span><span class='line'>    var rooms = [Room]()
</span><span class='line'>    var numberOfRooms: Int {
</span><span class='line'>        return rooms.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Room {
</span><span class='line'>        get {
</span><span class='line'>            return rooms[i]
</span><span class='line'>        }
</span><span class='line'>        set {
</span><span class='line'>            rooms[i] = newValue
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    func printNumberOfRooms() {
</span><span class='line'>        print("The number of rooms is \(numberOfRooms)")
</span><span class='line'>    }
</span><span class='line'>    var address: Address?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在<code>Residence</code>有了一个存储<code>Room</code>实例的数组，<code>numberOfRooms</code>属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code>属性简单地返回<code>Rooms</code>数组的count属性的值。。</p>

<p>residence还提供了rooms数组的快捷方式，即提供可读写的下标来访问<code>rooms</code>数组中指定位置的元素。</p>

<p>此外，<code>Residence</code>还提供了<code>printNUmberOfRooms()</code>方法，这个方法的作用是打印<code>numberOfRooms</code>的值。</p>

<p>最后，<code>Residence</code>还定义了一个可选属性<code>address</code>,其类型为<code>Address?</code>.Address类的定义在下面会说明。</p>

<p><code>Room</code>类是一个简单类，其实例被存储在<code>rooms</code>数组中。该类只包含一个属性<code>name</code>,以及一个用于将该属性设置为适当的房间名的初始化函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Room {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后一个类是<code>Address</code>,这个类有三个<code>String?</code>类型的可选属性，<code>buildingName</code>以及<code>buildingNuber</code>属性分别表示某个大厦的名称和号码，第三个属性<code>street</code>表示大厦所在街道的名称:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Address {
</span><span class='line'>    var buildingName: String?
</span><span class='line'>    var buildingNumber: String?
</span><span class='line'>    var street: String?
</span><span class='line'>    func buildingIdentifier() -&gt; String? {
</span><span class='line'>        if buildingName != nil {
</span><span class='line'>            return buildingName
</span><span class='line'>        } else if buildingNumber != nil && street != nil {
</span><span class='line'>            return "\(buildingNumber) \(street)"
</span><span class='line'>        } else {
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Address</code>类提供了<code>buildingIdentifier ()</code>方法，返回值为<code>String?</code>,如果<code>buildingName</code>有值则返回<code>buildingName</code>.或者，如果<code>buildingName</code>和<code>street</code>均有值则返回<code>buildingNumber</code>.否则，返回<code>nil</code>.</p>

<h2>通过可选链式访问属性</h2>

<p>下面的代码创建了一个<code>Person</code>实例，然后像志强一样，尝试访问<code>nubmerOfRooms</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let john = Person()
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>因为<code>john.residence</code>为<code>nil</code>,所以这个可选链式调用依旧会像先前一样失败.</p>

<p>还可以通过可选链式调用来设置属性的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someAddress = Address()
</span><span class='line'>someAddress.buildingNumber = "29"
</span><span class='line'>someAddress.street = "Acacia Road"
</span><span class='line'>john.residence?.address = someAddress</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，通过<code>john.residence</code>来设定<code>address</code>属性也会失败，因为<code>john.residence</code>当前为<code>nil</code>.</p>

<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的适应，但是它使用一个函数来创建<code>Address</code>实例，然后将该实例返回用于赋值。该函数会在返回前答应<code>Funcation was called</code>，这使你能验证等号右侧的代码是否被执行.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func createAddress() -&gt; Address {
</span><span class='line'>    print("Function was called.")
</span><span class='line'>
</span><span class='line'>    let someAddress = Address()
</span><span class='line'>    someAddress.buildingNumber = "29"
</span><span class='line'>    someAddress.street = "Acacia Road"
</span><span class='line'>
</span><span class='line'>    return someAddress
</span><span class='line'>}
</span><span class='line'>john.residence?.address = createAddress()</span></code></pre></td></tr></table></div></figure>


<p>没有答应任何消息，可以看出<code>createAddress()</code>函数并未被执行。</p>

<h2>通过可选链式调用方法</h2>

<p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值.</p>

<p><code>Residence</code>类中的<code>printNumberOfRooms()</code>方法打印当前的<code>numberOfRooms</code>值，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printNumberOfRooms() {
</span><span class='line'>    print("The number of rooms is \(numberOfRooms)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法没有返回值，然而，没有返回值的方法具有隐式的返回类型<code>Void</code>,这意味着没有返回值的方法也会返回<code>()</code>,或者或空的数组.</p>

<p>通过可选链式调用得到的返回值都是可选的。这样我们就可以使用<code>if</code>语句来判断是否成功调用<code>printNumberOfRooms()</code>方法，就是方法本身没有定义返回值，通过判断返回值是否为<code>nil</code>可以判断调用是否成功:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if john.residence?.printNumberOfRooms() != nil {
</span><span class='line'>    print("It was possible to print the number of rooms.")
</span><span class='line'>} else {
</span><span class='line'>    print("It was not possible to print the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “It was not possible to print the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>同样滴，可以据此判断通过可选链式调用为属性赋值是否成功，我们尝试给<code>john.residence</code>中的 address 属性赋值，即使<code>residence</code>为nil,通过可选链式调用给属性赋值会返回<code>Void?</code>,通过判断返回值是否为nil就可以知道赋值是否成功:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (john.residence?.address = someAddress) != nil {
</span><span class='line'>    print("It was possible to set the address.")
</span><span class='line'>} else {
</span><span class='line'>    print("It was not possible to set the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “It was not possible to set the address.”</span></code></pre></td></tr></table></div></figure>


<h2>通过可选链式调用访问下标</h2>

<p>通过可选链式的调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>

<blockquote><p><strong>注意</strong>
通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面，可选链式调用的问号一般直接跟在可选表达式的后面。</p></blockquote>

<p>下面这个例子用下标访问<code>john.residence</code>属性存储的<code>Residences</code>实例的<code>Rooms</code>数组中的第一个房间的名称，因为<code>john.residence</code>为<code>nil</code>,所以下标调用失败了.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    print("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the first room name.”</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在这个例子中，问号直接放在<code>john.residence</code>的后面，并且在方括号的前面，因为<code>john.residence</code>是可选值.</p>

<p>类似的，可以通过下标，用可选链式调用来赋值:</p>

<pre><code>john.residence?[0] = Room(name: "Bathroom")
</code></pre>

<p> 这样赋值同样会失败，因为<code>residence</code>目前是<code>nil</code>.</p>

<p> 如果你创建一个<code>Residence</code>实例，并未其<code>rooms</code>数组添加一些<code>Room</code>实例，然后将<code>Residence</code>实例赋值给<code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let johnsHouse = Residence()
</span><span class='line'>johnsHouse.rooms.append(Room(name: "Living Room"))
</span><span class='line'>johnsHouse.rooms.append(Room(name: "Kitchen"))
</span><span class='line'>john.residence = johnsHouse
</span><span class='line'>
</span><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    print("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// 打印 “The first room name is Living Room.”</span></code></pre></td></tr></table></div></figure>


<h2>访问可选类型的下标</h2>

<p>如果下标返回可选类型的值，比如Swift中<code>Dictionary</code>类型的键下标，可以在下标的结尾处放一个问号来在其可选值上进行可选链式调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
</span><span class='line'>testScores["Dave"]?[0] = 91
</span><span class='line'>testScores["Bev"]?[0]++
</span><span class='line'>testScores["Brian"]?[0] = 72
</span><span class='line'>// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中定义了一个<code>testScores</code>数组，包含了两个键值对，把String类型的键映射到一个<code>Int</code>值的数组。第三个键值不存在，故调用失败。</p>

<h2>连接多层可选链式的调用</h2>

<p>可以通过连接多个可选链式调用在更深的模型层级中访问属性，方法及下标，然而，多层可选链式调用不会增加返回值的可选层级。</p>

<p>也就是说：</p>

<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值</li>
<li>如果你返回的值就是可选的，可选链式调用不会让可选返回值变得'更可选'</li>
</ul>


<p>因此:</p>

<ul>
<li>通过可选链式调用访问一个<code>Int</code>值，将会返回<code>Int?</code>,无论使用了多少层可选链式调用</li>
<li>类似的，通过可选链式调用访问<code>Int?</code>值，依旧会返回<code>Int?</code>值，并不会返回<code>Int??</code></li>
</ul>


<p>下面的例子尝试访问<code>john</code>中的<code>residence</code>属性中的<code>address</code>属性中的street   属性，这里使用了两层可选链式调用，<code>residence</code>以及adress都是可选值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    print("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the address.”</span></code></pre></td></tr></table></div></figure>


<p>john.residence现在包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的值当前为nil.因此调用<code>john.residence?.adress?.street</code>会失败。</p>

<p>需要注意的是，上面的例子中,<code>street</code>的属性为<code>String?</code>.<code>john.residence?.address?.street</code>的返回值也依然是<code>String?</code>,即使已经使用了两层可选链式调用.</p>

<p>如果<code>john.residence.address</code>赋值一个<code>Address</code>实例，并且为<code>address</code>中的<code>street</code>属性设置一个有效值，我们就能通过可选链式调用来访问<code>street</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let johnsAddress = Address()
</span><span class='line'>johnsAddress.buildingName = "The Larches"
</span><span class='line'>johnsAddress.street = "Laurel Street"
</span><span class='line'>john.residence?.address = johnsAddress
</span><span class='line'>
</span><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    print("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's street name is Laurel Street.”</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子中，因为<code>john.residence</code>包含了一个有效的<code>Residence</code>实例，所以对<code>john.residence</code>的Address属性赋值将会成功。</p>

<h2>在方法的可选返回值上进行可选链式调用</h2>

<p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值，我们还可以在一个可选值上通过可选链式调用来调用方法，并且根据需要继续在方法的可选返回值上进行可选链式调用</p>

<p>在下面的例子中，通过可选链式调用<code>Address</code>的<code>buildingIdeneity()</code>方法，这个方法返回<code>String?</code>类型的值，如上所述，通过可选链式调用来调用该方法，最终的返回值依旧是 String?类型:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
</span><span class='line'>    print("John's building identifier is \(buildingIdentifier).")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's building identifier is The Larches.”</span></code></pre></td></tr></table></div></figure>


<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let beginsWithThe =
</span><span class='line'>    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
</span><span class='line'>        if beginsWithThe {
</span><span class='line'>            print("John's building identifier begins with \"The\".")
</span><span class='line'>        } else {
</span><span class='line'>            print("John's building identifier does not begin with \"The\".")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>// 打印 “John's building identifier begins with "The".”</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-自动引用计数]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/18/swift-zi-dong-yin-yong-ji-shu/"/>
    <updated>2016-03-18T11:17:07+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/18/swift-zi-dong-yin-yong-ji-shu</id>
    <content type="html"><![CDATA[<p>swift使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况，Swift内存管理机制会一直起作用，你无需自己来考虑内存的管理。ARC会在类的实例不再需要时，自动释放其占用的内存。
然后在少数的情况下，为了能帮助你管理内存，ARC需要更多的代码之间关系的信息。</p>

<!--more-->


<blockquote><p><strong>注意:</strong>
引用计数仅仅应用于类的实例。结构体和枚举类型是属于值类型，不是引用类型，也不是通过引用的方式存储和传递.</p></blockquote>

<h2>自动引用计数的工作机制</h2>

<p>当你每次创建一个类的新的实例的时候，arc会分配一块内存来存储该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的属性的值。
此外，当实例不在被使用时，ARC释放实例所占用的内存。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<p>然而，当ARC回收和释放了正在被使用中的实例，该实例的属性和方法将不再被访问和调用。实际上，如果你还试图访问这个实例，你的应用程序很可能会崩溃。</p>

<p>为了确保使用中的实例不会被销毁，ARC会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<p>为了使上述成为可能，无论你将实例赋值给属性，常量或者变量，他们都会
创建此实例的<code>强</code>引用,之所以称为强引用，是因为它会将实例牢牢地包吃住，只要强引用还在，实例是不允许被销毁的。</p>

<h2>自动引用计数实践</h2>

<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        print("\(name) is being initialized")
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Person类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值，并打印一个消息表明初始化过程生效。<code>Person</code>类也拥有一个析构函数，这个析构函数在实例被销毁时打印一条消息。</p>

<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，为新的<code>Person</code>实例建立了多个引用。由于这些变量是被定义为可选类型，它们的值会被自动初始化为nil,目前还不会引用到<code>Person</code>类的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var reference1: Person?
</span><span class='line'>var reference2: Person?
</span><span class='line'>var reference3: Person?</span></code></pre></td></tr></table></div></figure>


<p>现在创建Person类的实例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reference1 = Person(name: "John Appleseed")
</span><span class='line'>// prints "John Appleseed is being initialized”</span></code></pre></td></tr></table></div></figure>


<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，初始化的信息被打印出来。由此可以确定构造函数被执行。</p>

<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立一个强引用。正是因为这一个强引用，ARC会保证<code>Person</code>实例被保持在内存中不被销毁。</p>

<p>如果你将同一个<code>Person</code>实例也赋值给其它两个变量，该实例又会多出两个强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reference2 = reference1
</span><span class='line'>reference3 = reference1</span></code></pre></td></tr></table></div></figure>


<p>现在这个 <code>Person</code>实例有三个强引用了。</p>

<p>如果你通过给其中两个变量赋值<code>nil</code>的方式断开两个强引用，只留下一个强引用，<code>Person</code>实例也不会被销毁。</p>

<pre><code>reference1 = nil
reference2 = nil
</code></pre>

<p> 在你清楚地表明不再使用这个Person实例时，第三个也就是最后一个强引用被断开时，ARC会销毁它:</p>

<pre><code> reference3 = nil
// 打印 “John Appleseed is being deinitialized”
</code></pre>

<h2>类实例之间的循环强引用</h2>

<p>在上面的例子中，ARC会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>

<p>然而，我们可能会写出一个类实例的强引用永远不能变成0的代码。如果两个类实例互相拥有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的强引用。</p>

<p>你可以通过定义类之间的关系为弱引用或者无主引用，来避免强引用。不管怎样，让我们先来了解下它是如何产生的。</p>

<p>下面展示一个不经意产生循环强引用的例子。例子定义了两个类:<code>person</code>和<code>Apartment</code>,用来建模公寓和它其中的居民:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Apartment {
</span><span class='line'>    let unit: String
</span><span class='line'>    init(unit: String) { self.unit = unit }
</span><span class='line'>    var tenant: Person?
</span><span class='line'>    deinit { print("Apartment \(unit) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>每一个<code>Person</code>实例有一个类型为<code>String</code>,名字为<code>name</code>的属性，并有一个可选的初始化为nil的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>

<p>类似的，每个<code>Apartment</code>实例有个叫<code>unit</code>,类型为String的属性，并有一个可选的初始化为nil的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>

<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这能让你知道<code>Person</code>和<code>Apartment</code>的实例是否像预期那样被销毁。</p>

<p>接下来的代码片段中定义了两个可选类型的变量<code>john</code>和<code>unit4A</code>,并分别被设定为下面的的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为nil:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Person?
</span><span class='line'>var unit4A: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>unit4A = Apartment(unit: "4A")</span></code></pre></td></tr></table></div></figure>


<p>在两个实例被创建和赋值后，下面表现了强引用的关系。变量<code>john</code>现在有个指向<code>Person</code>实例的强引用，而变量<code>unit4A</code>有一个指向<code>Apartment</code>实例的强引用:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle01_2x.png" alt="logo" />
现在，你能够将两个实例关联在一起了，这样人就能有公寓住了，而工具也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>unit4A</code>中的实例，这样实例的属性才能被赋值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john!.apartment = unit4A
</span><span class='line'>unit4A!.tenant = john</span></code></pre></td></tr></table></div></figure>


<p>在将两个实例联系在一起后，强引用的关系如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle02_2x.png" alt="logo" /></p>

<p>不幸的是，这两个实例关联后会产生一个循环强引用，<code>Person</code>类现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>的强引用，因此，当你断开<code>john</code>和<code>uni4A</code>变量所持有的强引用时，引用计数并不会降到0.实例也不会被销毁。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>unit4A = nil</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意:</strong>当你把这两个变量设置为nil时，没有任何一个析构函数被调用，循环强引用会一直阻止<code>Person</code>和<code>Apartment</code>类实例被销毁，这既是你应用程序中造成的内存泄露。</p></blockquote>

<p>在你将<code>john</code>和<code>unit4A</code>设置为nil后，强应用关系如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle03_2x.png" alt="logo" /></p>

<p>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>

<h2>解决实例之间的循环强引用</h2>

<p>swift提供了两种方法用来解决在你使用类的属性时遇到的循环强引用的问题：弱引用(weak refrence)和无主引用(unowned refrecnce).</p>

<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不包吃强引用。这样实例能够互相引用而不产生循环强引用。</p>

<p>对于生命周期中会变成nil的实例使用弱引用。相反地，对于初始化赋值后再也不会给赋值为nil的实例，使用无主引用。</p>

<h3>弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止ARC销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>

<p>在实例的声明周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主易用。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有‘居民’的，因此适合使用弱引用来解决循环强引用。</p>

<blockquote><blockquote><p><em>注意</em>
弱引用必须被声明为变量，表明其值在运行时会被修改，若引用
不能被声明为常量。</p>

<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在Swift中，推荐使用可选类型描述可能没有值的类型。</p></blockquote></blockquote>

<p>因为弱引用不会曹植所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC会在引用的实例被销毁后自动将其赋值为nil.你可以像其他可选值一样，检查弱引用的值是否存在，你讲永远不会访问已销毁的实例的引用。</p>

<p>下面的例子跟上面 <code>person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>    属性被声明为弱引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Apartment {
</span><span class='line'>    let unit: String
</span><span class='line'>    init(unit: String) { self.unit = unit }
</span><span class='line'>    weak var tenant: Person?
</span><span class='line'>    deinit { print("Apartment \(unit) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后跟之前一样，建立两个变量(john和unit4A)之间的强引用，并关联两个实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Person?
</span><span class='line'>var unit4A: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>unit4A = Apartment(unit: "4A")
</span><span class='line'>
</span><span class='line'>john!.apartment = unit4A
</span><span class='line'>unit4A!.tenant = john</span></code></pre></td></tr></table></div></figure>


<p>现在，两个关联在一起的实例的引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference01_2x.png" alt="logo" /></p>

<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只持有对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference02_2x.png" alt="logo" /></p>

<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// 打印 “John Appleseed is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>唯一剩下指向<code>Apartment</code>实例的强引用来自变量<code>unit4A</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference03_2x.png" alt="logo" />
由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unit4A = nil
</span><span class='line'>// 打印 “Apartment 4A is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>上面的两段代码展示了变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出了“销毁”的信息。
这证明了引用循环被打破了。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型.你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code>表示这个一个无主引用。</p>

<p>由于无主引用是非可选类型，你不需要再使用它的时候将它展开。无主引用总是可以被直接访问。不过ARC无法再实例被销毁后将无主引用设为<code>nil</code>,因为非可选类型的变量不允许被赋值为<code>nil</code>.</p>

<blockquote><p><strong>注意:</strong>如果你试图在实例被销毁后，访问该实例的无主引用，会出发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。
还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>

<p>下面的例子定义两个类，<code>Customer</code>和<code>CrediCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p></blockquote>

<p><code>Customer</code>和<code>CrediCard</code>之间的关系与前面若引用例子中<code>Apartment</code>和<code>Person</code>的关系略为不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>Card</code>属性，但是<code>CreditCard</code>类有个一非可选类型的<code>Customer</code>属性。</p>

<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联.</p>

<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Customer {
</span><span class='line'>    let name: String
</span><span class='line'>    var card: CreditCard?
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CreditCard {
</span><span class='line'>    let number: UInt64
</span><span class='line'>    unowned let customer: Customer
</span><span class='line'>    init(number: UInt64, customer: Customer) {
</span><span class='line'>        self.number = number
</span><span class='line'>        self.customer = customer
</span><span class='line'>    }
</span><span class='line'>    deinit { print("Card #\(number) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面的代码段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Customer?</span></code></pre></td></tr></table></div></figure>


<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = Customer(name: "John Appleseed")
</span><span class='line'>john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)</span></code></pre></td></tr></table></div></figure>


<p>在你关联两个实例后，它们的引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/unownedReference01_2x.png" alt="logo" /></p>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。
由于<code>Customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/unownedReference02_2x.png" alt="logo" /></p>

<p>由于再也没有指向<code>Customer</code>实例的强引用了，该实例被销毁了，其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// 打印 “John Appleseed is being deinitialized”
</span><span class='line'>// 打印 ”Card #1234567890123456 is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了"销毁"的信息.</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。
<code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>,并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>,而另一个属性的值不允许为<code>nil</code>,这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p>然而，存在着第三种场景，在这种场景下，两个属性都必须有值，并且初始化完成永远不会为<code>nil</code>.在这种场景下，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>这使两个属性在初始化完成后能被直接访问,同时避免了循环了引用。</p>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>Country</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Country {
</span><span class='line'>    let name: String
</span><span class='line'>    var capitalCity: City!
</span><span class='line'>    init(name: String, capitalName: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.capitalCity = City(name: capitalName, country: self)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class City {
</span><span class='line'>    let name: String
</span><span class='line'>    unowned let country: Country
</span><span class='line'>    init(name: String, country: Country) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.country = country
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了建了两个类的依赖关系，<code>City</code>的构造函数接受一个<code>Country</code>实例作为参数，并且将实例保存到<code>country</code>属性。</p>

<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。</p>

<p>为了满足这种需求，通过在类型结尾处加上感叹号 （City!） 的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>,但是不需要展开它的值就能访问它.</p>

<p>由于<code>capitalCity</code>默认值是nil,一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这意味着一旦<code>name</code>属性被赋值后，<code>Country</code>的构造函数就能引用并传递隐式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>

<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var country = Country(name: "Canada", capitalName: "Ottawa")
</span><span class='line'>print("\(country.name)'s capital city is called \(country.capitalCity.name)")
</span><span class='line'>// 打印 “Canada's capital city is called Ottawa”</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子中，使用隐式可选值意味着满足了类的构造函数的两个构造阶段的要求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>

<h2>闭包引起的循环强引用</h2>

<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些强引用。</p>

<p>循环强引用还会发生在你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>,或者闭包中调用了实例的某个方法，例如：<code>self.someMethod()</code>,这两种情况都会导致闭包'捕获'self,从而产生循环强引用。</p>

<p>循环强引用的产生，是闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性，实质上，这跟之前的问题是一样的，两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>

<p>Swift提供了一种优雅的方法来解决这个问题，称之为<code>闭包捕获列表</code>.同样地，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的。</p>

<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个<code>HtmlElement</code>的类，用一种简单的模型表示HTML文档中一个单独的元素:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>
</span><span class='line'>    lazy var asHTML: Void -&gt; String = {
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名字，例如代表段落的<code>p</code>,或者代表换行的<code>br</code>,<code>HTMLElement</code>还定义了一个可选属性<code>text</code>,用来设置HTML元素呈现的文本。</p>

<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个lazy属性<code>asHtml</code>,这个属性引用了一个将<code>name</code>和<code>text</code>组合成html字符串片段的闭包。该属性是<code>Void-&gt;String</code>类型，或者理解为'一个没有参数，返回<code>String</code>的函数'。</p>

<p>默认情况下，闭包赋值给了<code>asHtml</code>属性，这个闭包返回一个代表HTml标签的字符串。如果<code>text</code>值存在，该标签就包含<code>text</code>;如果不包含<code>text</code>,该标签就不包含文本，对于段落元素，根据<code>text</code>是否有值，闭包会返回<code>"&lt;p&gt;some text&lt;/p&gt;"</code>或者<code>"&lt;p /&gt;"</code></p>

<p>可以像实例方法那样去命名，使用<code>asHtml</code>属性。然而，由于<code>asHtml</code>是闭包而不是实例方法，如果你想改变特定html元素处理方式的话，可以使用自定义闭包来取代默认值。</p>

<p>例如，可以将一个闭包赋值给<code>asHtml</code> 属性，这个闭包能在<code>text</code>属性是<code>nil</code>时使用默认文本，这是为了避免返回一个空的HTML标签:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let heading = HTMLElement(name: "h1")
</span><span class='line'>let defaultText = "some default text"
</span><span class='line'>heading.asHTML = {
</span><span class='line'>    return "&lt;\(heading.name)&gt;\(heading.text ?? defaultText)&lt;/\(heading.name)&gt;"
</span><span class='line'>}
</span><span class='line'>print(heading.asHTML())
</span><span class='line'>// 打印 “&lt;h1&gt;some default text&lt;/h1&gt;”</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong>
asHtml声明为lazy属性，因为只有当元素确实需要被处理为HTML输出的字符串时，才需要使用<code>asHTML</code>.也就是说，在默认的闭包中可以使用<code>self</code>,
因为只有初始化完成以及<code>self</code>确实存在后，才能访问lazy属性。</p></blockquote>

<p>HTMLElement类只提供了构造函数，通过<code>name</code>和<code>text</code>参数来初始化一个新元素，该类也定义了一个析构函数，当 <code>HTMLElement</code>被销毁时，打印一条消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>print(paragraph!.asHTML())
</span><span class='line'>// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong>
上面的paragraph是可选类型，因此我们可以赋值<code>nil</code>来演示循环强引用</p></blockquote>

<p>不幸的是，上面写的 <code>HTMLElement</code>类产生了类实例和作为<code>asHtml</code>默认是和闭包之间产生了循环强引用，循环强引用如下图所示:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/closureReferenceCycle01_2x.png" alt="lgoo" /></p>

<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其体内使用了<code>self</code>(引用了<code>self.name</code>和<code>self.text</code>),因此捕获了<code>self</code>,这意味着闭包又反过来持有了<code>HtmlElement</code>实例的强引用。这样两个对象就产生了循环强引用。</p>

<blockquote><p><strong>注意</strong>
随让闭包多次使用了<code>self</code>,它只捕获<code>HTMLElemnt</code>实例的一个强引用。</p></blockquote>

<p>如果设置<code>paragraph</code>变量为<code>nil</code>,打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMlElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>

<pre><code>paragraph = nil
</code></pre>

<p>注意,<code>HTMLElement</code>的析构函数并没有被打印，证明了 <code>HTMLElement</code>实例并没有被销毁.</p>

<h2>解决闭包引起的循环强引用</h2>

<p>在定义闭包时同事定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类之间的循环强引用。捕获列表定义了闭包体内捕获了一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>

<blockquote><p><strong>注意</strong>
Swift有如下要求:只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod()</code>,（而不只是<code>someProperty,someMethod()</code>）,这提醒你可能会一不小心就捕获了<code>self</code></p></blockquote>

<h3>定义捕获列表</h3>

<p>捕获列表中的每一项都由一对元素组成，一个元素是<code>weak</code>或者<code>unowned</code>关键字，另一个元素是类实例的引用(例如self)或初始化过的变量(如 delegate=self.delegate!)</p>

<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var someClosure: (Int, String) -&gt; String = {
</span><span class='line'>    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
</span><span class='line'>    // 这里是闭包的函数体
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文判断，那么可以把捕获列表和关键字 <code>in</code>放在闭包最开始的地方:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var someClosure: Void -&gt; String = {
</span><span class='line'>    [unowned self, weak delegate = self.delegate!] in
</span><span class='line'>    // 这里是闭包的函数体
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>.</p>

<p>相反的，在被捕获的引用可能会变成<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>.弱引用总是可选类型，并且当引用的类型被销毁后，弱引用的值会自动设置为<code>nil</code>.这使我们可以在闭包体内简单它们是否存在.</p>

<blockquote><p><strong>注意</strong>
如果被捕获的引用绝对不会变成<code>nil</code>,应该用无主引用，而不是弱引用</p></blockquote>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法，这样编写<code>HTMlElement</code>来避免循环强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>
</span><span class='line'>    lazy var asHTML: Void -&gt; String = {
</span><span class='line'>        [unowned self] in
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的<code>HTMLElement</code>实现和之前的实现一致，除了在<code>asHTML</code>闭包中多了一个捕获列表。这里捕获列表是<code>[unowded self]</code>,表示将<code>self</code>捕获为无主引用而不是强引用.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>print(paragraph!.asHTML())
</span><span class='line'>// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></code></pre></td></tr></table></div></figure>


<p>使用捕获列表后引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/closureReferenceCycle02_2x.png" alt="logo" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>,并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为nil,<code>HTMLElement</code>实例将会被销毁，并能看到析构函数打印出消息;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>paragraph = nil
</span><span class='line'>// 打印 “p is being deinitialized”</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何用cocoaPod发布框架]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/15/ru-he-yong-cocoapodfa-bu-kuang-jia/"/>
    <updated>2016-03-15T14:54:27+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/15/ru-he-yong-cocoapodfa-bu-kuang-jia</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="https://cocoapods.org/">cocoapods</a>是一款强大的框架依赖构建的工具，类似于java中的maven,可以快速搭建你项目中需要的框架，并且它可以自动帮你关联好第三方库之间的依赖关系， 这个很像ubuntu下的apt安装软件，自动帮你下载需要的依赖。</p>

<!--more-->


<p>使用cocoapod可以轻松的创建框架，发布到github上，可以让全世界的开发者下载到你的框架，并且使用，如果能为全世界的开源社区做点贡献，也是一件非常兴奋的事情。</p>

<p>开发静态库有两种方法:</p>

<h2>手动创建框架</h2>

<p>手动创建比较繁琐，而且容易出现问题，大致步骤如下:</p>

<ol>
<li>在xcode中创建一个 <code>Cocoa Touch Static Library</code></li>
<li>创建 <code>Podfile</code>文件</li>
<li>执行 <code>pod install</code>完成整个项目的构建</li>
<li>如果需要demo,手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行 <code>pod install</code>来完成框架的构建</li>
</ol>


<h2>使用Pod创建框架</h2>

<p><code>要求你系统中安装的cocoapod的版本&gt;0.3</code>
电脑环境:</p>

<ol>
<li>OS X ElCapitan 10.11.1</li>
<li>cocoapod 0.39</li>
<li>xcode 7.2</li>
<li>ruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15]</li>
<li>Homebrew 0.9.5 (no git repository)</li>
</ol>


<p>可以通过pod官网提供的命令来创建，让我们快速开始:</p>

<pre><code>pod lib create podLib-Andrew
</code></pre>

<p>这行命令会自动从pod官网的仓库中下载模板
然后它会问你几个问题</p>

<ol>
<li>What language do you want to use?? [ ObjC / Swift ] =>看你需要</li>
<li>Would you like to include a demo application with your library? [ Yes / No ]=>是否包含一个demo，我一般Yes</li>
<li>Which testing frameworks will you use? [ Specta / Kiwi / None ] =>是否需要包含一个测试框架</li>
<li>Would you like to do view based testing? [ Yes / No ]</li>
<li>What is your class prefix? =>类的前缀是什么</li>
</ol>


<p>执行成功之后，会自动用xcode打开工程，如果你的pod版本太新，比如1.0beta版本，可能不会自动创建workspace工作目录，这是由于pod1.0有些语法变了，你要相应的更改Podfile文件中的语法，具体参考官方最新的语法。</p>

<p>最终生成的目录结构如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-0.png" alt="logo" /></p>

<ol>
<li>Example 你的实例代码文件夹</li>
<li>.travis.yml -持续集成的配置文件 <a href="https://travis-ci.org/">travis-ci</a></li>
<li>_Pods.xcproject 工程的一个连接，类似快捷方式</li>
<li>LICENSE 默认是 <a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a></li>
<li>README.md 描述文件</li>
<li>pod 你存储源代码的地方</li>
</ol>


<h2>设置你的框架</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/xcode.png" alt="logo" /></p>

<p>让我们看打开后的工程目录</p>

<ol>
<li>你可以编辑Podspec metadata，包括里面的版本号和介绍等</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#
</span><span class='line'># Be sure to run `pod lib lint podLib-Andrew.podspec' to ensure this is a
</span><span class='line'># valid spec before submitting.
</span><span class='line'>#
</span><span class='line'># Any lines starting with a # are optional, but their use is encouraged
</span><span class='line'># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
</span><span class='line'>#
</span><span class='line'>
</span><span class='line'>Pod::Spec.new do |s|
</span><span class='line'>  s.name             = "podLib-Andrew"
</span><span class='line'>  s.version          = "0.0.1"
</span><span class='line'>  s.summary          = "这是我的第一个框架，希望能够帮到你"
</span><span class='line'>
</span><span class='line'># This description is used to generate tags and improve search results.
</span><span class='line'>#   * Think: What does it do? Why did you write it? What is the focus?
</span><span class='line'>#   * Try to keep it short, snappy and to the point.
</span><span class='line'>#   * Write the description between the DESC delimiters below.
</span><span class='line'>#   * Finally, don't worry about the indent, CocoaPods strips it!  
</span><span class='line'>  s.description      = &lt;&lt;-DESC
</span><span class='line'>                        "这是我的第一个框架，希望能够帮到你"
</span><span class='line'>                       DESC
</span><span class='line'>
</span><span class='line'>  s.homepage         = "https://github.com/andrew-anlu/podLib-Andrew"
</span><span class='line'>  # s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"
</span><span class='line'>  s.license          = 'MIT'
</span><span class='line'>  s.author           = { "Andrew" =&gt; "anluanlu123@163.com" }
</span><span class='line'>  s.source           = { :git =&gt; "https://github.com/andrew-anlu/podLib-Andrew.git", :tag =&gt; s.version.to_s }
</span><span class='line'>  # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'
</span><span class='line'>
</span><span class='line'>  s.platform     = :ios, '7.0'
</span><span class='line'>  s.requires_arc = true
</span><span class='line'>
</span><span class='line'>  s.source_files = 'Pod/Classes/**/*'
</span><span class='line'>  s.resource_bundles = {
</span><span class='line'>    'podLib-Andrew' =&gt; ['Pod/Assets/*.png']
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  # s.public_header_files = 'Pod/Classes/**/*.h'
</span><span class='line'>  # s.frameworks = 'UIKit', 'MapKit'
</span><span class='line'>  # s.dependency 'AFNetworking', '~&gt; 2.3'
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>s.name是我们库的名称</li>
<li>s.version是库原代码版本号</li>
<li>s.summary是对我们库的一个简单的介绍</li>
<li>s.homepage声明库的主页</li>
<li>s.license是所采用的授权版本</li>
<li>s.author是库的作者</li>
<li>s.platform是我们库所支持的软件平台，这在我们最后提交进行编译 时有用</li>
<li>s.source声明原代码的地址.</li>
</ul>


<p>按照默认配置，类库的源文件将位于Pod/Classes文件夹下，资源文件位于Pod/Assets文件夹下，可以修改s.source_files和s.resource_bundles来更换存放目录。s.public_header_files用来指定头文件的搜索位置。
s.frameworks和s.libraries指定依赖的SDK中的framework和类库，需要注意，依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成.a或.framework时才能让其他项目正常使用.</p>

<h2>建立远程版本库</h2>

<p>现在让我们去github上建立一个仓库，名字和工程的名字保持一致<code>podLib-Andrew</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-1.png" alt="pic" /></p>

<p>切换到终端，进入刚才的工程的根目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加到本地
</span><span class='line'>git add . 
</span><span class='line'>
</span><span class='line'>//提交到本地仓库
</span><span class='line'>git commit -m "initial commit"
</span><span class='line'>
</span><span class='line'>//和远程仓库建立关联关系
</span><span class='line'>git remote add origin git@github.com:andrew-anlu/podLib-Andrew.git
</span><span class='line'>
</span><span class='line'>//执行更细远程仓库的数据
</span><span class='line'>git pull origin master
</span><span class='line'>
</span><span class='line'>//重新执行添加
</span><span class='line'>git add .
</span><span class='line'>
</span><span class='line'>git commit -m "commit"
</span><span class='line'>
</span><span class='line'>//提交代码到远程仓库
</span><span class='line'>git push origin master
</span></code></pre></td></tr></table></div></figure>


<h2>编写源代码</h2>

<p>在Pod的classes文件夹中新建一个类 <code>StringUtils</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-2.png" alt="logo" /></p>

<p>StringUtils.h</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>
</span><span class='line'>@interface StringUtils : NSObject
</span><span class='line'>+(void)sayHello;
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>StringUtils.m</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "StringUtils.h"
</span><span class='line'>
</span><span class='line'>@implementation StringUtils
</span><span class='line'>+(void)sayHello{
</span><span class='line'>    NSLog(@"Hello world");
</span><span class='line'>}
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>注意源代码的存放位置一定要和 .podspec中的 s.source 路径要一致，不然不会起作用的。
运行 <code>pod install</code>,也许你也注意到了，每次添加或者修改类，或者添加图片等操作，都要执行 <code>pod install</code>或者<code>pod update</code>来更新应用。</p>

<blockquote><p><em>注意</em>
如果是生成swift功能，在Podfile文件中一定要有 <code>use_frameworks!</code> ，这行命令是指定框框是动态框架，因为swift要求要么依赖全部是动态框架，要么全部不是，所以如果注释掉，会报编译报错；</p>

<p>另外，swift工程中的源文件，如果想让外部调用的话，一定要声明成<strong><code>public</code></strong>,
这一点很重要。</p></blockquote>

<h3>Note</h3>

<p>添加完源代码之后，如果要在demo工程中引用，发现是引用不到的，原因就是你必须要把类库加入到demo工程中才行，默认在Podfile文件中生成的类库是动态类库，即 .framework的。
我尝试了好久，一直引用不了，于是就改成生成.a静态库的方式，完美引用。</p>

<p>修改成.a类库的方法就是在 Podfile中，把<code>#use_frameworks!</code> 注释掉就行了，这行代码默认就是生成动态类库的。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160317-0.png" alt="logo" /></p>

<h3>加入持续集成(Travis CI)</h3>

<p>这个模板包含了一个 <code>.travis.yml</code>文件，加入你在Github上开关了你的框架，打开 <a href="https://travis-ci.org/">travis-ci官网</a>，并且用github账号登录并且同步，打开你要开源的项目，设置 on</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/travi.png" alt="lgogo" /></p>

<h3>提交本地代码库</h3>

<p>修改podLib-Andrew.podspec 中的 <code>s.source</code>,</p>

<pre><code>  s.source           = { :git =&gt; "https://github.com/andrew-anlu/podLib-Andrew.git", :tag =&gt; s.version.to_s }
</code></pre>

<p>提交代码，并要打上tag</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m "commit v0.0.1"
</span><span class='line'>git tag 0.0.1
</span><span class='line'>git tag -a 0.0.1 -m "v0.0.1"</span></code></pre></td></tr></table></div></figure>


<h3>验证类库</h3>

<p>开发完静态类库之后，需要运行 <code>pod lib lint</code>验证一下类库是否符合 pod的要求。<code>pod spec lint</code>也是用来验证是否有效，区别在于</p>

<ol>
<li>pod lib lint  不访问网络，只在本地验证</li>
<li>pod spec lint 检查远程仓库和远程的tag</li>
</ol>


<p>pod官方推荐用<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk">trunk</a>来发布框架，<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk">trunk入门</a></p>

<p>假如你只想发布一个私人的框架，请看这个教程 <a href="https://guides.cocoapods.org/making/private-cocoapods">Private Specs Repos</a>,如果你想发布一个已经存在的私有框架，可以用下面的命令</p>

<pre><code>pod repo push SPEC_REPO *.podspec --verbose
</code></pre>

<h2>发布框架</h2>

<pre><code>pod trunk push podLib-Andrew.podspec
</code></pre>

<p>如果发布成功，执行 <code>pod search podLib</code>
就会搜到你的框架</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-4.png" alt="logo" /></p>

<h1>Done</h1>

<p>👍</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[闭包-swift]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/11/bi-bao-swift/"/>
    <updated>2016-03-11T16:48:06+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/11/bi-bao-swift</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。swift中的闭包与oc中的代码块(block)比较相似</p>

<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭包并包括着着这些常量和变量，俗称闭包。
swift会为您管理在捕获过程中涉及到所有内存操作。</p>

<!--more-->


<p>闭包采用如下三种形式之一</p>

<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中常量或变量值的匿名闭包</li>
</ol>


<p>swift的闭包表达式拥有简介的风格，并鼓励在常见场景下进行语法优化，主要优化如下:</p>

<ol>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略 return 关键字</li>
<li>参数名称缩写</li>
<li>尾随(Trailing)闭包语法</li>
</ol>


<h2>闭包表达式(Closure Expressions)</h2>

<p>嵌套函数是一个在较复杂函数中方便进行命名和定义字包含代码模块的方式。当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>

<p>闭包表达式是一种利用简介语法构建内联闭包的方式。闭包表达式提供一些语法优化，使得撰写闭包变得简单明了。下面的闭包表达式的例子通过使用几次迭代展示了 <code>sort(_:)</code>方法定义和语法优化的方式。
每一次迭代都用更简洁的方式描述了相同的功能。</p>

<h3>sort方法(The Sort Method)</h3>

<p>Swift标准库提供了名为<code>sort</code>的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序排序完成，<code>sort(_:)</code>方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被<code>sort(_:)</code>方法修改。</p>

<p>下面的闭包表达式示例使用<code>sort(_:)</code>方法对一个<code>String</code>类型数组进行字母逆序排序，以下是初始数组值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]</span></code></pre></td></tr></table></div></figure>


<p><code>sort(_:)</code>方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型的值表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回 true,反之返回false。</p>

<p>该例子对一个 <code>String</code>类型的数组进行排序，因此排序闭包函数类型需为(String,String)->Bool.
提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort(_:)</code>方法的参数传入:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func backwards(s1: String, s2: String) -&gt; Bool {
</span><span class='line'>    return s1 &gt; s2
</span><span class='line'>}
</span><span class='line'>var reversed = names.sort(backwards)
</span><span class='line'>// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></code></pre></td></tr></table></div></figure>


<p>如果第一个字符串(s1)大于第二个字符串(s2)，<code>backwards(_:_:)</code>函数返回<code>true</code>,表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。</p>

<h3>闭包表达式语法(Closure Expression Syntax)</h3>

<p>闭包表达式语法有如下一般形式:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{(parameters) -&gt; return type in
</span><span class='line'>  statements
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>闭包表达式语法可以使用常量，变量和<code>inout</code>类型作为参数，不能提供默认值。也可以在参数列表的最后使用可变参数。
元组也可以作为参数和返回值.</p>

<p>下面的例子展示了之前 <code>backwards(_:_:)</code>函数对应的闭包表达式版本的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = names.sort({ (s1:String , s2:String) -&gt; Bool in 
</span><span class='line'>  return s1 &gt; s2
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards(_:_:)</code>函数类型声明相同。在这两种方式中，都写成了(s1:String,s2:String) - >Bool.然而在内联闭包表达式中，函数和返回值类型都卸载大括号内，而不是大括号外。</p>

<p>闭包的函数体部分由关键字  in 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>

<p>由于这个闭包函数体部分如此短，以至于可以将其改写成一行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = names.sort({(s1:String,s2:String)-&gt;Bool in 
</span><span class='line'>  return s1&gt;s2
</span><span class='line'>  })</span></code></pre></td></tr></table></div></figure>


<p>该例中<code>sort(_:)</code>方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然后，参数现在变成了内联闭包。</p>

<h3>根据上下文推断类型(Inferring Type from Context)</h3>

<p>因为排序闭包函数是作为<code>sort(_:)</code>方法的参数传入的，swift可以推断其参数和返回值类型。<code>sort(_:)</code>方法被一个字符串数组调用，因此其参数必须是(String,String)->Bool类型的函数。这意味着(String,String)和Bool类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头(->)和围绕在参数周围的括号也可以被省略:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reversed = names.sort({s1,s2 in return s1 &gt; s2})</span></code></pre></td></tr></table></div></figure>


<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数活方法时，都可以推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。</p>

<p>尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能提高代码的可读性，则可以采用完整格式的闭包。而在<code>sort(_:)</code>方法这个例子里，闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>

<h3>单表达式闭包隐式返回</h3>

<p>单行表达式闭包可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写成:</p>

<pre><code>reversed=names.sort({s1,s2 in s1 &gt; s2})
</code></pre>

<p>在这个例子中，<code>sort(_:)</code>方法的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型之。因为闭包函数体只包含了一个单一表达式(<code>s1&gt;s2</code>),改表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略</p>

<h3>函数名称缩写</h3>

<p>swift自动为内联闭包提供了参数名称缩写功能，您可以额直接通过<code>$0,$1,$2</code>来顺序调用闭包参数，以此类推。
如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行判断。<code>in</code>关键字同样可以被省略额，因为此时闭包表达式完全有闭包函数体构成：</p>

<pre><code>reveserd = names.sort({$0 &gt; $1})
</code></pre>

<p>在这个例子中，$0和$1表示闭包中第一个和第二个<code>String</code>类型的参数。</p>

<h3>运算符函数(OPerator Functions)</h3>

<p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。Swift的<code>String</code>类型定了关于大于号(>)的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sort(_:)</code>方法的第二个参数需要的函数类型相符合。因此，您可以简单传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：</p>

<pre><code>reversed = names.sort(&gt;)
</code></pre>

<h2>尾随闭包(Trailing Closures)</h2>

<p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的彼表表达式，函数支持将其作为最后一个参数调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunctionThatTakesAClosure(closure: () -&gt; Void){
</span><span class='line'>     //函数体部分
</span><span class='line'>  }
</span><span class='line'>  // 以下是不使用尾随闭包进行函数调用
</span><span class='line'>  someFunctionThatTakesAClosure({
</span><span class='line'>    // 闭包主体部分
</span><span class='line'>  })
</span><span class='line'>
</span><span class='line'>  // 以下是使用尾随闭包进行函数调用
</span><span class='line'> someFunctionThatTakesAClosure() {
</span><span class='line'>     // 闭包主体部分
</span><span class='line'> }</span></code></pre></td></tr></table></div></figure>


<p>上面的sort排序可以改为:</p>

<pre><code>reversed = names.sort(){$0 &gt; $1}
</code></pre>

<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以吧()省略掉</p>

<pre><code>reversed = names.sort { $0 &gt; $1}
</code></pre>

<p>当闭包非常长以至于不能再一行中进行书写时，尾随闭包变得非常有用。举例来说，swift的<code>array</code>类型有一个<code>map(_:)</code>方法，其获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>

<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code>方法将返回一个新的数组，数组中包含了原数组中的元素-对应的映射后的值</p>

<p>下例介绍了如何在<code>map(_:)</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16,58,510]</code>转换为包含对应<code>String</code>类型的值的数组<code>["OneSix", "FiveEight", "FiveOneZero"]</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let digitNames = [
</span><span class='line'>    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
</span><span class='line'>    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
</span><span class='line'>]
</span><span class='line'>let numbers = [16, 58, 510]</span></code></pre></td></tr></table></div></figure>


<p>如上代码创建了一个数字位和它们英文版名字想映射的字典。同时还定义了一个准备转换为字符串数组的整形数组。
您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map(_:)</code>方法来创建对应的字符串版本数组:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let strings = numbers.map {
</span><span class='line'>    (var number) -&gt; String in
</span><span class='line'>    var output = ""
</span><span class='line'>    while number &gt; 0 {
</span><span class='line'>        output = digitNames[number % 10]! + output
</span><span class='line'>        number /= 10
</span><span class='line'>    }
</span><span class='line'>    return output
</span><span class='line'>}
</span><span class='line'>// strings 常量被推断为字符串类型数组，即 [String]
</span><span class='line'>// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]</span></code></pre></td></tr></table></div></figure>


<p><code>map(_:)</code>为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行判断。</p>

<p>在该例子中，闭包<code>number</code>参数被声明为一个变量参数，因此可以在闭包函数体内对齐进行修改，而不用再定义一个新的局部变量并将<code>number</code>的值赋值给它。闭包表达式指定了返回类型为String,以表明存储映射值的新数组类型为<code>String</code>.</p>

<p>闭包表达式在每次被调用的时候创建了一个叫做<code>output</code>的字符串并返回。</p>

<h3>捕获值(Capturing Values)</h3>

<p>闭包可以在其被定义的上下文中捕获常量或变量。及时定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>

<p>Swift中，可以捕获值的彼表的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数一级定义的常量和变量。</p>

<p>举个例子，这有一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>的嵌套函数。嵌套函数<code>incrementor()</code>从上下文中捕获了两个值，<code>reunningTotal</code>和<code>amount</code>。捕获这些值之后，<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。每次调用<code>incrementor</code>时，其会以<code>amout</code>作为增量增加<code>runningTotal</code>的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
</span><span class='line'>    var runningTotal = 0
</span><span class='line'>    func incrementor() -&gt; Int {
</span><span class='line'>        runningTotal += amount
</span><span class='line'>        return runningTotal
</span><span class='line'>    }
</span><span class='line'>    return incrementor
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>makeIncrementor</code>返回类型为<code>()-&gt;Int</code>.这意味着其返回一个函数，而不是一个简单类型的值。该函数在每次调用时不接受参数，值返回一个<code>Int</code>类型的值。
<code>makeIncrementer(forIncrement:)</code>函数定义了一个初始值为0的整形变量<code>runningTotal</code>，用来存储当前跑步总数。该值通过<code>incrementor</code>返回。</p>

<p><code>makeIncrementor(forIncrement:)</code>有一个<code>Int</code>类型的参数，其外部参数名为<code>forIncrement</code>,内部参数名为<code>amount</code>,该参数表示每次<code>incrementor</code>被调用时<code>runingTotal</code>将要增加的量。</p>

<p>嵌套函数<code>increment</code>用来执行实际的增加操作。该函数简单滴使用<code>runningTotal</code>增加<code>amount</code>，并将其返回。
如果我们单独看这个函数，会发现看上去不同寻常:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func incrementor() -&gt; Int {
</span><span class='line'>    runningTotal += amount
</span><span class='line'>    return runningTotal
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><code>incrementer()</code>函数并没有任何参数，但是在函数体访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为它从外围函数捕获了<code>runninTotal</code>和<code>amount</code>变量的引用。捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>

<p>下面是一个使用<code>makeIncrementor</code>的例子:</p>

<pre><code>let incrementByTen = makeIncrementor(forIncrement: 10)
</code></pre>

<p>该例子定义了一个叫做 <code>incrementByTen</code>的常量，该常量指向一个每次调用会将<code>runningTotal</code>变量增加10的 <code>incrementor</code>函数。调用这个函数多次可以得到如下结果:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>incrementByTen()
</span><span class='line'>// 返回的值为10
</span><span class='line'>incrementByTen()
</span><span class='line'>// 返回的值为20
</span><span class='line'>incrementByTen()
</span><span class='line'>// 返回的值为30</span></code></pre></td></tr></table></div></figure>


<p>如果您蒋欢了另一个<code>incrementor</code>，它会有属于它自己的一个全新的，独立的<code>runnintTotal</code>变量的引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let incrementBySeven = makeIncrementor(forIncrement: 7)
</span><span class='line'>incrementBySeven()
</span><span class='line'>// 返回的值为7</span></code></pre></td></tr></table></div></figure>


<p>再次调用原来的<code>incrementByTen</code>会在原来的变量<code>runningTotal</code>上继续增加值,该变量和<code>incrementBySeven</code>中捕获的变量没有任何联系:</p>

<pre><code>incrementByTen()
// 返回的值为40  
</code></pre>

<h2>闭包是引用类型</h2>

<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p>

<p>无论您将函数或闭包赋值一个常量还是变量，您实际上都是将常量或者变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用<code>incrementByTen</code>是一个常量，而并非闭包内容本身。</p>

<p>这也意味着如果您将闭包赋值给两个不同的常量或变量，两个值都会指向同一个闭包:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let alsoIncrementByTen = incrementByTen
</span><span class='line'>alsoIncrementByTen()
</span><span class='line'>// 返回的值为50</span></code></pre></td></tr></table></div></figure>


<h2>非逃逸闭包(Nonescaping Closures)</h2>

<p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注<code>@noescape</code>,用来指明这个闭包是不允许"逃逸"出这个函数的。将闭包标注<code>@noescape</code>能使编译器知道这个闭包的生命周期,从而可以进行一些比较激进的优化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunctionWithNoescapeClosure(@noescape closure: () -&gt; Void) {
</span><span class='line'>    closure()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>举个例子,<code>sort(_:)</code>方法接受一个用来进行元素比较的闭包作为参数。这个参数被标注了<code>@noescape</code>，因为它确保自己在排序结束之后就没用了。</p>

<p>一种能使闭包'逃逸'
出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多异步操作的函数接受一个闭包参数作为 completion handler.这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var completionHandlers: [() -&gt; Void] = []
</span><span class='line'>func someFunctionWithEscapingClosure(completionHandler: () -&gt; Void) {
</span><span class='line'>    completionHandlers.append(completionHandler)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>someFunctionWithEscapingClosure(_:)</code>函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你视图将这个参数标注为<code>@noescape</code>，你将会得到一个编译错误。</p>

<p>将闭包标注为<code>@noescape</code>使你能在闭包中隐式地引用<code>self</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeClass {
</span><span class='line'>    var x = 10
</span><span class='line'>    func doSomething() {
</span><span class='line'>        someFunctionWithEscapingClosure { self.x = 100 }
</span><span class='line'>        someFunctionWithNoescapeClosure { x = 200 }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let instance = SomeClass()
</span><span class='line'>instance.doSomething()
</span><span class='line'>print(instance.x)
</span><span class='line'>// prints "200"
</span><span class='line'>
</span><span class='line'>completionHandlers.first?()
</span><span class='line'>print(instance.x)
</span><span class='line'>// prints "100</span></code></pre></td></tr></table></div></figure>


<h2>自动闭包(Autoclosures)</h2>

<p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的花括号。</p>

<p>自动闭包让你能够延时求值，因为代码段不会被执行直到你显式的调用这个闭包。延迟求值对于那些有副作用和代价昂贵的代码来说是很有益处的，因为你能控制代码什么时候执行。下面的代码展示了闭包如何延时求值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
</span><span class='line'>print(customersInLine.count)
</span><span class='line'>// prints "5"
</span><span class='line'>
</span><span class='line'>let customerProvider = { customersInLine.removeAtIndex(0) }
</span><span class='line'>print(customersInLine.count)
</span><span class='line'>// prints "5"
</span><span class='line'>
</span><span class='line'>print("Now serving \(customerProvider())!")
</span><span class='line'>// prints "Now serving Chris!"
</span><span class='line'>print(customersInLine.count)
</span><span class='line'>// prints "4"</span></code></pre></td></tr></table></div></figure>


<p>尽管在闭包的代码中，<code>customersInLine</code>的第一个元素被移除了，不过在闭包调用之前，这个元素不会被移除的。如果这个闭包永远不被调用，那么闭包里卖弄的表达式将永远不会执行，那意味着列表中的元素永远不会被删除。请注意，<code>customeerProvider</code>的类型不是<code>String</code>,而是<code>() -&gt; String</code>,一个没有参数且返回值为<code>String</code>的函数。
将闭包作为参数传递给函数时，你能获的同样的延时求值行为.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
</span><span class='line'>func serveCustomer(customerProvider: () -&gt; String) {
</span><span class='line'>    print("Now serving \(customerProvider())!")
</span><span class='line'>}
</span><span class='line'>serveCustomer( { customersInLine.removeAtIndex(0) } )
</span><span class='line'>// prints "Now serving Alex!"</span></code></pre></td></tr></table></div></figure>


<p><code>serveCustomer(_:)</code>接受一个返回顾客名字的显式的闭包。下面的这个版本的 serveCustomer(_:)完成了相同的操作，不过它并没有接受一个显示的闭包，而是通过该将参数标记为<code>@autoclosure</code>来接收一个自动闭包。现在你可以将该函数当做接受<code>String</code>类型参数的函数来调用。<code>customerProvider</code>参数将自动转化为一个闭包，因为该参数标记了<code>@autoclosure</code>特性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// customersInLine is ["Ewa", "Barry", "Daniella"]
</span><span class='line'>func serveCustomer(@autoclosure customerProvider: () -&gt; String) {
</span><span class='line'>    print("Now serving \(customerProvider())!")
</span><span class='line'>}
</span><span class='line'>serveCustomer(customersInLine.removeAtIndex(0))
</span><span class='line'>// prints "Now serving Ewa!"</span></code></pre></td></tr></table></div></figure>


<p><code>@autoclosure</code>特性暗含了<code>@noescape</code>特性。如果你想让这个闭包可以"逃逸"，则应该使用<code>@autoclosure(escaping)</code>特性。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// customersInLine is ["Barry", "Daniella"]
</span><span class='line'>var customerProviders: [() -&gt; String] = []
</span><span class='line'>func collectCustomerProviders(@autoclosure(escaping) customerProvider: () -&gt; String) {
</span><span class='line'>    customerProviders.append(customerProvider)
</span><span class='line'>}
</span><span class='line'>collectCustomerProviders(customersInLine.removeAtIndex(0))
</span><span class='line'>collectCustomerProviders(customersInLine.removeAtIndex(0))
</span><span class='line'>
</span><span class='line'>print("Collected \(customerProviders.count) closures.")
</span><span class='line'>// prints "Collected 2 closures."
</span><span class='line'>for customerProvider in customerProviders {
</span><span class='line'>    print("Now serving \(customerProvider())!")
</span><span class='line'>}
</span><span class='line'>// prints "Now serving Barry!"
</span><span class='line'>// prints "Now serving Daniella!"</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，<code>collectCustomerProviders(_:)</code>函数并没有调用传入的<code>cusomerProvider</code>闭包，而是将闭包追加到了<code>customerProviders</code>数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包将会在函数返回之后被调用，因此，<code>customerProvider</code>参数必须允许“逃逸”出函数作用域.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习CAShapeLayer]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer/"/>
    <updated>2016-03-04T14:20:24+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/04/xue-xi-cashapelayer</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>CAShapeLayer继承自CALayer,因此，可以使用CaLayer的所有属性。但是，CAShapeLayer需要和贝塞尔曲线配合使用才有意义.</p>

<p>CAShapeLayer是在其坐标系统内绘制贝塞尔曲线的。因此使用CAShapeLayer需要与 <code>UIbezierPath</code>一起使用。</p>

<p>它有一个 <code>path</code>属性，而<code>UIBezierPath</code>就是对 <code>CGPathRef</code>类型的封装，因此这两者是绝配</p>

<!--more-->


<h2>CASHapeLayer和drawRect的比较</h2>

<ol>
<li>drawRect : 属于CoreGraphics框架，占用cpu,性能消耗大</li>
<li>CAShapeLayer:属于CoreAnimation框架，通过GPU来渲染图形，节省性能。动画渲染直接提交给手机的GPU,不消耗内存。</li>
</ol>


<p>这两者各有各的用途，而不是说有个CAShapeLayer就不需要drawRect了。</p>

<h2>CAShapeLayer月UIBezierPath的关系</h2>

<ol>
<li>CAShapeLayer中的shape代表形状的意思，所以需要形状才能生效</li>
<li>贝塞尔曲线可以创建矢量的路径，而<code>UIBezierPath</code>类是对 <code>CGPathRef</code>的封装</li>
<li>贝塞尔曲线给 <code>CAShapeLayer</code>提供路径，CAShapelayer在提供的路径中进行渲染。路径会闭环，所以绘制出了 <code>Shape</code></li>
<li>用于<code>CAShapeLayer</code>的贝塞尔曲线作为path,其path是一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线。</li>
</ol>


<h2>CAShapeLayer与UIBezierPath画圆</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-2.png" alt="logo" /></p>

<p>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(CAShapeLayer*)drawCircle{
</span><span class='line'>    CAShapeLayer *circleLayer=[CAShapeLayer layer];
</span><span class='line'>    
</span><span class='line'>    circleLayer.frame=CGRectMake(100, 10, 200, 200);
</span><span class='line'>    //设置居中显示
</span><span class='line'>   // circleLayer.position=self.view.center;
</span><span class='line'>    //设置填充颜色
</span><span class='line'>    circleLayer.fillColor=[UIColor clearColor].CGColor;
</span><span class='line'>    //设置线宽
</span><span class='line'>    circleLayer.lineWidth=2;
</span><span class='line'>    //设置线的颜色
</span><span class='line'>    circleLayer.strokeColor=[UIColor redColor].CGColor;
</span><span class='line'>    
</span><span class='line'>    //使用UIBezierPath创建路径
</span><span class='line'>    CGRect frame=CGRectMake(0, 0, 200, 200);
</span><span class='line'>    UIBezierPath *circlePath=[UIBezierPath bezierPathWithOvalInRect:frame];
</span><span class='line'>    //设置CAShapeLayer与UIBezierPath关联
</span><span class='line'>    circleLayer.path=circlePath.CGPath;
</span><span class='line'>    
</span><span class='line'>    [self.view.layer addSublayer:circleLayer];
</span><span class='line'>    
</span><span class='line'>    return circleLayer;
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，我们这里不是放在-drawRect:方法中调用的。我们直接将这个CAShapeLayer放到self.view.layer上，直接呈现出来。</p>

<p>我们创建一个<code>CAShapeLayer</code>，然后配置相关属性，然后再通过 <code>UIBezierPath</code>的类方法创建一个内切圆路径，然后将路径指定给<code>CAShapeLayer.path</code>,这就将两者关联起来了，最后，将这个层放到了self.view.layer上呈现出来。</p>

<h2>CAShapeLayer与UIBezierPath的简单Loading效果</h2>

<p>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)drawHalfCircle {
</span><span class='line'>  self.loadingLayer = [self drawCircle];
</span><span class='line'>
</span><span class='line'>  // 这个是用于指定画笔的开始与结束点
</span><span class='line'>  self.loadingLayer.strokeStart = 0.0;
</span><span class='line'>  self.loadingLayer.strokeEnd = 0.75;
</span><span class='line'>
</span><span class='line'>  self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1
</span><span class='line'>                                                target:self
</span><span class='line'>                                              selector:@selector(updateCircle)
</span><span class='line'>                                              userInfo:nil
</span><span class='line'>                                               repeats:YES];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)updateCircle {
</span><span class='line'>  if (self.loadingLayer.strokeEnd &gt; 1 && self.loadingLayer.strokeStart &lt; 1) {
</span><span class='line'>    self.loadingLayer.strokeStart += 0.1;
</span><span class='line'>  } else if (self.loadingLayer.strokeStart == 0) {
</span><span class='line'>    self.loadingLayer.strokeEnd += 0.1;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if (self.loadingLayer.strokeEnd == 0) {
</span><span class='line'>    self.loadingLayer.strokeStart = 0;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if (self.loadingLayer.strokeStart &gt;= 1 && self.loadingLayer.strokeEnd &gt;= 1) {
</span><span class='line'>    self.loadingLayer.strokeStart = 0;
</span><span class='line'>    [self.timer invalidate];
</span><span class='line'>    self.timer = nil;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>
我们要实现这个效果，是通过 <code>stokeStart</code>和<code>stokeEnd</code>这两个属性好实现的，这两个的取值范围是[0-1],当stokeStart的值慢慢变成1时，我们看到路径是慢慢消失的。这里实现的效果并不好，因为不能一直循环。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios的Block循环引用]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/04/iosde-blockxun-huan-yin-yong/"/>
    <updated>2016-03-04T13:22:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/04/iosde-blockxun-huan-yin-yong</id>
    <content type="html"><![CDATA[<p>ios在开发的过程中，很容易引发内存泄露问题。也很容易造成循环引用，之前使用block的时候也没有过多注意，其实坑很多。
对于新手来说，出现循环引用的时候，很难去排查。</p>

<!--more-->


<h2>Controller之间的block循环引用</h2>

<p>现在，我们声明两个类，一个是ViewController,另一个是TLController,在ViewController中有个按钮，点击 push到TlController中。
先看TLController中类的声明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void(^CallbackBlock)();
</span><span class='line'>
</span><span class='line'>@interface TLController : UIViewController
</span><span class='line'>- (instancetype)initWithCallback:(CallbackBlock)callback;
</span><span class='line'>
</span><span class='line'>@property (nonatomic, copy) CallbackBlock callbackBlock;</span></code></pre></td></tr></table></div></figure>


<p>TlController.m</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)initWithCallback:(CallbackBlock)callback{
</span><span class='line'>    self=[super init];
</span><span class='line'>    if(self){
</span><span class='line'>        _callbackBlock=callback;
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了验证该类是不是被释放掉了，我们重写两个方法来检测:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)viewDidAppear:(BOOL)animated{
</span><span class='line'>    [super viewDidAppear:animated];
</span><span class='line'>    NSLog(@"进入控制器：%@", [[self class] description]);
</span><span class='line'>}
</span><span class='line'>- (void)dealloc {
</span><span class='line'>    NSLog(@"控制器被dealloc: %@", [[self class] description]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在 ViewController中，创建一个按钮，按钮的单击事件如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 点击button时
</span><span class='line'>- (void)goToNext {
</span><span class='line'>    //__weak __typeof(self) weakSelf=self;
</span><span class='line'>    
</span><span class='line'>    TLController *vc = [[TLController alloc] initWithCallback:^{
</span><span class='line'>        [self.button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];
</span><span class='line'>    }];
</span><span class='line'>    self.vc = vc;
</span><span class='line'>    [self.navigationController pushViewController:vc animated:YES];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在看Viewcontroller，这里就形成了两个循环，因此vc属性得不到释放，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-0.png" alt="logo" /></p>

<p>这里形成了两个循环</p>

<ol>
<li><p>ViewContrller->强引用了vc->强引用了callback->强引用了Viewcontroller</p></li>
<li><p>Viewcontroler->强引用了属性vc->强引用了callback->强引用了Viewcontroller的属性button</p></li>
</ol>


<p>我们要解决这两个循环引用，可以如下操作:</p>

<p>不声明vc属性，或者将vc属性声明为weak弱引用类型，在callback回调处，将self.button改为 weakSelf.button,也就是让callback的这个block对viewcontroller弱引用，这样内存就可以顺利释放了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 点击button时
</span><span class='line'>- (void)goToNext {
</span><span class='line'>    __weak __typeof(self) weakSelf=self;
</span><span class='line'>    
</span><span class='line'>    TLController *vc = [[TLController alloc] initWithCallback:^{
</span><span class='line'>        [weakSelf.button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];
</span><span class='line'>    }];
</span><span class='line'>   // self.vc = vc;
</span><span class='line'>    [self.navigationController pushViewController:vc animated:YES];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Controller和View之间的block引用</h2>

<p>我们先定义一个view,用于和Contrller交互，当点击view上的按钮时，就把结果回调给controller;</p>

<p>TLView定义如下:
TlView.h</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void(^FeedbackBlock)(id model);
</span><span class='line'>@interface TLView : UIView
</span><span class='line'>@property (nonatomic, copy) FeedbackBlock block;
</span><span class='line'>- (instancetype)initWithBlock:(FeedbackBlock)block;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>TlView.m</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(instancetype)initWithBlock:(FeedbackBlock)block{
</span><span class='line'>    self=[super init];
</span><span class='line'>    if(self){
</span><span class='line'>        self.block=block;
</span><span class='line'>        UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
</span><span class='line'>        [button setTitle:@"反馈给controller" forState:UIControlStateNormal];
</span><span class='line'>        button.frame = CGRectMake(50, 200, 200, 45);
</span><span class='line'>        button.backgroundColor = [UIColor redColor];
</span><span class='line'>        [button setTitleColor:[UIColor yellowColor] forState:UIControlStateNormal];
</span><span class='line'>        [button addTarget:self action:@selector(feedback) forControlEvents:UIControlEventTouchUpInside];
</span><span class='line'>        [self addSubview:button];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>- (void)feedback {
</span><span class='line'>    if (self.block) {
</span><span class='line'>        // 传模型回去，这里没有数据，假设传nil
</span><span class='line'>        self.block(nil);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>// Only override drawRect: if you perform custom drawing.
</span><span class='line'>// An empty implementation adversely affects performance during animation.
</span><span class='line'>- (void)drawRect:(CGRect)rect {
</span><span class='line'>    // Drawing code
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'>
</span><span class='line'>- (void)dealloc {
</span><span class='line'>    NSLog(@"dealloc: %@", [[self class] description]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，在TlController中增加两个属性</p>

<pre><code>@property (nonatomic, strong) TLView *aView;
@property (nonatomic, strong) id currentModel;
</code></pre>

<p>  调用如下:</p>

<pre><code class="``">  -(void)testView{

   // __weak __typeof(self) weakSelf=self;

    self.aView = [[TLView alloc] initWithBlock:^(id model) {
        // 假设要更新model
        self.currentModel = model;
        //weakSelf.currentModel=model;
    }];
    // 假设占满全屏
    self.aView.frame = self.view.bounds;
    [self.view addSubview:self.aView];
    self.aView.backgroundColor = [UIColor whiteColor];
}
</code></pre>

<p>  在viewDidLoad方法中，调用<code>[self testView]</code></p>

<p>  这样Controller和view之间就形成了循环引用，如图:
  <img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160304-1.png" alt="logo" /></p>

<ol>
<li>TlViewController->强引用aView->block->tlViewcontroller属性的currentModel</li>
</ol>


<p>  解决的办法是:在创建aView的时候，block内对currentModel的引用改成弱引用</p>

<pre><code class="``">  __weak __typeof(self) weakSelf=self;

    self.aView = [[TLView alloc] initWithBlock:^(id model) {
        // 假设要更新model
        weakSelf.currentModel=model;
    }];
</code></pre>

<p>  很多程序员直接使用<em>currentModel,其实这样也会造成循环引用，因为</em>currentModel也是属于类的成员变量，也会被强引用的。要解决此问题，也要改成弱引用</p>

<pre><code class="``">  __block __weak __typeof(_currentModel) weakModel = _currentModel;
self.aView = [[TLView alloc] initWithBlock:^(id model) {
  // 假设要更新model
  weakModel = model;
}];
</code></pre>

<h2>模拟循环引用</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@autoreleasepool {
</span><span class='line'>  A *aVC = [[A alloc] init];
</span><span class='line'>  B *bVC = [[B allcok] init];
</span><span class='line'>  aVC.controller = bVC;
</span><span class='line'>  bVC.controller = aVC;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>aVC->强引用了bVC</p>

<p>bVC->强引用了aVC</p>

<p>如果是这样引用，就形成环了。aVC->bVC->aVC，这就形成了环。</p>

<h3>如果一个Controller中，存在一个局部变量，是否循环引用呢?</h3>

<p>在Viewcontroller中声明一个变量
<code>@property (nonatomic,strong)NSMutableArray *array;</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)test1{
</span><span class='line'>    self.array = [NSMutableArray arrayWithObjects:@"a",@"b",@"abc",nil];
</span><span class='line'>    TLController *vc = [[TLController alloc] initWithCallback:^{
</span><span class='line'>        [self.array removeObjectAtIndex:0];
</span><span class='line'>    }];
</span><span class='line'>    [self.navigationController pushViewController:vc animated:YES];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>点击跳转按钮，控制台打印</p>

<pre><code>BlockDemo1[5511:1169090] 进入控制器：TLController
2016-03-04 14:08:45.612 
</code></pre>

<p>点击回退,控制台打印</p>

<pre><code>BlockDemo1[5511:1169090] 控制器被dealloc: TLController
</code></pre>

<p>  说明成员变量NSMutableArray不会形成循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习UIBezierPath]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/03/xue-xi-uibezierpath/"/>
    <updated>2016-03-03T14:05:08+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/03/xue-xi-uibezierpath</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前就看到很多关于<code>UIBezierPath</code>的介绍，但是平常开发的时候一直没怎么用过，但是这个<code>UIBezierPath</code>对于开发画图是很有用的。故在此整理出来，方便以后使用和查阅。</p>

<!--more-->


<p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是Core Graphics框架关于路径的疯转。使用<code>UIBezierPath</code>可以定义简单的形状，如三角形，矩形或有多个直线和曲线组成的形状等。</p>

<p><code>UIBezierPath</code>是CGPathRef数据类型的封装。</p>

<p>使用<code>UIBezierPath</code>画图的步骤</p>

<ol>
<li>创建一个<code>UIBezierPath</code>对象</li>
<li>调用 -moveToPoint:设置初始线段的起点</li>
<li>添加线或者曲线去定义或者多个子路径</li>
<li>改变<code>UIBezierPath</code>对象跟绘图属性。我们可以设置画笔的颜色，size大小等等</li>
</ol>


<h2>UIBezierPath创建方法</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>+ (instancetype)bezierPath;
</span><span class='line'>+ (instancetype)bezierPathWithRect:(CGRect)rect;
</span><span class='line'>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
</span><span class='line'>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
</span><span class='line'>                            cornerRadius:(CGFloat)cornerRadius;
</span><span class='line'>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
</span><span class='line'>                        byRoundingCorners:(UIRectCorner)corners 
</span><span class='line'>                              cornerRadii:(CGSize)cornerRadii;
</span><span class='line'>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center 
</span><span class='line'>                                 radius:(CGFloat)radius 
</span><span class='line'>                             startAngle:(CGFloat)startAngle 
</span><span class='line'>                               endAngle:(CGFloat)endAngle 
</span><span class='line'>                              clockwise:(BOOL)clockwise;
</span><span class='line'>+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;</span></code></pre></td></tr></table></div></figure>


<pre><code>  + (instancetype)bezierPath;
</code></pre>

<p>   这个使用比较多，因为我们可以根据我们的需要任意定制样式，可以画出我们想要的图形</p>

<pre><code>+ (instancetype)bezierPathWithRect:(CGRect)rect;
</code></pre>

<p>这个工厂方法根据一个矩形画贝塞尔曲线</p>

<pre><code>+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
</code></pre>

<p> 这个工厂方法根据一个矩形画内切的贝塞尔曲线，通常用它来画圆和椭圆</p>

<pre><code> + (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                              cornerRadius:(CGFloat)cornerRadius;
</code></pre>

<p> 这个工厂方法画矩形，但是这个矩形是可以画圆角的。第一个参数是矩形，第二个参数是圆角大小</p>

<pre><code>+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                        byRoundingCorners:(UIRectCorner)corners 
                              cornerRadii:(CGSize)cornerRadii;
</code></pre>

<p> 这个工厂方法也是画矩形，但是可以指定某一个角成圆角，像这种我们可以很容易的给UIview扩展成圆角了</p>

<pre><code>+ (instancetype)bezierPathWithArcCenter:(CGPoint)center 
                                 radius:(CGFloat)radius 
                             startAngle:(CGFloat)startAngle 
                               endAngle:(CGFloat)endAngle 
                              clockwise:(BOOL)clockwise;
</code></pre>

<p> 这个工厂方法用于画圆弧，参数如下:
 Center:弧线中心点的坐标
 radius:弧线所在圆的半径
 startAngle:弧线开始的角度值
 endAngle:弧线结束时的角度值
 clockwise:是否顺时针画弧线</p>

<h3>画三角形</h3>

<p>如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-0.png" alt="三角形" /></p>

<p>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//画三角形
</span><span class='line'>-(void)drawTriangle{
</span><span class='line'>    UIBezierPath *path=[UIBezierPath bezierPath];
</span><span class='line'>    [path moveToPoint:CGPointMake(20, 20)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(self.frame.size.width-40, 20)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(self.frame.size.width/2, self.frame.size.height-20)];
</span><span class='line'>    //最后的闭合线可以通过closePath方法来自动生成。也可以调用addLineToPoint来添加
</span><span class='line'>    
</span><span class='line'>    [path closePath];
</span><span class='line'>    
</span><span class='line'>    //设置线宽
</span><span class='line'>    path.lineWidth=4;
</span><span class='line'>    //设置填充颜色
</span><span class='line'>    UIColor *fillColor=[UIColor yellowColor];
</span><span class='line'>    [fillColor set];
</span><span class='line'>    
</span><span class='line'>    [path fill];
</span><span class='line'>    
</span><span class='line'>    //设置画笔的颜色
</span><span class='line'>    UIColor *stokeColor=[UIColor blueColor];
</span><span class='line'>    [stokeColor set];
</span><span class='line'>    //根据我们设置的各个点，进行连线
</span><span class='line'>    [path stroke];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>画矩形</h3>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-1.png" alt="矩形" /></p>

<p>代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//画矩形
</span><span class='line'>-(void)drawMyRectPath{
</span><span class='line'>    UIBezierPath *path=[UIBezierPath bezierPathWithRect:CGRectMake(100, 100, self.frame.size.width-120, self.frame.size.height-120)];
</span><span class='line'>    path.lineWidth=2;
</span><span class='line'>    path.lineCapStyle=kCGLineCapRound;
</span><span class='line'>    
</span><span class='line'>    //设置填充颜色
</span><span class='line'>    UIColor *fillColor=[UIColor yellowColor];
</span><span class='line'>    [fillColor set];
</span><span class='line'>    [path fill];
</span><span class='line'>    
</span><span class='line'>    //设置画笔颜色
</span><span class='line'>    UIColor *stokeColor=[UIColor blueColor];
</span><span class='line'>    [stokeColor set];
</span><span class='line'>    //根据我们设置的各个点连线
</span><span class='line'>    
</span><span class='line'>    [path stroke];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>画圆</h3>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-2.png" alt=" circle" /></p>

<p>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//画圆形或者椭圆
</span><span class='line'>-(void)drawCirlcePath{
</span><span class='line'>    UIBezierPath *path=[UIBezierPath bezierPathWithOvalInRect:CGRectMake(10, 10, self.frame.size.width-20, self.frame.size.height-20)];
</span><span class='line'>    //设置线宽
</span><span class='line'>    path.lineWidth=4;
</span><span class='line'>    //设置填充颜色
</span><span class='line'>    UIColor *fillColor=[UIColor yellowColor];
</span><span class='line'>    [fillColor set];
</span><span class='line'>    
</span><span class='line'>    [path fill];
</span><span class='line'>    
</span><span class='line'>    //设置画笔的颜色
</span><span class='line'>    UIColor *stokeColor=[UIColor blueColor];
</span><span class='line'>    [stokeColor set];
</span><span class='line'>    //根据我们设置的各个点，进行连线
</span><span class='line'>    [path stroke];
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>画带圆角的矩形</h3>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-3.png" alt="圆角矩形" /></p>

<p>代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//画带圆角的矩形
</span><span class='line'>-(void)drawRoundedRectPath{
</span><span class='line'>    UIBezierPath *path=[UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width-40, self.frame.size.height-40) cornerRadius:10];
</span><span class='line'>    
</span><span class='line'>    //设置填充颜色
</span><span class='line'>    UIColor *fillColor=[UIColor yellowColor];
</span><span class='line'>    [fillColor set];
</span><span class='line'>    [path fill];
</span><span class='line'>    
</span><span class='line'>    //设置画笔颜色
</span><span class='line'>    UIColor *stokeColor=[UIColor blueColor];
</span><span class='line'>    [stokeColor set];
</span><span class='line'>    
</span><span class='line'>    //根据我们设置的各个点连线
</span><span class='line'>    [path stroke];
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>部分角是圆形的</h3>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-4.png" alt="circle" /></p>

<p>只需把上面的代码稍加修改:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIBezierPath *path=nil;
</span><span class='line'>    //[UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width-40, self.frame.size.height-40) cornerRadius:10];
</span><span class='line'>    
</span><span class='line'>CGRect rect=CGRectMake(20, 20, self.frame.size.width-40, self.frame.size.height-40);
</span><span class='line'>    
</span><span class='line'>path=[UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerTopLeft cornerRadii:CGSizeMake(20, 20)];</span></code></pre></td></tr></table></div></figure>


<h3>画弧度</h3>

<p>画弧前，我们需要先了解参考系
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-5.png" alt="sdf" /></p>

<p>效果图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160303-6.png" alt="logo" /></p>

<p>代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)drawARCPath{
</span><span class='line'>    const CGFloat pi=3.14159;
</span><span class='line'>    CGPoint center=CGPointMake(self.frame.size.width/2, self.frame.size.height/2);
</span><span class='line'>    UIBezierPath *path=[UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:kDegreesToRadians(135) clockwise:YES];
</span><span class='line'>    
</span><span class='line'>    path.lineCapStyle=kCGLineCapRound;
</span><span class='line'>    path.lineJoinStyle=kCGLineJoinRound;
</span><span class='line'>    path.lineWidth=5;
</span><span class='line'>    
</span><span class='line'>    UIColor *stokeColor=[UIColor redColor];
</span><span class='line'>    [stokeColor set];
</span><span class='line'>    
</span><span class='line'>    [path stroke];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode常见问题解析]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/01/xcodechang-jian-wen-ti-jie-xi/"/>
    <updated>2016-03-01T16:05:46+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/01/xcodechang-jian-wen-ti-jie-xi</id>
    <content type="html"><![CDATA[<p>启动项目或者编译的时候，xcode总是有一些莫名的错误，现在我把遇到的问题和异常信息都记录下来，以此共勉</p>

<h3>CodeSign error: code signing is required for product type &lsquo;Application&rsquo; in SDK &lsquo;iOS 9.2&rsquo;</h3>

<!--more-->


<p>解决方法:</p>

<ul>
<li>去这个文件夹下 <code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/目标文件下</code> 比如我这个就是iPhoneOS9.2.sdk，</li>
<li>你需要拷贝这个文件 SDKSettings.plist  到桌面上</li>
<li>打开这个文件，找到DefaultProperties这个选项，设置里面的属性CODE_SIGNING_REQUIRED 为 NO</li>
<li>保存这个文件，再把这个文件拷贝到原始的路径下</li>
</ul>


<p>搞定！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的数据存储]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/01/swiftzhong-de-shu-ju-cun-chu/"/>
    <updated>2016-03-01T10:52:34+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/01/swiftzhong-de-shu-ju-cun-chu</id>
    <content type="html"><![CDATA[<p>程序就是对数据进行处理的，存储数据在app端也是很有必要的。本章将学习如何使用文件系统在磁盘上存储信息，如何在内置的用户偏好设置数据库中存储简单数据。</p>

<!--more-->


<h2>NSuserDefaults</h2>

<p>NSUserDefaults类允许以"键值"形式保存设置信息。我们不需要加载和读取设置文件，偏好设置会被自动保存。</p>

<p>要访问存储在NSuserDefaults中的偏好设置，需要NSuserDefaults类的一个实例。为得到这样的一个实例，必须使用NSUserdefaults类额standardUserDefaults:</p>

<pre><code>let defaults=NSUserDefaults.standardUserDefaults()
</code></pre>

<p>要在默认对象中注册默认值，首先需要创建一个字典。这个字典的键与偏好设置的名字相同，与这些键关联的值就是这些设置的默认值。一旦有个这个字典，就用registerDefaults方法将它提供给默认对象</p>

<pre><code>let meDefaults=["greeting":"hello",
            "numberOfItems":1]
defaults.registerDefaults(meDefaults)
</code></pre>

<p>完成这一工作后，就可以使用默认对象的值了</p>

<p>用reigisterDefaults方法注册的"默认设置"并不是村村在磁盘上，也就是说在应用程序每次启动时都需要调用它。但在应用程序中设定的“默认设置”会被保存。</p>

<p>有了对一个NSuserdefaults对象的引用，就可以向对待字典一样对待NSUserdaults对象，我们可以使用ObjectForkey方法从默认对象中提取一个值</p>

<pre><code>let greeting=defaults.objectForKey("greeting") as? String
</code></pre>

<p>只有少数对象可以村村在默认对象中。可以存储在默认对象中的对象只有属性列表对象。</p>

<ul>
<li>字符串</li>
<li>数字</li>
<li>NSData</li>
<li>NSdate</li>
<li>数组和字典</li>
</ul>


<p> 如果需要在默认对象中存储任何其他类型的对象，应当首先对其存档(archive),转换为NSData</p>

<p>除了从默认对象中提取值之外，还可以设定值。在NSUserDefaults对象中设定值时，这个值将被永远保存
要在NSUserDefaults对象中设定一个对象，可以使用SetObject(_,forKey)</p>

<pre><code>let newGreeting="hi ,there";
defaults.setObject(newGreeting, forKey: "greeting")  
</code></pre>

<h2>使用NSFileManager</h2>

<p>应用程序与文件系统的界面是NSFileManager对象，利用它可以列出文件夹的内容，创建和重命名和删除文件，要访问NSFilemanager类，可以使用共享管理器对象</p>

<pre><code>let fileManager=NSFileManager.defaultManager()
</code></pre>

<h3>注意</h3>

<p>NSFileManager允许我们对其设定一个委托，在文件管理器完成诸如复制或移动文件之类的操作时，它会受到消息。在使用这一功能时，应当创建你自己的NSFileManager实例，而不是使用共享对象</p>

<pre><code>let fileManager=NSFileManager()
fileManager.delegate=self;
</code></pre>

<ul>
<li><p>获取一个临时目录</p>

<p>  //获取临时目录
  let tempraryDirectoryPath=NSTemporaryDirectory()
这个函数会返回一个字符串，它包含了可以在其中存储文件的目录路径。如果希望以NSURL形式使用它，就需要用fileURLWithPath方法进行转换。</p></li>
<li><p>创建目录</p></li>
</ul>


<p>利用NSFileManager，可以在文件系统上创建和删除项目。比如，要创建一个新目录，可以利用:</p>

<ul>
<li>创建文件
创建文件的过程也是一样的，我们在NSString中提供一个路径，文件应当包含的NSData,以及一个可选的字典，其中列出此文件应当拥有的属性：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fileManager.createFileAtPath(newFilePath!,
</span><span class='line'>      contents:NewFileData,
</span><span class='line'>      attributes:nil)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>删除文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fileManager.reomveItemAtURL(newFileURL!,error:&error)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>移动和复制文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fileManager.moveItemAtURL(sourceURL!,toURL:destinationURL,error:nil)</span></code></pre></td></tr></table></div></figure>


<p>要复制一个项目，可以这样做</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fileManager.copyItemAtURL(sourceURL!,toURL:destinationURL,error:nil)</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift基础知识]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/02/26/swiftji-chu-zhi-shi/"/>
    <updated>2016-02-26T14:37:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/02/26/swiftji-chu-zhi-shi</id>
    <content type="html"><![CDATA[<p>swift充分利用了语言设计的悠久历史，拥有非常多的设计特性，使得软件开发变得更容易，更简单，更安全。</p>

<ul>
<li>安全</li>
</ul>


<p>swift设计的初衷就是一门安全的语言，c语言中有许多缺陷，比如意外使用null指针，这些很难在swift中遇到。swift非常重视强类型化，除了一些极为特殊的情况下，它是不允许为空的。</p>

<!--more-->


<ul>
<li>现代</li>
</ul>


<p>swift包含了大量的现代语言的特性，可以轻松的表达代码逻辑。这些特性包括：模式匹配switch语句，闭包，所有值都是对象的概念</p>

<ul>
<li>强大</li>
</ul>


<p>swift可以访问整个Object-c运行时，而且可以无缝的连接到Object-c的类，意味着我们可以马上用swift编写出完整的ios和OSX App,不用等着别人从Oc向swift移植任何功能</p>

<h2>基础语法</h2>

<h3>变量和常量</h3>

<p>在swift中，let用来定义常量，如果一个值定义之后不希望再被改变，可以用let来声明</p>

<p>var用来定义变量，如果一个值一直再被赋值和变化，则可以用var来声明</p>

<p>swift中的常量必须拥有值，如果定义了一个常量，但是没有给定值会报错的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someConstant : Int
</span><span class='line'>//错误，常量在声明时必须包含值</span></code></pre></td></tr></table></div></figure>


<p>变量可以不包含值，只要不尝试访问它就行。换句话说，如果创建了一个变量，但没有为它设置值，那唯一能做的就是为它指定一个值。之后就可以使用它了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someVariable:Int
</span><span class='line'>someVariable += 2
</span><span class='line'>//错误，someVariable没有包含值，所以不能向它增加2
</span><span class='line'>
</span><span class='line'>someVariable=2
</span><span class='line'>someVariable+=2
</span><span class='line'>//成功，因为someVariable有一个值，可以进行平常操作
</span></code></pre></td></tr></table></div></figure>


<h3>类型</h3>

<p>我们不需要定义一个变量是什么类型，Swift可以根据它的初始值做出判断。这意味着在你定义一个变量并为其设定数值2时，这个变量会是Int类型：</p>

<pre><code>//隐式指定整数类型
var anInteger = 2
</code></pre>

<p>大多数类型都不能合并，因为编译器不知道结果会是什么类型。例如：我们不能将一个string值加到一个int值上。因为其结果毫无意义。</p>

<p>在Object-c中，nil实际上被定义为一个指向0的void指针。严格来说，它是一个数字，这就意味着我们可以进行类似下面的操作：</p>

<pre><code>int i=(int)(nil)+2
//等于2（因为0+2=2）
</code></pre>

<p>这在swift中是不允许的，因为nil和Int是不同类型</p>

<p>swift中的所有变量都是需要有取值的。如果希望允许一个变量在某些时候为nil,那就使它成为一个可选变量。可选变量的定义是在其类型中包含一个问号(?)</p>

<pre><code>//可选整数，允许为nil
var anOptionalInteger : Int? = nil
anOptionalInteger = 22
</code></pre>

<p>只有可选变量才允许被设置为nil.如果一个变量没有被定义为nil,那就不允许将它设定为nil值:</p>

<pre><code>//非可选，不允许为nil
var aNonOptionalInteger = 32

aNonOptionalInteger  = nil
//错误，只有可选值才能为nil
</code></pre>

<p>可以使用if语句来查看一个可选变量是否拥有值</p>

<pre><code>if anOptionalInteger !=nil {
   println("It has a value")
}else{
   println("It has no value");
}
</code></pre>

<p>对于可选变量，可以进行拆包操作，获得其取值。这一工作用 感叹号 !实现。</p>

<h5>注意</h5>

<p>如果对一个可选变量进行拆包，而它并没有值，程序将会抛出一个运行时错误，并会崩溃</p>

<pre><code>//可选类型必须使用!拆包
anOptionalInteger=2
1+anOptionalIntger!  //3

anOptionalInteger = nil
1+anOptionalInteger!
//崩溃：anOptionalInteger=nil,不能使用nil数据
</code></pre>

<p>如果不希望每次用到可选变量都要对其进行拆包，可以将它声明为已拆包的</p>

<pre><code>var unwrappedOptionalInteger:int!
unwarappedOptionalInteger=1
1+ unwarappedOptionalInteger  //2
</code></pre>

<p>这样就可以直接使用它们的值，但可能会不安全（因为它让你逃避了在需要时对其进行拆包的操作，可能会让你忘了它们有时会是nil）.谨慎使用</p>

<p>在swift中，可以在不同类型之间进行转换。例如：要将一个Int转换为一个string,可以这样做</p>

<pre><code>let aString=String(anInteger)
//"2"
</code></pre>

<h3>元组</h3>

<p>元组是数据的一个简单集合。利用元组，可以将多个值一起捆绑到单个值中：</p>

<pre><code>let aTuple = (1,"YES")
</code></pre>

<p>有了元组，就可以从中提取到值：</p>

<pre><code>let theNumber = aTuple.0  //=1
</code></pre>

<p>除了用数字提取元组的值之外，还可以为元组中的值添加标签：</p>

<pre><code>let anotherTuple = (aNumber：1,aString: "YES")
let theOhterNumber = anotherTuple.aNumber //1
</code></pre>

<h3>数组</h3>

<p>swift中的数组很容易使用。要创建一个数组，可以直接用 []:</p>

<pre><code>//整数数组
let arrayOfInteger : [Int] = [1,2,3]
</code></pre>

<p>Swift还可以推断出数组的类型：</p>

<pre><code>//暗含了数组类型
let implicitArrayofIntegers=[1,2,3]
</code></pre>

<p>还可以创建空数组，不过，这种情况需要人工指定其类型</p>

<pre><code>let anotherArray=[Int]()
</code></pre>

<p>用let关键字定义的数组，其内容是不可变的，也就是说，不允许改变其内容</p>

<p>有了数组之后，就可以使用其内容了。例如，可以使用append函数向数组的末尾追加对象</p>

<pre><code>var myArray =[1,2,3,4]
myArray.append(4)
</code></pre>

<p>除了在数组的末尾追加对象之外，还可以插入对象</p>

<pre><code>myArray.insert(5,atIndex:0)
</code></pre>

<h3>字典</h3>

<p>字典是一种将键映射到值的类型。当希望表示一组相关信息时，字典是很有用的。
声明一个字典</p>

<pre><code>var crew=["caption":"张三",
         "first officer":"jack",
         "second officer":"david"]  
</code></pre>

<p>有了字典，就可以通过下标来访问其内容。下标就是在变量名之后用方括号 []的地方。</p>

<pre><code>crew["Caption"]   //=张三
</code></pre>

<h3>控制流</h3>

<p>在swift中，所有的if语句以及所有的循环的主体都需要放在两个大括号。</p>

<pre><code>if(something){
 //这对大括号是必须的
}
</code></pre>

<p>当拥有一个集合时，比如一个数组，可以使用for-in循环来迭代每一项:</p>

<pre><code>let loopingArray=[1,2,3,4,5]
var loopSum=0
for number in loopingArray{
   loopSum += number
}
</code></pre>

<p>还可以使用for-in循环来迭代一个数值范围。例如</p>

<pre><code>var firstCount = 0
for index in 1..&lt;10{
  firstCounter++
}   
//循环9次
</code></pre>

<p>注意第一行中的..&lt;运算符，这是一个范围运算符，swift用它描述一个值到另一个值的数值范围。实际上有两个范围的运算符:两个句点加一个做尖括号(..&lt;),表示从第一个值开始知道最后一个值的一个范围（最后一个值不包含在内），例如5..&lt;9 包含了数字 5,6,7,8. 如果希望创建一个包含最后数值的范围，可以使用三个句点(&hellip;),这里没有尖括号，范围5&hellip;9包含的数值 5,6,7,8,9</p>

<h3>Switch</h3>

<p>switch是一种根据变量值运行代码的强大方式。</p>

<p>switch可以判断整数，还可以判断字符串</p>

<pre><code>let stringSwitch="Hello"
switch stringSwitch{
  case "Hello":
     println("A greeting");
  case "Goodbye":
     println("A farewell")
  default:
    println("something");

}
</code></pre>

<p>还可以对元组进行判断</p>

<pre><code>var str = "Hello, playground"

let tupleSwith=("YES",123)
switch tupleSwith{
case ("YES",123):
    print("Tuple contains 'YES' and 123");
    break;
case ("YES", 1):
    print("Tuple contains 'YES' and else")
    break;
default:
    print("tuple something")
    break;
}
</code></pre>

<p>switch的工作方式与C和Object-C中有点不同，在swift中，switch语句中的某一部分执行完毕后，不会自动“落入”下一部分，也就是说，不需要使用break关键字。</p>

<h3>函数和闭包</h3>

<p>函数可以向调用它们的代码返回一个值。在定义一个具有返回值的函数时，必须使用箭头(->)指明所返回数据的类型</p>

<pre><code>func sayHello()-&gt;Int{
 return 123
}
sayHello()
</code></pre>

<p>我们也可以向函数中传送参数，让其能够利用它们完成任务，在为函数定义参数时，还需要定义这些参数的类型：</p>

<pre><code>func thirdFunction(firstValue:Int, secondValue:Int)-&gt;Int{
  return firstValue+secondValue;
}
thirdFunction(1,2)
</code></pre>

<p>一个函数只可以返回一个值，我们前面已经看到这种情况，但也可以通过元组的方式返回多个值。另外，可以为元组中的值附加名字，以便能够更轻松的处理返回值：</p>

<pre><code>func fourthFunction(firstValue:Int,secondValue:Int)-&gt;(doubled:Int,test:Int){
    return (firstValue+1,secondValue*4)
}
fourthFunction(2,3)
</code></pre>

<p>在调用一个会返回元组的函数时，可以用数字访问它的值，如果有名字的话，也可以用名字来访问：</p>

<pre><code>//用数字访问
fourthFunction(2,4).1 //16
//其他相同，只是使用了名字:

fourthFunction（2，4）.test //16
</code></pre>

<p>在定义函数时，可以为参数指定名字，当无法马上明白每个参数的用途时，这一功能会非常有用。可以像下面这样来定义参数的名字</p>

<pre><code>func addNumbers(firstNumber num1:Int,toSecondNumber   num2:Int)-&gt;Int{
return num1+num2;
}
addNumbers(firstNumber: 2, toSecondNumber: 3) //5 
</code></pre>

<p> 在为参数创建名字时，就是为参数创建一个内部名字和一个外部名字。内部名字供函数引用该参数，而外部名字工调用该函数的外部代码使用。如果函数没有命名参数，那每个参数就只有一个内部名字。</p>

<p>在创建参数时，还可以为其参数指定默认值，这就意味着在调用这些函数时可以省略特定的参数；</p>

<pre><code>func multiplyNumber(firstNumber:Int,multiplier:Int=2)-&gt;Int{
return firstNumber+multiplier;
}
//可以省略具有默认值的参数
multiplyNumber(2);//4
</code></pre>

<p>有时，我们希望使用参数个数可变的函数，一个取值数目可变的参数成为可变参数，在这写情况下，我们希望一个函数能够处理任意数目的参，从0到一个无限数，为此可以使用三个句点(&hellip;)表示一个参数的取值是可变的。在函数的主体内部，可变参数变成一个数组，我们可以像使用其他数组一样使用它。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func sumNumbers(numbers:Int...)-&gt;Int{
</span><span class='line'>  //在这个函数中，'numbers'是一个数组
</span><span class='line'>    var total=0;
</span><span class='line'>    for number in numbers{
</span><span class='line'>        total+=number;
</span><span class='line'>    }
</span><span class='line'>    return total;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>sumNumbers(2,2,3,4) //11</span></code></pre></td></tr></table></div></figure>


<p>通常，函数以参数为输入时是按值传递的，输出返回的也是值，但是，如果有用inout关键字定义一个参数，那就可以按引用传送改参数，直接改变这个变量中存储的值。采用这种方式，可以用一个函数交换两个变量，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapValues(inout firstValue:Int,inout secondValue:Int){
</span><span class='line'>let tempValue=firstValue;
</span><span class='line'>firstValue=secondValue;
</span><span class='line'>secondValue=tempValue;
</span><span class='line'>}
</span><span class='line'>var swap1=2;
</span><span class='line'>var swap2=3;
</span><span class='line'>swapValues(&swap1, secondValue: &swap2)
</span><span class='line'>print(swap1) //3
</span><span class='line'>print(swap2) //2</span></code></pre></td></tr></table></div></figure>


<p>在调用函数时，这个变量的值可能会发生变化。</p>

<h3>将函数作为变量</h3>

<p>函数可以存储在变量在中，为此，首先声明一个变量，它能够存储一个接受特定参数，返回一个值的函数。声明之后，只要一个函数的参数与返回值类型都与声明中的函数相同，可以将它存储在这个变量中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func test1(v1:Int,v2:Int)-&gt;Int{
</span><span class='line'>     return v1+v2
</span><span class='line'> }
</span><span class='line'>  var numbersFunc:(Int,Int)-&gt;Int;
</span><span class='line'>  //numbersFunc现在可以存储任何接受两个int并返回一个int的函数
</span><span class='line'>  numbersFunc=test1;
</span><span class='line'>  numbersFunc(1,2) //3</span></code></pre></td></tr></table></div></figure>


<p>函数还可以接受其他函数作为参数并使用它们。这意味着可以将函数合并到一起。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func timesThree(number:Int)-&gt;Int{
</span><span class='line'>    return number*3;
</span><span class='line'>}
</span><span class='line'>func doSomethingToNumber(anumber:Int,thingToDo:(Int)-&gt;Int)-&gt;Int{
</span><span class='line'>//我们已经接受了某一函数作为参数，在本函数中将其称为"thingToDo"
</span><span class='line'>    
</span><span class='line'>    //使用‘anumber’作为参数调用函数 thingToDo
</span><span class='line'>    return thingToDo(anumber);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>doSomethingToNumber(100, thingToDo: timesThree); //300</span></code></pre></td></tr></table></div></figure>


<p>函数还可以返回其他函数。这意味着可以用函数创建新函数，并在自己的代码中使用这个新函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//返回一个函数
</span><span class='line'>func createAdder(numberToAdd:Int)-&gt;(Int)-&gt;Int{
</span><span class='line'>    func adder(number:Int)-&gt;Int{
</span><span class='line'>      return number+numberToAdd
</span><span class='line'>    }
</span><span class='line'>    return adder;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var addTwo=createAdder(12)
</span><span class='line'>addTwo(12)  //24</span></code></pre></td></tr></table></div></figure>


<h3>闭包</h3>

<p>swift的另一个特性是闭包-一些小的匿名代码块，可以像函数一样使用。可以非常方便的将闭包传送给其它函数，告诉他们应当如何执行某一任务。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> * 全局函数和嵌套函数其实就是特殊的闭包。 
</span><span class='line'> * 闭包的形式有： 
</span><span class='line'> * （1）全局函数都是闭包，有名字但不能捕获任何值。 
</span><span class='line'> * （2）嵌套函数都是闭包，且有名字，也能捕获封闭函数内的值。 
</span><span class='line'> * （3）闭包表达式都是无名闭包，使用轻量级语法，可以根据上下文环境捕获值。 
</span><span class='line'> *  
</span><span class='line'> * Swift中的闭包有很多优化的地方: 
</span><span class='line'> * (1)根据上下文推断参数和返回值类型 
</span><span class='line'> * (2)从单行表达式闭包中隐式返回（也就是闭包体只有一行代码，可以省略return） 
</span><span class='line'> * (3)可以使用简化参数名，如$0, $1(从0开始，表示第i个参数...) 
</span><span class='line'> * (4)提供了尾随闭包语法(Trailing closure syntax)</span></code></pre></td></tr></table></div></figure>


<p>为了举例说明闭包如何工作，请考虑内置的sorted函数。这个函数接受一个数组和一个闭包作为参数，并用这个闭包来确定应当如何对数组的各个元素进行排序。</p>

<p>sorted函数接受一个数组，并返回同一数组的一个有序版本。除了sorted函数之外，有一个sort函数，它接受一个数组，并将其修改为有序版本:</p>

<pre><code>var sortingInline=[2,3,5,19,1,10]
sort(&amp;sortingInline)
sortingInline //
</code></pre>

<p>要对一个数组进行排序，使小的数字出现在大数字之前，可以这样做：</p>

<pre><code>var numbers=[2,3,5,19,1,10]
var numbersSorted=sorted(numbers,{(n1:Int,n2:Int) - &gt;Bool in 
//进行排序，使得小数字出现在大数字之前
    return n2&gt;n1;
})
</code></pre>

<p>和函数一样，闭包可以接受参数。在上面的例子中，闭包指定了它所处理参数的名字和类型。但是，并不需要写的特别详细，编译器可以替我们推断参数的类型，非常类似于推断变量类型的方式。</p>

<pre><code>var numbersSortedReverse=sorted(numbers,{n1,n2 in 
     return n1&gt;n2;
})
</code></pre>

<p>如果不是特别在意参数拥有什么样的名字，可以让它更简便一些。如果省略了参数名，可以直接根据数字来引用每个参数（第一个参数名称为$0,第二个为$1）</p>

<p>另外，如果闭包只包含一行代码，可以省略return 关键字</p>

<pre><code>var numbersSortedAgain = sorted(numbers,{
       $1&gt;$0
})
</code></pre>

<p>如果一个闭包是函数调用中的最后一个参数，可以将它放在括号外面。这纯粹是为了提高可读性，不会改变闭包的工作方式</p>

<pre><code>var numbersSortedReversedAgain=sorted(numbers){
   $0&gt;$1
}
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* 
</span><span class='line'> * 如果函数需要一个闭包参数作为参数，且这个参数是最后一个参数，而这个闭包表达式又很长时， 
</span><span class='line'> * 使用尾随闭包是很有用的。尾随闭包可以放在函数参数列表外，也就是括号外。如果函数只有一个参数， 
</span><span class='line'> * 那么可以把括号()省略掉，后面直接跟着闭包。 
</span><span class='line'> */   
</span><span class='line'>// Array的方法map()就需要一个闭包作为参数  
</span><span class='line'>let strings = numbers.map { // map函数后面的()可以省略掉  
</span><span class='line'>  (var number) -&gt; String in  
</span><span class='line'>  var output = ""  
</span><span class='line'>  while number &gt; 0 {  
</span><span class='line'>    output = String(number % 10) + output   
</span><span class='line'>    number /= 10  
</span><span class='line'>  }  
</span><span class='line'>  return output  
</span><span class='line'>}  
</span><span class='line'>      
</span><span class='line'>/* 捕获值 
</span><span class='line'> * 闭包可以根据环境上下文捕获到定义的常量和变量。闭包可以引用和修改这些捕获到的常量和变量， 
</span><span class='line'> * 就算在原来的范围内定义为常量或者变量已经不再存在（很牛逼）。 
</span><span class='line'> * 在Swift中闭包的最简单形式是嵌套函数。 
</span><span class='line'> */   
</span><span class='line'>func increment(#amount: Int) -&gt; (() -&gt; Int) {  
</span><span class='line'>  var total = 0  
</span><span class='line'>  func incrementAmount() -&gt; Int {  
</span><span class='line'>    total += amount // total是外部函数体内的变量，这里是可以捕获到的  
</span><span class='line'>    return total  
</span><span class='line'>  }  
</span><span class='line'>  return incrementAmount // 返回的是一个嵌套函数（闭包）  
</span><span class='line'>}     
</span><span class='line'>      
</span><span class='line'>// 闭包是引用类型，所以incrementByTen声明为常量也可以修改total  
</span><span class='line'>let incrementByTen = increment(amount: 10)   
</span><span class='line'>incrementByTen() // return 10,incrementByTen是一个闭包  
</span><span class='line'>// 这里是没有改变对increment的引用，所以会保存之前的值  
</span><span class='line'>incrementByTen() // return 20     
</span><span class='line'>incrementByTen() // return 30     
</span><span class='line'>  
</span><span class='line'>let incrementByOne = increment(amount: 1)  
</span><span class='line'>incrementByOne() // return 1  
</span><span class='line'>incrementByOne() // return 2      
</span><span class='line'>incrementByTen() // return 40   
</span><span class='line'>incrementByOne() // return 3 </span></code></pre></td></tr></table></div></figure>


<h3>对象</h3>

<p>在swift中类看起来是这样的</p>

<pre><code>  class Vechicle {
    var color:String?
    var maxSpeed=80

    func description()-&gt;String{
      return "A\(self.color) vehicle";
    }
    func travel(){
       print("Traveling at \(maxSpeed) kph")
    }
}
</code></pre>

<p>  类中既包含了属性也包含方法。属性和方法都是类的组成部分，属性是变量，方法是函数。</p>

<p>  例如，要定义Vehicle类的一个实例，我们定义一个变量</p>

<pre><code>var redVehicle=Vehicle()
redVehicle.color="Red";
redVehicle.maxSpeed=100;
redVehicle.travel();
redVehicle.description()
</code></pre>

<h3>初始化与反初始化</h3>

<p>在swift中创建对象时，会调用一个被称为其初始化器的特殊方法。初始化器是用来为对象设定初始状态的方法。</p>

<p>除了初始化器之外，还有一个反初始化器，可以在对象消失时运行其中的代码。此方法在对象的retaincount数降到0时运行，就在要将该对象从内存中清除时调动。要想在对象永远消失之前进行一些必要的清理工作，这是最后一个机会。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class InitAndDeinitExample {
</span><span class='line'>    //指定的初始化器(也就是主初始化器)
</span><span class='line'>    init(){
</span><span class='line'>     print("I've been creted")
</span><span class='line'>    }
</span><span class='line'>    //便捷初始化器，是调用上述指定初始化器所必须的
</span><span class='line'>    convenience init(text:String){
</span><span class='line'>        self.init();//这是必须的
</span><span class='line'>        print("I was called with the convenience initializer!")
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //反初始化器
</span><span class='line'>    deinit{
</span><span class='line'>      print("I'm goint away!")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>//声明为可选类型
</span><span class='line'>var example:InitAndDeinitExample?
</span><span class='line'>//使用指定的初始化器
</span><span class='line'>example=InitAndDeinitExample()//I've been creted
</span><span class='line'>example=nil //I'm goint away!
</span><span class='line'>//使用便捷初始化器
</span><span class='line'>example=InitAndDeinitExample(text: "Hello"); //I was called with the convenience initializer!</span></code></pre></td></tr></table></div></figure>


<p>初始化器还可以返回nil.当初始化其不能成功地构造一个函数时，这一点很有用。例如，NSURL类有一个初始化器，它接受一个字符串，并将它转化为URL;如果这个字符串不是一个有效的URL,则初始化器返回nil.</p>

<p>要创建一个可以返回nil的初始化器，就在init关键字后面加一个问号，并在初始化器确定它不能成功地构造该对象时，return nil;</p>

<pre><code>    convenience init?(value:Int){

    self.init();
    if value &gt; 5{
        //不能初始化这个对象;返回nil,表示初始化失败
      return nil
    }
}
</code></pre>

<h3>属性</h3>

<p>类将其数据存储在属性中。在前面的例子中，属性是存储在对象中的一个简单值。在swift中，它称为存储属性。但是利用属性可以做很多事情，包括创建一些属性，利用代码来计算它们的值。这些属性称为计算属性，可以用它们提供一个更简单的接口，用来访问类中存储的信息。</p>

<p>例如，考虑一个代表矩形的类，它有一个width属性和一个height属性。再增加一个包含面积值的属性应该是很有用的，但你不想再有第三个属性，而是使用一个计算属性。从外部看来，这就是一个普通属性，但是从内部来说，它实际上是一个函数，可以在需要的时候计算其取值。</p>

<p>要定义一个计算属性，可以像声明存储属性一样声明一个变量，但在后面增加大括号({和})，在这些大括号内部，提供一个get部分，还可以提供有一个set部分；</p>

<pre><code>class Retangle {
var width:Double=0.0
var height:Double=0.0

var area:Double{
  //计算getter
    get{
        return width*height;
    }
    //计算setter
    set{
        width=sqrt(newValue)
        height=sqrt(newValue)
    }
}
}
</code></pre>

<p>  在上面的例子中，面积是通过计算长和宽的乘积而得到的，这个属性也是可设定的&ndash;如果设定了矩形的面积，代码就假定你希望创建一个正方形，并更新宽度和长度值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var rect=Retangle()
</span><span class='line'>rect.width=3.0
</span><span class='line'>rect.height=4.5
</span><span class='line'>rect.area
</span><span class='line'>rect.area=9</span></code></pre></td></tr></table></div></figure>


<p>在使用属性时，经常希望在一个属性发生变化时运行某些代码。为支持这一个功能，Swift属性允许向属性添加观察期，也就是一些小的代码块，可以在一个属性值即将发生变化之前运行。要创建一个属性观察期，需在属性后面添加一对大括号，并包含willSet和didSet代码块。这些块会分别获得一个参数-willSet在属性值发生变化之前被调用，它获得的是一个将要设定的值，而didSet获取的是一个旧值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class PropertyObserverExample {
</span><span class='line'>    var number:Int=0{
</span><span class='line'>        willSet(newNumber){
</span><span class='line'>           print("About to change to \(newNumber)")
</span><span class='line'>        }
</span><span class='line'>        didSet(oldNumber){
</span><span class='line'>          print("Just changed from \(oldNumber) to \(self.number)")
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var observer=PropertyObserverExample();
</span><span class='line'>observer.number=4</span></code></pre></td></tr></table></div></figure>


<p>我们还可以让属性变成惰性的。惰性属性就是知道首次访问时才会设定的属性。类的某些设置工作需要耗费大量的时间，利用惰性属性可以将这些工作推迟到将来真正需要时完成。为将一个属性定义为惰性的，可以在它的前面放一个lazy关键字。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SomeExpensiveClass {
</span><span class='line'>    init(id:Int){
</span><span class='line'>     print("Expensive class\(id) created")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class LazyPropertyExample {
</span><span class='line'>    var expensiveClass1=SomeExpensiveClass(id:1)
</span><span class='line'>    //注意，我们实际上正在构造一个类，但它被标记为惰性的
</span><span class='line'>    lazy var expensiveClass2=SomeExpensiveClass(id: 2)
</span><span class='line'>    
</span><span class='line'>    init(){
</span><span class='line'>        print("First class created!")
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var lazyExample=LazyPropertyExample()
</span><span class='line'>//输出"Expensive class1 created",然后输出"First class created"
</span><span class='line'>
</span><span class='line'>lazyExample.expensiveClass1 //不输出任何内容，它已经被创建
</span><span class='line'>lazyExample.expensiveClass2 //输出"Expensive class2 created!"</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，当创建lazyExample变量时，它立即创建SomeExpensiveClass的第一个实例。但是，第二个实例将一直等到代码中实际用到它时才会创建。</p>

<h3>协议</h3>

<p>协议可以看做是一个类的需求清单。定义协议，就是创建一个属性和方法清单，类可以声明他们拥有这些属性和方法。</p>

<p>协议看起来与类非常相似，只是我们没有提供任何实际的代码&ndash;只是定义了存在哪些种类的属性和函数，以及如何访问它们。</p>

<p>例如：</p>

<pre><code>protocol Blinking{
//这个属性必须（至少是）可获取的
var isBlining:Bool{get}

//这个属性必须是可获取的和可设置的
var blinkSpeed:Double{get set}

//这个函数必须存在，但是它做些什么由是实现者决定
func startBlinking(blinkSpeed:Double)-&gt;Void
</code></pre>

<p>}</p>

<p>有了协议，就可以创建遵守协议的类。当一个类遵守了协议时，就是向编译器做出了承诺：它实现了这个协议中列出的所有属性和方法，除此之外，它还可以有其他很多属性和方法，也可以遵守多个协议。</p>

<pre><code>class Light:Blinking {
var isBlining:Bool=false;
var blinkSpeed:Double=0.0

func startBlinking(blinkSpeed: Double) {
    print("I am now blikning")
    isBlining=true
    //我们说这里的self.blinkSpeed是为了帮助编译器
    //判断参数'blinkSpeed'和属性之间的区别
    self.blinkSpeed=blinkSpeed;
}
}  
</code></pre>

<p>调用如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>//可以是任何具有Blinking协议的对象
</span><span class='line'>var aBlinkThing:Blinking?
</span><span class='line'>
</span><span class='line'>aBlinkThing=Light();
</span><span class='line'>
</span><span class='line'>aBlinkThing!.startBlinking(4.0)
</span><span class='line'>
</span><span class='line'>aBlinkThing?.blinkSpeed</span></code></pre></td></tr></table></div></figure>


<h3>泛型</h3>

<p>Swift是一种静态类型化语言，这就是说，Swift编译器需要确切的了解你的代码正在处理什么类型的信息。这意味着你不能将字符串传送给打算用来出来日期的代码，而在Objective-c中是可能发生这种情况的。</p>

<p>利用泛型，在编写代码时，不需要准确地知道这些信息的类型。数组就是泛型的一个应用实例：数组实际上并没有对自己存储的数据进行任何操作，只是将他们存储为一个有序集合，事实上，数组就是泛型。</p>

<p>要创建一个泛型类型，可以像通常一样为对象命名，然后在两个尖括号之间指定任务泛型类型。传统上使用的术语是T.</p>

<pre><code>class Tree&lt;T&gt; {
var value:T
var children:[Tree&lt;T&gt;]=[]

init(value:T){
    self.value=value;
}

func addChild(value:T)-&gt;Tree&lt;T&gt;{
  let newChild=Tree&lt;T&gt;(value: value)
    children.append(newChild)
    return newChild;
}
}
</code></pre>

<p>一旦定义了一个泛型，就可以由它创建一个具体的非泛型类型。例如，可以使用刚刚创建的Tree类型，创建一个用于处理Int的版本和一个处理String的版本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//整数树
</span><span class='line'>let integerTree=Tree&lt;Int&gt;(value: 5)
</span><span class='line'>
</span><span class='line'>integerTree.addChild(10)
</span><span class='line'>integerTree.addChild(20)
</span><span class='line'>
</span><span class='line'>//字符串树
</span><span class='line'>let stringTree=Tree&lt;String&gt;(value: "hello")
</span><span class='line'>stringTree.addChild("YES")
</span><span class='line'>stringTree.addChild("swift")</span></code></pre></td></tr></table></div></figure>


<h3>序列化与反序列化</h3>

<p>我们还可以将对象转化为数据。为此，首先要使对象遵守NSObject和NSCoding协议，然后添加两个方法：encodeWithCoder,一个以NScoder为参数的初始化函数：</p>

<pre><code>class SerializableObject:NSObject,NSCoding {
var name:String?
func encodeWithCoder(aCoder: NSCoder) {
    aCoder.encodeObject(name!,forKey: "name")
}

override init(){
   self.name="My object"
}
required init(coder aDecoder:NSCoder){
   self.name=aDecoder.decodeObjectForKey("name") as? String
}
}
</code></pre>

<p>  这些对象与数据之间的相互转换非常简单</p>

<pre><code class="`"> let anObject=SerializableObject()

anObject.name="My thing that I'm saving"

//将它转换为数据
let objectConvertedToData=NSKeyedArchiver.archivedDataWithRootObject(anObject);

//将其转换回来，
//注意，此转换可能会失败，所以'unarchiveObjectWithData'返回一个可选值
//因此，使用‘as?’来查看它是否成功

let loadedObject=NSKeyedUnarchiver.unarchiveObjectWithData(objectConvertedToData) as? SerializableObject

loadedObject?.name
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用AFNetworking上传图片和视频]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/02/26/li-yong-afnetworkingshang-chuan-tu-pian-he-shi-pin/"/>
    <updated>2016-02-26T09:15:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/02/26/li-yong-afnetworkingshang-chuan-tu-pian-he-shi-pin</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>之前尝试过用原生的上传代码，但是比较麻烦，利用afnetworking进行上传还是很方便的。</p>

<p>文件上传后台服务器必须要有相应的代码支持，我们后台使用java做的，首先ios客户端要把上传的图片或者视频转换成标准的文件流，然后传给后台，才能顺利实现上传功能。</p>

<!--more-->


<h3>上传图片</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  上传图片
</span><span class='line'> */
</span><span class='line'>-(void)uploadPicture:(UIImage *)selectImg{
</span><span class='line'>    //房源id：houseId 经纪人姓名:agentName flag(0未审核)文件:file
</span><span class='line'>    NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:URL_UPLOADFILES parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData)
</span><span class='line'>                                    {
</span><span class='line'>                                        NSData *imgData=UIImageJPEGRepresentation(selectImg, 1.0);
</span><span class='line'>                                        [formData appendPartWithFileData:imgData name:@"file" fileName:@"ios.png" mimeType:@"image/jpeg"];
</span><span class='line'>                                        
</span><span class='line'>                                        NSData *data =[@"654321" dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>
</span><span class='line'>                                        [formData appendPartWithFormData:data name:@"houseAppKey"];
</span><span class='line'>                                        
</span><span class='line'>                                        NSData *data1 =[_houseID dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>                                        [formData appendPartWithFormData:data1 name:@"houseId"];
</span><span class='line'>                                        
</span><span class='line'>                                    }];
</span><span class='line'>    
</span><span class='line'>    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
</span><span class='line'>    NSURLSessionUploadTask *uploadTask;
</span><span class='line'>    
</span><span class='line'>    uploadTask = [manager
</span><span class='line'>                  uploadTaskWithStreamedRequest:request
</span><span class='line'>                  progress:nil
</span><span class='line'>                  completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
</span><span class='line'>                      [[UIManager shareInstance] hide];
</span><span class='line'>                      if (error) {
</span><span class='line'>                          MYLog(@"Error: %@", error);
</span><span class='line'>                      } else {
</span><span class='line'>                          NSDictionary *dict=responseObject;
</span><span class='line'>                          if(dict){
</span><span class='line'>                              NSInteger result=[dict[@"code"] integerValue];
</span><span class='line'>                              if(result==0){
</span><span class='line'>                                  NSString *msg=dict[@"msg"];
</span><span class='line'>                                  [[UIManager shareInstance] showSuccessWithMessage:msg duration:DURATIONTIME];
</span><span class='line'>                              }else{
</span><span class='line'>                                  [[UIManager shareInstance] showErrorWithMessage:@"上传失败" duration:DURATIONTIME];
</span><span class='line'>                              }
</span><span class='line'>                          }
</span><span class='line'>                      }
</span><span class='line'>                  }];
</span><span class='line'>    [uploadTask resume];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>上传视频</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark
</span><span class='line'>#pragma mark 上传视频
</span><span class='line'>-(void)updateVedio:(NSData *)vedioData{
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //房源id：houseId 经纪人姓名:agentName flag(0未审核)文件:file
</span><span class='line'>    NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:URL_UPLOADFILES parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData)
</span><span class='line'>                                    {
</span><span class='line'>                                    
</span><span class='line'>                                       [formData appendPartWithFileData:vedioData name:@"video1" fileName:@"video1.mov" mimeType:@"video/quicktime"];
</span><span class='line'>                                        
</span><span class='line'>                                        NSData *data =[@"654321" dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>                                        
</span><span class='line'>                                        [formData appendPartWithFormData:data name:@"houseAppKey"];
</span><span class='line'>                                        
</span><span class='line'>                                        NSData *data1 =[_houseID dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>                                        [formData appendPartWithFormData:data1 name:@"houseId"];
</span><span class='line'>                                        
</span><span class='line'>                                    }];
</span><span class='line'>    
</span><span class='line'>    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
</span><span class='line'>    NSURLSessionUploadTask *uploadTask;
</span><span class='line'>    
</span><span class='line'>    uploadTask = [manager
</span><span class='line'>                  uploadTaskWithStreamedRequest:request
</span><span class='line'>                  progress:nil
</span><span class='line'>                  completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
</span><span class='line'>                      [[UIManager shareInstance] hide];
</span><span class='line'>                      if (error) {
</span><span class='line'>                          MYLog(@"Error: %@", error);
</span><span class='line'>                      } else {
</span><span class='line'>                          NSDictionary *dict=responseObject;
</span><span class='line'>                          if(dict){
</span><span class='line'>                              NSInteger result=[dict[@"code"] integerValue];
</span><span class='line'>                              if(result==0){
</span><span class='line'>                                  NSString *msg=dict[@"msg"];
</span><span class='line'>                                  [[UIManager shareInstance] showSuccessWithMessage:msg duration:DURATIONTIME];
</span><span class='line'>                              }else{
</span><span class='line'>                                  [[UIManager shareInstance] showErrorWithMessage:@"上传失败" duration:DURATIONTIME];
</span><span class='line'>                              }
</span><span class='line'>                          }
</span><span class='line'>                      }
</span><span class='line'>                  }];
</span><span class='line'>    [uploadTask resume];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>图片多选</h3>

<p>如果想要一次上传多张图片的话，可能会用到
 <a href="https://github.com/chiunam/CTAssetsPickerController">AssetsPickerController</a><br/>
 这个第三方库</p>

<p> 我在代码中用法如下:</p>

<pre><code class="`"> -(void)takeVedios:(UIButton *)btn{
    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status){
        dispatch_async(dispatch_get_main_queue(), ^{

            // init picker
            CTAssetsPickerController *picker = [[CTAssetsPickerController alloc] init];
            // set delegate
            picker.delegate = self;
            // Optionally present picker as a form sheet on iPad
            if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
                picker.modalPresentationStyle = UIModalPresentationFormSheet;

            // present picker
            [self presentViewController:picker animated:YES completion:nil];
        });
    }];
}
</code></pre>

<h3>补充</h3>

<p>上传的时候最好有进度条进行提示，这是比较好的用户体验，AFNetworking官方也给出了上传下载的进度条实例，我这块之前没有做出很好的效果，以后有时间了再研究一下。</p>

<p>我用的AF的版本号是2.6的可能和最新版本的AF上传的代码有点区别，进度条的展示可能也有点区别，AFNetworking中的进度条用了NSProcess来显示，NSProcess可以用 KVO来监控实现，</p>

<p>代码片段:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  上传临时图片到服务器
</span><span class='line'> *
</span><span class='line'> *  @param selectImg 要传入的图片
</span><span class='line'> *  @param callback  回调函数
</span><span class='line'> */
</span><span class='line'>-(void)uploadToServerTEMP:(UIImage *)selectImg
</span><span class='line'>      UploadTEMPFileBlock:(UploadTEMPFileBlock)callback{
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:URL_UPLOADTEMP parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData)
</span><span class='line'>                                    {
</span><span class='line'>                                        NSData *imgData=UIImageJPEGRepresentation(selectImg, 1.0);
</span><span class='line'>                                        [formData appendPartWithFileData:imgData name:@"Filedata" fileName:@"ios.png" mimeType:@"image/jpeg"];
</span><span class='line'>                                    }];
</span><span class='line'>    
</span><span class='line'>    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
</span><span class='line'>    NSURLSessionUploadTask *uploadTask;
</span><span class='line'>    
</span><span class='line'>    NSProgress *progress = nil;
</span><span class='line'>    
</span><span class='line'>    uploadTask = [manager
</span><span class='line'>                  uploadTaskWithStreamedRequest:request
</span><span class='line'>                  progress:&progress
</span><span class='line'>                  completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
</span><span class='line'>                      if (error) {
</span><span class='line'>                          MYLog(@"Error: %@", error);
</span><span class='line'>                          callback(nil,error);
</span><span class='line'>                      } else {
</span><span class='line'>                          NSDictionary *dict=responseObject;
</span><span class='line'>                          if(dict){
</span><span class='line'>                              callback(dict,nil);
</span><span class='line'>                          }
</span><span class='line'>                          //[progress removeObserver:self forKeyPath:@"fractionCompleted"];
</span><span class='line'>                      }
</span><span class='line'>                  }];
</span><span class='line'>    
</span><span class='line'>    [progress addObserver:self
</span><span class='line'>               forKeyPath:@"fractionCompleted"
</span><span class='line'>                  options:NSKeyValueObservingOptionNew
</span><span class='line'>                  context:NULL];
</span><span class='line'>    [uploadTask resume];
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)observeValueForKeyPath:(NSString *)keyPath
</span><span class='line'>                      ofObject:(id)object change:(NSDictionary *)change context:(void *)context
</span><span class='line'>{
</span><span class='line'>    //[super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
</span><span class='line'>    
</span><span class='line'>    if ([keyPath isEqualToString:@"fractionCompleted"] && [object isKindOfClass:[NSProgress class]]) {
</span><span class='line'>        NSProgress *progress = (NSProgress *)object;
</span><span class='line'>        NSLog(@"Progress is %f", progress.fractionCompleted);
</span><span class='line'>      
</span><span class='line'>        [_processView setProgress:progress.fractionCompleted animated:YES];
</span><span class='line'>        
</span><span class='line'>         NSLog(@"progress.totalUnitCount:%lld;progress.completedUnitCount=%lld",progress.totalUnitCount,progress.completedUnitCount);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>经过检验，进度条显示有点问题，可能不是实时显示，进度条显示的不太准确。需要后期优化。</p>
]]></content>
  </entry>
  
</feed>
