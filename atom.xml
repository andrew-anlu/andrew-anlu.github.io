<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[安路的技术博客]]></title>
  <link href="http://andrew-anlu.github.io/atom.xml" rel="self"/>
  <link href="http://andrew-anlu.github.io/"/>
  <updated>2016-05-04T18:14:54+08:00</updated>
  <id>http://andrew-anlu.github.io/</id>
  <author>
    <name><![CDATA[安路]]></name>
    <email><![CDATA[andrewswift1987@gamil.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/catransform3d/"/>
    <updated>2016-05-04T17:25:54+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/catransform3d</id>
    <content type="html"><![CDATA[<h1>图层的几个坐标系</h1>

<p>对于ios来说，坐标系的(0,0)点在左下角，就是越往下，Y值越大。越向右，X值就越大.</p>

<!--more-->


<p>一个图层的frame,它是position,bounds,anchorPoint和transform尚需经的一部分。</p>

<p>设置一个新的frame将会相应的改变图层的position和bounds,但是frame本身并没有保存。</p>

<h3>position</h3>

<p>是一个CGPoint值，它指定图层相当于它父图层的位置，该值基于父图层的坐标系</p>

<h3>bounds</h3>

<p>是一个CGRect值，指定图层的大小(bounds.size)和图层的原点(bounds.origin)，这个坐标系是基于自身的。如果改变bounds的origin,那么在该图层的子图层，左边会跟着改变。也就是说，改变自身的坐标系，本身在福图层的位置不变，但它上面的自图层位置变化</p>

<h3>anchorPoint</h3>

<p>是一个CGPoint值，它是指定了一个基于bounds的符合坐标系的位置。锚点(anchor point)制定了bounds相对于position的值，同时也作为一个变化时候的中心点。锚点使用空间坐标系取值范围是0-1之间的数。默认是0.5,也就是图标的中心点，如果是(0,0)那么图层向左上方移动。如果是(1,1)就向右下方移动。</p>

<p>看下面的两个图，就能够清晰的看出锚点变化所带来的不一样。（此图为Mac OS 坐标系，如果是iOS，那么（0，0）点在图的左上方。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-ec88270eb7d8c9a0.png" alt="1" /></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-bfe77d9ab6636ce0.png" alt="2" /></p>

<p>对于anchorPoint的解释在ios中如图:</p>

<p>下图中的红点位置就是锚点的位置，默认是(0.5,0.5)。在对图像进行变化时，都是按照这个店来进行缩放，偏移等。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-76ff5832ae84e2f6.png" alt="1" /></p>

<p>一旦修改锚点位置为:(0,0),那么图像就会变成下图.各种变换就会按照这个点来运动.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-e6bcb36d43e12c4d.png" alt="2" /></p>

<p>所以说在ios系统中，锚点的坐标系是:左上角为(0,0),右下角为(1,1)。</p>

<p>根据此图，再理解上面的定义，就直观多了。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-47294f41d81081da.png" alt="1" /></p>

<h1>图层的几何变换</h1>

<p>可以通过矩阵来改变一个图层的几何形状。</p>

<p><em>CATransform3D</em>的数据结构定义了一个同质的三维变换(4*4 CGFloat值的矩阵),用于图层的旋转，缩放，偏移和应用的透视。</p>

<p>图层的2歌属性指定了变换矩阵:transform和sublayerTransform。</p>

<h3>transform</h3>

<p>是结合anchorPoint的位置来对图层和图层上的子图层进行变化</p>

<h3>sublayerTransform</h3>

<p>是结合anchorPoint的位置来对图层的子图层进行变化，不包括本身</p>

<h3>CATransform3DIdentity</h3>

<p>是单位矩阵，该矩阵没有缩放，旋转，歪斜，透视。该矩阵应用到图层上，就是设置默认值。</p>

<h1>变换函数</h1>

<h3>CATransform3DMakeTranslation</h3>

<p>官方文档:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Returns a transform that translates by '(tx, ty, tz)'. t' = [1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].
</span><span class='line'>
</span><span class='line'>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)。</span></code></pre></td></tr></table></div></figure>


<p>对于CATransform3D来说，它是一个4*4的 CGFloat的矩阵。而上面的值:<code>[1 0 0 0; 0 1 0 0; 0 0 1 0; tx ty tz 1].</code>给竖起来后，就发现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1    0    0    0
</span><span class='line'>
</span><span class='line'>0    1    0    0
</span><span class='line'>
</span><span class='line'>0    0    1    0
</span><span class='line'>
</span><span class='line'>tx   ty   tz   1</span></code></pre></td></tr></table></div></figure>


<p>竖起来就很明显了。</p>

<p>CATransform3D又是一个结构，他有自己的一个公式，可以进行套用.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct CATransform3D
</span><span class='line'>
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>CGFloat    m11（x缩放）,    m12（y切变）,      m13（旋转）,    m14（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m21（x切变）,    m22（y缩放）,      m23（）       ,    m24（）;
</span><span class='line'>
</span><span class='line'>CGFloat    m31（旋转）  ,    m32（ ）  ,      m33（）       ,    m34（透视效果，要操作的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;
</span><span class='line'>
</span><span class='line'>CGFloat    m41（x平移）,    m42（y平移）,    m43（z平移） ,    m44（）;
</span><span class='line'>
</span><span class='line'>};
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>根据这个公式就一目了然了。</p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)参数的意思就是 <em>tx:：x平移。  ty：y平移。  tz：z平移</em></p>

<p>CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tx：X轴偏移位置，往下为正数。
</span><span class='line'>
</span><span class='line'>ty：Y轴偏移位置，往右为正数。
</span><span class='line'>
</span><span class='line'>tz：Z轴偏移位置，往外为正数。</span></code></pre></td></tr></table></div></figure>


<p>举个栗子:</p>

<p>如果有两个图层，一个是绿色的，一个是红色的，先加载绿色，后加载红色</p>

<p>tx,ty的偏移就先不说了</p>

<p>如果绿色的tz为-10，红色的tz为0，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-7d642630070e7554.png" alt="1" /></p>

<p>如果绿色的tz为0,红色的tz为-10，效果如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-29ecdd06f03578f4.png" alt="2" /></p>

<p>对于tz来说，tz越大，那么图层就越靠近屏幕，值越小，图层越往里（离屏幕越远）</p>

<h4>CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz);</h4>

<p>t:就是上一个函数，其它都一样
就可以理解为函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);</h4>

<p><em>sx:</em> x轴缩放，代表一个缩放比例，一般都是0-1之间的数字
<em>sy:</em> y轴上缩放
<em>sz:</em> 整体比例变换时，也就是m11(sx) == m22(sy)时，若m33(sz) > 1时，图形整体缩小，若0&lt;1,图形整体放大，若m33(sz) &lt; 0时，发生关于原点的对称等比变换。</p>

<p>当sx = 1时，sy = 1时，如图:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-04771b49561f6d76.png" alt="1" /></p>

<p>当sx=0.5,sy=0.5时，如图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1511481-6023b3794fd9917d.png" alt="2" /></p>

<h4>CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz)</h4>

<p>t：就是上一个函数。其他的都一样。</p>

<p>就可以理解为：函数的叠加，效果的叠加</p>

<h4>CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);</h4>

<p>旋转效果</p>

<p>angle：旋转的弧度，所以要把角度转换成弧度：角度 * M_PI / 180</p>

<p>x:向X轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>y:向Y轴方向旋转。值范围-1 &mdash; 1之间</p>

<p>z:向Z轴方向旋转。值范围-1 &mdash; 1之间</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime运行时入门]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men/"/>
    <updated>2016-05-04T14:36:36+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/05/04/runtimeyun-xing-shi-ru-men</id>
    <content type="html"><![CDATA[<h2>什么是Rumtime</h2>

<p>我们写的代码在程序运行过程中都会被转化成runtime的C代码执行，例如<code>[target dosomething]</code>会被转化成 <code>objc_msgSend(target,@selector(doSomething));</code>.</p>

<!--more-->


<p>oc中一切都被设计成了对象，我们都知道一个类被初始化成一个实例，这个实例是一个对象，实际上一个类本质上也是一个对象，在runTime中用结构体表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 描述类中的一个方法
</span><span class='line'>typedef struct objc_method *Method;
</span><span class='line'>
</span><span class='line'>/// 实例变量
</span><span class='line'>typedef struct objc_ivar *Ivar;
</span><span class='line'>
</span><span class='line'>/// 类别Category
</span><span class='line'>typedef struct objc_category *Category;
</span><span class='line'>
</span><span class='line'>/// 类中声明的属性
</span><span class='line'>typedef struct objc_property *objc_property_t;</span></code></pre></td></tr></table></div></figure>


<p>类在rumtime中的表示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//类在runtime中的表示
</span><span class='line'>struct objc_class {
</span><span class='line'>    Class isa;//指针，顾名思义，表示是一个什么，
</span><span class='line'>    //实例的isa指向类对象，类对象的isa指向元类
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__
</span><span class='line'>    Class super_class;  //指向父类
</span><span class='line'>    const char *name;  //类名
</span><span class='line'>    long version;
</span><span class='line'>    long info;
</span><span class='line'>    long instance_size
</span><span class='line'>    struct objc_ivar_list *ivars //成员变量列表
</span><span class='line'>    struct objc_method_list **methodLists; //方法列表
</span><span class='line'>    struct objc_cache *cache;//缓存
</span><span class='line'>    //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
</span><span class='line'>    struct objc_protocol_list *protocols //协议列表
</span><span class='line'>    #endif
</span><span class='line'>} OBJC2_UNAVAILABLE;
</span><span class='line'>/* Use `Class` instead of `struct objc_class *` */</span></code></pre></td></tr></table></div></figure>


<h2>获取列表</h2>

<p>有时会有这样的需求，我们需要知道当前类中每个属性的名字(比如字典转模型，字典的key和模型对象的属性名字不匹配).</p>

<p>我们可以通过runtime的一系列方法获取类的一些信息(包括属性列表，方法列表，成员变量等)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> unsigned int count;
</span><span class='line'>    //获取属性列表
</span><span class='line'>    objc_property_t *propertyList = class_copyPropertyList([self class], &count);
</span><span class='line'>    for (unsigned int i=0; i&lt;count; i++) {
</span><span class='line'>        const char *propertyName = property_getName(propertyList[i]);
</span><span class='line'>        NSLog(@"property----&gt;%@", [NSString stringWithUTF8String:propertyName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取方法列表
</span><span class='line'>    Method *methodList = class_copyMethodList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Method method = methodList[i];
</span><span class='line'>        NSLog(@"method----&gt;%@", NSStringFromSelector(method_getName(method)));
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取成员变量列表
</span><span class='line'>    Ivar *ivarList = class_copyIvarList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Ivar myIvar = ivarList[i];
</span><span class='line'>        const char *ivarName = ivar_getName(myIvar);
</span><span class='line'>        NSLog(@"Ivar----&gt;%@", [NSString stringWithUTF8String:ivarName]);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //获取协议列表
</span><span class='line'>    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);
</span><span class='line'>    for (unsigned int i; i&lt;count; i++) {
</span><span class='line'>        Protocol *myProtocal = protocolList[i];
</span><span class='line'>        const char *protocolName = protocol_getName(myProtocal);
</span><span class='line'>        NSLog(@"protocol----&gt;%@", [NSString stringWithUTF8String:protocolName]);
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><em>注意：不要忘记在类的顶部导入头文件<code>#import &lt;objc/runtime.h&gt;</code></em></p>

<h2>方法调用</h2>

<p>让我们看一下在运行时方法的调用</p>

<p>如果用实例对象调用实例方法，回到实例的isa指针指向的对象（也就是类对象）操作。如果调用的是类方法，就回到类对象的isa指针指向的对象（也就是元类对象）中操作。</p>

<ol>
<li>首先，在相应操作的对象中的缓存方法列表汇总找调用的方法，如果找到，转向相应实现并执行</li>
<li>如果没有找到，在相应操作的对象 中的方法列表中找调用的方法，如果找到，转向相应的实现执行</li>
<li>如果没有找到，去父类指针所指向的对象中执行1,2</li>
<li>以此类推，如果一直到根类还没找到，转向拦截调用</li>
<li>如果没有重写拦截调用的方法，程序报错</li>
</ol>


<h2>拦截调用</h2>

<p>在方法调用中说到了，如果没有找到方法就会转向拦截调用。
什么是拦截调用呢</p>

<p>拦截调用就是，在找不到调用的方法程序崩溃之前，你有机会通过重写 NSObject的四个方法来处理.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)resolveClassMethod:(SEL)sel;
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel;
</span><span class='line'>//后两个方法需要转发到其他的类处理
</span><span class='line'>- (id)forwardingTargetForSelector:(SEL)aSelector;
</span><span class='line'>- (void)forwardInvocation:(NSInvocation *)anInvocation;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>第一个方法是当你调用一个不存在的类或者方法的时候，会调用这个方法，默认返回NO,你可以加上自己的处理然后返回YES</li>
<li>第二个方法和第一个相似，只不过处理的是实例方法</li>
<li>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要你返回一个有这个方法的target</li>
<li>第四个方法是将你调用的不存在的方法打包成<code>NSinvocation</code>传给你，做完你自己的处理后，调用<em>invokeWithTarget:</em>方法让某个target触发这个方法</li>
</ul>


<h2>动态添加方法</h2>

<p>重写了拦截调用的方法并且返回了YES，我们要怎么处理呢?
有一个办法就是根据传进来的<em>sel</em>类型的selector动态添加一个方法。</p>

<p>首先从外部隐式调用一个不存在的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//隐式调用方法
</span><span class='line'>[target performSelector:@selector(resolveAdd:) withObject:@"test"];</span></code></pre></td></tr></table></div></figure>


<p>然后，在target对象内部重写拦截调用的方法，动态添加方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void runAddMethod(id self, SEL _cmd, NSString *string){
</span><span class='line'>    NSLog(@"add C IMP ", string);
</span><span class='line'>}
</span><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel{
</span><span class='line'>
</span><span class='line'>    //给本类动态添加一个方法
</span><span class='line'>    if ([NSStringFromSelector(sel) isEqualToString:@"resolveAdd:"]) {
</span><span class='line'>        class_addMethod(self, sel, (IMP)runAddMethod, "v@:*");
</span><span class='line'>    }
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中<code>class_addMethod</code>的四个参数分别是:</p>

<ol>
<li><em>Class cls</em>给那个类添加方法，本例中是self</li>
<li><em>SEL name</em>添加的方法，本例中是重写的拦截调用传进来selector</li>
<li><em>IMP imp</em>方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用<code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code>获得方法的实现</li>
<li><code>"v@:*"</code>方法的签名，代表有一个参数的方法，返回值是void,如果是<code>i</code>，就是返回int</li>
</ol>


<h2>关联对象</h2>

<p>现在你准备用系统的一个类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。</p>

<p>这种情况的一般解决办法就是继承。</p>

<p>但是只增加一个属性，就去继承一个类，总是觉得太麻烦</p>

<p>这个时候，runtime的关联属性就发挥它的作用了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//首先定义一个全局变量，用它的地址作为关联对象的key
</span><span class='line'>static char associatedObjectKey;
</span><span class='line'>//设置关联对象
</span><span class='line'>objc_setAssociatedObject(target, &associatedObjectKey, @"添加的字符串属性", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象
</span><span class='line'>NSString *string = objc_getAssociatedObject(target, &associatedObjectKey);
</span><span class='line'>NSLog(@"AssociatedObject = %@", string);</span></code></pre></td></tr></table></div></figure>


<p><code>objc_setAssociatedObject</code>的四个参数:</p>

<ol>
<li><em>id object</em> 给谁设置关联对象</li>
<li><code>const void *key</code>关联对象唯一的key,获取时会用到</li>
<li><em>id value</em>关联对象</li>
<li><em>objc_AssociationPolicy</em>关联策略，共有以下几种策略</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum {
</span><span class='line'>    OBJC_ASSOCIATION_ASSIGN = 0,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, 
</span><span class='line'>    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
</span><span class='line'>    OBJC_ASSOCIATION_RETAIN = 01401,
</span><span class='line'>    OBJC_ASSOCIATION_COPY = 01403 
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>如果你熟悉OC，看名字就能知道几种策略的意思了吧</p>

<p><code>objc_getAssociatedObject</code>用来获取关联属性，它用到了两个参数:</p>

<ol>
<li><em>id object</em>获取谁的关联对象</li>
<li><code>const void *key</code>根据这个唯一的key获取关联对象</li>
</ol>


<p>其实，你还可以吧添加和获取关联对象的方法卸载你需要用到这个功能类的类别中，方便调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加关联对象
</span><span class='line'>- (void)addAssociatedObject:(id)object{
</span><span class='line'>    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
</span><span class='line'>}
</span><span class='line'>//获取关联对象
</span><span class='line'>- (id)getAssociatedObject{
</span><span class='line'>    return objc_getAssociatedObject(self, _cmd);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em></p>

<p>这里我们把<code>getAssociatedObject</code>方法的地址作为唯一的key,<em>_cmd</em>代表当前调用方法的地址</p></blockquote>

<h2>方法交换</h2>

<p>方法交换，顾名思义，及时将两个方法的实现交换。例如，将A方法和B方法交换，调用A方法的时候，就会执行B方法的代码，反之亦然。</p>

<p>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。
方式一:继承系统的类，重写方法.
方式二:使用runtime,交换方法.</p>

<p>参考网上的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "UIViewController+swizzling.h"
</span><span class='line'>#import &lt;objc/runtime.h&gt;
</span><span class='line'>
</span><span class='line'>@implementation UIViewController (swizzling)
</span><span class='line'>
</span><span class='line'>//load方法会在类第一次加载的时候被调用
</span><span class='line'>//调用的时间比较靠前，适合在这个方法里做方法交换
</span><span class='line'>+ (void)load{
</span><span class='line'>    //方法交换应该被保证，在程序中只会执行一次
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>
</span><span class='line'>        //获得viewController的生命周期方法的selector
</span><span class='line'>        SEL systemSel = @selector(viewWillAppear:);
</span><span class='line'>        //自己实现的将要被交换的方法的selector
</span><span class='line'>        SEL swizzSel = @selector(swiz_viewWillAppear:);
</span><span class='line'>        //两个方法的Method
</span><span class='line'>        Method systemMethod = class_getInstanceMethod([self class], systemSel);
</span><span class='line'>        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);
</span><span class='line'>
</span><span class='line'>        //首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
</span><span class='line'>        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
</span><span class='line'>        if (isAdd) {
</span><span class='line'>            //如果成功，说明类中不存在这个方法的实现
</span><span class='line'>            //将被交换方法的实现替换到这个并不存在的实现
</span><span class='line'>            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
</span><span class='line'>        }else{
</span><span class='line'>            //否则，交换两个方法的实现
</span><span class='line'>            method_exchangeImplementations(systemMethod, swizzMethod);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)swiz_viewWillAppear:(BOOL)animated{
</span><span class='line'>    //这时候调用自己，看起来像是死循环
</span><span class='line'>    //但是其实自己的实现已经被替换了
</span><span class='line'>    [self swiz_viewWillAppear:animated];
</span><span class='line'>    NSLog(@"swizzle");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>在一个自己定义的视图控制器中重写<em>viewWillAppear</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)viewWillAppear:(BOOL)animated{
</span><span class='line'>    [super viewWillAppear:animated];
</span><span class='line'>    NSLog(@"viewWillAppear");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac上如何把视频转成.Gif]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif/"/>
    <updated>2016-04-29T12:56:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/29/macshang-ru-he-ba-shi-pin-zhuan-cheng-dot-gif</id>
    <content type="html"><![CDATA[<p>之前看到很多github上的开源项目都带.gif的演示效果，感觉很好，今天就试着制作了一下，今天把我的制作过程记录下来，方便他人参考。</p>

<!--more-->


<h2>录制视频</h2>

<p>mac上自带的Quicktime就可以录制视频，选择录制屏幕</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160429-0.png" alt="1" /></p>

<p>录制完之后是 .mov 的后缀视频文件</p>

<h2>通过命令行转换</h2>

<p>在苹果系统上，可以通过命令行的方式转换视频，首先假定你的机器上已经安装了<a href="http://www.brew.sh">homebrew</a>.</p>

<p>然后打开终端，安装<a href="http://baike.baidu.com/link?url=H-RabHoLq9tR0Zxn-jduRSC7NAlSBkEjjsRnXEJ7Rw9RFE6dUNBnYyXidoiXNGCyOWKdcAtQMg-J8x_hFPSg5K">ffmpeg</a>插件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install ffmpeg</span></code></pre></td></tr></table></div></figure>


<p>然后定位到正确的目录，（有视频文件的那个目录，比如 Desktop）,假定你的视频名字是<code>ScreenFlow.mov</code>,你运行下面的命令就能生成GIF:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ffmpeg -i ScreenFlow.mov -pix_fmt rgb24 output.gif</span></code></pre></td></tr></table></div></figure>


<p>你会注意到生成文件很大，可以通过<a href="http://baike.baidu.com/link?url=WENMRejdDuoS2eXPiXrnvF2ohwpbTAe5oW_SOTsr2k099YbjyU4wCi-ngV31jzxvP0TvC-INM0FBcUk1sEDWQK"> image magick</a>工具来减少大小</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install imagemagick</span></code></pre></td></tr></table></div></figure>


<p>运行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ convert -layers Optimize output.gif output_optimized.gif</span></code></pre></td></tr></table></div></figure>


<h2>通过软件生成.GIF</h2>

<p><a href="http://gifbrewery.com">GifBrewery</a>是一款GIF动态图片制作工具. 支持将视频文件剪裁输出成GIF动态图片。</p>

<p>并且支持裁剪视频的长度，本人感觉挺好用的。</p>

<h2>上传到云端</h2>

<p>最后把制作好的.gif图片上传到云端就行了，比如 dropbox,七牛,阿里云等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewController转场动画]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua/"/>
    <updated>2016-04-28T15:54:40+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/28/viewcontrollerzhuan-chang-dong-hua</id>
    <content type="html"><![CDATA[<h2>自定义转场动画</h2>

<p>ios7中最让我激动的特性之一就是提供了新的API来支持自定义ViewController之间的转场动画。</p>

<!--more-->


<p>在开始研究新的API之间，我们先看看ios7中 navigation controller之间默认的行为发生了那些改变:在navigation controller中，切换两个view controller的动画变得更有交互性。比方说你想要pop一个view controller出去，你可以用手指从屏幕的左边缘开始拖动，慢慢地把当前的viewcontroller向右拖出屏幕去.</p>

<p>接下来，我们来看看这个新API。很有趣，这部分API大量的使用了协议而不是具体的对象。这初看起来有点奇怪，但是我更喜欢这样的设计，因为这种设计给我们这些开发者更大的灵活性。下面，让我们来做件简单的事情:在Navigation Controller中，实现一个自定义的push动画效果，为了完成这个任务，需要实现UINavigationControllerDelegate中的新方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
</span><span class='line'>                   navigationController:(UINavigationController *)navigationController
</span><span class='line'>        animationControllerForOperation:(UINavigationControllerOperation)operation
</span><span class='line'>                     fromViewController:(UIViewController*)fromVC
</span><span class='line'>                       toViewController:(UIViewController*)toVC
</span><span class='line'>{
</span><span class='line'>    if (operation == UINavigationControllerOperationPush) {
</span><span class='line'>        return self.animator;
</span><span class='line'>    }
</span><span class='line'>    return nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码可以看出，我们可以根据不同的操作(push或pop)返回不同的animator.我们可以把anmitor存到一个属性中，从而在多个操作之间实现共享，或者我们也可以为每个操作都创建一个新的animator对象，这里的灵活性很多。</p>

<p>为了让动画运行起来，我们创建一个自定义类，并且实现<code>UIViewControllerAnimatedTransitioning</code>这个协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Animator : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这个协议要求我们实现两个方法，其中一个定义了动画的持续时间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    return 0.25;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另一个方法描述整个动画的执行效果 ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext
</span><span class='line'>{
</span><span class='line'>    UIViewController* toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
</span><span class='line'>    UIViewController* fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
</span><span class='line'>    [[transitionContext containerView] addSubview:toViewController.view];
</span><span class='line'>    toViewController.view.alpha = 0;
</span><span class='line'>
</span><span class='line'>    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformMakeScale(0.1, 0.1);
</span><span class='line'>        toViewController.view.alpha = 1;
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        fromViewController.view.transform = CGAffineTransformIdentity;
</span><span class='line'>        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
</span><span class='line'>
</span><span class='line'>    }];
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的例子汇总，你可以看到如何运用洗衣的：这个方法中通过接受一个类型为<code>id&lt;UIViewControllerContextTransitioning&gt;</code>的参数，来获取transition context.值的注意的是，执行完动画之后，我们需要调用transitionContext的<code>completeTransition :</code>这个方法来更新ViewController的状态。剩下的代码和ios7之前的一样了，我们从transition context 中得到了需要做转场的两个View controller,然后使用最简单的Uiview animation来实现转场动画。这就是全部代码了，我们已经实现了缩放效果的转场动画了。</p>

<p>注意，这里只是为push操作实现了自定义效果的转场动画，对于pop操作，还是会使用默认的滑动效果，另外，上面我们实现的转场动画无法交互，下面我们就来看看解决这个问题。</p>

<h2>交互式的转场动画</h2>

<p>想要动画变地交互非常简单，我们只需要覆盖另一个UINavigationControllerDelegate的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController*)navigationController
</span><span class='line'>                          interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController
</span><span class='line'>{
</span><span class='line'>    return self.interactionController;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，在非交互式动画效果中，该方法返回nil.</p>

<p>这里返回的interaction controller是<code>UIPercentDrivenInteractionTransition</code>类的一个实例，开发者不需要任何配置就可以工作。我们创建了一个拖动收拾(Pan REcognizer),下面是处理该手势的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (panGestureRecognizer.state == UIGestureRecognizerStateBegan) {
</span><span class='line'>    if (location.x &gt;  CGRectGetMidX(view.bounds)) {
</span><span class='line'>        navigationControllerDelegate.interactionController = [[UIPercentDrivenInteractiveTransition alloc] init];
</span><span class='line'>        [self performSegueWithIdentifier:PushSegueIdentifier sender:self];
</span><span class='line'>    }
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>只有当用户从屏幕的右半部分开始触摸的时候，我们才把下一次动画效果设置为交互的（通过设置interactionController这个属性来实现），然后执行方法performSegueWithIdentifier:（如果你不是使用的storyboards,那么就直接调用pushViewController&hellip;这类方法）。为了让转场动画持续进行，我们需要调用 interaction controller的一个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateChanged) {
</span><span class='line'>    CGFloat d = (translation.x / CGRectGetWidth(view.bounds)) * -1;
</span><span class='line'>    [interactionController updateInteractiveTransition:d];
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>该方法会根据用户手指拖动的距离计算一个百分比，切换的动画效果也随着这个百分比来走，最酷的是，interaction controller会和animation controller一起协作，我们只使用了简单的UIView animation的动画效果，但是interaction controller却控制了动画的执行进度，我们并不需要吧interaction controller和Animation controller关联起来，因为所有这些系统都以一种解耦的方式自动地替我们完成了。</p>

<p>最后,我们需要更具用户收拾的停止状态来判断该操作是结束还是取消，先调用interaction controller 中对应的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>else if (panGestureRecognizer.state == UIGestureRecognizerStateEnded) {
</span><span class='line'>    if ([panGestureRecognizer velocityInView:view].x &lt; 0) {
</span><span class='line'>        [interactionController finishInteractiveTransition];
</span><span class='line'>    } else {
</span><span class='line'>        [interactionController cancelInteractiveTransition];
</span><span class='line'>    }
</span><span class='line'>    navigationControllerDelegate.interactionController = nil;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，当切换完成或者取消的时候，记得把interaction controller设置为nil.因为如果下一次的转场是非交互的，我们不应该返回这个旧的interaction controller。</p>

<p>现在我们已经实现了一个完全自定义的可交互的转场动画了。通过简单的手势识别和UIKIT提供的一个类，用几行代码就达到完成了。对于大部分的应用场景，你读到这就够用了，使用上面提到的方法就可以达到你想要的动画效果了。但如果你想更深入了解转场动画或者交互效果进行深度定制，请继续阅读下面的内容。</p>

<h3>完整工程下载</h3>

<p><a href="https://github.com/TLiOSDemo/CustomTransitionController/archive/master.zip">完整的代码在这里下载</a></p>

<h2>使用GPUImage定制动画</h2>

<p>下面我们就看看如何真正的，彻底的定制动画效果。这一次我们不实用UIviw animation,甚至连Core Animation也不用，完全自己来实现所有的动画效果。</p>

<p>我们使用 <a href="https://github.com/BradLarson/GPUImage">GPUImage</a>来实现一个非常漂亮的动画效果，这里我们实现的转场动画效果是：两个View controller像素化，然后相互消融在一起。实现方法是先对两个view controller进行截屏，然后再用GPUImage的图片滤镜（filter）处理这两张截图。</p>

<p>首先，我们先创建一个自定义类，这个类实现了UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning这两个协议：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface GPUImageAnimator : NSObject
</span><span class='line'>  &lt;UIViewControllerAnimatedTransitioning,
</span><span class='line'>   UIViewControllerInteractiveTransitioning&gt;
</span><span class='line'>
</span><span class='line'>@property (nonatomic) BOOL interactive;
</span><span class='line'>@property (nonatomic) CGFloat progress;
</span><span class='line'>
</span><span class='line'>- (void)finishInteractiveTransition;
</span><span class='line'>- (void)cancelInteractiveTransition;
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>为了加速动画的运行，我们可以图片一次加载到GPU中，然后所有的处理和绘图都直接在GPU上执行，不需要再传送到CPU上处理（这种数据传输很慢）。通过使用GPUImageview，我们就可以直接使用OPenGL画图。</p>

<p>创建滤镜链(Filter chain)也非常的直观，我们可以直接在样例代码的setup方法中看到如何构造它。比较有挑战的是如何让滤镜也<code>动</code>起来。GPUImage没有直接提供给我们动画效果，因此我们需要每渲染一帧就更新一下滤镜来实现动态的滤镜效果。使用<em>CADisplayLink</em>可以完成这个工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(frame:)];
</span><span class='line'>[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span></code></pre></td></tr></table></div></figure>


<p>在frame方法中，我们可以根据时间来更新动画进度，并相应地更新滤镜:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)frame:(CADisplayLink*)link
</span><span class='line'>{
</span><span class='line'>    self.progress = MAX(0, MIN((link.timestamp - self.startTime) / duration, 1));
</span><span class='line'>    self.blend.mix = self.progress;
</span><span class='line'>    self.sourcePixellateFilter.fractionalWidthOfAPixel = self.progress *0.1;
</span><span class='line'>    self.targetPixellateFilter.fractionalWidthOfAPixel = (1- self.progress)*0.1;
</span><span class='line'>    [self triggerRenderOfNextFrame];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>好了，基本上这样就完成了。如果你想要实现交互式的转场效果，那么在这里，就不能使用时间，而是要根据手势来更新动画进度，其它的代码基本差不多。</p>

<p>这个功能非常强大，你可以使用GPUImage中任何已有的滤镜，或者写一个自己的OpenGL来达到你想要的效果。</p>

<h2>结论</h2>

<p>本文只探讨了在navigation controller中的两个view controller之间的转场动画，但是这些做法在tab bar  controller或者任何你自己定义的view controller容器中也是通用的。另外，在ios7中，<em>UIcollectionViewController</em>也进行了扩展，现在你可以在布局之间进行自动以及交互的动画切换，背后使用的也是同样的机制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义AsyncDisplayKit-Node]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node/"/>
    <updated>2016-04-26T15:13:13+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/26/zi-ding-yi-asyncdisplaykit-node</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchy.png" alt="node" /></p>

<p>假设你已经读过<a href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/">AsyncDisplayKit入门</a>,下面我们将继续介绍AsyncDisplayKit.</p>

<!--more-->


<p>这篇教程将解释如何充分利用框架探索AsyncDisplayKit节点的层次结构，通过这样做，你将会更加熟悉AsyncDisplayKit这个有名的框架，并且会使你的app程序异常平滑，同时能够构建灵活的和可重用的ui</p>

<p>这AsyncDisplayKit中一个核心概念就是<code>node</code>,正如你所知，AsyncDisplayKit nodes 是一个线程安全的抽象于UIview之上的，（UIview不是线程安全的）,你可以学习更多AsyncDisplayKit在<a href="http://asyncdisplaykit.org/">AsyncDisplayKit’s Quick Start introduction</a></p>

<p>好消息是你已经知道了UIKit,那么你已经了解AsyncDisplayKit一些属性和方法了，因为API是很相似的。随后，你将会学到:</p>

<ul>
<li>如何去创建你自己的 AsDisplayNode</li>
<li>如何嵌套一个node到一个单个Node容器中，并且管理和重用</li>
<li>如何用一个Node层次结构支持View的层次结构，因为你自动减少在主线程绘制的机会，保持你的界面平滑和响应</li>
</ul>


<p>下面是你将要做的：你将要创建一个容器Node,并且添加两个子Node-其中一个是图片node,其中一个是文本node,你将会看到容器是如何测量他们的子Node尺寸和大小的.最后，你将会转化一个已经存在的UIview容器为一个ASDisplaytNode子类。</p>

<p>效果图如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt="node" /></p>

<h2>开始</h2>

<p>这个app,你将要创建一个卡片展示世界上一个奇观-泰姬陵</p>

<p>下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Starter.zip">开始工程</a></p>

<p>这个工程只有一个ViewController,这个工程是用 cocoaPods构建的，所以你必须安装 pods,然后创建 Podfile,引入 AsyncDisplayKit.</p>

<blockquote><p><em>注意</em>
如果你不了解 Pods,请学习<a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2">Introduction to CocoaPods Tutorial</a></p></blockquote>

<p>打开  ViewController.swift，然后注意到这个view controller只有一个常量<code>card</code>,它保存了一个泰姬陵的模型对象，你将会使用这个模型创建一个卡片的node去展示。</p>

<p>编译运行工程，你将会看到一个空的黑色屏幕
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-1-281x500.jpg" alt="logo" /></p>

<h2>创建并且显示一个容器Node</h2>

<p>现在你要开始构建你的第一个Node层次结构，它是非常相似的和创建一个UIview的层次结构</p>

<p>打开 Wonders-Bridging-Header.h，然后添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/ASDisplayNode+Subclasses.h&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>ASDisplayNode+Subclasses.h</code>是AsDisplayNode的一个内部方法，你需要在<code>ASDisplayNode</code>子类中实现这个header中定义的方法，但是你只能调用这些方法在你的 ASDisplayNode的子类中，这是和<code>UIGestureRecognizer</code>模式很相似的。</p>

<p>打开CardNode.swift，然后添加ASDisplayNode子类实现:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {}</span></code></pre></td></tr></table></div></figure>


<p>定义了一个新的ASDisplayNode子类，你将会把它作为一个容器去处理用户的交互</p>

<p>打开ViewController.swift,在viewDidLoad()中实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // Create, configure, and lay out container node
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  // Create container node’s view and add to view hierarchy
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码创建了一个新的卡片node,它定位在左上角并且高宽都是100.
不用担心之前的约束，你将会定位到中心在这个view controller中。</p>

<p>编译运行 ：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-2-281x500.jpg" alt="logo" /></p>

<p>太好了！你已经有了一个自定义的node在屏幕上显示，下一步是给你的子node取名为 <code>CardNode</code>,并且计算它的尺寸。在view中居中这是必须要知道的，你应该理解node布局引擎的工作原理。</p>

<h2>Node布局引擎</h2>

<p>下一步是询问Node去计算自己的尺寸通过调用<code>measure(constrainedSize:)</code>,你将会通过方法中constrainedSize参数去告诉node去计算一个尺寸去适应constrainedSize</p>

<p>通俗的说,这意味着计算大小不能大于限制大小。例如,考虑下面的图
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_measure.png" alt="logo" /></p>

<p>这个展示了一个约束的尺寸使用确定的宽度和高度，这个计算尺寸是和宽度相等的，但是比高度要小，它可能和宽度和高度都相等，或者比宽度和高度都要小，但是宽度和高度都不允许比约束的尺寸要大。</p>

<p>这个工作和UIView&rsquo;s<code>sizeThatFits(size:)</code>方法很相似。但是不同之处在于<code>measure(constrainedSize:)</code>计算它的尺寸，允许你访问缓存
node的calculatedSize属性。</p>

<p>一个例子就是当计算的高度和宽度的尺寸比约束尺寸更小的时候：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_constrained2.png" alt="lgo" /></p>

<p>这里图片的尺寸是更小比约束的尺寸，没有任何的sizing-to-fit，这里计算的尺寸比约束尺寸更小。</p>

<p>原因就是AsyncDisplayKit经常需要花费时间去计算尺寸，读取一个图片从硬盘中，可能会非常慢，通过合并尺寸到nodeApi,这个是线程安全的操作，这意味着计算尺寸可以在后台线程中运行！优雅的！它是一个有用的特性让你的UI程序平滑如黄油一般。</p>

<p>一个Node将会运行计算尺寸加入它没有存储值的话，假如这个约束尺寸提供是不同的，约束尺寸常常决定缓存的计算大小。</p>

<p>在程序中，工作如下:</p>

<ul>
<li>measure(constrainedSize:)返回一个存储你的尺寸或者进行一个计算尺寸通过调用calculateSizeThatFits(constrainedSize:)</li>
<li>你替换所有的尺寸计算通过<code>calculateSizeThatFits(constrainedSize:)</code>在你的ASDisplayNode子类中</li>
</ul>


<blockquote><p><em>注意</em>
calculateSizeThatFits(constrainedSize:)是ASDisplayNode的内部方法，你不应该在外部调用它</p></blockquote>

<h2>测量Node的大小</h2>

<p>现在是时候测量你的自己的node大小了。</p>

<p>打开CardNode.swift,然后替换这个类中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CardNode: ASDisplayNode {
</span><span class='line'> 
</span><span class='line'>  override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>    return CGSize(width: constrainedSize.width * 0.2, height: constrainedSize.height * 0.2)
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>到现在为止，这个方法返回的大小是约束提供尺寸的20%.</p>

<p>打开ViewController.swift,删除viewDidLoad() 中的实现，然后实现下面的<code>createCardNode(containerRect:)</code>方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'> 
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  // 1
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  let origin = CGPointZero
</span><span class='line'>  let size = CGSize(width: 100, height: 100)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'> 
</span><span class='line'>  // 2
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>func createCardNode(#containerRect: CGRect) -&gt; CardNode {
</span><span class='line'>  // 3
</span><span class='line'>  let cardNode = CardNode()
</span><span class='line'>  cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
</span><span class='line'>  cardNode.measure(containerRect.size)
</span><span class='line'> 
</span><span class='line'>  // 4
</span><span class='line'>  let size = cardNode.calculatedSize
</span><span class='line'>  let origin = containerRect.originForCenteredRectWithSize(size)
</span><span class='line'>  cardNode.frame = CGRect(origin: origin, size: size)
</span><span class='line'>  return cardNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>删除之前创建的代码，配置和布局代码</li>
<li>删除之前的代码，把node加入到view的层次结构中</li>
<li>createCardNode(containerRect:) 创建了一个卡片Node使用相同的背景颜色和容器node,它用作一个容器去约束卡片node的大小，所以这个卡片Node不能比containerRect’的尺寸更大</li>
<li>通过originForCenteredRectWithSize(size:) 方法设置卡片到中心位置。</li>
</ol>


<p>定位到createCardNode(containerRect:) 这个方法，替换viewDidLoad():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  let cardNode = createCardNode(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>  view.addSubview(cardNode.view)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当视图加载的时候，createCardNode(containerRect:)创建一个新的CardNode,这个卡片的Node不能比主屏幕的bounds尺寸更大。</p>

<p>在这个观点中，这个ViewController的视图还没有加载出来，因此，它不是安全的对用于ViewContrller的bounds尺寸。所以你使用主屏幕的尺寸去约束卡片Node的大小。</p>

<p>运行起来，尽管达不到优雅，因为这个视图控制器横跨了整个屏幕，稍后，我们将添加适当的方法，现在，它工作还可以。</p>

<p>编译运行，你将会看到你的node在正中心了.
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>异步节点设置和布局</h2>

<p>有时它会花费人们很多时间去解析复杂的层次结构，假如这是在主线程发生，这将会阻塞主线程，假如你想取悦用户的话，你不能让用户一直等待，之前用户是不能和程序有任何交互的。</p>

<p>因为这个原因，你将会在后台线程创建设置nodes，这样你能避免阻塞主线程。</p>

<p>在createCardNode(containerRect:)和viewDidLoad():中实现addCardViewAsynchronously(containerRect:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func addCardViewAsynchronously(#containerRect: CGRect) {
</span><span class='line'>  dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)) {
</span><span class='line'>    let cardNode = self.createCardNode(containerRect: containerRect)
</span><span class='line'>    dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>      self.view.addSubview(cardNode.view)
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>addCardViewAsynchronously(containerRect:)</code>创建这个<code>CardNode</code>在一个线程队列中，这是很好的，因为nodes是线程安全的！创建好之后，配置这个Node,然后异步调用主线程把Node添加到视图控制器中&ndash;毕竟，UIKit不是线程安全的！</p>

<blockquote><p><em>注意</em>
一旦你创建了Node的视图，所有访问node的节点只在主线程</p></blockquote>

<p>重新实现viewDidLoad()通过调用<code>addCardViewAsynchronously(containerRect:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这将不再阻塞主线程，确保用户界面是可以随时响应的。</p>

<p>编译运行，和之前一样，不过所有的操作都是在后台线程执行的</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>约束节点大小</h2>

<p>记得之前我你会使用一个更优雅的解决方案节点不仅仅依靠屏幕尺寸的大小
?现在我来兑换我的诺言</p>

<p>打开 ViewController.swift，添加下面的属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var cardViewSetupStarted = false</span></code></pre></td></tr></table></div></figure>


<p>然后替换viewDidLoad()为viewWillLayoutSubviews():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/* Delete this method
</span><span class='line'>override func viewDidLoad() {
</span><span class='line'>  super.viewDidLoad()
</span><span class='line'>  addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
</span><span class='line'>}
</span><span class='line'>*/
</span><span class='line'> 
</span><span class='line'>override func viewWillLayoutSubviews() {
</span><span class='line'>  super.viewWillLayoutSubviews()
</span><span class='line'>  if !cardViewSetupStarted {
</span><span class='line'>    addCardViewAsynchronously(containerRect: view.bounds)
</span><span class='line'>    cardViewSetupStarted = true
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>替换掉了住屏幕的尺寸，这上面的逻辑是视图控制器的尺寸去约束卡片的尺寸。</p>

<p>现在它是线程安全的,去用这个视图控制器的尺寸，当viewWillLayoutSubviews()替换调viewDidLoad()。这一次在这个声明周期中，这个视图控制器已经设置好了它的尺寸。</p>

<p>这种加载方式是很出众的，因为一个视图控制器能被设置任何尺寸,你不想依赖视图控制器去横跨整个屏幕</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/screen_size_tyranny.png" alt="log" /></p>

<p>这个视图可能会加载多次，所以viewWillLayoutSubviews()能被调用多次，你仅仅想创建这个CardNode一次，所以这就是为什么你需要一个cardViewSetupStarted标识去证明这个视图控制创建多次。</p>

<p>编译运行：</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-3-281x500.jpg" alt="logo" /></p>

<h2>Node层次结构</h2>

<p>现在你有一个空的Node容器在屏幕上，现在你想展示一些内容，方式的就是你添加一些子node到这个Node容器中，下面的结构图展示了简单的Node结构图</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_Nodes.png" alt="node" /></p>

<p>添加子Node看起来将会非常像你在UIview中添加子View的过程。</p>

<p>第一步你需要添加一个图片的node,但是首先你的需要了解容器Node是如何布局子Node的。</p>

<h2>子Node的布局</h2>

<p>你现在知道了如何去测量容器的尺寸和如何去计算容器尺寸去布局容器内的node视图，但是这个容器node是如何布局它们的子Node呢？</p>

<p>有以下两步:</p>

<ol>
<li>第一，你测量每个子Node的尺寸在<code>calculateSizeThatFits(constrainedSize:).</code>中，这将确保每一个子Node都缓存一个计算好的尺寸</li>
<li>在UIKIt的主线程布局中，AsyncDisplayKit将会调用<code>layout()</code>在你的自定义的ASDisplayNode子类中，<code>layout()</code>的工作就像UIview的 <code>layoutSubivews()</code>，除了这个<code>layout()</code>不会计算所有子视图的尺寸，布局()简单查询计算每个节点的大小</li>
</ol>


<p>回到UI上，这个泰姬陵卡片尺寸将会和它的图片大小一样，并且这个标题将会适合它的大小。最简单的方式就是去测量这个<code>泰姬陵图片</code>node的大小并且使用这个结果去约束文本node的尺寸，所以这个文本node将会适合图片尺寸的大小</p>

<p>接下来，你将要使用lay out去布局你的卡片子Node,让我们开始</p>

<h2>添加一个子Node</h2>

<p>打开CardNode.swift,然后添加下面的代码在CardNode</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let imageNode: ASImageNode
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>init(card: Card) {
</span><span class='line'>  imageNode = ASImageNode()
</span><span class='line'>  super.init()
</span><span class='line'>  setUpSubnodesWithCard(card)
</span><span class='line'>  buildSubnodeHierarchy()
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>func setUpSubnodesWithCard(card: Card) {
</span><span class='line'>  // Set up image node
</span><span class='line'>  imageNode.image = card.image
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 4
</span><span class='line'>func buildSubnodeHierarchy() {
</span><span class='line'>  addSubnode(imageNode)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>图片Node属性:这行代码添加一个图片Node的属性，去引用卡片图像的子Node</li>
<li>初始化:这个设计的初始化使用一个卡片模型保存卡片的图像和文本</li>
<li>设置子Node:这个方法使用卡片模型的图像去保存开始项目中的子Node图片</li>
<li>容器层次结构:你设置Node的层次结构就像你能设置视图的层次结构一样，这个方法创建卡片的层次结构通过添加一个子Node来实现。</li>
</ol>


<p>下一步，实现calculateSizeThatFits(constrainedSize:):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
</span><span class='line'>  // 1 
</span><span class='line'>  imageNode.measure(constrainedSize)
</span><span class='line'> 
</span><span class='line'>  // 2 
</span><span class='line'>  let cardSize = imageNode.calculatedSize
</span><span class='line'> 
</span><span class='line'>  // 3 
</span><span class='line'>  return cardSize
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的工作如下:</p>

<ol>
<li>这个卡片的尺寸就会匹配背景图片的大小，这个测量背景图片的尺寸会适合内嵌的约束尺寸，所有Node的子类都会被AsyncDisplay框架感知并且知道如何设置它们的尺寸，包括AsImageNode</li>
<li>这行代码临时存储图片计算的尺寸，特别说明的是，它使用图片Node测量尺寸正如卡片Node尺寸去约束子NOde，当添加更多的子Node的时候，你将会使用这个值</li>
<li>返回这个卡片Node的计算好的尺寸</li>
</ol>


<p>下一步，覆盖layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layout() {
</span><span class='line'>  imageNode.frame =
</span><span class='line'>    CGRect(origin: CGPointZero, size: imageNode.calculatedSize).integerRect
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个图片的逻辑位置在左上角，坐标轴原点，它也确保了这个图片Node的frame没有任何多余的值，所以你能避免像素边界显示问题</p>

<p>注意这个方法是如何使用图片的Node去缓存计算尺寸的在布局的过程中。</p>

<p>因为这个图片Node的尺寸决定了卡片Node的尺寸，这个图片将会横跨这个卡片</p>

<p>回到ViewController.swift，然后添加一个createCardNode(containerRect:), 替换到之前初始化的<code>CardNode</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let cardNode = CardNode(card: card)</span></code></pre></td></tr></table></div></figure>


<p>这行代码使用新的初始化去添加一个卡片Node,这个卡片值将会在初始化的时候被传入，并且存储这个泰姬陵的卡片模型</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-6-281x500.jpg" alt="t" /></p>

<p>漂亮，你成功的创建了容器Node并且呈现了Node的层次结构，当然，这个很简单，但是它是一个完成的Node层次！</p>

<h2>添加更多的子Node</h2>

<p>也许你已经注意到了，没有添加标题，不用担心，让我们开始添加吧。</p>

<p>打开CardNode.swift，然后添加下面的属性titleTextNode在类中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode: ASTextNode</span></code></pre></td></tr></table></div></figure>


<p>在<code>init(card:)</code>方法中初始化<code>titleTextNode</code>，在super.init()这行代码之前:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode = ASTextNode()</span></code></pre></td></tr></table></div></figure>


<p>添加下面的这行代码在<code>setUpSubnodesWithCard(card:):</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(card.name)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码给titleTextNode设置了富文本内容，<code>attributedStringForTitleText(text:)</code>是一个帮助方法被加到了NSAttributedString扩展属性中。在之前的开始工程中，它创建了富文本使用提供的标题。</p>

<p>下一步，在<code>buildSubnodeHierarchy():</code>的结尾增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>要确保它是在添加到图片Node的后面，不然图片将会遮盖住标题。</p>

<p>在内置的方法<code>calculateSizeThatFits(constrainedSize:)</code>中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.measure(cardSize)</span></code></pre></td></tr></table></div></figure>


<p>使用子Node的测量尺寸来作为卡片的约束尺寸</p>

<p>添加如下的布局代码layout():</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame =
</span><span class='line'>  FrameCalculator.titleFrameForSize(titleTextNode.calculatedSize, containerFrame: imageNode.frame)
</span></code></pre></td></tr></table></div></figure>


<p>这行代码计算标题Node的frame通过工具方法FrameCalculator</p>

<p>编译运行:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/ASDK_NodeHierarchies-7-281x500.jpg" alt="test" /></p>

<p>至此，你已经构建了完整的子Node层次结构，使用了容器Node,并且添加了两个子Node</p>

<h2>完整工程</h2>

<p><a href="https://github.com/TLSwiftDemo/Wonders/archive/master.zip">完整工程在这里下载</a></p>

<p>have fun 😀~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义ColletionView布局]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju/"/>
    <updated>2016-04-24T21:05:32+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/24/zi-ding-yi-colletionviewbu-ju</id>
    <content type="html"><![CDATA[<p>UICollectionView在ios6中第一次被引入，也是UIKit <a href="http://oleb.net/blog/2012/09/uicollectionview/">视图类中的一颗新星</a>
。它和UITableview共享一套API设计，但也在UItableView上做了一些扩展。UICOllectionView最强大，同时显著超出UITableView的特色就是其完全灵活的布局结构。这这篇文章中，<!--more--> 我们将会实现一个相当复杂的自定义Collection view布局，并且顺便讨论一下这个类设计的重要部分，项目的实例代码在 <a href="https://github.com/objcio/issue-3-collection-view-layouts">GitHub</a>上。</p>

<h2>布局对象(Layout Objects)</h2>

<p>UITableView和UICollectionView都是 data-source和delegate驱动的。他们在显示其子视图集的过程中仅扮演容器角色,且对子视图集真正的内容毫不知情。</p>

<p>UICollectioNView在此之上进行了进一步抽象。它将子视图的位置，大小和外观的控制权拖过给一个单独的布局对象。通过提供一个自定义布局对象，你技术可以实现任何你能想象到的布局。布局继承自UICollectionVieLayout抽象基类.IOS6中以UICollectionViewFloyLayout类的形式提出了一个具体的布局实现。</p>

<p>我们可以使用flow layout实现一个标准的gridview,这可能是colle tion view中最常见的使用案例了。尽管大多数人都这么想，但是Apple很聪明，没有明确的命名这个类为UIColletionViewGridLayout,而使用了更为通用的术语 flow layout,更好的描述了该类的功能：它通过一个接一个的放置cell来建立自己的布局，当需要的时候，插入横排或竖排的分栏符。通过自定义滚动方向，大小和cell之间的间距，flow layout 也可以在单行或单列中布局cell。实际上，UITableView的布局可以想象成flow layout的一种特殊情况。</p>

<p>在你准备自己写一个UICollectionViewLayout的子类之前，你需要问你自己，你是否能够使用UICollectionViewFlowlayout实现你心里的布局。这个类是<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout">很容易定制的</a>,并且可以继承本身进行进一步的定制，感兴趣的看<a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4">这篇文章</a></p>

<h2>Cells和其他Views</h2>

<p>为了适应任意布局,collection view简历了一个类似，但比 table view更灵活的视图层级，像往常一样，你的主要内容显示在cell中，cell可以被任意分组到section中。CollectionView的cell必须是UICollectionViewCell的子类。除了cell，collection view额外管理着两种视图:supplementary views和decoration views.</p>

<p>collection view中的Supplemnetary views相当于table view的section header和footer views.像cells一样，他们的内容都有数据源对象驱动，然而和tableview 中用法不一样，supplementary view并不一定会作为header或footer view;他们的数量和位置完全由布局控制.</p>

<p>Decoration views纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从dataSource 获取的contents.当布局对象指定需要一个decoration view的时候，collection view会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views和decoration views必须是UICollectionReusableView的子类。布局使用的每个视图类都需要在collection view中注册，这样当data Source让它们从reuse pool中出列时，它们才能够创建新的实例。如果你是使用的interface Builder，则可以通过在可视化编辑器中拖拽一个cell到collection view上完成cell在collection view中的注册。同样的方法也可以用在supplementary view上，前提是你使用了UIcollectionviewFlowLayout.如果没有，你只能通过调用 <code>registerClass:</code>或者<code>registerNib:</code>方法手动注册视图类了。你需要在<code>viewDidload</code>中做这些操作.</p>

<h2>自定义布局</h2>

<p>作为一个非常有意义的自定义collection view布局的例子，我们不妨想一个典型的日历应用程序中的周视图。日历一次显示一周，星期中的每一天现在列中，每一个日历事件将会在我们的colleectio view中以一个cell显示，位置和大小代表事件起始日期事件和持续时间。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/calendar-collection-view-layout.png" alt="test" />
一般有两种类型的 collection view布局:</p>

<ol>
<li>独立于内容的布局计算.这正是你所知道的像UITableview和UIcollectionViewFlowLayout这些情况。每个cell的位置和外观不是基于其显示的内容，但所有cell的显示顺序是基于内容的顺序。可以把默认的flow layout作为例子。每个cell都是基于前一个cell的放置(或者如果没有足够的空间，则从下一行开始).布局对象不必访问实际数据来计算布局.</li>
<li>基于内容的布局计算。我们的日历视图正式这样类型的例子。为了计算显示事件的气势和街二叔事件，布局对象需要直接访问 collection view的数据源。在很多情况下，布局对象不仅需要取出当前可见cell的数据，还需要从所有记录中取出一些决定当前那些cell可见的数据。</li>
</ol>


<p>在我们的日历示例中，布局对象如果访问某一个矩形内的cells的属性，那就必须迭代数据源提供的所有事件来决定那些位于要求的时间窗口个中。与一些相对简单，数据源独立计算的flow layout比起来，这足够计算出cell在一个矩形内的index paths了（假设网格中所有的cells的大小都一样）.</p>

<p>如果有一个依赖内容的布局，那就是暗示你需要些自定义的布局类了，同时不能使用自定义的UICOllectionViewFlowLayout，所以这正是我们需要做的事情。</p>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html">UICollectionViewLayout文档</a>列出了子类需要重写的方法.</p>

<h2>collectionViewContentSize</h2>

<p>由于 collection view对它的content并不知情，所以布局首先要提供的信息就是滚动区域的大小，这样collection view才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括supplementary views和decoration views。注意，尽管大多数经典的collection view限制在一个轴方向上滚动(正如UIcollectionviewFlowLayout一样)，但是这不是必须的。</p>

<p>在我们的日历示例中，我们想要视图垂直的滚动。比如，如果我们想要在垂直空间上一个小时占去100点，这样显示一整天的内容高度就是2400点。注意，我们不能够水平滚动，这就意味这我们collectionview只能显示一周。为了能够在日历中的多个星期间分页，我们可以在一个独立的scroll view中（可以使用U<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIPageViewControllerClassReferenceClassRef/UIPageViewControllerClassReference.html">IPageViewController</a>）中使用多个 collection view（一周一个）,或者坚持使用一个collection view并且返回足够大的内容宽度，这回使得用户感觉在两个方向上滑动自由。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (CGSize)collectionViewContentSize
</span><span class='line'>{
</span><span class='line'>    // Don't scroll horizontally
</span><span class='line'>    CGFloat contentWidth = self.collectionView.bounds.size.width;
</span><span class='line'>
</span><span class='line'>    // Scroll vertically to display a full day
</span><span class='line'>    CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay);
</span><span class='line'>
</span><span class='line'>    CGSize contentSize = CGSizeMake(contentWidth, contentHeight);
</span><span class='line'>    return contentSize;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了简单起见，我选择布局在一个非常简单的模型上：假定每周天数相同，每天时长相同，也就是说天数用0-6表示。在一个真实的日历程序中，布局将会为自己的几段大量使用基于 <code>NSCalendaar</code>的日期</p>

<h2>layoutAttributesForElementsInRect：</h2>

<p>这是任何布局类中最重要的方法了，同时可能也是最容易让人迷惑的方法。collection view调用这个方法并传递一个自身坐标系统中的矩形过去。这个矩形代表了这个视图的可见矩形区域(也即是它的bounds)，你需要准备好处理传给你的任何矩形。</p>

<p>你的视线必须返回一个包含 UICollectionviewLayoutAttributes对象的数组，为每一个cell包含一个这样的对象，supplementary View或decoration view在矩形区域内是可见的。UICollectionViewLayoutAttributes类包含了colletion view内item的所有相关的布局属性。默认情况下，这个类包含 frame,center,size,transform3D,alpha,Zindex和hidden属性。如果你的布局想要控制其他视图的属性(比如背景颜色)，你可以创建一个UICollectionViewLayoutAttributes的子类，然后加上你自己的属性。</p>

<p>布局属性对象(Layout attributes objects)通过indexPath属性和他们对应的cell,supplementary view或者decoration view关联在一起。collection view为所有items从布局对象中请求到布局属性后，它将会实例化所有视图，并将对应的属性应用到每个视图上去。</p>

<p>注意!这个方法涉及到所有类型的视图，也就是cell,supplementary views和decoration views.一个幼稚的实现可能会选择忽略传入的矩形，并且为collection view中所有的视图返回布局属性。在原型设计和开发布局阶段，这是一个有效的方法。但是，这将会性能产生非常坏的影响，特别是可见cell远少于所有cell数量的时候，collection view和布局对象将会为那些不可见的而试图做额外不必要的工作。</p>

<p>你的视线需要做这几步:</p>

<ol>
<li>创建一个空的可变数组来存放所有的布局属性</li>
<li>确定index paths中那些cells的frame完全或部分位于矩形中。这个计算需要你从collection view的数据源中取出你需要显示的数据。然后在循环中调用你视线的<code>layoutattributesForItemIndexPath:</code>方法为每个index path创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</li>
<li>如果你的布局包含supplementary views,计算矩形内可见supplementary view的index paths.在循环中调用你实现的<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>,并且将这些对象加到数组中。通过为kind参数传递你选择的不同字符，你可以却分出不同种类的supplementary views(比如headers和footers)。当需要创建视图时，collectionview会将kind字符传回到你的数据源。记住supplermentary 和decoration views的数量和种类完全有布局控制。你不会受到headers和footers的限制.</li>
<li>如果布局包含decoration views，计算矩形内可见decoration views的index paths.在循环中调用你实现的<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>
，并且将这些对象加到数组中</li>
<li>返回数组</li>
</ol>


<p>我们自定义的布局没有使用 decoration views,但是使用了两种supplermentary views(column headers和row headers):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    NSMutableArray *layoutAttributes = [NSMutableArray array];
</span><span class='line'>    // Cells
</span><span class='line'>    // We call a custom helper method -indexPathsOfItemsInRect: here
</span><span class='line'>    // which computes the index paths of the cells that should be included
</span><span class='line'>    // in rect.
</span><span class='line'>    NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in visibleIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForItemAtIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Supplementary views
</span><span class='line'>    NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"DayHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect];
</span><span class='line'>    for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) {
</span><span class='line'>        UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>        [self layoutAttributesForSupplementaryViewOfKind:@"HourHeaderView"
</span><span class='line'>                               atIndexPath:indexPath];
</span><span class='line'>        [layoutAttributes addObject:attributes];
</span><span class='line'>    }
</span><span class='line'>    return layoutAttributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>layoutAttributesFor…IndexPath</h2>

<p>有时，collection view会为某个特殊的cell,supplementary 或者decoration view向布局对象请求布局属性，而非所有可见的对象。这就是当其他三个方法开始起作用时，你实现的<code>layoutAttributesForItemAtIndexPath:</code>需要创建并返回一个单独的布局属性对象，这样才能正确的格式化传给你的index path 所对应的cell.</p>

<p>你可以通过调用<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>这个方法，然后根据index path修改属性。为了得到需要显示在这个index path内的数据，你可能需要访问collection view的数据源。到目前为止，至少确保设置了frame尚需经，除非你所有的cell都位于彼此上方。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath
</span><span class='line'>{
</span><span class='line'>    CalendarDataSource *dataSource = self.collectionView.dataSource;
</span><span class='line'>    id event = [dataSource eventAtIndexPath:indexPath];
</span><span class='line'>    UICollectionViewLayoutAttributes *attributes =
</span><span class='line'>    [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
</span><span class='line'>    attributes.frame = [self frameForEvent:event];
</span><span class='line'>    return attributes;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你正在使用自动布局，你可能会赶到惊讶，我们正在直接修改布局参数的frame属性，而不是和约束共事，但这正是UIcollectionViewLayout的工作。尽管你坑你使用自动布局来定义collection view的frame和它内部每个cel的布局，但cells的frames还是需要通过老式的方法计算出来。</p>

<p>类似的，<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code>和<code>layoutAttributesForDecorationViewOfKind:atIndexPath:</code>方法分别需要为supplementary 和decoration views做相同的事。只有你的布局包含这样的视图你才需要实现这两个方法。UICollectionViewlayoutAttributes包含另外两个工厂方法，</p>

<p><code>+layoutAttributesForSupplementaryViewOfKind:withIndexPath:</code> 和 <code>+layoutAttributesForDecorationViewOfKind:withIndexPath:</code>，用他们来创建正确的布局属性对象</p>

<h2>shouldInvalidateLayoutForBoundsChange:</h2>

<p>最后，当collection view的bounds改变时，布局需要告诉collection view是否需要重新计算布局。我的猜想是：当collectionview改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个优质的实现可能只会简单的返回YES。芮然实现功能很重要，但是scrollview的bounds在滚动时也会改变，这意味着你的布局美妙会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。</p>

<p>当collection view的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view将它的bounds传给<code>shouldInvalidateLayoutForBoundsChange:</code>方法，这样我们便能比较视图当前的bounds和新的bounds来确定返回值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
</span><span class='line'>{
</span><span class='line'>    CGRect oldBounds = self.collectionView.bounds;
</span><span class='line'>    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>        return NO;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>动画</h2>

<h3>插入和删除</h3>

<p>UITableview中的cell自带了一套非常漂亮的插入和删除的动画。但是当为UIcollectionView增加和删除cell定义动画功能时，UIKit工程师们遇到这样一个问题：如果Collection view的布局是完全可变的，那么预先定义好的动画就没办法和开发者自定义的布局很好的融合。他们提出了一个优雅的方法：当一个cell(或者supplementary 或者 decoration View)被插入到collection view中时，collection View不仅向其布局请求cell正常正常状态下的布局尚需经，同时还请求其初始的布局尚需经，比如，需要在开始有插入动画的cell。CollectionView会简单的创建一个anmiation block,并在这个block中，将所有cell的属性从初始状态改变到常态</p>

<p>通过提供不同的初始布局属性，你可以完全自定义插入动画。比如设置初始的alpha为0将会产生一个淡入的动画。同时设置一个平移或者缩放将会产生移动缩放的效果。</p>

<p>同样的原理应用到删除上，这次动画是从常态到一些列你设置的最终布局属性。这些逗你需要在布局类中为initial或final布局参数实现的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>initialLayoutAttributesForAppearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingItemAtIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:
</span><span class='line'>
</span><span class='line'>finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:</span></code></pre></td></tr></table></div></figure>


<h2>布局间切换</h2>

<p>可以通过类似的方式将一个collection view布局动态的切换到另外一个布局。当发送一个<code>setCollectionViewLayout:animated:</code>消息时，collection view会为cells在新的布局中查询新的布局参数，然后动态的将每个cell从旧参数变换到新的布局参数。你不需要做任何事情。</p>

<h2>结论</h2>

<p>根据自定义collection view布局的复杂性，写一个通常很不容易。确切的说，本质上这和从头写一个完整的实现相同布局自定义视图类一样困难了。因为所涉及的计算需要确定去那些子视图是当前可见的，以及他们的位置。尽管如此，使用UIcollectionview还是给你带来了一些很好的效果，比如cell重用，自动支持动画，更不要提整洁的独立布局，子视图管理。</p>

<p>自定义collection view布局也是向<a href="http://objccn.io/issue-1-1/">轻量级view Controller</a>迈出了很好的异步，正如你的view controller不要包含任何布局代码。应该和一二个独立的dataSource类结合在一起，collection view的视图控制器将很难再包含任何代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OHHTTPStubs介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao/"/>
    <updated>2016-04-22T17:18:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/ohhttpstubsjie-shao</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>是一个模拟网络请求的一个框架，它使用起来非常方便和强大，它能帮你</p>

<ol>
<li>测试你的app仿真一个服务器（比如加载一个本地文件）,模拟网络慢的情况等</li>
<li>使用伪造的网络数据编写单元测试</li>
</ol>


<!--more-->


<h2>简单用法</h2>

<h2>在Objc中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>  return [request.URL.host isEqualToString:@"mywebservice.com"];
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<h2>在swift中</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>stub(isHost("mywebservice.com")) { _ in
</span><span class='line'>  // Stub it with our "wsresponse.json" stub file (which is in same bundle as self)
</span><span class='line'>  let stubPath = OHPathForFile("wsresponse.json", self.dynamicType)
</span><span class='line'>  return fixture(stubPath!, headers: ["Content-Type":"application/json"])
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>语法讲解</h2>

<p><code>OHHTTPStubs stubRequestsPassingTest:</code>方法创建了模拟服务器，<code>request</code>是请求的标准判断，比如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[request.URL.host isEqualToString:@"mywebservice.com"]</span></code></pre></td></tr></table></div></figure>


<p>意思就是如果请求的url是<code>mywebservice.com</code>，我们就返回response,要不然不执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> NSString* fixture = OHPathForFile(@"wsresponse.json", self.class);
</span><span class='line'>  return [OHHTTPStubsResponse responseWithFileAtPath:fixture
</span><span class='line'>            statusCode:200 headers:@{@"Content-Type":@"application/json"}];</span></code></pre></td></tr></table></div></figure>


<p>返回一个respoinse,其中包含了返回的数据，</p>

<ol>
<li>获取的一个本地文件</li>
<li>返回的状态码 200  (200表示正确返回)</li>
<li>headers：返回的头,如果是json一般是:@{@&ldquo;Content-Type&rdquo;:@&ldquo;application/json&rdquo;}</li>
</ol>


<h1>快速开始一个Demo</h1>

<h2>创建一个空工程</h2>

<p>用xcode创建一个工程，用pods创建一个Podfile</p>

<p>内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'OHHTTPStubs', '~&gt; 5.0.0'
</span><span class='line'>
</span><span class='line'>target :OHHTTPStubsDemoTests, :exclusive =&gt; true do
</span><span class='line'>    link_with 'OHHTTPStubsDemoTests'
</span><span class='line'>    
</span><span class='line'>    pod 'OHHTTPStubs'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>执行 <code>pod install</code></p>

<p>成功安装OHHTTPStubs后，在OHHTTPStubsDemoTests目录中编写测试类:</p>

<h3>创建session</h3>

<p>在顶部声明一个变量session</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (nonatomic,strong) NSURLSession *session;</span></code></pre></td></tr></table></div></figure>


<p>在setUp方法中，创建该变量实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.session=[NSURLSession sharedSession];</span></code></pre></td></tr></table></div></figure>


<p>在 testExample()方法中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  返回自定义的普通文本
</span><span class='line'> */
</span><span class='line'>- (void)testExample {
</span><span class='line'>    
</span><span class='line'>    //开始模拟服务器
</span><span class='line'>    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //发送请求的url后缀必须是.com结尾的
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"com"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        //创建一个字符串
</span><span class='line'>        NSData * stubData = [@"hello world" dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>        //响应数据
</span><span class='line'>        /**
</span><span class='line'>         *  responseWithData:返回的数据
</span><span class='line'>            statusCode:状态码,200表示成功
</span><span class='line'>            headers:http的header
</span><span class='line'>         */
</span><span class='line'>        return [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:@{@"Content-Type":@"text/plain"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //在XCT测试框架中，这个表示期望值，因为这个期望值是支持异步测试的，我们是异步请求，所以一定要是使用XCTestExpectation这个特性
</span><span class='line'>     XCTestExpectation *expectation=[self expectationWithDescription:@"sessionDataTask expectation"];
</span><span class='line'>    
</span><span class='line'>    //创建session任务
</span><span class='line'>    NSURLSessionDataTask *dataTask=[self.session dataTaskWithURL:[NSURL URLWithString:@"hello.com"] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        //解析返回的字符串
</span><span class='line'>        NSString *resultStr=[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的数据:%@",resultStr);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(resultStr!=nil);
</span><span class='line'>        
</span><span class='line'>        //断言返回的字符串是hello world,如果不是，则断言失败
</span><span class='line'>        XCTAssertTrue([resultStr isEqualToString:@"hello world"]);
</span><span class='line'>        
</span><span class='line'>        //在想异步测试的地方加上下面这行代码
</span><span class='line'>        [expectation fulfill];
</span><span class='line'>    }];
</span><span class='line'>    //启动任务
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    
</span><span class='line'>    //使用XCTestExpectation,必须设置如下的waitForExpectationsWithTimeout方法，如果超时则失败
</span><span class='line'>    [self waitForExpectationsWithTimeout:4 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%s",__FUNCTION__);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>   
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里面使用到了 <code>XCTestExpectation</code>，这是特性是用来测试异步程序代码的。在想测试异步代码的地方加上<code>[expectation fulfill];</code>,
最后，要加上<code>waitForExpectationsWithTimeout</code>方法，它们是配对出现的。</p>

<p>OHHTTPStubs创建了模拟服务器后，下面发的任何网络请求都会被模拟服务器返回，正如上面的代码所示，测试结果:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-3.png" alt="test" />
断言成功！</p>

<h2>添加本地文件</h2>

<ol>
<li>在本地创建一个stub.txt的文本文件，内容自定</li>
<li>在本地创建一个stub.jpg的图片，图片自定</li>
</ol>


<p>图片
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-5.png" alt="1" /></p>

<p>文本
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-4.png" alt="2" /></p>

<h3>创建文本的TextStub</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建文本的TextStub
</span><span class='line'> */
</span><span class='line'>-(void)createTextStub{
</span><span class='line'>    // #1
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; textStub = nil;
</span><span class='line'>    
</span><span class='line'>    // #2
</span><span class='line'>    textStub= [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"txt"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        
</span><span class='line'>        NSString *path = OHPathForFile(@"stub.txt",self.class);
</span><span class='line'>        
</span><span class='line'>       //#3
</span><span class='line'>        return [[OHHTTPStubsResponse responseWithFileAtPath:path
</span><span class='line'>                                                 statusCode:200 headers:@{@"Content-Type":@"text/plain"}]
</span><span class='line'>                requestTime:1.0f
</span><span class='line'>                responseTime:OHHTTPStubsDownloadSpeedWifi];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    //#4
</span><span class='line'>    textStub.name = @"text stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面代码意义如下:</p>

<ol>
<li>声明一个返回的OHHTTPStubsDescriptor,这是创建模拟服务器的返回结果描述</li>
<li>开始创建模拟服务器</li>
<li>返回response，其中设置了返回数据，状态码，请求时间等</li>
<li>给textStub起个名字</li>
</ol>


<h2>测试文本的模拟服务器</h2>

<p>创建一个testStubTextTask方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试文本的Stub任务
</span><span class='line'> */
</span><span class='line'>-(void)testStubTextTask{
</span><span class='line'>    //创建文本的模拟服务器
</span><span class='line'>    [self createTextStub];
</span><span class='line'>    //创建一个期望值
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"high expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSession *session=[NSURLSession sharedSession];
</span><span class='line'>    
</span><span class='line'>    NSString *urlString=@"stub.txt";
</span><span class='line'>    NSURLSessionDataTask *dataTask = [session dataTaskWithURL:[NSURL URLWithString:urlString] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        NSString* receivedText = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
</span><span class='line'>        NSLog(@"返回的结果:%@",receivedText);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(receivedText!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataTask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:5 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>创建图片的stub</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  创建Image的stub
</span><span class='line'> */
</span><span class='line'>-(void)createImageStub{
</span><span class='line'>    static id&lt;OHHTTPStubsDescriptor&gt; imageStub = nil;
</span><span class='line'>    
</span><span class='line'>    imageStub=[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [request.URL.pathExtension isEqualToString:@"png"];
</span><span class='line'>    } withStubResponse:^OHHTTPStubsResponse * _Nonnull(NSURLRequest * _Nonnull request) {
</span><span class='line'>        return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFile(@"stub.jpg", self.class) statusCode:200 headers:@{@"Content-Type":@"image/jpeg"}];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    imageStub.name=@"Image stub";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>测试Image的模拟服务器</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> *  测试Image的模拟服务器
</span><span class='line'> */
</span><span class='line'>- (void)testImageStubTask{
</span><span class='line'>    
</span><span class='line'>    [self createImageStub];
</span><span class='line'>    
</span><span class='line'>    XCTestExpectation *expection=[self expectationWithDescription:@"Image Expection"];
</span><span class='line'>    
</span><span class='line'>    NSURLSessionDataTask *dataStask=[self.session dataTaskWithURL:[NSURL URLWithString:@"test.png" relativeToURL:nil] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
</span><span class='line'>        
</span><span class='line'>        UIImage *image=[UIImage imageWithData:data];
</span><span class='line'>        
</span><span class='line'>        NSLog(@"返回的image:%@",image.description);
</span><span class='line'>        
</span><span class='line'>        XCTAssert(image!=nil);
</span><span class='line'>        
</span><span class='line'>        [expection fulfill];
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [dataStask resume];
</span><span class='line'>    
</span><span class='line'>    [self waitForExpectationsWithTimeout:3 handler:^(NSError * _Nullable error) {
</span><span class='line'>        if(error){
</span><span class='line'>            NSLog(@"出错了:%@",error.description);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>完整工程</h2>

<p><a href="https://github.com/TLOpenSpring/OHHTTPStubsDemo/archive/master.zip">完整工程在这里下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode更新后插件失效的解决方案]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an/"/>
    <updated>2016-04-22T16:17:45+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/22/xcodegeng-xin-hou-cha-jian-shi-xiao-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<p>Xcode的插件对于开发者来说无疑是一把利器，让开发者能够将更多的时间和精力放在代码上面。但是开发者都会遇到一个问题，就是每次Xcode更新到最新的版本，之前的插件全部都失效了，需要重新安装一遍很是麻烦。</p>

<!--more-->


<p>插件失效的原因:</p>

<blockquote><blockquote><ul>
<li>系统安装了一个Xcode</li>
<li>开发者未正确的将自己的DVTPlugInCompatibilityUUID添加到插件中</li>
<li>成功安装了插件，但是却在Xcode识别插件的时候，选了 Skip Bundle</li>
</ul>
</blockquote></blockquote>

<h2>终端指令实现</h2>

<p>//获取DVTPlugInCompatibilityUUID字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID
</span></code></pre></td></tr></table></div></figure>


<h2>找到插件的目录</h2>

<ol>
<li>打开xcode插件所在的目录:<code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>,打开路径的快捷键是shift＋command＋g 然后输入上面的地址</li>
<li>选择已经安装的插件，例如:VVDocumenter-Xcode，右键显示包内容</li>
<li>找到info.plist文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item,value的值为之前的Xcode的UUID,(或者直接在item0中value修改也可以)保存</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-1.png" alt="step2" /></p>

<h2>重启xcode</h2>

<p>重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-0.png" alt="step1" /></p>

<h2>效果如下</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160422-2.png" alt="s" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试并发程序]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu/"/>
    <updated>2016-04-21T17:38:05+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/21/ce-shi-bing-fa-cheng-xu</id>
    <content type="html"><![CDATA[<p>在开发高质量应用程序的过程中，测试时一个很重要的工具。在过去，当并发不是应用程序架构中重要组成部分的时候，测试就想单简单。随着这几年的发展，使用并发设计模式变得越来越重要了，想要测试好并发应用程序，已成了一个不小的挑战.</p>

<!--more-->


<p>测试并发代码最主要的困难在于程序或信息流不是反应在调用堆栈上。函数并不会立即返回给调用者，而是通过回调函数block，通知或者一些类似的机制，这些使得测试变得更加困难。</p>

<p>然后，测试异步代码也会带来一些好处，比如可以揭露较差的程序设计，让最终的实现变得更加清晰。</p>

<h1>异步测试的问题</h1>

<p>首先，我们来看一个简单地同步单元测试的例子，两个数求和的方法.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b {
</span><span class='line'>    return a + b;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>测试这个方法很简单，只需要比较该方法返回值是否和期望值相同，如果不相同，则测试失败。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAddition {
</span><span class='line'>    int result = [Calculator add:2 to:2];
</span><span class='line'>    STAssertEquals(result, 4, nil);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们利用block将该方法改成异步返回结果，为了模拟测试失败，我们会在方法实现中故意添加一个bug.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (int)add:(int)a to:(int)b block:(void(^)(int))block {
</span><span class='line'>    [[NSOperationQueue mainQueue] addOperationWithBlock:^{
</span><span class='line'>        block(a - b); // 带有bug的实现
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>虽然这是一个人为的例子，但是它却真实的反映了编程中可能经常遇到的问题，只不过实际过程更加复杂罢了。</p>

<p>测试上面的方法最简单的做法就是把断言放到Block中。尽管我们的方法实现中存在bug,但是这种测试永远不是失败的；</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 千万不要使用这些代码！
</span><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block:^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil); // 永远不会被调用到
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里的断言为什么没失败呢？</p>

<h1>关于SenTestingKit</h1>

<p>在老版本的xcode中所使用的测试框架是基于 <a href="http://www.sente.ch/software/ocunit/">OCUnit</a>。为了理解之前所提到的异步测试问题，我们需要了解一下测试包中的各个部分之间的执行顺序。下图展示了一个简化的流程。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKit-call-stack.png" alt="test" /></p>

<p>在测试框架在主run loop开始运行之后，主要执行了一下几个步骤:</p>

<ol>
<li>配置一个包含所有相关测试的测试包</li>
<li>运行测试包，内部会调用所有以test开头测试用例的方法。运行结束后会返回一个包含单个测试结果的对象。</li>
<li>调用exit()退出测试</li>
</ol>


<p>这其中我们最感兴趣的是单个测试时如何被调用的。在异步测试中，包含断言的Block会被加到run loop。当所有的测试执行完毕后，测试框架就会退出，而block却从来没有被执行，因此不会引起测试失败。</p>

<p>当然我们有很多种方法来解决这个问题。但是素有的方法都必须在住run loop中运行，而且在测试方法返回和比较结果之前需要处理已入队的所有操作。</p>

<p><a href="https://github.com/allending/Kiwi">kiwi</a>使用测试轮询，它可以在测试方法中被滴啊用。<a href="https://github.com/gabriel/gh-unit/">GHUnit</a>编写了一个单独的测试类，它必须在测试的方法内初始化，并在结束时接受一个通知。以上两种方式都是通过编写相应的代码来确保异步异步测试方法在测试结束之前都不会返回。</p>

<h1>SenTesgingKit的异步扩展</h1>

<p>我们对这个问题的解决方案是对SenTestingKit添加一个扩展，它在栈上使用同步执行，并把每个部分加入到主队列中。正如下图所见，在验证整个测试框架结果之前，报告异步测试成功或失败的Block就被加入到队列。这种执行顺序允许我们开启一个测试并等待它的测试结果。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/SenTestingKitAsync-call-stack.png" alt="test" /></p>

<p>如果测试方法以Async结尾，框架就睡认为该方法是异步测试。此外，在异步测试中，我们必须手动的报告测试成功，同时为了防止Block永远不会被调用，我们还需要添加了一个超时方法，之前的错误的测试方法修改如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testAdditionAsync {
</span><span class='line'>    [Calculator add:2 to:2 block^(int result) {
</span><span class='line'>        STAssertEquals(result, 4, nil);
</span><span class='line'>        STSuccess(); // 通过调用这个宏来判断是否测试成功
</span><span class='line'>    }];
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>设计异步测试</h1>

<p>就像同步测试一样，异步测试也应该比被测试的功能简单许多。复杂的测试并不会改进代码的质量，反而会给测试本身带来更多的Bug,在以测试驱动开发的情况下，简单的测试会让我们对组件，接口以及架构的行为有更清醒的认识.</p>

<p>为了运行到实际中，我们创建了一个实例框架: <a href="sd">AsyncTestDemo</a>,它从一个虚拟的服务器获取图像信息，框架中包含了一个资源管理器，它对外提供了一个可以根据图像Id获取图像对象的接口。该接口的工作原理是资源管理器从虚拟服务器获取图片对象信息，并更新到数据库。</p>

<p>虽然这个示例框架只是为了演示，但在我们自己开发的许多应用中也使用了这种模式。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/PinacotecaCore.png" alt="test" /></p>

<p>从上图我们可以知道，示例框架有三个组件我们需要测试:</p>

<ol>
<li>模型层</li>
<li>模拟服务器请求的服务器接口控制器(API Controller)</li>
<li>管理Core data堆栈以及连接模型层和服务接口控制器的资源管理器</li>
</ol>


<h2>模型层</h2>

<p>测试应该尽量使用同步的方式进行，而模型层就是一个很好的实例。只要不同的被托管对象上下文之间没有复杂的依赖关系，测试用例都应该根据上下文在主线程上设置它自己的core data堆栈，并在其中执行各自的操作。</p>

<p>在这个测试实例中，我们就是在 setup 方法中设置core data堆栈，然后检查 PCImage实体的描述是否存在，如果不存在就构造一个，并更新它的值，当然这和异步测试没有关系，我们就不深入细说了。</p>

<h2>服务器接口控制器</h2>

<p>框架中的第二个组件就是服务器接口控制器，它主要处理服务器请求以及服务器API到模型的映射关系。让我们来看一下下面这个方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- [PCServerAPIController fetchImageWithId:queue:completionHandler:]</span></code></pre></td></tr></table></div></figure>


<p>调用它需要三个形参：一个图片对象Id，所在的执行队列，以及一个完成后的回调方法。</p>

<p>因为服务器根本不存在，一个比较好的做法就是伪造一个代理服务器，正好<a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a>可以解决这个问题。在它的最新版本中，可以在示例的请求响应中包含一个bundle,发送给客户端。</p>

<p>为了能stub请求，OHHTTPStubs需要在测试类初始化时或者 setup方法中进行配置。首先我们需要加载一个包含请求响应对象(response)的bundle:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSURL *url = [[NSBundle bundleForClass:[self class]]
</span><span class='line'>                        URLForResource:@"ServerAPIResponses"
</span><span class='line'>                         withExtension:@"bundle"];
</span><span class='line'>
</span><span class='line'>NSBundle *bundle = [NSBundle url];</span></code></pre></td></tr></table></div></figure>


<p>然后我们从bundle加载response对象，作为请求的响应值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OHHTTPStubsResponse *response;
</span><span class='line'>response = [OHHTTPStubsResponse responseNamed:@"images/123"
</span><span class='line'>                                   fromBundle:responsesBundle
</span><span class='line'>                                 responseTime:0.1];
</span><span class='line'>
</span><span class='line'>[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
</span><span class='line'>    return YES /* 如果所返回的request是我们所期望的，就返回YES */;
</span><span class='line'>} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
</span><span class='line'>    return response;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>通过如上的设置之后，简化版的<a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCServerAPIControllerTests.m">测试服务器接口控制器</a>如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testFetchImageAsync
</span><span class='line'>{
</span><span class='line'>    [self.server
</span><span class='line'>        fetchImageWithId:@"123"
</span><span class='line'>                   queue:[NSOperationQueue mainQueue]
</span><span class='line'>       completionHandler:^(id imageData, NSError *error) {
</span><span class='line'>          STAssertEqualObjects([NSOperationQueue currentQueue], queue, nil);
</span><span class='line'>          STAssertNil(error, [error localizedDescription]);
</span><span class='line'>          STAssertTrue([imageData isKindOfClass:[NSDictionary class]], nil);
</span><span class='line'>
</span><span class='line'>          // 检查返回的字典中的值.
</span><span class='line'>
</span><span class='line'>          STSuccess();
</span><span class='line'>       }];
</span><span class='line'>    STFailAfter(2.0, nil);    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>资源管理器</h2>

<p>最后一个部分是资源管理器，它不但把服务器接口控制器和膜形成呢个联系起来，还管理着core data堆栈。下面我们想测试获取一个图片对象的方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[PCResourceManager imageWithId:usingManagedObjectContext:queue:updateHandler:]</span></code></pre></td></tr></table></div></figure>


<p>该方法根据Id返回一个图片对象。如果图片在数据库中不存在，它会创建一个包含Id的新对象，然后通过服务器接口控制器获取图片对象的详细信息。</p>

<p>由于资源管理器的测试不应该依赖于服务器接口控制器，所以我们可以用<a href="http://ocmock.org/">OCMock</a>来模拟，如果要做方法的部分stub,它是一个理想的框架.如以下的 <a href="https://github.com/objcio/issue-2-async-testing/blob/master/PinacotecaCore/PinacotecaCoreTests/PCResourceManagerTests.m">资源管理器测试</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>OCMockObject *mo;
</span><span class='line'>mo = [OCMockObject partialMockForObject:self.resourceManager.server];
</span><span class='line'>
</span><span class='line'>id exp = [[serverMock expect] 
</span><span class='line'>             andCall:@selector(fetchImageWithId:queue:completionHandler:)
</span><span class='line'>            onObject:self];
</span><span class='line'>[exp fetchImageWithId:OCMOCK_ANY queue:OCMOCK_ANY completionHandler:OCMOCK_ANY];</span></code></pre></td></tr></table></div></figure>


<p>上面的代码实际上它并没有真正调用服务器接口控制器的方法，而是调用我们卸载测试类中的方法。</p>

<p>用上面的作坊，对资源管理的测试就变得很直观。当我们调用资源管理器获取资源时，实际上调用的使我们模拟的服务器接口控制器的方法，这样我们也能检查调用服务器接口控制器时参数是否正确。在调用了获取图像对象的方法后，资源管理器会更新模型，然后调用验证测试成功与否的宏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)testGetImageAsync
</span><span class='line'>{
</span><span class='line'>    NSManagedObjectContext *ctx = self.resourceManager.mainManagedObjectContext;
</span><span class='line'>    __block PCImage *img;
</span><span class='line'>    img = [self.resourceManager imageWithId:@"123"
</span><span class='line'>                  usingManagedObjectContext:ctx
</span><span class='line'>                                      queue:[NSOperationQueue mainQueue]
</span><span class='line'>                              updateHandler:^(NSError *error) {
</span><span class='line'>                                       // 检查error是否为空以及image是否已经被更新 
</span><span class='line'>                                       STSuccess();
</span><span class='line'>                                   }];    
</span><span class='line'>    STAssertNotNil(img, nil);
</span><span class='line'>    STFailAfter(2.0, @"Timeout");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>总结</h1>

<p>刚开始的时候，使用并发设计模式测试应用程序是具有一定的挑战性，但是一旦你理解了他们的不同，并建立最佳实践，一切都会变得简单而有趣。</p>

<p>😀fun~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios中的多任务]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu/"/>
    <updated>2016-04-19T10:17:49+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/19/ioszhong-de-duo-ren-wu</id>
    <content type="html"><![CDATA[<p>在ios7之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限，除了VOIP和基于地理位置特性之外，唯一能做的地方就是后台任务(background tasks)让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，或者备份用户的照片到你的服务器上，你都仅能完成一部分工作.</p>

<p> <!--more--></p>

<p>ios7添加了两个新的API以便你的程序可以在后台更新界面以及内容。首先是后台获取(background Fetch)，它允许你定义地从网络获取新的内容。第二个API就是远程通知(Remote Notifications)，这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务(Background Trasnfer service)中执行定期的任务，也允许你在进程之外可以执行网络传输(下载和上传)工作</p>

<p>后台获取(Background Fetch)和远程通知(Remote notification)基于简单的 ApplicationDelegate钩子，在应用程序挂起之前的30秒时间执行工作。它们不是用于CPU频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>

<p>对于用户来说,多任务处理有点显而易见的改变就是新的应用切换程序，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的&ndash;现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络，新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>

<h2>后台获取</h2>

<p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前出发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午一点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你想系统报告新数据无法获取，ios会适应并使用此信息避免会继续获取。</p>

<p>开启后台获取的第一步是在info plist文件中对UIBackgroundModes键指定特定的值。最简单的途径是在Xcode的project editor中新的Capabilities标签页设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/capabilities-on-bgfetch.jpg" alt="logo" /></p>

<p>或者你可以手动配置这个值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;key&gt;UIBackgroundModes&lt;/key&gt;
</span><span class='line'>&lt;array&gt;
</span><span class='line'>    &lt;string&gt;fetch&lt;/string&gt;
</span><span class='line'>&lt;/array&gt;  </span></code></pre></td></tr></table></div></figure>


<p>接下来，告诉IOS多久进行一次数据获取</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</span><span class='line'>{
</span><span class='line'>    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];
</span><span class='line'>
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ios默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该制定一个你想要的时间间隔。例如，一个天气的应用程序，可能只需要几个小时更新一次，IOS将会在后台获取之间至少等待你指定的时间间隔。</p>

<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把minimumBackgroundFetchInterval设置为UIApplicationBackgroundFetchIntervalNever,专业那个可以节省资源。</p>

<p>最后一步是在应用程序委托中实现下列方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)                application:(UIApplication *)application 
</span><span class='line'>  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];
</span><span class='line'>    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];
</span><span class='line'>
</span><span class='line'>    NSURL *url = [[NSURL alloc] initWithString:@"http://yourserver.com/data.json"];
</span><span class='line'>    NSURLSessionDataTask *task = [session dataTaskWithURL:url 
</span><span class='line'>                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
</span><span class='line'>
</span><span class='line'>        if (error) {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultFailed);
</span><span class='line'>            return;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // 解析响应/数据以决定新内容是否可用
</span><span class='line'>        BOOL hasNewData = ...
</span><span class='line'>        if (hasNewData) {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>        } else {
</span><span class='line'>            completionHandler(UIBackgroundFetchResultNoData);
</span><span class='line'>        }
</span><span class='line'>    }];
</span><span class='line'>
</span><span class='line'>    // 开始任务
</span><span class='line'>    [task resume];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有30秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面，30秒时间应该足够去网络获取数据和获取界面的缩略图，但是最多只有30秒，当完成了网络请求和更新界面后，你应该执行完成的回调。</p>

<p>完成回调的执行有两个目的，首先，系统会估量你的进程消耗的电量，并根据你传递的UIBackgroundFetchResult参数记录新数据是否可用，其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器，当用户在应用间切换时，用户将会看到新内容，这种通过completion handler来报告并且生成截图的方法，在新的多任务处理API中是很常见的。</p>

<p>在实际的应用中，你应该将completionHandler传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>

<p>在这里，你可能想知道ios是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的声明周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想象为用户从Springboard启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>

<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看UIAppcation的applicationState属性来判断应用是不是从后台启动。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Launched in background %d", UIApplicationStateBackground == application.applicationState);
</span><span class='line'>
</span><span class='line'>    return YES;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>测试后台数据获取</h2>

<p>有两种可以模拟后台获取的途径。最简单是从Xcode运行你的应用，当应用运行时，在Xcode的Debug菜单选择Simulate Background Fetch.</p>

<p>第二种方法，使用scheme更改Xcode运行程序的方式。在Xcode菜单的Product选项，选择Scheme然后选择Manager Schemes.在这里，你可以编辑或者添加一个新的scheme,然后选中Launch due to a background fetch event ,如下图:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/edit-scheme-simulate-background-fetch.png" alt="logo" /></p>

<h2>远程通知</h2>

<p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时消息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载一遍离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中有两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候的才会启动。</p>

<p>一条远程通知实际上只是一条普通的带有content-available 标志的推送通知。你可以发送一条带有提醒消息的推送去告诉用户有事情发生了，同时在后台对界面进行更新。但远程通知也可以做到安静的，没有提醒消息或者任何声音 的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>

<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。ios和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，知道设备下次发送保持活动状态的数据包，或者受到另外一个通知。</p>

<h2>发送远程通知</h2>

<p>要发送一条远程通知，需要在推送通知的有效负载设置content－available 标志。content－available 标志和用来通知报刊应用的键值是一样的。因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>

<p>我建议在开发的时候，使用<a href="http://nomad-cli.com/#houston">Nomand CLI&rsquo;s Houston</a>工具发送推送消息，当然你可以使用你喜欢的库或者脚本。</p>

<p>你可以通过nomad-cli ruby gem来安装Houston</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem install nomad-cli</span></code></pre></td></tr></table></div></figure>


<p>然后通过包含在Noman的apn实用工具发送一条通知:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Send a Push Notification to your Device
</span><span class='line'>apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42</span></code></pre></td></tr></table></div></figure>


<p>在这里，-n标志指定应该包含content-available 健值,-d标志允许添加我们自定义的数据键值到有效负荷.
通知的有效负荷(payload)结果和下面类似:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "aps" : {
</span><span class='line'>        "content-available" : 1
</span><span class='line'>    },
</span><span class='line'>    "content-id" : 42
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ios7中添加了新的应用程序委托方法，当接收到一条带有 content－available的推送通知时，下面的方法会被调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)application:(UIApplication *)application 
</span><span class='line'>  didReceiveRemoteNotification:(NSDictionary *)userInfo 
</span><span class='line'>        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Remote Notification userInfo is %@", userInfo);
</span><span class='line'>
</span><span class='line'>    NSNumber *contentID = userInfo[@"content-id"];
</span><span class='line'>    // 根据 content ID 进行操作
</span><span class='line'>    completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>和后台抓取一样，应用程序进入后台启动，也有30秒时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>

<h2>NSurlSession和后台传输服务(Background Transfer Service)</h2>

<p>NSURLSession是ios7添加的一个新类，它也是Foundation Networking中的新技术。作为NSURLConnection的替代品，一些熟悉的概念和类都保留下来了，例如NSURL,NSURLRequest,NSURLResponse.所以，你可以使用NSURLSessionTask这一NSURLConnnection的替代品，来处理网络请求及响应。一共有3种回话任务：数据，下载和上传。每一种都向NSURLSessionTask添加了语法糖，根据你的需要，适当选择一种。</p>

<p>一个NSURLSession对象协调一个或多个NSURLSessionTask对象，并根据NSURLSessionTask创建的NSURLSessionConfiguration实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的NSURLSessionTask对象。要利用后台传输服务，你将会使用<code>[NSURLSessionConfiguration backgroundSessionConfiguration]</code>来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>

<p>NSURLSessionConfiguration允许你设置默认的HTTP头，配置缓存策略，限制使用蜂窝煤数据等等。其中一个选项是discretionary标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备足够电量时，设备才通过wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>

<p>目前为止，我们大概了解了NSURLSession，以及一个后台回话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传入服务的下载队列。当下载完成后，我们会通知用户该文件已经可以用了。</p>

<h2>NSURLSessionDownloadTask</h2>

<p>首先，我们先处理一条远程通知，并把一个NSURLSessionDownloadTask添加到后台传输服务的队列。在backgroundURLSession方法张，我们根据后台回话配置，创建一个NSURLSession对象，并把application delegate作为回话的委托对象。文档不建议对于相同的标识符(identifier)创建多个回话对象，所以我们使用dispatch_once来避免潜在的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSURLSession *)backgroundURLSession
</span><span class='line'>{
</span><span class='line'>    static NSURLSession *session = nil;
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        NSString *identifier = @"io.objc.backgroundTransferExample";
</span><span class='line'>        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
</span><span class='line'>        session = [NSURLSession sessionWithConfiguration:sessionConfig 
</span><span class='line'>                                                delegate:self 
</span><span class='line'>                                           delegateQueue:[NSOperationQueue mainQueue]];
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    return session;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)           application:(UIApplication *)application 
</span><span class='line'>  didReceiveRemoteNotification:(NSDictionary *)userInfo 
</span><span class='line'>        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Received remote notification with userInfo %@", userInfo);
</span><span class='line'>
</span><span class='line'>    NSNumber *contentID = userInfo[@"content-id"];
</span><span class='line'>    NSString *downloadURLString = [NSString stringWithFormat:@"http://yourserver.com/downloads/%d.mp3", [contentID intValue]];
</span><span class='line'>    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];
</span><span class='line'>
</span><span class='line'>    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];
</span><span class='line'>    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];
</span><span class='line'>    task.taskDescription = [NSString stringWithFormat:@"Podcast Episode %d", [contentID intValue]];
</span><span class='line'>    [task resume];
</span><span class='line'>
</span><span class='line'>    completionHandler(UIBackgroundFetchResultNewData);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们使用NSURLSession类方法创建爱你一个下载任务，配置请求，并提供说明供以后使用。因为所有回话任务一开始处于挂起状态，你必须谨记要调用[task resume]保证开始了任务。</p>

<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现NSURLSessionDelegate或NSURLSessionTaskDelegate的方法，你应该阅读Apple的<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42">Life Cycle of a URL Session with Custom Delegates</a>文档，它讲解了所有类型回话任务的完成生命周期。</p>

<p>NSURLSessionDownloadDelegate中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时URL.你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#Pragma Mark - NSURLSessionDownloadDelegate
</span><span class='line'>
</span><span class='line'>- (void)         URLSession:(NSURLSession *)session 
</span><span class='line'>               downloadTask:(NSURLSessionDownloadTask *)downloadTask
</span><span class='line'>  didFinishDownloadingToURL:(NSURL *)location
</span><span class='line'>{
</span><span class='line'>    NSLog(@"downloadTask:%@ didFinishDownloadingToURL:%@", downloadTask.taskDescription, location);
</span><span class='line'>
</span><span class='line'>    // 用 NSFileManager 将文件复制到应用的存储中
</span><span class='line'>    // ...
</span><span class='line'>
</span><span class='line'>    // 通知 UI 刷新
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)  URLSession:(NSURLSession *)session 
</span><span class='line'>        downloadTask:(NSURLSessionDownloadTask *)downloadTask 
</span><span class='line'>   didResumeAtOffset:(int64_t)fileOffset 
</span><span class='line'>  expectedTotalBytes:(int64_t)expectedTotalBytes
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)         URLSession:(NSURLSession *)session 
</span><span class='line'>               downloadTask:(NSURLSessionDownloadTask *)downloadTask 
</span><span class='line'>               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten 
</span><span class='line'>  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
</span><span class='line'>{
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会受到一系列消息。App delegate的: handleEventsForBackgroundURLSession：方法会在这些NSURLSession委托的消息发送前被调用，然后URLSessionDidFinishEventsForBackgroundURLSession在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler）,并在后面的方法中执行回调以便更新界面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)                  application:(UIApplication *)application 
</span><span class='line'>  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
</span><span class='line'>{
</span><span class='line'>    // 你必须重新建立一个后台 seesiong 的参照
</span><span class='line'>    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为
</span><span class='line'>    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession
</span><span class='line'>    NSURLSession *backgroundSession = [self backgroundURLSession];
</span><span class='line'>
</span><span class='line'>    NSLog(@"Rejoining session with identifier %@ %@", identifier, backgroundSession);
</span><span class='line'>
</span><span class='line'>    // 保存 completion handler 以在处理 session 事件后更新 UI
</span><span class='line'>    [self addCompletionHandler:completionHandler forSession:identifier];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
</span><span class='line'>{
</span><span class='line'>    NSLog(@"Background URL session %@ finished events.\n", session);
</span><span class='line'>
</span><span class='line'>    if (session.configuration.identifier) {
</span><span class='line'>        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler
</span><span class='line'>        [self callCompletionHandlerForSession:session.configuration.identifier];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier
</span><span class='line'>{
</span><span class='line'>    if ([self.completionHandlerDictionary objectForKey:identifier]) {
</span><span class='line'>        NSLog(@"Error: Got multiple handlers for a single session identifier.  This should not happen.\n");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    [self.completionHandlerDictionary setObject:handler forKey:identifier];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)callCompletionHandlerForSession: (NSString *)identifier
</span><span class='line'>{
</span><span class='line'>    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];
</span><span class='line'>
</span><span class='line'>    if (handler) {
</span><span class='line'>        [self.completionHandlerDictionary removeObjectForKey: identifier];
</span><span class='line'>        NSLog(@"Calling completion handler for session %@", identifier);
</span><span class='line'>
</span><span class='line'>        handler();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果当后台传输完成时，应用程序不再停留在前台，那么对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用陈谷根本没有在运行，ios将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在application:didFinishLaunchingWithOptions: 方法被调用之后被调用.</p>

<h2>配置和限制</h2>

<p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读NSURLSessionConfiguration部分，以便最好滴满足你的使用场景。例如:NSURLSessionTasks通过NSURLSessionConfiguration的timeoutIntervalForResource属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限wifi宽带的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>

<p>除了下载任务，NSURLSession也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像ios6那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要再后台运行，一个比较好的做法是,把NSURLSessionConfiguration的sessionSendsLaunchEvents属性设置为NO。高效利用系统资源，是一件让Ios和用户都高兴的事。</p>

<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对NSURLSession的使用简单的基于block的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用Http重定向。后台传输服务只支持HTTP和HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>

<p>另外，要注意的是在后台回话中，NSURLSessionDataTasks是完全不支持的，你应该只处于短期的，小请求为目的的使用这些任务，而不是用来下载或上传。</p>

<h2>总结</h2>

<p>在ios7中强大的多任务和网络API为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的API，一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>

<ul>
<li>使用适当的新的API来为你的应用程序提供内容</li>
<li>尽可能早地调用completion handler以提高效率</li>
<li>让completion hander为应用程序更新界面快照</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsynDisplayKit入门篇]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian/"/>
    <updated>2016-04-15T10:22:30+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/15/asyndisplaykitru-men-pian</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>FaceBook的Paper团队给我们开源了一个很棒的库:<a href="https://github.com/facebook/AsyncDisplayKit">AsynDisplayKit</a>,这个库能让你通过将图像解码，布局以及渲染操作都放到后台线程处理，从而带来了快速响应的用户界面，也就是说不再会因为界面卡顿尔阻断用户交互。</p>

<!--more-->


<p>例如，对于非常复杂的界面，你可以使用 AsyncDisplayKit构建它而得到一种如丝般顺滑的，60帧每秒的滑动体验。而平常的UIkit优化就不太可能克服这样的性能挑战。</p>

<p>从本教程中，你将从一个初始项目开始，它主要有一个UICollectionView的滑动问题，而使用AysncDisplayKit将大大提供其滑动性能。一路上，你将学会如何在旧项目上使用AsyncDisplaykit.</p>

<blockquote><p><em>注意</em>，在本教程之前，你应该熟悉 Swift,Core Animation以及Core Graphics.</p></blockquote>

<h2>开始</h2>

<p>开始之前，请先看看<a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/">AsyncDisplayKit介绍</a>,对它有个简要的概念，知道它是解决什么问题的。</p>

<p>准备好了，就下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/04/Layers-Start.zip">开始项目</a>,你需要至少Xcode6.1和iosSDK 8.1来编译它，如果用最新Xcode打开，swift语法需要做下转换和修改，请自行解决这些兼容问题.</p>

<p>你要研究的项目是由UICollectionView制作的卡片式界面来描述不同的雨林动物，每张信息卡上包含了一个图片，名字以及一个队雨林动物的描述，卡片的背景图是主图片的模糊感，视觉上设计的效果保证了文字的清晰可读。</p>

<p><img src="http://cc.cocimg.com/api/uploads/20141124/1416797117122129.png" alt="logo" />
在Xcode中，打开初始项目的 Layers.xcworkspace。</p>

<p>在本教程里，请遵循以下原则以体会AsyncDisplayKit的那些十分吸引人的好处。</p>

<p>将应用运行到真机上，在模拟器上很难看出性能改善。</p>

<p>应用是通用的，但在ipad上看起来最好。</p>

<p>最后，要真正感谢这个库为你所有的事情，请尽量在最旧的ios8.1的设备上去运行该应用，第三代的ipad最好，因为它随让是视网膜屏，但是运行的不是很快。</p>

<p>运行该项目，效果如下:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt="logo" /></p>

<p>试着滑动CollectionVie并注意那可怜的帧率，在第三代ipad上，帧率只有15-20FPS，实在丢掉太多帧了，在本教程的最后，你能在60 FPS的帧率下滑动它.</p>

<blockquote><p><em>注意</em>
你所看到的图像都是在App的asset目录里，并不是从网络里获取的。</p></blockquote>

<p>在一个旧项目中使用AsyncDisplayKit前，你应该通过Instruments测量你的UI的性能，这样才能有一个基准线以便对比改动的效果。</p>

<p>最重要的是，你要知道是CPU-绑定，还是GPU-绑定，也就是说是CPU还是GPU拉低了应用的帧率，这个信息会告诉你该充分利用AsyncDisplayKit的那个特性以优化应用的性能。</p>

<p>如果你有时间，看看之前提到的WWDC2012 session 或在真实的设备上使用Instruments来评估初始项目的时间曲线。滑动性能是CPU-绑定的，你能猜到是什么原因导致了 CollectionView 丢掉了这么多帧吗?</p>

<h2>为项目准备好使用 AsyncDisplayKit</h2>

<p>在旧项目里使用AsyncDisplayKit，总结起来就是使用 Display Node 层级结构替换视图层级结构或Layer树，各种Display Node是AsyncDisplayKit的关键所在，它们位于视图之上，而且是线程安全的，也就是说之前在主线程才能执行的任务现在也可以在非主线程中执行。这就是减少主线程的工作量以执行其它操作，例如处理触摸事件，或如下本应用的情况下，处理CollectionView的滑动。</p>

<p>这就意味着在本教程里，你的第一步是移除视图层级结构。</p>

<h3>移除视图的层次结构</h3>

<p>打开 RainForestCardCell.Swift并删除awakeFromNib() 中所有的 addSubview(&hellip;.)调用，然后得到如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'>  contentView.layer.borderColor =
</span><span class='line'>    UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>  contentView.layer.borderWidth = 1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，替换LayoutSubviews()的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再讲configureCellDisplayWithCardInfo(cardInfo:)的内容替换如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>删除RainforestCardCell的所有视图属性，只留一个如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后编译运行，你看的的是黑洞洞的一片:</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt="logo" /></p>

<p>现在所有的cell都空了，滑动起来就很顺滑，你的目标是保证之后添加完各个Node之后，依然顺滑如初。</p>

<h3>添加一个占位图</h3>

<p>打开RainforestCardCell.swift,给RainforestCardCell添加一个可选的 CALayer变量，名为placeholderLayer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要一个占位图是因为显示会异步完成，如果这个过程需要一些时间，那用户就会看到空的cell 。就如同如果你要从网络上获取图像，那么就需要用占位图来填充Cell,这能让你的用户知道内容还没准备好。随让在我们这种情况下，你是在后台线程绘制而不是从网络上下载。</p>

<p>在awakeFromNib()里，删除contentView的border设置，再创建并配置一个placeholderLayer.将其添加到cell的contentview的layer上，现在这个方法如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func awakeFromNib() {
</span><span class='line'>  super.awakeFromNib()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer = CALayer()
</span><span class='line'>  placeholderLayer.contents = UIImage(named: "cardPlaceholder")!.CGImage
</span><span class='line'>  placeholderLayer.contentsGravity = kCAGravityCenter
</span><span class='line'>  placeholderLayer.contentsScale = UIScreen.mainScreen().scale
</span><span class='line'>  placeholderLayer.backgroundColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 1).CGColor
</span><span class='line'>  contentView.layer.addSublayer(placeholderLayer)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在layoutSubviews()里，你需要布局placeholderLayer.替换这个方法为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译并运行，你从虚无的边缘回来了:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt="logo" /></p>

<p>普通的CALayer不是由UIview支持的，当它们改变frame时，默认会有隐式动画，这就是你看到layer在布局放大时，要修复这个问题，改动layoutSubviews()如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func layoutSubviews() {
</span><span class='line'>  super.layoutSubviews()
</span><span class='line'> 
</span><span class='line'>  CATransaction.begin()
</span><span class='line'>  CATransaction.setValue(kCFBooleanTrue, forKey: kCATransactionDisableActions)
</span><span class='line'>  placeholderLayer?.frame = bounds
</span><span class='line'>  CATransaction.commit()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，问题解决了。</p>

<p>现在占位图不会乱动，不再动画它们的frame了。</p>

<h2>第一个Node</h2>

<p>重建App的第一步就是给每一个UICollectionView cell 添加一个背景图片的Node,步骤如下:</p>

<ol>
<li>创建，布局并添加一个图像Node到UICollectionView cell</li>
<li>处理cell重用Node和它们的layer</li>
<li>模糊图像Node</li>
</ol>


<p>但在做之前，打开 Layers-Bridging-Header.h 并导入 AsyncDisplayKit :</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;
</span><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>这会让所有的Swift文件都能访问AsyncDisplayKit类库。</p>

<p>编译一下，确保没有错误</p>

<p>现在，我们来看看Collectin View的祖成:</p>

<ul>
<li>View Controller: RainforestViewController没有什么花哨的东西，它只是为所有的雨林卡片获取一个数据数组，并为UIcollectioNView实现DataSource.事实上，你不需要花太多时间在这个上</li>
<li>DataSource:大部分时间都将花在Cell类的RainforestCardCell上，ViewController出队每个cell，并将雨林卡片的数据用configureCellDisplayWithCardInfo(cardInfo:) 传给它。cell就使用这个数据来配置自身.</li>
<li>Cell: 在configureCellDisplayWithCardInfo(cardInfo:)里，cell创建，配置，布局以及添加Node到它自己身上。这就意味着每次ViewController出队一个cell,这个cell就会创建并添加它自己一个新的Node层级结构</li>
</ul>


<p>如果你使用View而不是Node，那么这样做对于性能来说就不是最佳策略。但因为你可以异步的创建，配置以及布局，而且Node也是异步地绘制，所以这不会是一个问题。真正的难点是在cell准备重用时取消任何在进行额异步操作并移除旧的node.</p>

<p>然而，在实际生产中，你最好使用ASRangeController来缓存你的Node,这样你就不用每次在cell重用时重建它的Node层级结构，ASRangeController超出了本教程的范围。</p>

<p>OK，动手!</p>

<h3>添加背景图片Node</h3>

<p>现在你要走一遍用Node配置cell的过程，一次一步：
打开RainforestCardCell.swift 并替换configureCellDisplayWithCardInfo(cardInfo:) 为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个ASImageNode常量，叫做backgroundImageNode.</p>

<p>AsyncDisplayKit带有好几种Node类型，包括ASImageNode，用于显示图片。它相当于UIImageView,除了ASImageNode是默认异步的解码图片。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这让backgroundImageNode变为layer支持的Node.</p>

<p>Node可由UIview支持或CALayer支持，当node需要处理事件时（例如触摸事件），你就要使用UIView支持的Node.如果你不需要处理事件，只需要显示一下内容，那使用Layer支持的Node会更加轻量，因此可以获得一个小的性能提升。</p>

<p>因为本教程的APP不需要处理事件，所以你可以让所有的Node都设置为Layer支持的。在上面的代码中，由于backgroundImageNode为Layer支持的。AsyncDisplayKit会创建一个CALayer用于雨林动物图像内容的显示.</p>

<p>继续在 configureCellDisplayWithCardInfo(cardInfo:)添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>这里使用FrameCalculator为backgroundImageNode布局.</p>

<p>FrameCalculator是一个帮助类，负责给每个Node布局。注意所有的东西都是手动布局的，没有使用AutoLayout约束。<strong>如果你需要构建自适应布局或者本地化驱动的布局，那就要注意，因为你不能给Node添加约束</strong></p>

<p>接下来，添加如下代码到configureCellDisplayWithCardInfo(cardInfo:)底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layer and Wrap Up Section
</span><span class='line'>self.contentView.layer.addSublayer(backgroundImageNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>这句将backgroundImageNode的layer添加到cell ContentView的layer上。</p>

<blockquote><p><strong>注意</strong>
AsyncDisplayKit会为backgroundImageNode创建一个Layer.然而，你必须要将Node放到某个Layer树中才能在屏幕上显示，这个Node会异步地绘制，所以直到绘制完成，它的内容都不会显示，尽管它的Layer已经在一个Layer树中。</p></blockquote>

<p>从技术的角度来说，layer一直都存在。但渲染图像是异步进行的。layer初始化时没有内容，一旦渲染完成，layer的contents就会更新为包含图像的内容。</p>

<p>在这个点，cell的contentView的layer将会包含两个Sublayer:一个占位图和Node的layer。在node完成绘制前，只有占位图会显示。</p>

<p>注意到configureCellDisplayWithCardInfo(cardInfo:)会在每次cell出队时被调用。每次cell被回收，这个逻辑会添加一个新的sublayer到cell的contentview layer上。不要担心，你很快会解决这个问题。</p>

<p>回到RainforestCardCell.swift开头，给RainforestCardCell添加一个ASImageNode变量存为属性backgroundImageNode，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你之所以需要这个属性是因为必须要有某个东西将backgroundImageNode的引用保留住，否则ARC就会将其释放，也就不会有任何东西显示出来了&ndash;即使Node的在一个layer树中，你依然需要保留Node.</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:)底部的Node Layer and Wrap Up Section ,设置cell新的backgroundImageNode为之前的backgroundImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>下面是完整的configureCellDisplayWithCardInfo(cardInfo:) 方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Creation Section
</span><span class='line'>  let backgroundImageNode = ASImageNode()
</span><span class='line'>  backgroundImageNode.image = image
</span><span class='line'>  backgroundImageNode.contentMode = .ScaleAspectFill
</span><span class='line'>  backgroundImageNode.layerBacked = true
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layout Section
</span><span class='line'>  backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)
</span><span class='line'> 
</span><span class='line'>  //MARK: Node Layer and Wrap Up Section
</span><span class='line'>  self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>  self.backgroundImageNode = backgroundImageNode
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，观察AsyncDisplaytKit是如何异步地使用图像设置Layer的Contents的。这能让你在CPU还在绘制layer的内容的同事上下滑动页面。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>如果你运行在旧设备上，注意图像是如何弹出到位置&ndash;这是爆米花效果，但不总是让人喜欢。本教程的最后一节将会搞定这个不令人愉快的弹出效果，给你展示图像如何弹入弹出，如同摇滚巨星。</p>

<p>如同之前所讨论的，新的Node会在每次cell被重用时创建，这并不理想，因为这意味着新的Layer会在每次cell被重用时加入。</p>

<p>如果你想看看Sublayer堆积太多的影响，那就不停的滑上滑下，然后加断点打印出cell的contentview的Layer的sublayers属性。你会看到很多layer,这不好.</p>

<h2>处理cell重用</h2>

<p>继续RainforestCardCell.swift,给RainforestCardCell 添加一个contentLayer的CALayer属性，这个属性也是一个可选类型:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你将使用此属性去移除Cell的ContentView的Layer树中旧的Node Layer.虽然你可以简单地保留Node并访问其Layer属性，但上面的写法更加明确。</p>

<p>添加如下代码到configureCellDisplayWithCardInfo(cardInfo:) 结尾：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.contentLayer = backgroundImageNode.layer</span></code></pre></td></tr></table></div></figure>


<p>这句让backgroundImageNode的Layer保留到contentLayer属性。</p>

<p>替换prepareForReuse()的实现如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'>  backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为AsyncDisplaytKit能够异步地绘制Node,所以Node让你能预防从头绘制或取消任何在进行的绘制。无论是你需要预防或取消绘制，都可将preventOrcancelDisplay设置为true,如上面的代码所示，在本来中，你要在cell被重用前取消任何正在进行的绘制活动.</p>

<p>接下来，添加如下代码到prepareForReuse（）尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer?.removeFromSuperlayer()</span></code></pre></td></tr></table></div></figure>


<p>这将contentLayer从其SuperLayer(也就是contentview的Layer)中移除.</p>

<p>每次一个cell被回收时，这个代码就移除Node的旧Layer,因而解决了堆积问题。所以在任何时间，你的Node最多只有两个sublayer:占位图和Node的Layer.</p>

<p>接下来添加如下代码到prepareForReuse()尾部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>contentLayer = nil
</span><span class='line'>backgroundImageNode = nil</span></code></pre></td></tr></table></div></figure>


<p>这确保cell释放它们的引用，这样如有必要，ARC才好做清理工作。</p>

<p>编译运行，这次，没有sublayer会堆积的问题，且所有不必要的绘制都将被取消.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt="logo" /></p>

<p>是时候来点模糊效果了!
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/asyncscroll.png" alt="blue" /></p>

<h2>模糊图像</h2>

<p>要实现模糊图像，你要添加一个额外的步骤到图像Node的显示过程里。</p>

<p>继续RainforestCardCell.swift ,在configureCellDisplayWithCardInfo(cardInfo:) 的设置backgroundImageNode.layerBacked 的后面，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'>  if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>    30,
</span><span class='line'>    tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>    saturationDeltaFactor: 1.8,
</span><span class='line'>    maskImage: nil, 
</span><span class='line'>    didCancel:{ return false }) {
</span><span class='line'>      return blurredImage
</span><span class='line'>  } else {
</span><span class='line'>    return image
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ASImageNode的imageModificationBlock给你一个积水在显示之前去处理底层的图像，这是非常实用的功能，它让你对图像Node做一些操作，例如添加滤镜等。</p>

<p>在上面的代码中，你使用imageModificationBlock来为cell的背景图像应用模糊效果。关键点就是图像Node将会绘制它的内容并在后台执行这个闭包，而主线程依然顺滑流畅。这个闭包接受原始的UIImage并返回一个修改过的UIimage.</p>

<p>上面的代码使用了UIImage的模糊category,它由Apple在WWDC2013提供。使用了Accelerate framework 在CPU上模糊图像。因为模糊会消耗很多时间和内存，这个版本的category被修改为包含了取消机制。这个模糊方法将定期调用didCancel闭包来决定是否应该停止模糊。</p>

<p>现在，上面的代码给didCancel简单地返回false,之后你可以重写didCancel闭包.</p>

<blockquote><p><em>注意</em>
还记得第一次运行APP时collectionView那可怜的滑动效果吗？模糊方法阻塞了主线程。通过使用AsyncDisplayKit将模糊放入后台线程，你就大幅度地提高了CollectionView的滑动性能。简直天壤之别。</p></blockquote>

<p>编译并运行，观察模糊效果:
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="lgo" />
注意你可以非常流畅的滑动页面了</p>

<p>当Collectionview出队一个cell时，一个模糊操作将开始后台线程，当用户快速滑动时，CollectionView会重用每个cell多次，并开始许多模糊操作。我们的目标是在cell准备重用时取消正在进行中的模糊操作。</p>

<p>你已经在prepareForReuse()里取消了Node的绘制操作，但一旦控制被移交给处理你图像修改的闭包，那就是你的责任来处理Node的preventOrCancelDisplay的设置。</p>

<h2>取消模糊操作</h2>

<p>要取消进行中的模糊操作，你需要实现模糊方法的didCancel闭包.</p>

<p>添加一个捕获列表到imageModificationBlock以捕捉一个backgroundImageNode的weak引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>   ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你需啊哟weak引用来避免闭包和图像Node之间的循环引用问题。你将使用这个weak  backgroundImageNode 来确定是否要取消模糊操作。</p>

<p>是时候构建模糊取消碧波啊了。添加如下代码到imageModificationBlock:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in
</span><span class='line'>  if input == nil {
</span><span class='line'>    return input
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  let didCancelBlur: () -&gt; Bool = {
</span><span class='line'>    var isCancelled = true
</span><span class='line'>    // 1
</span><span class='line'>    if let strongBackgroundImageNode = backgroundImageNode {
</span><span class='line'>      // 2
</span><span class='line'>      let isCancelledClosure = {
</span><span class='line'>        isCancelled = strongBackgroundImageNode.preventOrCancelDisplay
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>      // 3
</span><span class='line'>      if NSThread.isMainThread() {
</span><span class='line'>        isCancelledClosure()
</span><span class='line'>      } else {
</span><span class='line'>        dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    return isCancelled
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面解释一下这些代码：</p>

<ol>
<li>得到backgroundImageNode的Strong引用，准备其干活。如果backgroundImageNode在本次运行时小时，那么isCancelled将保持为true,然后模糊操作会被取消，如果没有Node需要显示，自然没有必要继续模糊操作。</li>
<li>在此你将操作取消检查包在闭包里，因为一旦Node创建它的Layer或View，那就只能在主线程访问Node的属性。由于你需要访问preventOrCancelDisplay，所以你必须在主线程检查。</li>
<li>最后，确保isCancelledClosure是在主线程进行，无论是在主线程直接运行，还是不再主线程而通过dispatch_sync来调度。它必须是一个同步的调度，因为我们需要闭包完成，并在didCancelblue闭包返回之前设置isCancelled.</li>
</ol>


<p>在调用applyBlurWithRadius(&hellip;)中，修改传递给didCancel的参数，替换一直返回false的闭包为你刚才定义并保留在didCancelBlur的闭包。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let blurredImage = input.applyBlurWithRadius(
</span><span class='line'>  30,
</span><span class='line'>  tintColor: UIColor(white: 0.5, alpha: 0.3),
</span><span class='line'>  saturationDeltaFactor: 1.8,
</span><span class='line'>  maskImage: nil,
</span><span class='line'>  didCancel: didCancelBlur) {
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你看你不会注意到太多差别，但现在任何在cell离开屏幕时还未完成的模糊都会被取消了。这就意味着设备比之前做的更少。你可能观察到轻微的性能提升，特别是在较慢的设备如第三代iPad上运行。</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<p>你的卡片需要内容，通过下面四个小节，你将学会:</p>

<ul>
<li>创建一个容器Node,它将所有的SubNode绘制到一个单独的CALayer里</li>
<li>构建一个Node层次结构</li>
<li>创建一个自定义的ASDispalyNode子类，并在后台构建并布局Node层次结构</li>
</ul>


<p>做完这些，你就会得到一个看起来和添加AsyncDisplayKit之前一样的APP，但有着黄油版顺滑的滑动体验。</p>

<h2>栅格化的容器Node</h2>

<p>直到现在，你一直在操作cell内的一个单独的Node，接下来，你将创建一个容器Node，它会包含所有卡片内容。</p>

<h3>添加一个容器Node</h3>

<p>继续 RainforestCardCell.swift,在 configureCellDisplayWithCardInfo(cardInfo:) 的backgroundImageNode.imageModificationBlock后面以及Node Layout Section前面添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Container Node Creation Section
</span><span class='line'>let containerNode = ASDisplayNode()
</span><span class='line'>containerNode.layerBacked = true
</span><span class='line'>containerNode.shouldRasterizeDescendants = true
</span><span class='line'>containerNode.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor
</span><span class='line'>containerNode.borderWidth = 1</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做containerNode的ASDisplayNode常量。注意这个容器的shouldRasterizeDescendants,这是一个关于节点如何工作的提示以及一个如何让它们工作的更好的机会.</p>

<p>如单词<code>descendants (子孙)</code>所暗示的，你可以创建 AsyncDisplayKit Node的层次结构或树，就如你可以创建Core Animation Layer 的层次结构一样。例如，如果你有一个都是Layer支持的Node层级结构，那么AsyncDisplaykit将会为每个Node创建一个分离的CALayer,Layer层次结构将会和Node层级结构一样，如同镜像。</p>

<p>这听起来很熟悉：它类似于当你使用UIkit时，Layer层次结构镜像于View层次结构。然而，这个Layer的栈有一些不同的效果。</p>

<p>首先，因为是异步渲染，你就不会看到每个layer一个接一个的显示，当AsyncDisplayKit绘制完成每个layer，它马上制作layer的显示内容，所以如果你有一个layer的绘制比其他layer耗时更长，那么它将会在它们之后显示。用户会看到零碎的layer组件，这个过程通常是不可见的，因为Core Animation会在显示任何东西之前重绘所有必须的Layer。</p>

<p>第二，有需要Layer能够引起性能问题。每个CALayer都需要一个支持存储来保存它的像素位图和内容。同样，CoreAnimation必须将每个Layer通过XPC发给渲染服务器。最后，渲染服务器可能需要重绘一些Layer以复合它们，例如在混合layer时，总的来说，更多的Layer意味着CoreAnimation更多的工作。所以限制layer使用的数量有许多不同的好处。</p>

<p>为了解决这个问题，AsyncDisplayKit有一个方便的特性，它允许你绘制一个Node层次结构到一个单独的Layer容器里。这就是shouldRasterizeDescendants所做的，当你设置它，那在完成素有的subnode的绘制之前，ASDisplayNode将不会设置Layer的Contents。</p>

<p>所以在之前的步骤里，设置容器Node的shouldRasterizeDescendants为true有两个好处:</p>

<ol>
<li>它确保卡片一次显示所有的Node，如同旧的同步绘制</li>
<li>而且它通过栅格化Layer栈为单个Layer并较少未来的合成而提高了效率</li>
</ol>


<p>不足之处是，由于你将所有的layer放入了一个位图，你就不能再之后单独动画某个Node了。</p>

<p>接下来，在 Container Node Creation Section后，添加backgroundImageNode为containerNode的subnode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><em>注意</em>
添加Node的顺序很重要，就如同subview和sublayer,最先添加的Node会被之后添加的阻挡显示</p></blockquote>

<p>替换 Node Layout Section 的第一行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Layout Section
</span><span class='line'>containerNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</span></code></pre></td></tr></table></div></figure>


<p>最后，使用FrameCalculator布局backgroundImageNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>backgroundImageNode.frame = FrameCalculator.frameForBackgroundImage(
</span><span class='line'>  containerBounds: containerNode.bounds)</span></code></pre></td></tr></table></div></figure>


<p>这设置backgroundImageNode填满整个containerNode.</p>

<p>你几乎完成了新的Node层次结构，但首先你需要正确地设置Layer层次结构，因为容器Node现在是根。</p>

<h3>管理容器Node的Layer</h3>

<p>在Node Layer and Wrap Up Section，将backgroundImageNode的Layer添加到containerNode的layer上，而不是containerView的Layer上:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentView.layer.addSublayer(backgroundImageNode.layer)
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentView.layer.addSublayer(containerNode.layer)</span></code></pre></td></tr></table></div></figure>


<p>删除下面的backgroundImageNode保留:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.backgroundImageNode = backgroundImageNode</span></code></pre></td></tr></table></div></figure>


<p>因为cell只需要单独保留容器Node,所以你要移除backgroundImageNode属性。</p>

<p>不再设置cell的contentLayer属性为backgroundImageNode的Layer,现在将其设置为containerNode的layer：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Replace the following line...
</span><span class='line'>// self.contentLayer = backgroundImageNode.layer
</span><span class='line'>// ...with this line:
</span><span class='line'>self.contentLayer = containerNode.layer</span></code></pre></td></tr></table></div></figure>


<p>给RainforestCardCell添加一个可选的ASDisplayNode实例存储为属性containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>记住你需要保留你自己的Node，如果你不怎么做它们就会被立即释放。</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:)，在Node Layer and Wrap Up Section 最后，设置containerNode属性为containerNode常量:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>编译运行，模糊的图形将会再次显示！但还有最后一件事要去改变，因为现在有了新的Node层次结构，回忆之前cell重用时你将图像停止显示。现在你需要让整个Node层次结构停止显示。</p>

<h3>在新的Node层次结构上处理cell重用</h3>

<p>继续RainforestCardCell.swift ，在prepareForReuse()里，替换设置backgroundImageNode.preventOrCancelDisplay 为在 containerNode 上调用 recursiveSetPreventOrCancelDisplay(&hellip;) 并传递 true：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode?.preventOrCancelDisplay = true
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'> 
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你要取消整个Node层次结构的绘制，就使用 recursiveSetPreventOrCancelDisplay()。这个方法将会设置这个node以及所有子Node的preventOrCancelDisplay属性，无论true或false。</p>

<p>接下来，依然在prepareForReuse(),用设置containerNode为nil替换设置backgroundImageNode为nil:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  ...
</span><span class='line'>  contentLayer = nil
</span><span class='line'>
</span><span class='line'>  // Replace this line...
</span><span class='line'>  // backgroundImageNode = nil
</span><span class='line'>  // ...with this line:
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>移除RainforestCardCell的backgroundImageNode属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  // var backgroundImageNode: ASImageNode? ///&lt; REMOVE THIS LINE
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，这个APP就如之前一样，但现在你的图像Node在容器Node内，而重用依然和它应有的方式一样.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt="logo" /></p>

<h2>cell内容</h2>

<p>目前为止你有了一个Node层级结构，但容器内还只有一个Node&ndash;图像Node.现在是时候设置Node层次结构去复制在添加AsyncDisplayKit之前时应用的视图层次结构了。这意味着添加text和一个未模糊的特征图像。</p>

<h3>添加特征图像</h3>

<p>我们要添加特征图像了，它是一个未模糊的图像，显示在卡片的顶部。</p>

<p>打开RainforestCardCell.swift ，并找到configureCellDisplayWithCardInfo(cardInfo:).在Node Creation Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let featureImageNode = ASImageNode()
</span><span class='line'>featureImageNode.layerBacked = true
</span><span class='line'>featureImageNode.contentMode = .ScaleAspectFit
</span><span class='line'>featureImageNode.image = image</span></code></pre></td></tr></table></div></figure>


<p>这会创建并配置一个叫做featureImageNode的ASImageNode常量。它被设置为Layer支持的，放大以适用，并设置显示图像，这次不需要模糊。</p>

<p>在Node Hierarchy Section的最后，添加featureImageNode为containerNode的subNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(featureImageNode)
</span></code></pre></td></tr></table></div></figure>


<p>你正在用更多Node填充容器哦!</p>

<p>在Node Layout Section中，使用FrameCalculator布局featureImageNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>featureImageNode.frame = FrameCalculator.frameForFeatureImage(
</span><span class='line'>  featureImageSize: image.size,
</span><span class='line'>  containerFrameWidth: containerNode.frame.size.width)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你就会看到特征图像在卡片的顶部出现，位于模糊图像的上方，注意特征图像和模糊图像是如何在同一时间跳出。这是你之前添加的shouldRasterizeDescendants在起作用.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0015.png" alt="logo" /></p>

<h2>添加Title文本</h2>

<p>接下来添加文字Label,以显示动物的名字和描述，首先来添加动物名字吧。</p>

<p>继续configureCellDisplayWithCardInfo(cardInfo:),找到Node Creation Section。添加下列代码到这节尾部，就在创建featureImageNode之后：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let titleTextNode = ASTextNode()
</span><span class='line'>titleTextNode.layerBacked = true
</span><span class='line'>titleTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(cardInfo.name)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做titleTextNode的AsTextNode常量。</p>

<p>ASTextNode是另一个AsyncDisplayKit提供的Node子类，其用于显示文本。他是一个具有UIlabel效果的Node.它接受一个attributedString,由TextKit支持，有许多特性如文本链接，要学到更多关于这个Node的功能，去看ASTextNode.h吧。</p>

<p>初始羡慕包含一个NSAttributedString的扩展，它提供了一个工厂方法去生成一个属性字符串用于Title和Description文本以显示在雨林卡片上。上面的代码使用了这个扩展的attributedStringForTitleText(&hellip;) 方法。</p>

<p>现在在Node Hierarchy Section 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(titleTextNode)</span></code></pre></td></tr></table></div></figure>


<p>这就添加了titleTextNode到Node层次结构里，它将位于特征图像和背景图像智商，因为它在它们之后添加。</p>

<p>在Node Layout Section底部添加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>titleTextNode.frame = FrameCalculator.frameForTitleText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>一样使用FrameCalculator布局titleTextNode,就像backgroundImageNode和featureImageNode那样。</p>

<p>编译运行，你就有了一个title显示在特征图像的顶部。再次说明，Label只会在整个Cell准备好渲染时才渲染。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0017.png" alt="logo" /></p>

<h2>添加Description文本</h2>

<p>添加一个有着Description文本的Node和添加Title文本的Node类似.</p>

<p>回到configureCellDisplayWithCardInfo(cardInfo:),在 Node Creation Section 最后，添加如下代码。就在之前创建titleTextNode的语句之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let descriptionTextNode = ASTextNode()
</span><span class='line'>descriptionTextNode.layerBacked = true
</span><span class='line'>descriptionTextNode.backgroundColor = UIColor.clearColor()
</span><span class='line'>descriptionTextNode.attributedString = 
</span><span class='line'>  NSAttributedString.attributedStringForDescriptionText(cardInfo.description)</span></code></pre></td></tr></table></div></figure>


<p>这就创建并配置了一个叫做descriptionTextNode的AStextNode实例。</p>

<p>在 Node Hierarchy Section最后，添加descriptionTextNode到containerNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>在 Node Layout Section,一样使用FrameCalculator布局descriptionTextNode：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>descriptionTextNode.frame = FrameCalculator.frameForDescriptionText(
</span><span class='line'>  containerBounds: containerNode.bounds,
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，现在你能看到Description文本了。
<img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0018.png" alt="logo" /></p>

<h2>自定义Node子类</h2>

<p>目前为止，你使用了ASImageNode和AStextNode,但有些时候你需要自己定义Node,就如同某些时候在传统的UIKit编程里你需要自己的View一样。</p>

<h3>创建梯度Node类</h3>

<p>接下来，你将给GradientView.swift 添加Core Graphics 代码来构建一个自定义的梯度Display Node,这回被用于创建一个绘制梯度的自定义Node.梯度图会显示在特征图像的地步以便让Title看起来更加明显。</p>

<p>打开Layers-Bridging-Header.h，并添加如下代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;AsyncDisplayKit/_ASDisplayLayer.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>需要这一步是因为这个类没有包含在主头文件中，你在子类化任何ASDisplayNode或者_ASDisplayLayer时都需要访问这个类。</p>

<p>菜单 File\New\File… 。选择 iOS\Source\Cocoa Touch Class 。命名类为 GradientNode 并使其作为 ASDisplayNode 的子类。选择 Swift 语言并点击 Next 。保存文件再打开 GradientNode.swift 。</p>

<p>添加如下方法到这个类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如同Uiview或者CALayer,你可以子类化ASDisplayNode去做自定义绘制。你可以使用如同用于UIView的Layer或单独的CALayer的绘制代码，这取决于客户Node如何配置Node.查看ASDisplayNode+Subclasses.h 获取更多关于子类化 ASDisplayNode 的信息。</p>

<p>进一步，ASDisplayNode的绘制方法比在UIView和CALayer里接受更多参数，给你提供方法少做工作，更有效率。</p>

<p>要为你的自定义DisplayNode填充内容，你需要实现来自<em>ASDisplayLayerDelegate协议的drawRect(&hellip;) 或 displayWithParameters(&hellip;)。在继续之前，看看 </em>ASDisplayLayer.h 得到这个方法和它们参数的信息。搜索_ASDisplayLayerDelegate。重点看看头文件注释里关于drawRect(..)的描述。</p>

<p>因为梯度图位于特征图的上方，使用Core Graphics 绘制，所以你需要使用drawRect.</p>

<p>打开GradientView.swift 并拷贝drawRect(&hellip;)的内容到GradientNode.swift 的drawRect(&hellip;)，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,
</span><span class='line'>    isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {
</span><span class='line'>  let myContext = UIGraphicsGetCurrentContext()
</span><span class='line'>  CGContextSaveGState(myContext)
</span><span class='line'>  CGContextClipToRect(myContext, bounds)
</span><span class='line'>
</span><span class='line'>  let componentCount: UInt = 2
</span><span class='line'>  let locations: [CGFloat] = [0.0, 1.0]
</span><span class='line'>  let components: [CGFloat] = [0.0, 0.0, 0.0, 1.0,
</span><span class='line'>    0.0, 0.0, 0.0, 0.0]
</span><span class='line'>  let myColorSpace = CGColorSpaceCreateDeviceRGB()
</span><span class='line'>  let myGradient = CGGradientCreateWithColorComponents(myColorSpace, components,
</span><span class='line'>    locations, componentCount)
</span><span class='line'>
</span><span class='line'>  let myStartPoint = CGPoint(x: bounds.midX, y: bounds.maxY)
</span><span class='line'>  let myEndPoint = CGPoint(x: bounds.midX, y: bounds.midY)
</span><span class='line'>  CGContextDrawLinearGradient(myContext, myGradient, myStartPoint,
</span><span class='line'>    myEndPoint, UInt32(kCGGradientDrawsAfterEndLocation))
</span><span class='line'>
</span><span class='line'>  CGContextRestoreGState(myContext)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后删除GradientView.swift,确保编译没有错误</p>

<h3>添加梯度Node</h3>

<p>打开RainforestCardCell.swift并找到configureCellDisplayWithCardInfo(cardInfo:)，在Node Creation Section底部，添加如下代码，就在创建descriptionTextNode的代码之后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let gradientNode = GradientNode()
</span><span class='line'>gradientNode.opaque = false
</span><span class='line'>gradientNode.layerBacked = true</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个叫做gradientNode的GradientNode常量。</p>

<p>在Node Hierarchy Section，在添加featureImageNode那样下面，添加gradientNode到containerNode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//MARK: Node Hierarchy Section
</span><span class='line'>containerNode.addSubnode(backgroundImageNode)
</span><span class='line'>containerNode.addSubnode(featureImageNode)
</span><span class='line'>containerNode.addSubnode(gradientNode) ///&lt; ADD THIS LINE
</span><span class='line'>containerNode.addSubnode(titleTextNode)
</span><span class='line'>containerNode.addSubnode(descriptionTextNode)</span></code></pre></td></tr></table></div></figure>


<p>梯度Node需要这个位置才能在特征图之后，Title之下。</p>

<p>然后添加如下代码到Node Layout Section底部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gradientNode.frame = FrameCalculator.frameForGradient(
</span><span class='line'>  featureImageFrame: featureImageNode.frame)</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你将看到梯度在特征图的底部，title确实看的更清楚了</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>爆米花特效</h2>

<p>如之前提到的，cell的Node内容会在完成绘制时“弹出”，这不是很理想，所以让我们继续，以修复这个问题，但首先，更加深入AsyncDisplayKit以看看它是怎么工作的。</p>

<p>在configureCellDisplayWithCardInfo(cardInfo:) 的Container Node Creation Section，关闭容器Node的shouldRasterizeDescendants：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = false</span></code></pre></td></tr></table></div></figure>


<p>编译运行，你会注意到现在容器层次结构里不同的Node一个接一个的弹出。你会看到文字弹出然后是特征图，然后是模糊背景图。</p>

<p>当shouldRasterizeDescendants关闭后，AsyncDisplayKit就不是绘制一个容器Layer了，它会创建一个镜像卡片Node层次结构的Layer数。记得爆米花特效存在是因为每个Layer都在它绘制结束后立即出现，而某些Layer比另外一个花费更多时间在绘制上。</p>

<p>这不是我们所需要的，但它描述了AsyncDisplayKit的工作方式，我们不想要这个行为，所以还是将shouldRasterizeDescendants打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.shouldRasterizeDescendants = true</span></code></pre></td></tr></table></div></figure>


<h2>在后台构造Node</h2>

<p>除了异步的绘制，使用AsyncDisplayKit,你同样可以异步地创建，配置以及布局。深呼吸一下，接下来开始做事情。</p>

<h3>创建一个Node构造操作(OPeration)</h3>

<p>你要讲Node层次结构的构造包装到一个NSOperation中，这样做很棒，因为这个操作能很容易的在不同的操作队列中执行，包括后台队列。</p>

<p>打开RainforestCardCell.swift ，然后添加如下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func nodeConstructionOperationWithCardInfo(cardInfo: RainforestCardInfo, image: UIImage) -&gt; NSOperation {
</span><span class='line'>  let nodeConstructionOperation = NSBlockOperation()
</span><span class='line'>  nodeConstructionOperation.addExecutionBlock { 
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>  return nodeConstructionOperation
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>绘制并不是唯一会拖慢主线程的操作，对于复杂的屏幕，布局计算也有可能变得昂退。目前为止，本教程当前状态的项目，一个缓慢的Node布局会引起Collectionview丢帧。</p>

<p>60FPS意味着你有大约17ms的时间让你的cell准备好显示，否则一个或者多个帧就会被丢掉。这在Table view和 collection view有很复杂的cell时时非常常见的，滑动时丢帧就是这个原因。</p>

<p>AsyncDisplayKit前来救援</p>

<p>你将使用上面的nodeConstructionOperation将所有Node层次结构以及布局从主线程剥离并放入后台NSOperatonQueue，进一步确保Collection view能尽量以接近60 fps的帧率滑动。</p>

<blockquote><p><em>注意</em>
你可以在后台访问并设置Node的属性，但只能在Node的Layer或View被创建之前，也就是当你第一次访问Node的Layer或View属性时。</p></blockquote>

<p>一旦Node的Layer或View被创建，你必须在主线程才能访问和设置Node的属性，因为Node将会转发这些调用到它的Layer或View.如果你得到一个崩溃log说“Incorrect display node thread affinity”,那就意味着在创建Node的Layer或View之后，你依然尝试在后台访问或设置Node的属性。</p>

<p>修改nodeConstructionOperation 操作Block的内容如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nodeConstructionOperation.addExecutionBlock {
</span><span class='line'>  [weak self, unowned nodeConstructionOperation] in
</span><span class='line'>  if nodeConstructionOperation.cancelled {
</span><span class='line'>    return
</span><span class='line'>  }
</span><span class='line'>  if let strongSelf = self {
</span><span class='line'>    // TODO: Add node hierarchy construction
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在这个操作运行时，cell可能已经被释放了，在那种情况下，你不需要做任何工作。类似的，如果操作被取消了，那一样也没有工作要做了。</p>

<p>之所以对nodeConstructionOperation使用 unowner无主引用是为了避免在操作和执行必要之间产生循环引用。</p>

<p>现在找到configureCellDisplayWithCardInfo(cardInfo:)。将任何在Image Size Section之后的代码移动到nodeConstructionOperation的执行闭包里，将代码放在strongSelf的条件语句里，即 TODO的位置，之后configureCellDisplayWithCardInfo(cardInfo:)将开起来如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>目前，你会有一些编译错误，这是因为操作Block里的self是weak引用，因此是可选的。但你有一个self的strong引用，因为代码在可选绑定语句内。所以替换错误的几行成下面的样子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>strongSelf.contentLayer = containerNode.layer
</span><span class='line'>strongSelf.containerNode = containerNode</span></code></pre></td></tr></table></div></figure>


<p>最后，添加如下代码到你刚改动的三行之下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>containerNode.setNeedsDisplay()</span></code></pre></td></tr></table></div></figure>


<p>编译确保没有错误。如果你现在运行，那么之后占位图会显示，因为Node的创建操作还没有实际使用。让我们来添加它</p>

<h3>使用Node创建操作</h3>

<p>打开 RainforestCardCell.swift 并添加如下属性：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestCardCell: UICollectionViewCell {
</span><span class='line'>  var featureImageSizeOptional: CGSize?
</span><span class='line'>  var placeholderLayer: CALayer!
</span><span class='line'>  var backgroundImageNode: ASImageNode?
</span><span class='line'>  var contentLayer: CALayer?
</span><span class='line'>  var containerNode: ASDisplayNode?
</span><span class='line'>  var nodeConstructionOperation: NSOperation? ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就添加了一个叫做nodeConstructionOperation可选属性。
当Cell准备回收时，你会使用这个属性取消Node的构造。这会在用户非常快速地滑动Collection View时发生，特别是如果布局还需要一些计算时间的话。</p>

<p>在prepareForReuse()添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func prepareForReuse() {
</span><span class='line'>  super.prepareForReuse()
</span><span class='line'> 
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let operation = nodeConstructionOperation {
</span><span class='line'>    operation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  containerNode?.recursiveSetPreventOrCancelDisplay(true)
</span><span class='line'>  contentLayer?.removeFromSuperlayer()
</span><span class='line'>  contentLayer = nil
</span><span class='line'>  containerNode = nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这就在cell重用时取消了操作，所以如果Node创建还没完成，它也不会完成。</p>

<p>现在找到 configureCellDisplayWithCardInfo(cardInfo:) ,并添加如下指示的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {
</span><span class='line'>  // ADD FROM HERE...
</span><span class='line'>  if let oldNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    oldNodeConstructionOperation.cancel()
</span><span class='line'>  }
</span><span class='line'>  // ...TO HERE
</span><span class='line'> 
</span><span class='line'>  //MARK: Image Size Section
</span><span class='line'>  let image = UIImage(named: cardInfo.imageName)!
</span><span class='line'>  featureImageSizeOptional = image.size
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个Cell现在会在它准备重用并开始配置时，取消任何进行中的 Node构造操作。这确保了操作被取消，即使cell在准备重用前就被重新配置。</p>

<p>在主线程运行</p>

<p>AsyncDisplayKit允许你在非主线程做许多工作。但当它要面对UIKit和CoreAnimation时，你还是需要在主线程做。目前为止，你从主线程移走了所有的Node创建，但还有一件事需要被放在主线程&ndash;即设置coreAnimation的Layer层次结构。</p>

<p>在RainforestCardCell.swift里，找到nodeConstructionOperationWithCardInfo(cardInfo:image:) 并替换Node Layer and Wrap Up Section 为如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>dispatch_async(dispatch_get_main_queue()) { [weak nodeConstructionOperation] in
</span><span class='line'>  if let strongNodeConstructionOperation = nodeConstructionOperation {
</span><span class='line'>    // 2
</span><span class='line'>    if strongNodeConstructionOperation.cancelled {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 3
</span><span class='line'>    if strongSelf.nodeConstructionOperation !== strongNodeConstructionOperation {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 4
</span><span class='line'>    if containerNode.preventOrCancelDisplay {
</span><span class='line'>      return
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    // 5
</span><span class='line'>    //MARK: Node Layer and Wrap Up Section
</span><span class='line'>    strongSelf.contentView.layer.addSublayer(containerNode.layer)
</span><span class='line'>    containerNode.setNeedsDisplay()
</span><span class='line'>    strongSelf.contentLayer = containerNode.layer
</span><span class='line'>    strongSelf.containerNode = containerNode
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面描述一下:</p>

<ol>
<li>回忆当Node的Layer属性被第一个访问时，所有的Layer会被创建。这就是为何你必须运行Node Layer并在主线程包装小节，因此代码访问Node的Layer.</li>
<li>操作被检查以确定是否在添加Layer之前就已经取消了。在操作完成前，cell被重用或者重新配置，就很可能出现这样的情况，那你就不应该添加Layer了。</li>
<li>作为一个保险，确保Node当前的nodeConstructionOperation和调度闭包的操作是同一个NSOperation</li>
<li>如果containerNode的preventOrCancel是true就立即返回。如果构造操作完成，但node的绘制还没有被取消，你依然不想Node的layer现在在cell里</li>
<li>最后，添加Node的Layer到层次结构中，如果必要，这就创建Layer.</li>
</ol>


<p>编译确保没有错误</p>

<h3>开始Node创建操作</h3>

<p>你依然没有实际创建和开始操作，让我们开始吧</p>

<p>继续在RainforestCardCell.swift里，改变configureCellDisplayWithCardInfo(cardInfo:) 的方法签名为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func configureCellDisplayWithCardInfo(
</span><span class='line'>  cardInfo: RainforestCardInfo,
</span><span class='line'>  nodeConstructionQueue: NSOperationQueue)</span></code></pre></td></tr></table></div></figure>


<p>这里添加了一个新的参数nodeConstructionQueue.它就是一个用于Node创建操作入队的NSOperationQueue.</p>

<p>在func configureCellDisplayWithCardInfo(
  cardInfo: RainforestCardInfo,
  nodeConstructionQueue: NSOperationQueue) 底部，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let newNodeConstructionOperation = nodeConstructionOperationWithCardInfo(cardInfo, image: image)
</span><span class='line'>nodeConstructionOperation = newNodeConstructionOperation
</span><span class='line'>nodeConstructionQueue.addOperation(newNodeConstructionOperation)</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个Node构造操作，将其保留在nodeConstructionOperation属性，并将其添加到传入的队列。</p>

<p>最后打开 RainforestViewController.swift ，给RainforestViewController添加一个叫做nodeConstructionQueue 的初始化为常量的属性，如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class RainforestViewController: UICollectionViewController {
</span><span class='line'>  let rainforestCardsInfo = getAllCardInfo()
</span><span class='line'>  let nodeConstructionQueue = NSOperationQueue() ///&lt; ADD THIS LINE
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接下来，在collectionView(collectionView:cellForItemAtIndexPath indexPath:)里，传递View Controller的 nodeConstructionQueue到 configureCellDisplayWithCardInfo(cardInfo:nodeConstructionQueue:) ：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.configureCellDisplayWithCardInfo(cardInfo, nodeConstructionQueue: nodeConstructionQueue)</span></code></pre></td></tr></table></div></figure>


<p>cell将会创建一个新的Node构造操作并将其添加到ViewControler的操作队列里并发运行。记住在cell出队时就会创建一个新的Node层次结构。这并不理想，但足够好。如果你要缓存Node的重用，看看ASRangeController 吧</p>

<p>OK，编译运行，你讲看到和之前一样的效果，但现在布局和渲染都没在主线程执行了，牛！我打赌你从来没有想过你看到这一天你所做的事情，这就是AsyncDisplayKit的威力。你可以将更多不需要再主线程操作从主线程中移除，这将给主线程更多机会处理和用户的交互，让你的App摸起来如黄油般顺滑</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt="logo" /></p>

<h2>淡入Cell</h2>

<p>在这个就简短的章节，你将会学到:</p>

<ul>
<li>用自定义的Display Layer子类来支持Node</li>
<li>触发Node Layer的隐式动画</li>
</ul>


<p>这将会确保你的移除爆米花特效并最终带来良好的淡入动画</p>

<p>创建一个新的Layer子类.</p>

<p>菜单 File\New\File… ，选择 iOS\Source\Cocoa Touch Class 并单击Next.命名类为AnimatedContentsDisplayLayer并使其作为_ASDisplayLayer子类。选择 Swift语言并单击Next.最后保存并打开AnimatedContentsDisplayLayer.swift .</p>

<p>现在添加如下方法到类:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>override func actionForKey(event: String!) -&gt; CAAction! {
</span><span class='line'>  if let action = super.actionForKey(event) {
</span><span class='line'>    return action
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  if event == "contents" && contents == nil {
</span><span class='line'>    let transition = CATransition()
</span><span class='line'>    transition.duration = 0.6
</span><span class='line'>    transition.type = kCATransitionFade
</span><span class='line'>    return transition
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Layer有一个contents属性，它告诉系统为这个Layer绘制什么，AsyncDisplayKit通过在后台渲染contents并最后在主线程设置contents</p>

<p>这个代码将会添加一个过渡动画，这样contents就会淡入到View中，你可以在Apple的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html">Core Animation Prgramming Guide</a>找到更多关于隐式Layer动画</p>

<p>打开 RainforestCardCell.swift。在nodeConstructionOperationWithCardInfo(cardInfo:image:) 里，在Container Node Creation Section开头，改动如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// REPLACE THIS LINE...
</span><span class='line'>// let containerNode = ASDisplayNode()
</span><span class='line'>// ...WITH THIS LINE:
</span><span class='line'>let containerNode = ASDisplayNode(layerClass: AnimatedContentsDisplayLayer.self)</span></code></pre></td></tr></table></div></figure>


<p>这会告诉容器Node使用AnimatedContentsDisplayLayer实例作为其支持Layer,因此自动带来淡入效果</p>

<blockquote><p><em>注意</em>
只有_ASDisplayLayer的子类才能被异步地绘制</p></blockquote>

<p>编译运行，你讲看到容器Node会在其绘制好之后淡入.</p>

<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0023.png" alt="logo" /></p>

<h2>完整工程</h2>

<p><a href="https://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Layers-Finished-7.3.zip">完整工程</a>请在这里下载!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过一个Demo详解UIStackView]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-%5B%3F%5D-ge-demoxiang-jie-uistackview/"/>
    <updated>2016-04-04T19:48:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/tong-guo-[?]-ge-demoxiang-jie-uistackview</id>
    <content type="html"><![CDATA[<p><a href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/">在上一个章节</a>我们已经介绍了什么是UIStackView了，其实它更类似于Android开发中的LinerLayer排版技术。</p>

<p>这一章节，我们通过一个完整的例子来讲解UIStackView的用法</p>

<!--more-->


<h2>开始</h2>

<p>下下载这个<a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Starter.zip">开始工程</a>,下载完毕后，用Iphone6 模拟器运行起来，你将会看到一个度假旅游的列表</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/01-table-view-is-now-correct_750x1334-281x500.png" alt="logo" />
点击第一行cell,咋看，这个视图没有什么问题，但是你仔细观察，就会发现有几个问题:</p>

<ol>
<li>看视图的下面的那一排按钮，它们中间都有一定间隙规则布局，但是它们并没有适配整个屏幕的布局，看着挺丑的，临时转换屏幕landscape orientation,通过 <code>Command-left</code></li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/02-issues-visible-in-landscape-view_1334x750-480x270.png" alt="logo" /></p>

<ol>
<li>在详情页面，点击hidden按钮，它成功地隐藏了文字，但是下面的内容并没有顶上去，中间一片空白
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/03-hide-weather-issue_750x1334-281x500.png" alt="logo" /></li>
</ol>


<p>现在你已经有几点好的建议去提升app的体验，现在让我们开始切入这个工程</p>

<p>打开Main.storyboard然后找到 <code>Spot Info View Controller</code>,这里有一些颜色在stackView中。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/04-colorful-scene-in-storyboard_504x636-396x500.png" alt="logo" /></p>

<p>这些标签和按钮已经有几种不同颜色的背景色，但是在运行时他们的背景色就是透明的，在这个storyboard中，他们仅仅是为了帮助你展示stackView是怎么改变属性影响嵌套的子视图</p>

<p>你不需要做这些，但是从另一个观点来说你实际上喜欢去看看这些背景色当运行程序的时候，你能临时做些改变在SpotInfoViewController的viewDidLoad()中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Clear background colors from labels and buttons
</span><span class='line'>for view in backgroundColoredViews {
</span><span class='line'>  view.backgroundColor = UIColor.clearColor()
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当然，其它标签都有占位符文字说明，他们仅仅是为了让你区分哪些是和后台连接的。哪些是描述什么内容的。例如<code>&lt;whyVisitLabel&gt;</code>是连接</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@IBOutlet weak var whyVisitLabel: UILabel!</span></code></pre></td></tr></table></div></figure>


<p>另外一个需要注意的是在这个storyboard中不是默认的 600 x 600,当你使用SizeClass的时候。</p>

<p>SizeClass总是可用的，但是初始化Navigation Controller 默认是总是iPhone 4-inch在模拟器下，这个是容易的在storyboard中，这个模拟器在启动的时候是不受影响的，这个视图将会动态适应不同的设备。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/05-simulated-metrics-iphone-4-inch_639x173.png" alt="logo" /></p>

<h2>你的第一个StackView</h2>

<p>第一件事是你将通过一个stackView修复最下面一排按钮的间距，一个stackView能描述在不不同轴向的布局（横向坐标和纵向坐标），其中之一就是子视图之间的距离设置。</p>

<p>幸运的是，修改已经存在的View在一个stackView中并不复杂，选中 <code>Spot Info View Controller</code>底部的所有按钮</p>

<p>检查这三个按钮是不是都选择上了，打开左边的控件面板查看，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/08-verify-button-selection_360x90.png" alt="logo" /></p>

<p>一旦选中了，在storyboard的右下角点击new Stack button
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/09-stack_button_outlined_148x52.png" alt="logo" /></p>

<p>这个按钮将会变成嵌入式的在stackView中</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/10-bottom-row-is-now-in-stack-view_640x100.png" alt="logo" /></p>

<p>这些按钮看起来不是平滑的，稍后我们将会修复</p>

<p>当这个stackView开始嵌套这些按钮的时候，我们将要添加自动布局给这个stackView</p>

<p>当你嵌套一个视图在一个stackView中，这个视图的任何约束都会被移除，例如，在嵌套到stackView之钱，在最前面的那个按钮<code>Submit Rating</code>有个垂直距离的约束和<code>Rating:</code>label之间:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/11-prior-constraint_420x90.png" alt="logo" /></p>

<p>点击<code>Submit Rating</code>按钮去看看是否还有这个约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/12-no-more-constraints_400x80.png" alt="logo" /></p>

<p>为了给stackView添加约束，首先你必须选中它，一个简单的方式去选择这个stackView在outline View:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" />
另外一种方式是按住 shift&amp;Right-click 在你想选择的视图上，或者按钮 <code>control</code>+<code>shift</code>+<code>左键点击</code>在你想要选择的视图上，你将会看到一个菜单视图，供你选择。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/15-select-stack-view-in-view-hierarchy-menu_400x280.png" alt="logo" /></p>

<p>现在，点击pin按钮在自动布局的工具条上  去 添加约束。</p>

<p>首先检查Constrain to margins，然后添加下载的约束:</p>

<pre><code>Top: 20, Leading: 0, Trailing: 0, Bottom: 0
</code></pre>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/17-bottom-stack-view-constraints_264x364.png" alt="logo" /></p>

<p>现在，这个stackVeiw是正确的尺寸，但是它有一点拉伸第一个按钮，因为它要去利用多余的空间。</p>

<p>stackView有个<code>distribution</code>属性来决定子视图的布局，当前，它是fill,这意味着包含的子视图都会完全填充stackview剩下的空间，为了修补这个，这个stackView将要展开其中的一个子视图去填补这个多余的空间</p>

<p>然而，你并不期望这个按钮完全填充stackView，你想让他们占用相同的空间。</p>

<p>选中这个stackView,然后修改它的属性<code>Distribution</code>从<code>Fill</code>到<code>Equal Spacing:</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/19-change-distribution-to-equal-spacing_640x148.png" alt="logo" /></p>

<p>现在编译运行，点击这个cell.旋转屏幕，你将会看到底部的按钮平分在屏幕的底部，是不是很酷呢!
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/20-now-buttons-are-equally-spaced_1334x750-480x270.png" alt="logo" /></p>

<p>如果不使用stackView来解决这个问题，你不得不使用sapce views，在没两个按钮之间，你的加入等比宽度的约束。很是麻烦。
它看起来像是下面这样，这中间的space View看起来有点灰色</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/21-alternate-solution-1_346x76.png" alt="logo" /></p>

<p>这个问题还是不是很大在一个storyboard中，但是很多视图都是动态的，这就不是一个简单的任务了，在运行时去增加一个按钮或者隐藏一个按钮，因为需要去调节视图和约束之间的关系。</p>

<p>为了在一个stack view中隐藏一个视图，你不得不设置子视图的hidden属性为true.现在你将要修复之前说过的那个问题，就是当点击 hidden之后，文字消失，下面的多余空间要顶上去。</p>

<h2>转换Sections</h2>

<p>你将要转换所有的section用stack view中，这将要确保你容易的完成你的任务，下一步你将要转换 rating section.</p>

<h3>Rating section</h3>

<p>定位到你刚才的页面，然后选择<code>RATING</code>标签和 星星的视图：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/22-select-rating-label-and-stars-label_640x74.png" alt="logo" />
然后点击 stack按钮让其嵌套在一个stackView中。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/23-after-clicking-stack-button_640x74.png" alt="logo" />
 现在，点击PIN按钮，添加下面三个属性:</p>

<pre><code class="`"> Top: 20, Leading: 0, Bottom: 20
</code></pre>

<p> <img src="http://7xkxhx.com1.z0.glb.clouddn.com/24-add-second-stack-view-constraints_264x171.png" alt="logo" /></p>

<p> 现在切换到<code>Attributes inspector</code>，设置 spacing为8:
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/25-set-spacing-to-8_259x87.png" alt="logo" /></p>

<p> 这时，你看到视图上的两个控件之间已经有些间距了，
 <img src="http://7xkxhx.com1.z0.glb.clouddn.com/26-stars-label-weirdly-stretched_640x85.png" alt="logo" />
 有时候，xcode可能提示你stackview的位置是不正确的，但是这些警告将会消失，当你更新其它控件的时候，你通常可以忽略他们。</p>

<p>为了证明这个，改变 <code>Alignment</code>从<code>Fill</code>到<code>Top</code>然后再改为Fill,你将会看到这个stars 标签变成正确的位置了。</p>

<p>编译运行你的app,一切看起来还是和从前一样.</p>

<h2>取消嵌套一个Stack View</h2>

<p>在你深入学习之前，去进行一些"急救"训练，有时，你会发现你的视图上有一个你不再需要的stackview,或许你为了练习而导致的事故。</p>

<p>幸运的是，这里有容易的方式去移除一个嵌套的view从stack view中。</p>

<p>首先，你最好选择你想要删除的stack view,按住<code>Option</code>键，然后点击 <code>stack</code>按钮，点击 <code>Unembed</code>菜单就可以了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/28-how-to-unembed_186x71.png" alt="logo" /></p>

<h2>你的第一个垂直Stack view</h2>

<p>现在，你将要创建一个垂直的stack view,选中<code>WHY VISIT</code>标签和<code>&lt;whyVisitLabel&gt;</code>：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/29-select-why-visit-labels_640x90.png" alt="logo" />
Xcode将会正确的推断出这个视图将会需要一个垂直的stack view,点击<code>Stack</code>按钮去嵌套它们到一个stack view中。</p>

<p>当stack view添加成功之后，嵌套的视图的约束将会给删除，当前的这个stack view没有任何约束，所以它会适配子视图中最大尺寸的。</p>

<p>当这个stack view选中的时候，点击 Pin按钮，设置如下属性:
Top, Leading and Trailing 都为0</p>

<p>然后，点击dropdown在右下角，然后选择<code>WEATHER (current distance = 20):</code></p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/31-dont-select-nearest-neighbor-constraint_463x417.png" alt="logo" /></p>

<p>最后，添加这4个约束，你将会看到如下结果：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/32-why-visit-stack-view-stretched_640x90.png" alt="logo" />
现在你有两个一个展开的stackview,它的右边界是定位到了视图的右边界，然而，这下面的标签依然是同样宽的，你将要修复它通过stack view的<code>alignment</code>属性</p>

<h2>Alignment属性</h2>

<p>这个alignment属性决定了stack view在其轴向上的布局方式，可能是Fill,Leading,Center和Trailing.</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/33-horizontal-and-vertical-alignment_594x171.png" alt="logo" /></p>

<p>在垂直的stackview中，选择不同的属性，将会看到不同的布局:</p>

<p>Fill:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/34-alignment-fill_640x64.png" alt="logo" /></p>

<p>Leading:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/35-alignment-leading_640x64.png" alt="logo" /></p>

<p>Center:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/36-alignment-center_640x64.png" alt="lgo" /></p>

<p>Trailing:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/37-alignment-trailing_640x64.png" alt="lgo" /></p>

<p>当你测试完每个属性值后，最后设置成Fill</p>

<p>编译运行程序看起来是OK的，特别需要指出的是，<code>Fill</code>意味着你想要所有的视图都是完全占用空间在其轴向上，这将引起<code>WHY VISIT</code>标签去展开它到右边缘。</p>

<p>但是如果你只想下面的label张开到右边缘，此时该怎么做呢?</p>

<h2>转换"what to see"模块</h2>

<p>这个转换和上面的那个很相似，介绍如下:</p>

<ol>
<li>首先，选择<code>WHAT TO SEE</code>标签和<code>&lt;whatToSeeLabel&gt;</code></li>
<li>点击<code>Stack</code>按钮</li>
<li>点击<code>Pin</code>按钮</li>
<li>设置<code>margins</code>约束，添加下面4个约束</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<ol>
<li>设置stack view的Alignment为FIll</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/39-after-what-to-see-section_640x308.png" alt="logo" />
编译运行你的工程，验证页面是不是看起来和之前一样。</p>

<p>剩下就是这个<code>weather</code>模块了</p>

<h2>转换weather模块</h2>

<p>这个weather模块比其他几个稍微复杂一些，因为它包含了一个hidden按钮</p>

<p>一种方法是你将会创建一个最近的stacview通过嵌套<code>WEATHER</code>标签和<code>Hide</code>按钮在一个水平的stackview中，然后嵌套水平的stackview和<code>&lt;weatherInfoLabel&gt;</code>到一个垂直的stackview中。</p>

<p>看起来你像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/40-weather-stack-in-stack_640x92.png" alt="lgo" /></p>

<p>点击<code>Stack</code>按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/43-weather-click-stack-button_640x92.png" alt="logo" /></p>

<p>然后点击 Pin按钮，设置margin约束,设置如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Top: 20, Leading: 0, Trailing: 0, Bottom: 20</span></code></pre></td></tr></table></div></figure>


<p>设置 stack view的Alignment为Fill
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/44-weather-alignment-fill_640x92.png" alt="logo" /></p>

<p>你需要一个在hide按钮和<code>WEATHER</code>标签的右边加一个约束，因为<code>WEATHER</code>标签被加到了stack view中，它的所有约束都被自动去掉了.</p>

<p>然后，你希望底部的<code>&lt;weatherInfoLabel&gt;</code>去填充整个stack view.</p>

<p>你可以完成这个通过把<code>WEATHER</code>嵌套进一个垂直的stack view中，记住垂直stackview可以设置alignment为 .Leading,假如stack view是拉伸的超出了它固有的边界，它包含的子视图将会到达它的边界。</p>

<p>选择<code>WEATHER</code>标签通过document outline，或者通过<code>Control-Shift-click</code>方法:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/45-select-just-the-weather-label_640x92.png" alt="logo" /></p>

<p>点击 stack按钮:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/46-weather-in-horizontal-stack_640x92.png" alt="lgo" /></p>

<p>设置Alignment为Leading,然后确保axis是垂直方向:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/47-vertical-and-leading_640x92.png" alt="log" /></p>

<p>完美！你已经完成了外部的stackview平铺，在嵌套的stackView中去填充它的宽度，但是内部的stackview允许这个标签去保持它原有的宽度。</p>

<p>编译运行，为什么hide按钮现在飘到上面去了呢？
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/48-hide-label-incorrect-position_750x573-419x320.png" alt="dlo" /></p>

<p>它是因为当你嵌套<code>WEATHER</code>标签到一个stackview中时，它的所有和hide按钮相关的约束都被移除掉了。</p>

<p>现在你需要给hide按钮和<code>WEATHER</code>标签之间增加新的约束,按住<code>control-drag</code>从Hide按钮拖向<code>WEATHER</code>标签:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/49-drag-to-weather-label_380x94.png" alt="logo" /></p>

<p>添加两个约束:</p>

<ol>
<li>Horizontal Spacing</li>
<li>Baseline</li>
</ol>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/50-add-multiple-constraints_380x224.png" alt="logo" />
编译运行，这个Hide按钮看起来正常了。</p>

<p>现在所有的模块都是在唯一的stackview中了，你把他们全部都嵌套进了stackview中。</p>

<h2>设置第一级Stack view</h2>

<p>点击 <code>command</code> 然后选择所有的5个顶级的stackview在 outline view中
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/52-select-all-stack-views-in-outline_640x260.png" alt="log" /></p>

<p>然后点击stack按钮：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/53-stack-all-the-views_640x185.png" alt="lgo" /></p>

<p>点击Pin按钮，设置约束属性:
全部都设置成0.然后设置Spacing为20, Alignment为Fill,你的storyboard看起来像是这样:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/54-set-the-spacing-to-20-and-alignment-to-fill_640x300.png" alt="g" /></p>

<p>编译运行，此时你的 hide按钮又跑偏了，和之前设置的一样，需要把hide和<code>WEATHER</code>重新建立约束:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/56-add-constraints-to-button-again_380x223.png" alt="d" /></p>

<p>编译运行，此时hide按钮在正确的位置上了。</p>

<h2>重新布局视图</h2>

<p>现在所有的的模块都在顶级的stackview中，你现在可以更改<code>what to see</code>模块的位置，比如和<code>weather</code>模块的位置进行互换。</p>

<p>选择<code>middle stack view</code>从outline view然后拖拽它和weather的那个stackview进行互换，
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/57-drag-and-drop-to-reposition-section_639x130.png" alt="log" /></p>

<p>此时，<code>weather</code>模块是第三个模块，但是这个 hide按钮不是在stackview中，它不会被移动。</p>

<p>选中 Hide按钮 :
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/58-hide-button-not-moved_640x130.png" alt="logo" />
然后点击<code>Resolve Auto Layout Issues</code>在自动布局的菜单上点击 update frame:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/59-resolve-auto-layout-issues_356x269.png" alt="logo" /></p>

<h2>Size class based configuration</h2>

<p>最后，你能把你注意力集中到之前的任务清单上，在加载模式中，垂直空间是昂贵的，所以你想让stackview中的模块靠近些，为了做到这些，你将要使用size classes去设置顶部stackview的空间从20修改成10.</p>

<p>选中顶部的stackview然后点击小小的<code>+</code>号，设置spacing:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/61-select-plus-button_260x120.png" alt="log" /></p>

<p>选择 Any Width > Compact Height:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/62-anywidth-compact-height_403x108.png" alt="lgo" /></p>

<p>然后设置Spacing 为10,在 new wAny hC文本框中:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/63-set-spacing-to-10_260x160.png" alt="lgo" /></p>

<h2>动画</h2>

<p>打开SpotInfoViewController.swift文件，然后找到<code>updateWeatherInfoViews(hideWeatherInfo:animated:).</code>方法</p>

<p>你将要替换这一行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>weatherInfoLabel.hidden = shouldHideWeatherInfo</span></code></pre></td></tr></table></div></figure>


<p>改成如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if animated {
</span><span class='line'>  UIView.animateWithDuration(0.3) {
</span><span class='line'>    self.weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>  }
</span><span class='line'>} else {
</span><span class='line'>  weatherInfoLabel.hidden = shouldHideWeatherInfo
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编译运行，点击<code>hide</code>和<code>show</code>按钮，会不会感觉出来有点动画效果呢?</p>

<p>在stackview中增加动画效果也是很容易的，比如hidden, alignment, distribution, spacing，甚至axis。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程 <a href="http://www.raywenderlich.com/wp-content/uploads/2015/09/VacationSpots_Complete.zip">完整工程</a></p>

<p>希望能够帮到你~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIStackView介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao/"/>
    <updated>2016-04-04T15:47:37+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/04/04/uistackviewjie-shao</id>
    <content type="html"><![CDATA[<p>UIStackView类提供了一个高效的接口用于平铺一行或一列的视图组合.Stack视图使你的依靠自动布局的能力，创建用户接口使得可以动态的调整设备的朝向，屏幕尺寸以及任何可用范围内的变化。Stack视图管理着所有它的 arrageedSubviews属性中视图的布局，这些视图根据它们在arrangedSubviews数组中的顺序沿着stack视图的轴向排列，精确的布局变量根据Stack视图的 axixs,distribution,allignment,spcing,和其它属性决定。</p>

<!--more-->


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/130054395519774.png" alt="logo" /></p>

<p>使用 Stack视图，打开一个你希望编辑的storyboard,从对象库中拖出一个Horizontal Stack View或者Vertical Stack View,并放置到你希望的位置上，下一步，将控件或视图拖拽到stack中，如果需要你可以继续添加视图或者控件给指定的statck.Interface buider将根据stack内容自动调节尺寸，你可以通过修改尚需经面板中stack视图的属性调整statck的外观.</p>

<h2>Stack视图与自动布局</h2>

<p>Stack视图使用自动布局来定位和控制其管理的视图的尺寸，stack视图沿着它的轴向拼凑第一个和最后一个被管理的视图，使其便捷平齐。对一个月水平stack视图，这意味着第一个被管理的视图的左边界是与stack的左边界对齐的，并且最后一个被管理的视图右边界与stack右边界是平齐的。对于垂直stack,上边界和下边界格式对齐的。如果你设置了stack视图的 <code>layoutMarginsRelativeArrangement</code>为YES,stack视图将使用相关的边距与其内容对齐，而不是边界。</p>

<p>对于除去<code>UIStackViewDistributionFillEqually</code>分布以外的分布方式，stack视图使用被管理视图的<code>intrinsicContentSize</code>属性来计算沿着stack轴向的视图尺寸，<code>UIStackViewDistributionFillEqually</code>分布将调节所有被管理视图的在stack轴向上拥有相同尺寸，以填充stack视图。如果可能，stack视图将拉伸所有被管理的视图，来匹配其在stack轴向上最长的原有尺寸。</p>

<p>对于除去<code>UIStackViewAlignmentFill</code>对齐以外的对齐方式，stack视图使用其管理的视图的<code>intrinsicContentSize</code>属性来计算视图垂直于stack轴向的尺寸。<code>UIStackViewAlignmentFill</code>重新调节了所有其管理的视图，使这些视图填充stack视图垂直于其轴向空间。如果可能，stack视图将拉伸所有管理的视图来匹配其垂直于stack轴向的最大固有尺寸。</p>

<h2>定位和调整Stack视图尺寸</h2>

<p>当stack视图允许你布局其内容而不直接使用自动布局，你将仍然需要使用自动布局来定位stack视图，通常情况下，这意味着需要皮凑至少两个边界相邻的stack来定义它的位置，没有额外约束的情况下，系统会为stack视图计算一个尺寸来适应其内容:</p>

<ul>
<li>沿着stack视图轴向，其适应尺寸等于其管理的视图尺寸与间距的和</li>
<li>垂直于stack视图轴向，其适应尺寸等于其管理的视图中最大视图的尺寸</li>
<li>如果stack视图的<code>layoutMarginsRelativeArrangement</code>为YES,stack视图的适应尺寸会包括边距空间</li>
</ul>


<p>你可以提供额外的约束来具体说明stack视图的高度，宽度或者两者兼有，在这些情况下，stack视图调整了其管理的视图的布局和尺寸来填充指定区域。精确的布局变量根据stack视图的属性获得。可以通过查看<code>UIStackViewDistribution</code>和<code>UIStackViewAlignment</code>枚举，已获得一个完整的stack视图。</p>

<p>你也可以根据stack视图的第一条或最后一条基线定位它，而不是使用顶部，底部或者中心Y值，类似于stack视图的适应尺寸，这些基线都是基于stack视图的内容计算得到的</p>

<ul>
<li><p>一个水平的stack视图调用 <code>viewForFirstBaselineLayout</code>方法或者 <code>viewForLastBaselineLayout</code>方法时返回它最高的视图。如果最高的视图也是一个stack视图，那么其返回的将是在嵌套的stack视图上调用<code>viewForFirstBaselineLayout</code>方法或者<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
<li><p>一个垂直的stack视图当调用 <code>viewForFirstBaselineLayout</code>方法时返回的是其管理的第一个视图，当调用<code>viewForLastBaselineLayout</code>方法时返回的是其管理的最后一个视图。如果这两个视图之一也是stack视图，那么其返回的将是在嵌套的stack视图上对应调用<code>viewForFirstBaselineLayout</code>方法或<code>viewForLastBaselineLayout</code>方法的结果。</p></li>
</ul>


<blockquote><p><em>注意</em>
基线对齐方式只作用于那些高度匹配其原本内容高度的视图，如果视图被拉伸或压缩过，那么基线将出现在错误的位置上。</p></blockquote>

<h2>通过Stack视图布局</h2>

<p>这有一些通用方法用于stack视图。这个清单是要高亮一些有用的实例来显示 stack视图的灵活性，目前这还不是一个完整的清单。</p>

<ul>
<li>只是定义位置. 你可以通过固定两个与其父视图相邻的边界来定义stack视图的位置。在这里，stack视图的尺寸将根据其管理的视图在两个维度上自由扩展。</li>
</ul>


<p>举个例子，在Figure 1中，stack视图的左边界和上边界都已经相对固定于其父视图。这些标签将根据带有8个点的两者之间的空间作为第一基准线。这对于相对于其本身左对齐的stack视图内容是有效的。</p>

<p>Figure1定义位置
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140040561762600.png" alt="logo" /></p>

<ul>
<li>定义沿着 stack视图轴向的尺寸。这里，你固定了沿着stack视图轴向相对于其父视图的两个边界，定义了stack视图沿着其轴向的尺寸。你将需要固定其它边界中的一个来定义stack视图的位置。stack视图将沿着其轴向改变尺寸和位置来填充定义的空间:然而，未固定的边界将根据其管理的最大视图的尺寸自动移动。</li>
</ul>


<p>举例Figure 2,stack视图的左，上，右边界都已经相对于其父视图固定了。使用<code>UIStackViewDistributionFill</code>分布是的其内容重设尺寸来填充它的高度，并且从文本框有比标签更低的内容紧凑优先级开始，它将在必要的时候被拉伸。</p>

<p>Figure2定义沿着stack视图轴向的尺寸</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/140059516762099.png" alt="logo" /></p>

<ul>
<li>定义垂直于stack视图轴向的尺寸。这类似于上一个实例，但是你固定了垂直于stack视图轴向的连个边界和沿着轴向的一个边界。这使得stack视图在你增加或移除其管理的视图时将沿着其轴向扩展或回缩。除非你使用了
<code>UIStackViewDistributionFillEqually</code>分布，被管理的视图将跟根据其原有尺寸调节尺寸。垂直于其轴向的视图将根据其stack视图的对齐模式在其定义的范围内平铺。</li>
</ul>


<p>举例，Figure3展示了一个包含了四个标签和一个按钮的垂直stack视图。这个stack视图使用了8个点的间隙和<code>UIStackViewAlignmentCenter</code>对齐方式。stack视图的高度将根据stack内部元素的增减而增大或回缩。</p>

<p>FIgure3.定义垂直于stack视图轴向的尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140110013482874.png" alt="logo" /></p>

<ul>
<li>同时定义stack视图的位置和尺寸。这里你固定了stack视图的所有四个边界。stack视图将在提供的范围之内平铺其内容，举例，Figure4展示了一个所有四个边界都相对于其父视图固定的垂直stack视图。通过使用<code>UIStackViewAlignmentCenter</code>对齐方式和<code>UIStackViewDistributionFill</code>分布方式，stack视图确保其内容将水平和垂直居中填充屏幕，然后，获得想要的布局需要两个额外的步骤，默认情况下，stack视图会垂直拉伸标签而不是图片，要缩放图片控件，就要降低其内容紧凑优先级到低于标签，额外的，为了保持图片缩放时的长宽比，你必须设置图片视图的模式为 Aspect Fit.增加一个图片视图月stack视图间相等约束将有助于确保图片将被缩放来填充可用范围。</li>
</ul>


<p>Figure 4.同时定义stack视图的位置和尺寸
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140122324105787.png" alt="logog" /></p>

<h2>管理stack视图的展现</h2>

<p>UistackView是UIview的非渲染型子类。它没提供其自由的任何用户接口，相反地，它只管理被其管理的视图的位置和尺寸。因此，有些属性(如backgroundCOlor)在stack视图上是无效的。类似的，你无法重写layerClass,drawRect等方法。</p>

<p>这里有一系列的属性来定义stack视图如何平铺其内容。</p>

<ul>
<li>axis(轴向)属性决定了stack的朝向，只有垂直和水平</li>
<li>distributin(分布)属性决定了其管理的视图在沿着其轴向上的布局</li>
<li>alignment(对齐)属性决定了其管理的视图在垂直于其轴向上的布局</li>
<li>spacing(空隙)属性决定了其管理的视图间的最小间隙</li>
<li>baselineRelativeArragement 属性决定了其视图间的垂直间隙是否根据基线测量得到</li>
<li>layoutMarginsRelativeArrangement 属性决定了 stack 视图平铺其管理的视图时是否要参照它的布局边距</li>
</ul>


<p>通常情况下，你会使用一个stack视图来布局小数量的视图，你可以通过在其他stack视图上嵌套多个stack视图的方式创建更加复杂的视图层次结构。举例：Figure5展示乐意个包含两个水平stack视图的垂直stack视图。每一个水平stack视图各包含一个标签和一个文本框.</p>

<p>Figure 5.Stack 视图的嵌套
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/140146204108925.png" alt="logo" /></p>

<p>你也可以通过增加被管理的视图的额外约束来完备的吊接一个被管理视图的展现，举例说明，你可以使用约束类设置视图的最小或最大的高度或宽度，或者你可以定义一个长宽比。当平铺其内容时，stack视图将使用这些约束。举例来说，在Figure4中，当图片被压缩时，图片视图的一个长宽比约束被强行赋予了一个长宽比数。</p>

<blockquote><p><strong>注意</strong>
当给一个stack视图内的视图增加约束时要特别注意避免传入冲突，作为惯例，如果一个视图的尺寸在一个指定的维度上默认回到其原本内容的尺寸，那么你可以安全的在这个维度上增加约束</p></blockquote>

<h2>维护其惯例的视图与子视图之间的统一性</h2>

<p>Stack视图确保它的arragedSubveiws属性将一直是其 subviews属性的子集合。明确的说，stack视图强制实施了以下规定:</p>

<ul>
<li>无论何时stack视图增加了一个视图到它的arrangedSubviews数组，其也将把这个视图作为子视图增加，如果还未增加的话。</li>
<li>无论何时一个子视图从stack视图中移除，那么stack视图也将从从arrangedSubviews数组中移除.</li>
<li>从arrangedSubviews移除一个视图并不会将其作为姿势图移除。stack视图将不再管理改视图的尺寸和位置，但是该视图扔将是视图结构的一部分，并且当其可见的狂下仍会被渲染到屏幕上。</li>
</ul>


<p>当arrangedSubviews数组一直包含着subviews数组的自己和，这些数组间的顺序仍然是独立的。</p>

<ul>
<li>arrangedSubviews数组的顺序定义了展现在stack中的视图的顺序。对于水平stack视图，这些视图将以阅读顺序平铺，即最小索引的视图在较大索引视图的左侧。对于垂直stack视图，这些视图是从上到下平铺的，及较小索引的视图在较大索引视图的上方。</li>
<li>subviews数组中的顺序定义了子视图在z轴上的顺序。如果视图重叠，有较小索引的子视图将出现在有家多音的子视图后方。</li>
</ul>


<h2>动态改变stack视图内容</h2>

<p>当视图被加入，移除或插入arrangedSubviews数组时，或当一个被管理的子视图的hidden属性改变时，stack视图都会自动更新它的布局。</p>

<p>Oc代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>firstView.hidden = YES;</span></code></pre></td></tr></table></div></figure>


<p>swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Appears to remove the first arranged view from the stack.
</span><span class='line'>// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.
</span><span class='line'>let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>firstView.hidden = true</span></code></pre></td></tr></table></div></figure>


<p>stack视图也会自动响应其任何属性的改变。举例，你可以更新stack视图的axis属性来动态改变朝向</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if (self.stackView.axis == UILayoutConstraintAxisHorizontal) {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisVertical;
</span><span class='line'>}else {
</span><span class='line'>    self.stackView.axis = UILayoutConstraintAxisHorizontal;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Toggle between a vertical and horizontal stack
</span><span class='line'>if stackView.axis == .Horizontal {
</span><span class='line'>    stackView.axis = .Vertical
</span><span class='line'>}else {
</span><span class='line'>    stackView.axis = .Horizontal
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>对于被管理的子视图的hidden属性的变化和stack视图属性的变化，你可以通过将这些改变内置到一个动画块代码的方式以动画的方式展现。</p>

<p>OC代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>[UIView animateWithDuration:0.25 animations:^{
</span><span class='line'>    UIView * firstView = self.stackView.arrangedSubviews[0];
</span><span class='line'>    firstView.hidden = YES;
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>Swift代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Animates removing the first item in the stack.
</span><span class='line'>UIView.animateWithDuration(0.25) { () -&gt; Void in
</span><span class='line'>    let firstView = stackView.arrangedSubviews[0]
</span><span class='line'>    firstView.hidden = true}</span></code></pre></td></tr></table></div></figure>


<h2>常用方法</h2>

<h3>创建Stack视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- initWithArrangedSubviews:  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>管理安排的子视图</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- addArrangedSubview: (New in iOS 9.0)
</span><span class='line'>  arrangedSubviews Property (New in iOS 9.0)
</span><span class='line'>- insertArrangedSubview:atIndex: (New in iOS 9.0)
</span><span class='line'>- removeArrangedSubview: (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>设置布局</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alignment Property  (New in iOS 9.0)
</span><span class='line'>axis Property  (New in iOS 9.0)
</span><span class='line'>baselineRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>distribution Property  (New in iOS 9.0)
</span><span class='line'>layoutMarginsRelativeArrangement Property  (New in iOS 9.0)
</span><span class='line'>spacing Property  (New in iOS 9.0)</span></code></pre></td></tr></table></div></figure>


<h3>常量</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIStackViewDistribution
</span><span class='line'>UIStackViewAlignment</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解RunLoop]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop/"/>
    <updated>2016-03-29T17:29:43+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/29/shen-ru-li-jie-runloop</id>
    <content type="html"><![CDATA[<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799466416554.jpeg" alt="runloop" /></p>

<p>RunLoop是ios和OSX开发中非常基础的一个概念，本章将会介绍一下在ios中，苹果是利用RunLoop实现自动释放池，延迟回调，触摸事件，屏幕刷新等.</p>

<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成之后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function loop() {
</span><span class='line'>    initialize();
</span><span class='line'>    do {
</span><span class='line'>        var message = get_next_message();
</span><span class='line'>        process_message(message);
</span><span class='line'>    } while (message != quit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p> 这种模型通常被称为 <code>Event Loop</code>,Event Loop在很多系统和框架中都有实现，比如 Node.js的事件处理，比如window程序的消息循环，再比如OS X/IOS里的RunLoop.实现这种模型的关键点在于:如何管理事件/消息,如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时被唤醒。</p>

<p> 所以，RunLoop实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面的EventLoop逻辑。线程执行了这个函数后，就会一直处理这个函数内部"接受消息->等待->处理"的循环中，知道这个循环结束(比如传入quit的消息)，函数返回.</p>

<p> 在OSX/IOS系统中，提供了两个这样的对象:NSRunLoop和CFRunLoopref.</p>

<p> CFRunLoopRef是在CoreFoundation框架内，它提供了纯C函数的API,所有这些API都是线程安全的。</p>

<p> NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API,但是这些API不是线程安全的。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS开发中能遇到两个线程对象:pthread_t 和 NSThread.过去苹果有份文档表明了NSThread只是pthread_t 的封装，但那份文档已经失效了，现在它们也有肯定都是直接包装自最底层的mach thread。</p>

<p>你可以通过pthread_main_np() 或 [NSThread mainThread] 来获取主线程,也可以通过pthread_self()或者[NSThread currentThread]来获取当前线程。CFRunLoop是基于pthread来管理的。</p>

<p>苹果不允许直接创建RunLoop,它只提供了两个自动获取的函数:CFRunLoopGetMain()和CFRUnLoopGetCurrent().这两个函数内部的逻辑大概是下面这样:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
</span><span class='line'>static CFMutableDictionaryRef loopsDic;
</span><span class='line'>/// 访问 loopsDic 时的锁
</span><span class='line'>static CFSpinLock_t loopsLock;
</span><span class='line'>  
</span><span class='line'>/// 获取一个 pthread 对应的 RunLoop。
</span><span class='line'>CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
</span><span class='line'>    OSSpinLockLock(&loopsLock);
</span><span class='line'>     
</span><span class='line'>    if (!loopsDic) {
</span><span class='line'>        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
</span><span class='line'>        loopsDic = CFDictionaryCreateMutable();
</span><span class='line'>        CFRunLoopRef mainLoop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    /// 直接从 Dictionary 里获取。
</span><span class='line'>    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
</span><span class='line'>     
</span><span class='line'>    if (!loop) {
</span><span class='line'>        /// 取不到时，创建一个
</span><span class='line'>        loop = _CFRunLoopCreate();
</span><span class='line'>        CFDictionarySetValue(loopsDic, thread, loop);
</span><span class='line'>        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
</span><span class='line'>        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
</span><span class='line'>    }
</span><span class='line'>     
</span><span class='line'>    OSSpinLockUnLock(&loopsLock);
</span><span class='line'>    return loop;
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetMain() {
</span><span class='line'>    return _CFRunLoopGet(pthread_main_thread_np());
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>CFRunLoopRef CFRunLoopGetCurrent() {
</span><span class='line'>    return _CFRunLoopGet(pthread_self());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码来看，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary里，线程刚创建时并没有RunLoop,如果你不主动获取，那它一直不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时，你只能在一个线程的内部获取其RunLoop(主线程除外)</p>

<h2>RunLoop对外的接口</h2>

<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModelRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>


<p>其中，CFRunLoopModelRef类并没有对外暴露，只是通过CFRunLoopRef的接口进行了封装，他们的关系如下:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798883604537.png" alt="runloop" /></p>

<p>一个RunLoop包含若干个Model,每个model又包含若干个Source/Timer/Observer。每次调用RunLoop的主函数时，只能指定其中一个model,这个Model被称作为CurrentMode.如果需要切换Mode,只能退出Loop,再重新指定一个Mode进入。这样做是为了分隔开不同组的 Source/Timer/Observer,让其互不影响.</p>

<p>CFRunLoopSourceREf是事件产生的地方。Source有两个版本，Source0和Source1.</p>

<ul>
<li>Source0只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，然后手动调用CFRunLoopwakeUp(runloop)来唤醒RunLoop,让其处理这个事件</li>
<li>Source1包含乐业一个match_port和一个回调(函数指针),被用于通过内核和其它线程相反发送消息。这种Source能主动唤醒Runloop的线程</li>
</ul>


<p><em>CFRUnLoopTimerRef</em>是基于时间的触发器，它和NStimer可以混用，其包含一个时间长度和一个回调(函数指针).当其加入到RUnLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调.</p>

<p><em>CFRunLoopObserverRef</em>是观察者，每个Observer都包含了一个回调，当Runloop的状态发生变化时，观察者就能通过回调接收到这个变化。可以观测的时间点有以下几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
</span><span class='line'>    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
</span><span class='line'>    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
</span><span class='line'>    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
</span><span class='line'>    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
</span><span class='line'>    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
</span><span class='line'>    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>上面的 Source/Timers/Observer 被统称为Mode item,一个Item可以被同事加入多个Mode,但一个Item被重复加入同一个mode时是不会有效果的。如果一个Mode中一个item都没有，则RunLoop会直接退出，不进入循环。</p>

<h2>Runloop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __CFRunLoopMode {
</span><span class='line'>    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
</span><span class='line'>    CFMutableSetRef _sources0;    // Set
</span><span class='line'>    CFMutableSetRef _sources1;    // Set
</span><span class='line'>    CFMutableArrayRef _observers; // Array
</span><span class='line'>    CFMutableArrayRef _timers;    // Array
</span><span class='line'>    ...
</span><span class='line'>};
</span><span class='line'>  
</span><span class='line'>struct __CFRunLoop {
</span><span class='line'>    CFMutableSetRef _commonModes;     // Set
</span><span class='line'>    CFMutableSetRef _commonModeItems; // Set
</span><span class='line'>    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
</span><span class='line'>    CFMutableSetRef _modes;           // Set
</span><span class='line'>    ...
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这里有个概念叫<code>CommonModes</code>：一个Mode可以将自己标记为<code>Common</code>属性（通过将其ModeName添加到RunLoop的 &ldquo;CommmonModes"中）。每当RunLoop的内容发生变化时，RunLoop都会自动将_CommonModeItems里的 Source/Observer/Timer同步到具有'Common'标记的所有Mode里。</p>

<p>应用场景:主线程的RunLoop里有两个预置的Mode:KCFRunLoopDefaultMode和UITrackingRunLoopMode。这两个Mode都已经被标记为"Common"属性。DefaultMode是App平时所处的状态，TrackingRunLoopMode是追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，TImer会得到重复回调，但此时滑动一个TableView时，RunLoop会将mode切换到 TrackingRunLoopMode,这时Timer就不会被回调，并且也不会影响到滑动操作.</p>

<p>有时你需要一个Timer,在两个Mode中都能得到回调，一种办法就是将这个Timer分别加入这两个Mode.还有一种方式，就是将TImer加入到顶层RunLoop的"commonModeItems"中，“commonMOdeItems”被RunLoop自动更新到所有具有"Common"属性的Mode里去.</p>

<p>CFRunLoop对外暴露的管理Mode接口只有下面2个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);
</span><span class='line'>CFRunLoopRunInMode(CFStringRef modeName, ...);</span></code></pre></td></tr></table></div></figure>


<p>Mode暴露的管理Mode Item的有下面几个:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
</span><span class='line'>CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);
</span><span class='line'>CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span></code></pre></td></tr></table></div></figure>


<h2>RunLoop的内部逻辑</h2>

<p>根据苹果官方文档的说明，RunLoop内部逻辑大致如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432798974517485.png" alt="logo" /></p>

<p>实际上，RunLoop就是这样一个函数，其内部是一个 do-while循环，当你调用 CFRunLoopRun()时，线程就会一直停留在这个循环里，知道超时或被手动停止，该函数才会返回.</p>

<h2>苹果用RunLoop实现的功能</h2>

<p>首先我们可以先看一下App启动后RunLoop的状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFRunLoop {
</span><span class='line'>    current mode = kCFRunLoopDefaultMode
</span><span class='line'>    common modes = {
</span><span class='line'>        UITrackingRunLoopMode
</span><span class='line'>        kCFRunLoopDefaultMode
</span><span class='line'>    }
</span><span class='line'>  
</span><span class='line'>    common mode items = {
</span><span class='line'>  
</span><span class='line'>        // source0 (manual)
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = _UIApplicationHandleEventQueue}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventSignalCallback }}
</span><span class='line'>        CFRunLoopSource {order = 0, {
</span><span class='line'>            callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>  
</span><span class='line'>        // source1 (mach port)
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 17923}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 12039}}
</span><span class='line'>        CFRunLoopSource {order = 0,  {port = 16647}}
</span><span class='line'>        CFRunLoopSource {order =-1, {
</span><span class='line'>            callout = PurpleEventCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 2407,
</span><span class='line'>            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1c03,
</span><span class='line'>            callout = __IOHIDEventSystemClientAvailabilityCallback}}
</span><span class='line'>        CFRunLoopSource {order = 0, {port = 1b03,
</span><span class='line'>            callout = __IOHIDEventSystemClientQueueCallback}}
</span><span class='line'>        CFRunLoopSource {order = 1, {port = 1903,
</span><span class='line'>            callout = __IOMIGMachPortPortCallback}}
</span><span class='line'>  
</span><span class='line'>        // Ovserver
</span><span class='line'>        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
</span><span class='line'>            callout = _UIGestureRecognizerUpdateObserver}
</span><span class='line'>        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _afterCACommitHandler}
</span><span class='line'>        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
</span><span class='line'>            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
</span><span class='line'>            callout = _wrapRunLoopWithAutoreleasePoolHandler}
</span><span class='line'>  
</span><span class='line'>        // Timer
</span><span class='line'>        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
</span><span class='line'>            next fire date = 453098071 (-4421.76019 @ 96223387169499),
</span><span class='line'>            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
</span><span class='line'>    },
</span><span class='line'>  
</span><span class='line'>    modes ＝ {
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 =  { /* same as 'common mode items' */ },
</span><span class='line'>            sources1 =  { /* same as 'common mode items' */ },
</span><span class='line'>            observers = { /* same as 'common mode items' */ },
</span><span class='line'>            timers =    { /* same as 'common mode items' */ },
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = 0, {
</span><span class='line'>                    callout = FBSSerialQueueRunLoopSourceHandler}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = {
</span><span class='line'>                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
</span><span class='line'>                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
</span><span class='line'>            )},
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>  
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventSignalCallback}}
</span><span class='line'>            },
</span><span class='line'>            sources1 = {
</span><span class='line'>                CFRunLoopSource {order = -1, {
</span><span class='line'>                    callout = PurpleEventCallback}}
</span><span class='line'>            },
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        },
</span><span class='line'>         
</span><span class='line'>        CFRunLoopMode  {
</span><span class='line'>            sources0 = (null),
</span><span class='line'>            sources1 = (null),
</span><span class='line'>            observers = (null),
</span><span class='line'>            timers = (null),
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，系统默认注册了5个Mode;</p>

<ol>
<li>kcfRunLoopDefaultMode:App默认的Mode,通常主线程是在这个Mode下运行的</li>
<li>UITrackingRunLoopMode:界面跟踪Mode,用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode,启动完成后不再使用</li>
<li>CGEventReceiveRunLoopMode:接受系统事件的内部Mode,通常用不到</li>
<li>KcfRunLoopCommonModes:这是一个占位的Mode,没有实际作用</li>
</ol>


<p>当RunLoop进行回调时，一般都是通过一个很长的函数调用出去(call out),当你在你的代码中断点调试时，通常能在调用栈上看到这些函数。下面就是这几个函数的整理版本，如果你在你的调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    /// 1. 通知Observers，即将进入RunLoop
</span><span class='line'>    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
</span><span class='line'>    do {
</span><span class='line'>  
</span><span class='line'>        /// 2. 通知 Observers: 即将触发 Timer 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);
</span><span class='line'>        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 4. 触发 Source0 (非基于port的) 回调。
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
</span><span class='line'>  
</span><span class='line'>        /// 6. 通知Observers，即将进入休眠
</span><span class='line'>        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 7. sleep to wait msg.
</span><span class='line'>        mach_msg() -&gt; mach_msg_trap();
</span><span class='line'>         
</span><span class='line'>  
</span><span class='line'>        /// 8. 通知Observers，线程被唤醒
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被Timer唤醒的，回调Timer
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
</span><span class='line'>        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);
</span><span class='line'>  
</span><span class='line'>        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
</span><span class='line'>        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>    } while (...);
</span><span class='line'>  
</span><span class='line'>    /// 10. 通知Observers，即将退出RunLoop
</span><span class='line'>    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
</span><span class='line'>    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>AutoReleasePool</h3>

<p>App启动后，苹果在主线程RunLoop里注册了两个Observer,其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()。</code></p>

<p>第一个Observer监视的事件是进入Loop,其回调内都会调用<code>_objc_autoreleasePoolPush()</code>,创建自动释放池。</p>

<p>第二个Observer监视了两个事件：BeforeWaiting时调用
<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将推出Loop)时调用<code>_objc_autoreleasePoolPop()</code>来释放自动释放池。</p>

<p>在主线程执行的代码，通常都是写在事件回调，Timer回调内的，这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄露，开发者也不必显示创建Pool了。</p>

<h3>手势识别</h3>

<p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的 <code>touchesBegin/Move/End</code>系列回调打断.随后系统将对应的<code>UIGestureRecognizer</code>标记为待处理。</p>

<p>苹果注册了一个Observer检测BeforeWaiting (Loop即将进入休眠) 事件,这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>,其内部会获取所有刚被标记为待处理的 GestureRecognizer,并执行GestureRecognizer的回调</p>

<h3>界面更新</h3>

<p>当在操作UI时，比如改变了Frame,更新了UIview/CaLayer的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后,这个UIview/CALayer就会标记为待处理，并被提交到一个全局的容器中。</p>

<p>苹果注册了一个Observer监听BeforeWaiting(即将进入睡眠)和Exit(即将退出Loop)事件，回调去执行一个很长的函数:</p>

<h3>定时器</h3>

<p>NStimer其实就是<code>CFRunLoopTimerRef</code>,他们之间是toll-free bridged的，一个NStimer注册到RunLoop后，RunLoop会为其重复的时间点注册号通知，例如10:00,11:00,12:00,这几个时间点，</p>

<p>如果某个时间点被错过了，例如执行一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行，就好比等公交，如果10:10时，我忙着玩手机错过了，那我只能等10：20的那趟公交了。</p>

<p>CADisplayLink是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个很长的任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉，在快速滚动TableView时，即使一帧的卡顿也会让用户有所感觉.FaceBook开源的 <a href="https://github.com/facebook/AsyncDisplayKit.git">AsyncDisplayKit</a>就是为了解决界面卡顿的问题，其内部也用到了RunLoop。</p>

<h3>performSelecter</h3>

<p>当调用NSobject的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop,则这个方法会失效.</p>

<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个TImer加到对应的线程中，同样滴，如果对应线程没有RunLoop该方法也会失效.</p>

<h3>关于GCD</h3>

<p>实际上RunLoop底层也会用到GCD的东西，比如RUnLoop是用dispatch_source_t 实现的Timer.但同时GCD提供的某些接口也用了RUnLoop，比如dispatch_async().</p>

<p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会想主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中去的这个block,并在回调.</p>

<h3>关于网络请求</h3>

<p>ios中，关于网络请求的接口自下而上如下几层:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFSocket
</span><span class='line'>CFNetwork       -&gt;ASIHttpRequest
</span><span class='line'>NSURLConnection -&gt;AFNetworking
</span><span class='line'>NSURLSession    -&gt;AFNetworking2, Alamofire</span></code></pre></td></tr></table></div></figure>


<ul>
<li>CFSocket是最底层的接口，值负责socket通信</li>
<li>CGNetwork是基于cfSocket等接口的上层封装</li>
<li>NSUrlConnection是基于CFNetwork的更高层的封装，提供面向对象的接口，AFNetworking工作于这一层</li>
<li>NSURlSession是ios7中新增的接口，表面和NSUrlConnection并列的，但底层仍然用到了NSURLConnection 的部分功能，AFNetworking2 和 Alamofire 工作于这一层。
*</li>
</ul>


<p>下面主要介绍NSURlConnection的工作过程.</p>

<p>通常使用NSURLconnection时，你会传入一个Delegate,当你调用 [connection start] 后，这个delegate就会不停的收到事件回调。实际上，start这个函数的内部会获取 CurrentRunLoop,然后在其中的DefaultMode添加了4个Source0, CFMultiplexerSource是负责各种Delegate回调的, CFHTTPCookieStorage是处理各种Cookie的。</p>

<p>当开始网络传输时，我们可以看到NSURLCOnnenction创建了两个新线程:
com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private.其中，CFSocket线程是处理底层socket连接的。NSUrlConnnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过该之前添加的Source0通知上层的delegate。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/1432799200369980.png" alt="logo" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调</p>

<h2>RunLoop的实际应用举例</h2>

<p>AFURLConnectionOperation 这个类是基于<code>NSURLConnection</code>构建的，其希望能在后台线程接收Delegate回调。为此，AFNetworking单独创建了一个线程，并在这个线程中启动了一个RunLoop:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
</span><span class='line'>    @autoreleasepool {
</span><span class='line'>        [[NSThread currentThread] setName:@"AFNetworking"];
</span><span class='line'>        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
</span><span class='line'>        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
</span><span class='line'>        [runLoop run];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>+ (NSThread *)networkRequestThread {
</span><span class='line'>    static NSThread *_networkRequestThread = nil;
</span><span class='line'>    static dispatch_once_t oncePredicate;
</span><span class='line'>    dispatch_once(&oncePredicate, ^{
</span><span class='line'>        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
</span><span class='line'>        [_networkRequestThread start];
</span><span class='line'>    });
</span><span class='line'>    return _networkRequestThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>RunLoop启动前内部必须要有至少一个 Timer/Observer/Source,所以AFNetworking在[run start]之前放入了一个新的NSmachPort添加进入了。通常情况下，调用者需要持有NSMachPort (mach_port),并在外部线程通过这个Port发送消息到loop内；但此处添加port只是为了让RunLoop不至于退出，并没有实际的发送消息.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start {
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    if ([self isCancelled]) {
</span><span class='line'>        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    } else if ([self isReady]) {
</span><span class='line'>        self.state = AFOperationExecutingState;
</span><span class='line'>        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
</span><span class='line'>    }
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当需要在这个后台线程执行任务时，AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的RunLoop中。</p>

<h2>AsyncDisplayKit</h2>

<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下:
UI线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，Ui对象操作.</p>

<p>排版通常包括计算视图的大小，计算文本的高度，等操作。</p>

<p>绘制一般有文本绘制，例如CoreText,图片绘制，例如预先解压，元素图形绘制等.</p>

<p>UI对象操作通常包括UIView/CaLayer等ui 对象的创建，设置属性和销毁.</p>

<p>其中前两类操作可以通过各种方法扔到后台线程中执行，而最后一类操作只能在主线程中完成，并且有时后面的操作需要一栏前面操作的结果。（例如UITextView创建时可能需要提前计算出文本的大小）.ASDK所做的，就是尽量将能放入到后台的任务放入到后台，不能则尽量推迟(例如视图的创建，属性的调整)</p>

<p>为此，ASDK创建了一个名为 <code>ASDisplayNode</code>的对象，并在内部封装了UiView/CaLayer，它具有和UIView/CALayer相似的属性，例如 frame,backgroundColor等。所有这些尚需经都可以放到后台线程更改，开发者可以只通过Node来操作器内部的UIVidw/CaLayer，这样就可以将排版和绘制放入到了后台线程，但是无论怎么操作，这些属性总是需要在某个时刻同步到主线程的 UIview/CaLayer中。</p>

<p>ASDK仿照 QuartzCore/UIKit框架的模式，实现了一套类似的界面更新机制:即在主线程的RunLoop中添加一个Observer,监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件,在收到回调时，遍历所有之前放入队列等待处理的任务，然后一一执行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSUrlSession详解]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie/"/>
    <updated>2016-03-27T18:48:28+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/27/nsurlsessionxiang-jie</id>
    <content type="html"><![CDATA[<p>NSUrlSession是NSUrlConnection的替代品。</p>

<p>NSUrlConennection指的是一组构成 Foundation框架中URL加载系统的相互关联的组件:NSURLRequest,NSUrlResponse,NSURlProtocol等,在协商发送一个请求到服务器的过程中，该服务器可发出验证质询，这可以由共享的cookie，证书存储（credential storage）或通过连接委托自动处理。必要的时候，为了无缝地改变装载行为，传出请求也可以被注册的NSURLProtocol对象截获.</p>

<!--more-->


<p>不管怎样，考虑到NSURLConnection作为一个网络基础架构，成千上万的Cocoa和Cocoa Touch应用程序从中获益，它已经表现得相当好。但是，这些年来，iPhone和iPad新兴的用例，特别是有一些已经向NSURLConnection的几个核心设想提出了挑战，对其重构已经迫在眉睫。</p>

<p>在2013年的WWDC上，Apple揭开了NSURLConnection继任者的面纱：NSURLSession.</p>

<p>与NSUrlConnection类似，除了同名类 NSUrlsession,NSUrlSession指的是一组相互依赖的类，NSURlSession包括与之前相同的组件，例如NSUrlRequest,NSURLCatch等等。
　　</p>

<h2>NSURlconenction 与 NSSession的不同</h2>

<p>　　与NSUrlConnection相比，NSUrlSession最直接的改善就是提供了配置每个回话的缓存，协议，cookie和证书策略(credential policies),甚至跨应用程序共享它们的能力。这使得框架的网络基础架构和部分应用程序独立工作，而不会相互干扰，每一个NSUrlSession对象都是根据一个NSURlSessionConfiguration初始化的，
　　
　　</p>

<p>该NSURlSessionConfiguration指定了上面提到的策略，一级一系列为了提高移动设备性能而专门添加的新选项。</p>

<p>NSUrlSession的另一个重要组成部分就是会话任务，它负责处理数据的加载，以及客户端与服务器之间的文件和数据的上传和下载。</p>

<h2>NSURLSession简介</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="logo" /></p>

<p>NSURLsession关键对象负责接收和发送http请求，创建NSURlSessionConfiguration,这里有三种方式:</p>

<ul>
<li><code>defaultSessionConfiguration</code>创建一个默认的配置文件，用户可以存储缓存，创建证书和缓存cookie等</li>
<li><code>ephemeralSessionConfiguration</code>和默认配置文件很相似，除了它可以在内存中存储之外，它更像是一个私有的session</li>
<li><code>backgroundSessionConfiguration</code>这个配置文件支持上传和下载任务在后台。当程序挂起或者被终止之后任务可以继续执行。</li>
</ul>


<p><code>NSURLSessionConfiguration</code>依然可以让你配置session的属性，比如设置超时时间，缓存策略和http请求头等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration">这里</a>有完整的配置文档。</p>

<p><code>NSURLSessionTask</code>是一个抽象的任务符号,一个session创建一个任务，它不仅可以请求数据，还可以上传和下载。</p>

<p>这里有三种类型的任务：</p>

<ul>
<li><code>NSURLSessionDataTask</code>：用这个任务可以发送http请求，从而从服务器得到返回的数据</li>
<li><code>NSURLSessionUploadTask</code>：用这个任务可以从本地硬盘上往服务器上传文件，一般是HTTP post请求或者PUT请求.</li>
<li><code>NSURLSessionDownloadTask</code>:用这个任务可以从远程服务器上下载文件</li>
</ul>


<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="logo" /></p>

<p>你可以挂起，回滚和取消任务，<code>NSURLSessionDownloadTask</code>还有一个特性就是支持断点下载。</p>

<p>一般来讲, NSURLSession 有两种方式返回数据：</p>

<ol>
<li>利用completion handler,当任务完成之后，不管是成功返回还是产生错误；</li>
<li>还有一种就是利用NSSession的代理，依然可以捕获到返回的数据;</li>
</ol>


<h2>编写实例Demo</h2>

<p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip">启动工程在这里下载</a>,</p>

<p>开始做一个 在Itunes搜索歌曲，通过<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html">Itunes API</a>下载歌曲的这么个小工程，支持暂停，下载功能。</p>

<p>下完工程，运行效果如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt="itunes" /></p>

<h3>开始编写代码</h3>

<p>你可以添加代码去查询itunes中的歌曲，通过查找 Itunes search Api.</p>

<p>在<code>SearchViewController.swift</code>文件中，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>let defaultSession = NSURLSession(configuration: NSURLSessionConfiguration.defaultSessionConfiguration())
</span><span class='line'>// 2
</span><span class='line'>var dataTask: NSURLSessionDataTask?</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做了如下工作:</p>

<ol>
<li>用默认的配置文件创建NSURLSession</li>
<li>你定义了一个<code>NSURLSessionDataTask</code>变量，用它发送http请求，这个任务将会被重复初始化和重复利用在用户创建一个新查询的时候</li>
</ol>


<p>现在，替换<code>searchBarSearchButtonClicked(_:)</code>里面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func searchBarSearchButtonClicked(searchBar: UISearchBar) {
</span><span class='line'>  dismissKeyboard()
</span><span class='line'> 
</span><span class='line'>  if !searchBar.text!.isEmpty {
</span><span class='line'>    // 1
</span><span class='line'>    if dataTask != nil {
</span><span class='line'>      dataTask?.cancel()
</span><span class='line'>    }
</span><span class='line'>    // 2
</span><span class='line'>    UIApplication.sharedApplication().networkActivityIndicatorVisible = true
</span><span class='line'>    // 3
</span><span class='line'>    let expectedCharSet = NSCharacterSet.URLQueryAllowedCharacterSet()
</span><span class='line'>    let searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!
</span><span class='line'>    // 4
</span><span class='line'>    let url = NSURL(string: "https://itunes.apple.com/search?media=music&entity=song&term=\(searchTerm)")
</span><span class='line'>    // 5
</span><span class='line'>    dataTask = defaultSession.dataTaskWithURL(url!) {
</span><span class='line'>      data, response, error in
</span><span class='line'>      // 6
</span><span class='line'>      dispatch_async(dispatch_get_main_queue()) {
</span><span class='line'>        UIApplication.sharedApplication().networkActivityIndicatorVisible = false
</span><span class='line'>      }
</span><span class='line'>      // 7
</span><span class='line'>      if let error = error {
</span><span class='line'>        print(error.localizedDescription)
</span><span class='line'>      } else if let httpResponse = response as? NSHTTPURLResponse {
</span><span class='line'>        if httpResponse.statusCode == 200 {
</span><span class='line'>          self.updateSearchResults(data)
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>    // 8
</span><span class='line'>    dataTask?.resume()
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>运行后代码如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160401-1.png" alt="logo" /></p>

<p>如果出现错误<code>An SSL error has occurred and a secure connection to the server cannot be made.</code></p>

<p>请在info.plist中配置，在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为 YES</p>

<p>上面的代码步骤意义如下:</p>

<ol>
<li>检查用户每一次查询，dataTask是否已经初始化，如果没有，则取消该任务</li>
<li>设置的状态栏上的转子运行起来，证明数据正在请求当中</li>
<li>当用户输入查询参数之前，调用 请求字符串的<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>,确保是一个正确的URL.　(这个 text 的类型是 String ，常用于搜索功能，在  URL 中包含被搜的关键字，如果不处理搜中文或者带空格的英文会直接崩溃);</li>
<li>下一步创建一个NSURL用上面的（安全的）字符串，使用GET请求去调用Itunes Search API</li>
<li>从创建的Session中，你初始化<code>NSURLSessionDataTask</code>去处理http请求，这个<code>NSURLSessionDataTask</code>任务使用completion handler （回调函数）去响应服务器返回的数据</li>
<li>异步调用主线程，在主线程上隐藏网络请求的转子</li>
<li>如果http请求是成功的，你可以调用<code>updateSearchResults(_:)</code>来刷新表格数据，返回数据是NSData类型的，需要在updateSearchResults方法中进行处理</li>
<li>所有任务默认是挂起状态，需要你调用 <code>resume()</code>去启动任务</li>
</ol>


<h2>下载</h2>

<p>看着搜索到的歌曲，感觉页面不错，但是如果我们能够通过点击 download,然后把歌曲下载到本地是不是更爽呢?下一步让我实现这个功能点.</p>

<p>用多线程实现下载是容易的。首先你要创建一个新的文件命名为 <code>Download.swift</code>. 打开这个文件，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Download: NSObject {
</span><span class='line'> 
</span><span class='line'>  var url: String
</span><span class='line'>  var isDownloading = false
</span><span class='line'>  var progress: Float = 0.0
</span><span class='line'> 
</span><span class='line'>  var downloadTask: NSURLSessionDownloadTask?
</span><span class='line'>  var resumeData: NSData?
</span><span class='line'> 
</span><span class='line'>  init(url: String) {
</span><span class='line'>    self.url = url
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>属性说明如下:</p>

<ul>
<li>URL:下载文件的url地址，它也扮演着唯一的标识符在下载过程中</li>
<li>isDownloading:是否正在下载或暂停</li>
<li>progress : 下载的进度,[0-1]</li>
<li>downloadTask: NSURLSessionDownloadTask下载任务</li>
<li>resumeData:当你暂停一个下载任务时，它负责存储此时的数据量；如果后台服务器支持的话，当用户再次点击继续下载，它会从这里开始继续下载这个文件，俗称 断点下载</li>
</ul>


<p>切换到 <code>SearchViewController.swift</code>，添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var activeDownloads = [String: Download]()</span></code></pre></td></tr></table></div></figure>


<h2>创建下载任务</h2>

<p>准备工作做得差不多了，现在你只需实现下载，首先你要创建一个session去实现下载任务.</p>

<p>在 <code>SearchViewController.swift</code>文件中，在<code>viewDidLoad():</code>之前添加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var downloadsSession: NSURLSession = {
</span><span class='line'>  let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span><span class='line'>  let session = NSURLSession(configuration: configuration, delegate: self, delegateQueue: nil)
</span><span class='line'>  return session
</span><span class='line'>}()</span></code></pre></td></tr></table></div></figure>


<p>这里初始化了一个session,用默认的配置文件，去处理所有的下载任务，你也可以指定delegate,这将会使你收到 <code>NSURLSession</code>的代理调用，这个是很有用的，它能有效的跟踪下载任务下载的进度和是否下载完成等。</p>

<p>设置代理的队列是nil,会促使session创建一个操作队列，默认的去调用代理方法和回调方法.</p>

<p>在创建<code>downloadsSession</code>属性的时候，我们加了<code>lazy</code>特性，这会让你延迟加载这个session直到你需要它的时候，更重要的是，它会通过<code>self</code>作为代理参数去初始化，假如<code>self</code>还没有初始化。</p>

<p>在<code>SearchViewController.swift</code>文件中，找到空的<code>NSURLSessionDownloadDelegate</code>并且扩展如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDownloadDelegate {
</span><span class='line'>  func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>    print("Finished downloading.")
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>NSURLSessionDownloadDelegate</code>定义了代理方法你需要去实现，在你使用 NSURLSession 下载任务的时候，这个唯一的不是可选的代理方法是 <code>URLSession(_:downloadTask:didFinishDownloadingToURL:),</code>,当下载完成的时候，将会执行这个代理方法，打印简答的一句话.</p>

<p>在<code>SearchViewController.swift</code>文件中，替换<code>startDownload(_:)</code>这个方法的代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func startDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl, url =  NSURL(string: urlString) {
</span><span class='line'>    // 1
</span><span class='line'>    let download = Download(url: urlString)
</span><span class='line'>    // 2
</span><span class='line'>    download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>    // 3
</span><span class='line'>    download.downloadTask!.resume()
</span><span class='line'>    // 4
</span><span class='line'>    download.isDownloading = true
</span><span class='line'>    // 5
</span><span class='line'>    activeDownloads[download.url] = download
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当你点击 <code>Download</code>按钮的时候，你将会调用<code>startDownload(_:)</code>函数去执行下载命令，上面的代码执行的步骤如下:</p>

<ol>
<li>你用URL去初始化一个DownLoad对象</li>
<li>使用上面的NSURL和downloadsSession去初始化<code>NSURLSessionDownloadTask</code></li>
<li>调用resume()去启动一个下载任务</li>
<li>设置下载标识 为true</li>
<li>最后，你把下载的URL作为key,download对象作为值放到一个字典中</li>
</ol>


<p>编译运行你的项目，查询出来的歌曲中，点击 Download按钮，你将会看到一个消息打印在控制台。
<code>Finished downloading.</code></p>

<h2>保存&amp;播放</h2>

<p>当下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>提供了一个URL存储临时文件路径，你的工作就是移动它到你程序的沙盒当中，在这个方法返回之前。当然，这个过程当中你需要删除全局字典中正在下载的download对象，并且更新表格.</p>

<p>你需要添加一个Helper方法简化这个操作，在<code>SearchViewController.swift</code>中，添加如下方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func trackIndexForDownloadTask(downloadTask: NSURLSessionDownloadTask) -&gt; Int? {
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    for (index, track) in searchResults.enumerate() {
</span><span class='line'>      if url == track.previewUrl! {
</span><span class='line'>        return index
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法仅仅返回 当前的URL在 searchResults集合中的索引，下一步，替换 URLSession(_:downloadTask:didFinishDownloadingToURL:) 中的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL) {
</span><span class='line'>  // 1
</span><span class='line'>  if let originalURL = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>    destinationURL = localFilePathForUrl(originalURL) {
</span><span class='line'> 
</span><span class='line'>    print(destinationURL)
</span><span class='line'> 
</span><span class='line'>    // 2
</span><span class='line'>    let fileManager = NSFileManager.defaultManager()
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.removeItemAtURL(destinationURL)
</span><span class='line'>    } catch {
</span><span class='line'>      // Non-fatal: file probably doesn't exist
</span><span class='line'>    }
</span><span class='line'>    do {
</span><span class='line'>      try fileManager.copyItemAtURL(location, toURL: destinationURL)
</span><span class='line'>    } catch let error as NSError {
</span><span class='line'>      print("Could not copy file to disk: \(error.localizedDescription)")
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'> 
</span><span class='line'>  // 3
</span><span class='line'>  if let url = downloadTask.originalRequest?.URL?.absoluteString {
</span><span class='line'>    activeDownloads[url] = nil
</span><span class='line'>    // 4
</span><span class='line'>    if let trackIndex = trackIndexForDownloadTask(downloadTask) {
</span><span class='line'>      dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>        self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: trackIndex, inSection: 0)], withRowAnimation: .None)
</span><span class='line'>      })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做的事情如下:</p>

<ol>
<li>定义了两个变量，<code>originalURL</code>请求路径的url,<code>destinationURL</code>变量则是通过<code>localFilePathForUrl(_:)</code>方法生成的，该方法会获取当前程序的沙盒路径再追加 传递的URL的最后一个后缀(/)的路径作为返回的参数。作为目标文件夹的路径</li>
<li>使用NSFileManager,在开始拷贝文件之前，先删除目标文件夹下的文件，如果存在的话。然后进行拷贝从本地拷贝到目标文件夹</li>
<li>删除download从全局的download字典中</li>
<li>最后刷新表格对应的哪一行</li>
</ol>


<p>编译运行你的工程，点击搜索然后选中一行进行下载，当下载完成时候，在控制台会打印一行信息,下载的目标路径</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>file:///Users/Andrew/Library/Developer/CoreSimulator/Devices/875165C2-FA55-4884-96AE-A7C8E3223C12/data/Containers/Data/Application/52B47648-04A2-4C26-8BCF-F41D2C76CA21/Documents/mzm.gyadmzom.aac.p.m4a</span></code></pre></td></tr></table></div></figure>


<p>这时下载按钮将会消失，再次点击表格的对应的那行，将会弹出一个 MPMoviePlayerViewController,开始播放音频.</p>

<h2>监视下载进度</h2>

<p>当然，现在你还没有监视下载的进度条，为了提高用户体验，你将要改变你的App去监听下载的进度在每个cell中。</p>

<p>在SearchViewController.swift文件中,找到 <code>NSURLSessionDownloadDelegate</code>的扩展，然后添加如下的代理方法:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func URLSession(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
</span><span class='line'> 
</span><span class='line'>    // 1
</span><span class='line'>    if let downloadUrl = downloadTask.originalRequest?.URL?.absoluteString,
</span><span class='line'>      download = activeDownloads[downloadUrl] {
</span><span class='line'>      // 2
</span><span class='line'>      download.progress = Float(totalBytesWritten)/Float(totalBytesExpectedToWrite)
</span><span class='line'>      // 3
</span><span class='line'>      let totalSize = NSByteCountFormatter.stringFromByteCount(totalBytesExpectedToWrite, countStyle: NSByteCountFormatterCountStyle.Binary)
</span><span class='line'>      // 4
</span><span class='line'>      if let trackIndex = trackIndexForDownloadTask(downloadTask), let trackCell = tableView.cellForRowAtIndexPath(NSIndexPath(forRow: trackIndex, inSection: 0)) as? TrackCell {
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          trackCell.progressView.progress = download.progress
</span><span class='line'>          trackCell.progressLabel.text =  String(format: "%.1f%% of %@",  download.progress * 100, totalSize)
</span><span class='line'>        })
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过这个代理方法做的工作如下:</p>

<ol>
<li>使用提供的 downloadTask 找到URL属性，然后从全局激活的下载字典中查找 DownLoad对象</li>
<li>这个方法将会返回总的字节数和已经写入的字节数，你可以利用这个两个值算出当前的下载进度并且实时更新进度条。</li>
<li>NSByteCountFormatter 将会把字节数转化成人类能够看懂的文件大小，有将会使用这个字符串去显示下载的文件大小和百分比</li>
<li>最后，你将要定位到这个Cell,在主线程中更新进度条和显示的百分比</li>
</ol>


<p>下一步，你将要配置这个cell属性去显示进度条</p>

<p>找到下面的代码在 <code>tableView(_:cellForRowAtIndexPath:):</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let downloaded = localFileExistsForTrack(track)</span></code></pre></td></tr></table></div></figure>


<p>添加如下代码在这行的上面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var showDownloadControls = false
</span><span class='line'>if let download = activeDownloads[track.previewUrl!] {
</span><span class='line'>  showDownloadControls = true
</span><span class='line'> 
</span><span class='line'>  cell.progressView.progress = download.progress
</span><span class='line'>  cell.progressLabel.text = (download.isDownloading) ? "Downloading..." : "Paused"
</span><span class='line'>}
</span><span class='line'>cell.progressView.hidden = !showDownloadControls
</span><span class='line'>cell.progressLabel.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>为了跟踪正在下载的歌曲，你将要设置 showDownloadControls为true,否则，你将要设置为false.你将要显示这进度条和文字。</p>

<p>为了暂停任务，显示"Paused"状态，否则，显示 “Downloading&hellip;.”
最后，替换这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded</span></code></pre></td></tr></table></div></figure>


<p>使用下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.downloadButton.hidden = downloaded || showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>到这，你可以告诉表格是否隐藏下载按钮。</p>

<p>编译运行你的工程，点击下载按钮，你将要看到一个进度条和下载的进度，以及下载的百分比。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/Screen-Shot-2015-08-17-at-11.02.03-pm-480x78.png" alt="logo" /></p>

<p>OK,你做到了!😀</p>

<h2>暂停 恢复  取消下载任务</h2>

<p>假如我需要暂停一个任务，或者取消任务？此时该怎么做呢？</p>

<p>在这个章节，你将要实现暂停，恢复，取消任务操作。</p>

<p>你将要开始编写代码，通过允许用户去取消一个正在激活的任务
替换 <code>cancelDownload(_:)</code> 使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func cancelDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      download.downloadTask?.cancel()
</span><span class='line'>      activeDownloads[urlString] = nil
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了取消任务，你可以从全局激活的字典中取出Download对象，然后调用它的 cancel() 方法，执行取消命令，然后在全局字典中移除它</p>

<p>暂停任务和取消任务非常类似，不同点在于当你暂停一个任务的时候，会产生恢复数据，它包含了足够多的信息去恢复下载数据，当然后台服务器必须要支持这个特性才能完全实现断点下载功能.</p>

<blockquote><p><strong>注意</strong>
你能恢复一个下载任务在一定的控制条件下，例如，从你第一下请求下载开始，这个下载资源就不能再改变了。想要更详细的控制条件，请参考苹果的 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionDownloadTask_class/index.html#//apple_ref/occ/instm/NSURLSessionDownloadTask/cancelByProducingResumeData:">官方文档</a></p></blockquote>

<p>现在，替换 <code>pauseDownload(_:)</code>使用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func pauseDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if(download.isDownloading) {
</span><span class='line'>        download.downloadTask?.cancelByProducingResumeData { data in
</span><span class='line'>          if data != nil {
</span><span class='line'>            download.resumeData = data
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>        download.isDownloading = false
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个关键字是不同的 cancelByProducingResumeData(_:) 替代了 cancel(),你检索这个恢复的数据从这个方法cancelByProducingResumeData提供的回调函数中，并且把恢复的数据保存到Download的resumeData属性中。并且设置isDownloading=false</p>

<p>下面替换<code>resumeDownload(_:)</code>用下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func resumeDownload(track: Track) {
</span><span class='line'>  if let urlString = track.previewUrl,
</span><span class='line'>    download = activeDownloads[urlString] {
</span><span class='line'>      if let resumeData = download.resumeData {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      } else if let url = NSURL(string: download.url) {
</span><span class='line'>        download.downloadTask = downloadsSession.downloadTaskWithURL(url)
</span><span class='line'>        download.downloadTask!.resume()
</span><span class='line'>        download.isDownloading = true
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当用户恢复一个下载任务时，你检查下当前的Download对象 恢复数据的属性是否有值，如果有值，你将会创建一个新的下载任务通过 <code>downloadTaskWithResumeData(_:)</code>和一个恢复数据的参数，启动<code>resume()</code>恢复数据的命令;如果这个 恢复数据的属性是空的或者其他一些原因，你将要用URL创建一个新的下载任务，启动它.</p>

<p>在上面的案例中，你设置这个isDownloading为true,表明任务正在进行.</p>

<p>还有一件事件要做就是设置这三个函数的工作属性，你需要在cell中显示 或者隐藏 <code>暂停</code>，<code>取消</code>和<code>继续下载</code>按钮。</p>

<p>找到 <code>tableView(_:cellForRowAtIndexPath:)</code>然后找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let download = activeDownloads[track.previewUrl!] {</span></code></pre></td></tr></table></div></figure>


<p>然后添加下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let title = (download.isDownloading) ? "Pause" : "Resume"
</span><span class='line'>cell.pauseButton.setTitle(title, forState: UIControlState.Normal)</span></code></pre></td></tr></table></div></figure>


<p>暂停和继续下载按钮共用一个按钮。</p>

<p>下一步，添加下面的代码在 <code>tableView(_:cellForRowAtIndexPath:)</code>结尾:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cell.pauseButton.hidden = !showDownloadControls
</span><span class='line'>cell.cancelButton.hidden = !showDownloadControls</span></code></pre></td></tr></table></div></figure>


<p>当下载任务激活的时候，这里仅仅把按钮显示出来。</p>

<p>编译运行你的工程，下载几个歌曲试试，你可以暂停，继续下载，取消 下载任务。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="logo" /></p>

<h2>支持后台下载</h2>

<p>你的App现在看来已经很不错了，但是还有一个问题，是否支持后台任务下载:当你的程序进入后台模式或者因为别的原因意外终止了，后台任务是否能继续下载?</p>

<p>假如你的App不再运行了，那它怎么能继续工作呢？这儿有一个守护进程在App运行之外，去管理后台任务下载；它发送一个适当的代理方法通知给app让其任务下载继续，当这个app正在下载的时候突然退出，这个任务将要继续下载。</p>

<p>当任务完成的时候，这个守护进程将要重新加载在后台模式中，这个重新加载app将要重新连接这同样的session.收到相关的完成的代理消息并且执行一些要求的动作，比如持久化下载的文件到硬盘上等。</p>

<blockquote><p><em>注意</em>
如果你强制退出app通过app switche，这个系统将要取消所有后台下载的任务，并且不会再视图重启这个app</p></blockquote>

<p>仍然在SearchViewController.swift这个文件中，在初始化 <code>downloadsSession</code>的地方，找到下面这行代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
</span></code></pre></td></tr></table></div></figure>


<p>替换成下面的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier("bgSessionConfiguration")</span></code></pre></td></tr></table></div></figure>


<p>替换默认的session配置文件，指定一个特殊的后台session配置文件，注意你设置了唯一的ID为这个session,这会允许你引用并且重新连接同样的后台session.</p>

<p>下一步，在 viewDidLoad()中，增加如下代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_ = self.downloadsSession</span></code></pre></td></tr></table></div></figure>


<p>调用懒加载属性<code>downloadsSession</code>,确保应用程序确实创建了一个后台session 的SearchViewController的实例。</p>

<p>当一个后台任务完成的时候，这个App不再运行，这个app将会重新运行到后台进程中，你需要去处理你的app的一些代理方法.</p>

<p>切换到 AppDelegate.swift,添加下面的代码在类的顶部:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var backgroundSessionCompletionHandler: (() -&gt; Void)?</span></code></pre></td></tr></table></div></figure>


<p>下一步，添加如下代码在AppDelegate.swift:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func application(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: () -&gt; Void) {
</span><span class='line'>  backgroundSessionCompletionHandler = completionHandler
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>提供一个completionHandler作为一个变量在你的App代理方法中，等会会用到。</p>

<p>application(_:handleEventsForBackgroundURLSession:)会唤醒这个App处理完成这个后台任务，你需要去处理两个事情：</p>

<ul>
<li>首先，通过代理方法用这个App去重新连接这个后台session,一旦你创建并且每次使用后台session时，SearchViewController就会被实例化，你已经重新连接了.</li>
<li>第二，你需要去捕获完成的回调方法，在完成的回调函数中，更新你的UI,然后告诉系统你的App已经工作完毕使用后台任务的session.</li>
</ul>


<p>但是什么时候你将会调用完成的回调函数呢？
<code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>将会是一个好的选择，它是NSURLSessionDelegate的一个代理方法，当所有的任务在后台session中完成的时候。</p>

<p>实现下面的扩展在<code>SearchViewController.swift</code>中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension SearchViewController: NSURLSessionDelegate {
</span><span class='line'> 
</span><span class='line'>  func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
</span><span class='line'>    if let appDelegate = UIApplication.sharedApplication().delegate as? AppDelegate {
</span><span class='line'>      if let completionHandler = appDelegate.backgroundSessionCompletionHandler {
</span><span class='line'>        appDelegate.backgroundSessionCompletionHandler = nil
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), {
</span><span class='line'>          completionHandler()
</span><span class='line'>        })
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码仅仅抓取了在APPDelegate中存储的回调函数，并且在主线中调用它.</p>

<p>编译运行你的工程，开始几个下载之后迅速按在home键，使得下载任务进入后台，等几十秒你的下载任务将会完成，然后双击home,关闭当前程序。</p>

<p>下载任务将会完成并且他们将会更新显示状态。</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt="logo" /></p>

<p>OK，这个demo已经完备了。</p>

<h2>完整工程下载</h2>

<p>你可以下载完整的工程从 <a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip">这里</a></p>

<p>更多资源</p>

<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/">苹果的官方文档</a></li>
<li><a href="https://github.com/Alamofire/Alamofire">AlamoFire</a>是Swift中非常流行的第三方框架，可以学习一下.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperationQueue简单介绍]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao/"/>
    <updated>2016-03-26T08:11:55+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/26/nsoperationqueuejian-dan-jie-shao</id>
    <content type="html"><![CDATA[<p>在iOS中有两种方式来实现多线程:NSOperation和GCD.
其中GCD是基于C的底层的API,而NSOperation则是GCD实现的Object-c的API,随让NSOPeration是基于GCD实现的，但是并不意味着它是一个GCD的重复版本，相反，我们可以用NSOperation轻易的实现一些GCD要写大量代码的事情，因此，NSOperation是被推荐使用的.</p>

<!--more-->


<h2>为什么优先使用NSOperationQuere,而不是GCD</h2>

<p>你可能写过这样的网络请求的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(_Queue, ^{  
</span><span class='line'>    //请求数据 
</span><span class='line'>    NSData *data = [NSData dataWithContentURL:[NSURL URLWithString:@"http://domain.com/a.png"]]; 
</span><span class='line'>    dispatch_async(dispatch_get_main_queue(), ^{ 
</span><span class='line'>        [self refreshViews:data];
</span><span class='line'>     });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>这段代码是可以正常工作的，但是有一个很大的缺点，就是<em>这个任务是无法取消的</em></p>

<p><code>dataWithContentURL:</code>是同步拉取数据，它会一直阻塞主线程，直到所有的数据返回之后；这个期间，并发队列就需要为其它任务新建线程，这样可能导致性能下降问题。因此我们不推荐这种写法来从网络上拉取数据。</p>

<p>操作队列是有GCD提供的一个队列模型的Coco对象，GCD提供了更加底层的控制，而操作队列则在GCD之上实现了更加方便的功能。NSOperation相对GCD来说有以下优点:</p>

<ul>
<li>提供了GCD中不那么容易复制的有用特性</li>
<li>可以很方便的取消一个NSOperation的执行</li>
<li>可以容易的添加任务的依赖关系</li>
<li>提供了任务的状态:isExecting,isFinished
*</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue就是一个线程队列，可以吧 <code>NSOperation</code>加入到队列中，可以取消或者执行完队列中所有的 <code>NSOperation</code>,我们可以通过<code>maxConcurrentOperationCount</code>属性来控制并发任务的数量，当设置为1时，就是一个串行队列。</p>

<h2>NSOperation</h2>

<p>它是创建线程的对象，系统已经默认提供了<code>NSBlockOperaton</code>和<code>NSInvocationOperation</code>.你也可以实现自己的子类，通过重写
<code>main</code>或者<code>start</code>方法来自定义nsoperation</p>

<p>使用<code>main</code>方法非常简单，不需要管理一些状态属性,当main方法返回的时候，这个operation就执行结束了，所以一般用来执行同步任务。</p>

<p>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么重写<code>start</code>方法，但是注意，在这种情况下，你必须手动的管理操作的状态，只有发送isFinished的KVO消息时，才认为是operaiton结束。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>@implementation YourOperation
</span><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = YES;
</span><span class='line'>    // 任务代码 ...
</span><span class='line'>}
</span><span class='line'>- (void)finish //异步回调
</span><span class='line'>{
</span><span class='line'>    self.isExecuting = NO;
</span><span class='line'>    self.isFinished = YES;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p><em>当实现了<code>start</code>方法时，默认就会执行start方法，而不执行main方法</em>，为了让操作队列捕获到做的改变，需要将状态的属性配合KVO的方式实现，如果你不使用它们默认的sette来进行设置的话，就需要在合适的时候手动发送KVO消息。</p>

<p>需要手动管理的状态有:</p>

<ol>
<li>isExecuting  代表任务正在进行中</li>
<li>isFinished   代表任务已经执行完成</li>
<li>isCanceled  代表任务已经取消</li>
</ol>


<p>手动发送KVo消息，通知状态:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[self willChangeValueForKey:@"isCancelled"];
</span><span class='line'>_isCancelled = YES;
</span><span class='line'>[self didChangeValueForKey:@"isCancelled"];</span></code></pre></td></tr></table></div></figure>


<p>为了能使用队列所提供的取消功能，你需要在长时间操作中不时地检查isCanceled属性，比如在一个长的循环中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)main
</span><span class='line'>{
</span><span class='line'>    while (notDone && !self.isCancelled) {
</span><span class='line'>        // 任务处理
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>简单使用</h2>

<p>NSOperaiton和NSOperationQueue实现多线程的步骤:</p>

<ol>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>将取出的NSOperation封装放到一条新线程中执行</li>
</ol>


<p>NSOperation是个抽象类，并不具备封装操作的能力，必须实现它的子类。</p>

<h3>NSInvocationOperation子类</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建操作对象，封装要执行的任务
</span><span class='line'>//NSInvocationOperation   封装操作
</span><span class='line'>    NSInvocationOperation *operation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test) object:nil];
</span><span class='line'>    
</span><span class='line'>    //执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>一旦执行操作，就会调用target的test方法</p>

<p>操作对象默认在主线程中执行，只有添加到列队中才会开启新的线程，即默认情况下，如果操作没有放到队列queue中，都是同步执行，只有将NSoperation放到一个NSOperationQueue中，才会异步执行.</p>

<h2>NSBlockOoperaiton</h2>

<p>创建对象和添加操作:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>    NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        //......
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //添加操作
</span><span class='line'>    [operation addExecutionBlock:^{
</span><span class='line'>        //....
</span><span class='line'>    }];</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//创建NSBlockOperation操作对象
</span><span class='line'>     NSBlockOperation *operation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>    
</span><span class='line'>     //添加操作
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation1------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     [operation addExecutionBlock:^{
</span><span class='line'>         NSLog(@"NSBlockOperation2------%@",[NSThread currentThread]);
</span><span class='line'>     }];
</span><span class='line'>     
</span><span class='line'>     //开启执行操作
</span><span class='line'>    [operation start];</span></code></pre></td></tr></table></div></figure>


<p>只要NSBlockOperation封装的操作数>1，就会异步操作。</p>

<h2>NSOperationQueue</h2>

<p>NSOperationQueue可以调用start方法来执行任务，但默认是同步执行的。
如果将NSOperation添加到NSOperationQueue中，系统就会自动异步执行NSOPeration中的操作。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "YYViewController.h"
</span><span class='line'>
</span><span class='line'>@interface YYViewController ()
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation YYViewController
</span><span class='line'>
</span><span class='line'>- (void)viewDidLoad
</span><span class='line'>{
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    //创建NSInvocationOperation对象，封装操作
</span><span class='line'>    NSInvocationOperation *operation1=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test1) object:nil];
</span><span class='line'>    NSInvocationOperation *operation2=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(test2) object:nil];
</span><span class='line'>    //创建对象，封装操作
</span><span class='line'>    NSBlockOperation *operation3=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--1----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    [operation3 addExecutionBlock:^{
</span><span class='line'>        NSLog(@"NSBlockOperation3--2----%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    //创建NSOperationQueue
</span><span class='line'>    NSOperationQueue * queue=[[NSOperationQueue alloc]init];
</span><span class='line'>    //把操作添加到队列中
</span><span class='line'>    [queue addOperation:operation1];
</span><span class='line'>    [queue addOperation:operation2];
</span><span class='line'>    [queue addOperation:operation3];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test1
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test1--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)test2
</span><span class='line'>{
</span><span class='line'>    NSLog(@"NSInvocationOperation--test2--%@",[NSThread currentThread]);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>系统自动将NSOperationqueue中的NSOPeration对象取出，将其封装的操作放到一条新的线程中执行，
上面的代码一共有4个任务，operation1和operation2分别有一个任务，operation3有两个任务，一共4个任务，开启了4条线程。</p>

<p>这些任务是并行执行的。</p>

<blockquote><p><strong>提示</strong>
队列的取出时有顺序的，与打印结果并不矛盾，这就好比赛跑，起跑的顺序是A,B,C，但是到达终点的顺序就不一样是 A B  C了。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-泛型]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing/"/>
    <updated>2016-03-24T10:11:56+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/24/swift-fan-xing</id>
    <content type="html"><![CDATA[<p>泛型代码可以让你编写使用自定义需求以及任意类型的灵活可冲中的函数和类型，它可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>

<!--more-->


<p>泛型是swift的强大特性之一，许多swift标准库是通过泛型代码构建的。事实上，泛型的使用贯穿饿了正本语言手册，只是你可能没有发现而已。例如,swift的<code>Array</code>和<code>Dictionary</code>都是泛型集合。你可以创建一个<code>Int</code>数组，也可以创建一个<code>String</code>数组，甚至可以是任意其它Swift类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>

<h2>泛型所解决的问题</h2>

<p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个<code>Int</code>值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个函数使用输入输出函数(<code>inout</code>)来交换<code>a</code>和<code>b</code>的值。</p>

<p><code>swapTwoInts(_:_:)</code>函数交换<code>b</code>的原始值到<code>a</code>,并交换<code>a</code>的原始值到<code>b</code>,你可以调用这个函数交换两个<code>Int</code>变量的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoInts(&someInt, &anotherInt)
</span><span class='line'>print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
</span><span class='line'>// 打印 “someInt is now 107, and anotherInt is now 3”</span></code></pre></td></tr></table></div></figure>


<p>诚然，<code>swapTwoInts(_:_:)</code>函数挺有用，但是它只能交换<code>Int</code>值，如果你想要交换两个<code>String</code>值或者<code>Double</code>值，就不能不写更多的函数，例如<code>swapTwoStrings(_:_:)</code>和<code>swapTwoDoubles(_:_:)</code>,如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoStrings(inout a: String, inout _ b: String) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func swapTwoDoubles(inout a: Double, inout _ b: Double) {
</span><span class='line'>    let temporaryA = a
</span><span class='line'>    a = b
</span><span class='line'>    b = temporaryA
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可能注意到<code>swapTwoInts(_:_:) 和 swapTwoDoubles(_:_:)</code>,的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 int,String,Double.</p>

<p>在实际的应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。</p>

<blockquote><p><em>注意</em>
在上面的三个函数中，<code>a</code>和<code>b</code>类型相同，如果<code>a</code>和<code>b</code>类型不同，那他们俩就不能交换值。Swift是类型安全的语言，所以不会允许一个<code>String</code>类型的变量和一个<code>Double</code>类型的变量互换值。视图这样做将导致编译错误。</p></blockquote>

<h2>泛型函数</h2>

<p>泛型函数可以适用于任何类型，下面的<code>swapTwoValues(_:_:)</code>函数是上面三个函数的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoValues&lt;T&gt;(inout a:T,inout _ b:T){
</span><span class='line'> let temporaryA=a;
</span><span class='line'> a=b;
</span><span class='line'> b= temporaryA;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>swapTwoValues(_:_:)</code>的函数主体和<code>swapTwoInts(_:_:)</code>函数是一样的。他们只在第一行有所不同，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func swapTwoInts(inout a: Int, inout _ b: Int)
</span><span class='line'>func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T)</span></code></pre></td></tr></table></div></figure>


<p>这个函数的泛型版本使用了占位类型名(在这里用字母<code>T</code>来表示)来代替实际的类型名(例如<code>Int</code>,<code>String</code>或者<code>Double</code>).占位类型名没有指明<code>T</code>必须是什么类型，但是它指明了<code>a</code>和<code>b</code>必须是同一类型<code>T</code>,而不论<code>T</code>代表什么类型，只有<code>swapTwoValues(_:_:)</code>函数在调用时，才能根据所传入的实际类型决定<code>T</code>所代表的类型。</p>

<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名(T),而且使用尖括号括起来的(<code>&lt;T&gt;</code>).这个尖括号告诉Swift那个<code>T</code>是<code>swapTwoValues(_:_:)</code>函数定义的一个占位类型名，因此swift不会去查找名为<code>T</code>的实际类型。</p>

<p>swapTwoValues(<em>:</em>:) 函数现在可以像 swapTwoInts(<em>:</em>:) 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code>函数调用时，<code>T</code>所代表的类型都会由传入的值的类型判断出来.</p>

<p>在下面的两个例子中，<code>T</code>分别代表<code>Int</code>和<code>String</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var someInt = 3
</span><span class='line'>var anotherInt = 107
</span><span class='line'>swapTwoValues(&someInt, &anotherInt)
</span><span class='line'>// someInt is now 107, and anotherInt is now 3
</span><span class='line'>
</span><span class='line'>var someString = "hello"
</span><span class='line'>var anotherString = "world"
</span><span class='line'>swapTwoValues(&someString, &anotherString)
</span><span class='line'>// someString is now "world", and anotherString is now "hello"</span></code></pre></td></tr></table></div></figure>


<h2>类型参数</h2>

<p>在上面的<code>swapTwoValues(_:_:)</code>例子中，占位类型<code>T</code>是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来(<T>).</p>

<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型，或者作为函数的返回类型，还可以用作函数主题中的注释类型。在这些情况下，类型参数在函数调用时被实际类型所代替。</p>

<h2>命名类型参数</h2>

<p>在大多数情况下，类型参数具有一个描述性名字，例如<code>Dictionary&lt;Key,Value&gt;</code>中的key和value,以及<code>Array&lt;Element&gt;</code>中的<code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当他们之间的关系没有意义时，通常使用单一的字母来命名，例如<code>T</code>,<code>U</code>,<code>V</code>，正如上面演示的<code>swapTwoValues(_:_:)</code>函数中的<code>T</code>一样.</p>

<h2>泛型类型</h2>

<p>除了泛型函数，Swift还允许你定义泛型类型。这些自定义类，结构体和枚举可以适用于任何类型，如同<code>Array</code>和<code>Dictionary</code>的用法。</p>

<p>这部分内容将向你展示如何编写一个名为<code>stack</code>（栈）的泛型集合类型。栈是一系列值的有序集合，如<code>Array</code>类型，但它比Swift的array类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素，称为入栈。同样滴，栈也只能从末端移除元素。</p>

<p>下面展示了一个如何编写一个非泛型版本的栈，在这种情况下是<code>Int</code>型的栈.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStack {
</span><span class='line'>    var items=[Int]()
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个结构体在栈中使用一个名为<code>items</code>的<code>array</code>属性来存储值。<code>Stack</code>提供了两个方法:<code>push(_:)</code>和<code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为<code>mutating</code>，因为他们需要修改结构体的<code>items</code>数组。</p>

<p>上面的<code>IntStack</code>结构体只能用于Int类型，不过可以定义一个泛型的<code>Stack</code>结构体，从而能够处理任意类型的值。</p>

<p>下面是相同代码的泛型版本:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Stack&lt;Element&gt; {
</span><span class='line'>    var items=[Element]();
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Element){
</span><span class='line'>        items.append(item);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Element{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>注意，<code>Stack</code>基本上和<code>IntStack</code>相同，只是占位类型参数<code>Element</code>代替了实际的<code>Int</code>类型。这种类型参数包裹在一对尖括号里(<code>&lt;Element&gt;</code>)，紧跟在结构体名后面、</p>

<p><code>Element</code>为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体定义中通过<code>Element</code>来引用。在这种情况下，<code>Element</code>在如下三个地方被用作占位符:</p>

<ul>
<li>创建 items 属性，使用<code>Element</code>类型的空数组进行初始化</li>
<li>执行<code>psh(_:)</code>方法的单一参数<code>item</code>的类型必须是<code>Element</code>类型</li>
<li>指定<code>pop()</code>方法的返回值类型必须是<code>Element</code>类型.</li>
</ul>


<p>由于<code>stack</code>是泛型类型，因此可以用来创建Swift中任意有效类型的栈，如同<code>Array</code>和<code>Dictionary</code>.</p>

<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个<code>Stack</code>实例。例如，要创建一个<code>String</code>类型的栈，可以写成<code>Stack&lt;String&gt;</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var stackOfStrings = Stack&lt;String&gt;()
</span><span class='line'>stackOfStrings.push("uno")
</span><span class='line'>stackOfStrings.push("dos")
</span><span class='line'>stackOfStrings.push("tres")
</span><span class='line'>stackOfStrings.push("cuatro")
</span><span class='line'>// 栈中现在有 4 个字符串</span></code></pre></td></tr></table></div></figure>


<p>移除并返回栈顶部的值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let fromTheTop = stackOfStrings.pop()
</span><span class='line'>// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></code></pre></td></tr></table></div></figure>


<h2>扩展一个泛型类型</h2>

<p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型的参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>

<p>下面的例子扩展了泛型类型<code>Stack</code>，为其添加了一个名为<code>topItem</code>的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Stack{
</span><span class='line'>    var topItem:Element?{
</span><span class='line'>        return items.isEmpty ? nil:items[items.count];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>topItem</code>属性会返回一个<code>Element</code>类型的可选值。当栈为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>nil</code>;当栈不为空的时候，<code>topItem</code>会返回<code>items</code>数组中的最后一个元素.</p>

<p>注意，这个扩展并没有定义一个类型参数列表。相反地，<code>Stack</code>类型已有的类型参数名<code>Element</code>，被用在扩展中表示计算型属性<code>topItem</code>的可选类型，<code>topItem</code>现在可以用来访问任意<code>Stack</code>实例的顶端元素而不是移除它</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let topItem = stackOfStrings.topItem {
</span><span class='line'>    print("The top item on the stack is \(topItem).")
</span><span class='line'>}
</span><span class='line'>// 打印 “The top item on the stack is tres.”</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>类型约束</h2>

<p><code>swapTwoValues(_:_:)</code>函数和<code>Stack</code>类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须集成自特定类，或者符合一个特定的协议或者协议组合。</p>

<p>例如,Swift的<code>Dictionary</code>类型对字典的键的类型做了限制，在字典的描述中，字典的键必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code>之所以需要其键是可哈希的，是为了便于检查字典是否已经包含了某个特定键的值。如无此要求，Dictionary将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中指定键的值。</p>

<p>这个要求强制加上了一个类型约束作用域<code>Dictionary</code>的键类型上，其键类型必须符合<code>Hashable</code>协议，这是swift标准库中定义的一个特定协议。所有的swfit基本类型(String,Int,Double)默认都是可哈希的。</p>

<p>当你创建自定义反省类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的。</p>

<h2>类型约束语法</h2>

<p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分割，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
</span><span class='line'>    // 这里是泛型函数的函数体部分
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的这个函数有两个类型参数。第一个类型是参数<code>T</code>,有一个要求<code>T</code>必须是<code>SomeClass</code>自雷的类型约束；第二个类型参数<code>U</code>,有一个要求<code>U</code>必须符合<code>someProtocol</code>协议的类型约束.</p>

<h2>类型约束实践</h2>

<p>这里有个名为<code>findStringIndex</code>的非泛型函数，该函数的功能在<code>String</code>值的数组中查找指定<code>String</code>值的索引。弱查找到匹配的字符串，<code>findStringIndex(_:_:)</code>函数返回该字符串在数组中的索引值，反之则返回<code>nil</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findStringIndex(array: [String], _ valueToFind: String) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该函数可以用于查找字符串数组中的某个字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
</span><span class='line'>if let foundIndex = findStringIndex(strings, "llama") {
</span><span class='line'>    print("The index of llama is \(foundIndex)")
</span><span class='line'>}
</span><span class='line'>// 打印 “The index of llama is 2”</span></code></pre></td></tr></table></div></figure>


<p>如果只能查找字符串在数组中的索引，用处不是很大，不过，你可以写出相同功能的泛型函数<code>findIndex(_:_:)</code>,用占位类型<code>T</code>代替<code>String</code>类型。</p>

<p>下面展示了<code>findStringIndex(_:_:)</code>函数的泛型版本<code>findIndex(_:_:)</code>.请注意这个函数仍然返回<code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到一个可选值。需要提醒的是，这个函数无法通过编译，原因例子后面说明:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>func findIndex&lt;T&gt;(array:[T], valueToField:T)-&gt;Int?{
</span><span class='line'>    for (index, value)in array.enumerate(){
</span><span class='line'>        if value == valueToField{
</span><span class='line'>            return index;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return nil;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即<code>if vlaue == valueToField</code>。不是所有的Swift类型都可以用等号(==)进行比较。例如，如果你创建一个你自己的类活结构体表示一个复杂的数据模型，那么Swift无法猜到对于这个类或者结构体而言 “相等”意味着什么。正因为如此，这部分代码无法保证适用于每个可能的类型<code>T</code>,当你试图编译这部分代码的时候会出现相应的错误。</p>

<p>不过所有的这些并不会让我们无从下手。Swift标准库中定义了一个<code>Equatable</code>协议，该协议要求任何符合该协议的类型必须实现等式符号(==),从而对符合该协议的类型的任意两个值进行比较。所有的Swift标准类型自动支持Equatable协议。</p>

<p>任何<code>Equatable</code>类型都可以安全地使用在<code>findIndex(_:_:)</code>函数中，因为其保证支持等式操作符。为了说明事实，当你定义一个函数时，你可以定义一个<code>Equatable</code>类型约束作为类型参数定义的一部分:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? {
</span><span class='line'>    for (index, value) in array.enumerate() {
</span><span class='line'>        if value == valueToFind {
</span><span class='line'>            return index
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    return nil
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>findIndex(_:_:)</code>中的这个单一类型参数协作<code>T:Equatable</code>，也就意味着<code>任何符合Equatable</code>协议的<code>T</code>类型。</p>

<p>findIndex函数现在可以成功编译了。并且可以作用于任何符合<code>Equatable</code>的类型，如<code>Double</code>或<code>String</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
</span><span class='line'>// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中
</span><span class='line'>let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
</span><span class='line'>// stringIndex 类型为 Int?，其值为 2</span></code></pre></td></tr></table></div></figure>


<h2>关联类型</h2>

<p>下面例子定义了一个<code>Container</code>协议，该协议定义了关联类型<code>ItemType</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol Container{
</span><span class='line'>   typealias ItemType
</span><span class='line'>    mutating func append(item:ItemType)
</span><span class='line'>    
</span><span class='line'>    var count:Int{get}
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;ItemType{get}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p><code>Container</code>协议定义了三个任何采纳协议的类型必须提供的功能：</p>

<ul>
<li>必须可以通过<code>append</code>方法添加一个新元素到容器里。</li>
<li>必须可以通过<code>count</code>属性获取容易中元素的数量，并返回一个Int</li>
<li>必须可以通过接受<code>Int</code>索引值的下标检索到每一个元素</li>
</ul>


<p>这个协议没有指定容易中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳<code>Container</code>协议的类型必须是提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>

<p>任何采纳<code>Container</code>协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素类型。</p>

<p>为了定义这三个条件，<code>Container</code>协议需要在不知道容易中元素具体类型的情况下引用这种类型。</p>

<p><code>Container</code>协议声明了一个关联类型<code>ItemType</code>，协作<code>typealias Itemtype</code>.这个协议无法定义<code>ItemType</code>是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code>别名提供了一种方式来引用<code>Container</code>中元素的类型，并将之用于<code>append</code>方法和下标，从而保证任何<code>Container</code>的预期行为都能够被执行。</p>

<p>下面采用复合<code>Container</code>协议:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct IntStackContainer:Container {
</span><span class='line'>    var items:[Int]
</span><span class='line'>    
</span><span class='line'>    mutating func push(item:Int){
</span><span class='line'>     items.append(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    mutating func pop()-&gt;Int{
</span><span class='line'>        return items.removeLast();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    //Container协议的实现部分
</span><span class='line'>    typealias ItemType=Int
</span><span class='line'>    
</span><span class='line'>    mutating func append(item: ItemType) {
</span><span class='line'>        self.push(item)
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    var count:Int{
</span><span class='line'>      return items.count
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    subscript(i:Int)-&gt;Int{
</span><span class='line'>        return items[i];
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>IntStackContainer</code>结构体实现了<code>Container</code>协议的三个要求，其原有功能也不会和这些要求冲突。</p>

<p>此外，<code>IntStackContainer</code>指定 ItemType为Int类型，即<code>typealias ItemType = Int</code>，从而将<code>Container</code>协议中抽象的<code>ItemType</code>类型转为具体的<code>Int</code>类型。</p>

<h2>通过扩展一个存在的类型来指定关联类型</h2>

<p>Swift的<code>Array</code>已经提供了<code>append(_:_:)</code>方法，一个<code>count</code>属性，以及一个接受<code>Int</code>型索引值的可用来检索数组元素的下标。这三个功能都符合<code>Container</code>协议的要求，也就意味着你可以扩展<code>Array</code>去符合<code>Container</code>协议，只需简单滴声明<code>Array</code>采纳该协议即可。你可以通过一个空扩展来实现这点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Array:Container{}</span></code></pre></td></tr></table></div></figure>


<p>如何上面的泛型<code>Stack</code>结构一样，array的<code>append(_:)</code>方法和下标确保了Swift可以推断出<code>ItemType</code>的类型，定义了这个扩展后，你可以将任意<code>Array</code>当做<code>Container</code>来使用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-可选链]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/22/swift-ke-xuan-lian/"/>
    <updated>2016-03-22T09:35:29+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/22/swift-ke-xuan-lian</id>
    <content type="html"><![CDATA[<p>可选链式调用(Optional Chaining)是一种可以在当前值可能为<code>nil</code>的可选值上请求和调用属性，方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值为nil,那么调用将返回<code>nil</code>.多个调用可以连接在一起形成一个链，如果其中任何一个点为<code>nil</code>,整个调用链就会失败，即返回nil.</p>

<!--more-->


<h2>使用可选链式调用代替强制展开</h2>

<p>通过在想调用的属性，方法，下标的可选值后面放一个问号(?),可以定义一个可选链，这一点很像在可选值后面加一个(!)来强制展开它的值。它们的主要区别在于当可选值为空时，可选链式就会调用失败，然而强制展开就会触发运行时错误。</p>

<p>为了反映可选链时调用可以在空值(nil)上调用的事实，不论这个调用的属性，方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链时调用是否成功，如果调用有返回值则说明调用成功，返回 <code>nil</code>则说明调用失败。</p>

<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是<code>Int</code>类型，则会变成<code>Int?</code>类型。</p>

<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>

<p>首先定义两个类<code>Person</code>和<code>Residence</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence:Residence?
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>class Residence {
</span><span class='line'>    var numberOfRooms=1
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Residence</code>有一个<code>Int</code>类型的属性<code>numberOfRooms</code>,其默认是值是1，<code>Person</code>具有一个可选的<code>residence</code>属性，其类型为<code>Residence?</code></p>

<p>如果创建一个新的<code>Person</code>实例，因为它的<code>residence</code>属性是可选的，<code>john</code>属性将初始化为<code>nil</code>:</p>

<pre><code>let john=Person()
</code></pre>

<p>如果使用叹号(!)强制展开获得这个<code>john</code>的<code>Residence</code>属性中的<code>numberofRooms</code>值，会触发运行时错误，因为这时<code>residence</code>没有可以展开的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let roomCount = john.residence!.numberOfRooms
</span><span class='line'>// 这会引发运行时错误</span></code></pre></td></tr></table></div></figure>


<p><code>john.residence</code>为非nil值的时候，上面的调用会成功，并且把<code>roomCount</code>设置为<code>Int</code>类型的房间数量，正如上面所提到的，当<code>residence</code>为<code>nil</code>的时候上面这段代码会触发运行时错误。</p>

<p>可选链时调用提供了另一种访问<code>numberOfRooms</code>的方式，使用问号(?)来代替原来的叹号(!)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>在<code>residence</code>后面添加问号之后，Swift就会在<code>residence</code>不为nil的情况下访问<code>numberOfRooms</code>.</p>

<p>因为访问<code>numberOfRooms</code>又看呢过失败，可选链式调用会返回<code>Int?</code>类型，或称为'可选的Int'。如上例所示，当<code>residence</code>为<code>nil</code>的时候，可选的<code>Int</code>将会为<code>nil</code>,表明无法访问<code>numberOfRooms</code>。访问成功时，可选的<code>Int</code>值会通过可选绑定展开，并复制给非可选类型的<code>roomCount</code>常量。</p>

<p>要注意的是，及时<code>numberOfRooms</code>是非可选的<code>Int</code>时，这一点也成立。只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回一个<code>Int?</code>而不是<code>Int</code>.</p>

<p>可以将一个<code>Residence</code>的实例赋值给<code>john.residence</code>，这样它就不在是<code>nil</code>了:</p>

<pre><code>john.residence=Residenc();
</code></pre>

<p>john.residence现在包含一个实际的<code>Residence</code>实例，而不再是<code>nil</code>.如果你试图使用先前的可选链式调用访问<code>numberOfRooms</code>，它现在将返回值为1的<code>Int?</code>类型的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's residence has 1 room(s).”</span></code></pre></td></tr></table></div></figure>


<h2>可选链式调用定义模型类</h2>

<p>通过使用可选链式调用可以调用多层属性，方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性，方法和下标。</p>

<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在<code>person</code>和<code>Residence</code>的基础上增加了<code>Room</code>类和<code>Address</code>类，一级相关的属性，方法和下标.</p>

<p><code>Person</code>类的定义基本保持不变:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    var residence: Residence?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Residence类比之前复杂些。增加了一个名为<code>Rooms</code>的变量属性，该属性被初始化为<code>[Room]</code>类型的空数组:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Residence {
</span><span class='line'>    var rooms = [Room]()
</span><span class='line'>    var numberOfRooms: Int {
</span><span class='line'>        return rooms.count
</span><span class='line'>    }
</span><span class='line'>    subscript(i: Int) -&gt; Room {
</span><span class='line'>        get {
</span><span class='line'>            return rooms[i]
</span><span class='line'>        }
</span><span class='line'>        set {
</span><span class='line'>            rooms[i] = newValue
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    func printNumberOfRooms() {
</span><span class='line'>        print("The number of rooms is \(numberOfRooms)")
</span><span class='line'>    }
</span><span class='line'>    var address: Address?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在<code>Residence</code>有了一个存储<code>Room</code>实例的数组，<code>numberOfRooms</code>属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code>属性简单地返回<code>Rooms</code>数组的count属性的值。。</p>

<p>residence还提供了rooms数组的快捷方式，即提供可读写的下标来访问<code>rooms</code>数组中指定位置的元素。</p>

<p>此外，<code>Residence</code>还提供了<code>printNUmberOfRooms()</code>方法，这个方法的作用是打印<code>numberOfRooms</code>的值。</p>

<p>最后，<code>Residence</code>还定义了一个可选属性<code>address</code>,其类型为<code>Address?</code>.Address类的定义在下面会说明。</p>

<p><code>Room</code>类是一个简单类，其实例被存储在<code>rooms</code>数组中。该类只包含一个属性<code>name</code>,以及一个用于将该属性设置为适当的房间名的初始化函数:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Room {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最后一个类是<code>Address</code>,这个类有三个<code>String?</code>类型的可选属性，<code>buildingName</code>以及<code>buildingNuber</code>属性分别表示某个大厦的名称和号码，第三个属性<code>street</code>表示大厦所在街道的名称:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Address {
</span><span class='line'>    var buildingName: String?
</span><span class='line'>    var buildingNumber: String?
</span><span class='line'>    var street: String?
</span><span class='line'>    func buildingIdentifier() -&gt; String? {
</span><span class='line'>        if buildingName != nil {
</span><span class='line'>            return buildingName
</span><span class='line'>        } else if buildingNumber != nil && street != nil {
</span><span class='line'>            return "\(buildingNumber) \(street)"
</span><span class='line'>        } else {
</span><span class='line'>            return nil
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>Address</code>类提供了<code>buildingIdentifier ()</code>方法，返回值为<code>String?</code>,如果<code>buildingName</code>有值则返回<code>buildingName</code>.或者，如果<code>buildingName</code>和<code>street</code>均有值则返回<code>buildingNumber</code>.否则，返回<code>nil</code>.</p>

<h2>通过可选链式访问属性</h2>

<p>下面的代码创建了一个<code>Person</code>实例，然后像志强一样，尝试访问<code>nubmerOfRooms</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let john = Person()
</span><span class='line'>if let roomCount = john.residence?.numberOfRooms {
</span><span class='line'>    print("John's residence has \(roomCount) room(s).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>因为<code>john.residence</code>为<code>nil</code>,所以这个可选链式调用依旧会像先前一样失败.</p>

<p>还可以通过可选链式调用来设置属性的值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let someAddress = Address()
</span><span class='line'>someAddress.buildingNumber = "29"
</span><span class='line'>someAddress.street = "Acacia Road"
</span><span class='line'>john.residence?.address = someAddress</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，通过<code>john.residence</code>来设定<code>address</code>属性也会失败，因为<code>john.residence</code>当前为<code>nil</code>.</p>

<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的适应，但是它使用一个函数来创建<code>Address</code>实例，然后将该实例返回用于赋值。该函数会在返回前答应<code>Funcation was called</code>，这使你能验证等号右侧的代码是否被执行.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func createAddress() -&gt; Address {
</span><span class='line'>    print("Function was called.")
</span><span class='line'>
</span><span class='line'>    let someAddress = Address()
</span><span class='line'>    someAddress.buildingNumber = "29"
</span><span class='line'>    someAddress.street = "Acacia Road"
</span><span class='line'>
</span><span class='line'>    return someAddress
</span><span class='line'>}
</span><span class='line'>john.residence?.address = createAddress()</span></code></pre></td></tr></table></div></figure>


<p>没有答应任何消息，可以看出<code>createAddress()</code>函数并未被执行。</p>

<h2>通过可选链式调用方法</h2>

<p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值.</p>

<p><code>Residence</code>类中的<code>printNumberOfRooms()</code>方法打印当前的<code>numberOfRooms</code>值，如下所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func printNumberOfRooms() {
</span><span class='line'>    print("The number of rooms is \(numberOfRooms)")
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个方法没有返回值，然而，没有返回值的方法具有隐式的返回类型<code>Void</code>,这意味着没有返回值的方法也会返回<code>()</code>,或者或空的数组.</p>

<p>通过可选链式调用得到的返回值都是可选的。这样我们就可以使用<code>if</code>语句来判断是否成功调用<code>printNumberOfRooms()</code>方法，就是方法本身没有定义返回值，通过判断返回值是否为<code>nil</code>可以判断调用是否成功:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if john.residence?.printNumberOfRooms() != nil {
</span><span class='line'>    print("It was possible to print the number of rooms.")
</span><span class='line'>} else {
</span><span class='line'>    print("It was not possible to print the number of rooms.")
</span><span class='line'>}
</span><span class='line'>// 打印 “It was not possible to print the number of rooms.”</span></code></pre></td></tr></table></div></figure>


<p>同样滴，可以据此判断通过可选链式调用为属性赋值是否成功，我们尝试给<code>john.residence</code>中的 address 属性赋值，即使<code>residence</code>为nil,通过可选链式调用给属性赋值会返回<code>Void?</code>,通过判断返回值是否为nil就可以知道赋值是否成功:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (john.residence?.address = someAddress) != nil {
</span><span class='line'>    print("It was possible to set the address.")
</span><span class='line'>} else {
</span><span class='line'>    print("It was not possible to set the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “It was not possible to set the address.”</span></code></pre></td></tr></table></div></figure>


<h2>通过可选链式调用访问下标</h2>

<p>通过可选链式的调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>

<blockquote><p><strong>注意</strong>
通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面，可选链式调用的问号一般直接跟在可选表达式的后面。</p></blockquote>

<p>下面这个例子用下标访问<code>john.residence</code>属性存储的<code>Residences</code>实例的<code>Rooms</code>数组中的第一个房间的名称，因为<code>john.residence</code>为<code>nil</code>,所以下标调用失败了.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    print("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the first room name.”</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在这个例子中，问号直接放在<code>john.residence</code>的后面，并且在方括号的前面，因为<code>john.residence</code>是可选值.</p>

<p>类似的，可以通过下标，用可选链式调用来赋值:</p>

<pre><code>john.residence?[0] = Room(name: "Bathroom")
</code></pre>

<p> 这样赋值同样会失败，因为<code>residence</code>目前是<code>nil</code>.</p>

<p> 如果你创建一个<code>Residence</code>实例，并未其<code>rooms</code>数组添加一些<code>Room</code>实例，然后将<code>Residence</code>实例赋值给<code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let johnsHouse = Residence()
</span><span class='line'>johnsHouse.rooms.append(Room(name: "Living Room"))
</span><span class='line'>johnsHouse.rooms.append(Room(name: "Kitchen"))
</span><span class='line'>john.residence = johnsHouse
</span><span class='line'>
</span><span class='line'>if let firstRoomName = john.residence?[0].name {
</span><span class='line'>    print("The first room name is \(firstRoomName).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the first room name.")
</span><span class='line'>}
</span><span class='line'>// 打印 “The first room name is Living Room.”</span></code></pre></td></tr></table></div></figure>


<h2>访问可选类型的下标</h2>

<p>如果下标返回可选类型的值，比如Swift中<code>Dictionary</code>类型的键下标，可以在下标的结尾处放一个问号来在其可选值上进行可选链式调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
</span><span class='line'>testScores["Dave"]?[0] = 91
</span><span class='line'>testScores["Bev"]?[0]++
</span><span class='line'>testScores["Brian"]?[0] = 72
</span><span class='line'>// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中定义了一个<code>testScores</code>数组，包含了两个键值对，把String类型的键映射到一个<code>Int</code>值的数组。第三个键值不存在，故调用失败。</p>

<h2>连接多层可选链式的调用</h2>

<p>可以通过连接多个可选链式调用在更深的模型层级中访问属性，方法及下标，然而，多层可选链式调用不会增加返回值的可选层级。</p>

<p>也就是说：</p>

<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值</li>
<li>如果你返回的值就是可选的，可选链式调用不会让可选返回值变得'更可选'</li>
</ul>


<p>因此:</p>

<ul>
<li>通过可选链式调用访问一个<code>Int</code>值，将会返回<code>Int?</code>,无论使用了多少层可选链式调用</li>
<li>类似的，通过可选链式调用访问<code>Int?</code>值，依旧会返回<code>Int?</code>值，并不会返回<code>Int??</code></li>
</ul>


<p>下面的例子尝试访问<code>john</code>中的<code>residence</code>属性中的<code>address</code>属性中的street   属性，这里使用了两层可选链式调用，<code>residence</code>以及adress都是可选值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    print("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “Unable to retrieve the address.”</span></code></pre></td></tr></table></div></figure>


<p>john.residence现在包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的值当前为nil.因此调用<code>john.residence?.adress?.street</code>会失败。</p>

<p>需要注意的是，上面的例子中,<code>street</code>的属性为<code>String?</code>.<code>john.residence?.address?.street</code>的返回值也依然是<code>String?</code>,即使已经使用了两层可选链式调用.</p>

<p>如果<code>john.residence.address</code>赋值一个<code>Address</code>实例，并且为<code>address</code>中的<code>street</code>属性设置一个有效值，我们就能通过可选链式调用来访问<code>street</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let johnsAddress = Address()
</span><span class='line'>johnsAddress.buildingName = "The Larches"
</span><span class='line'>johnsAddress.street = "Laurel Street"
</span><span class='line'>john.residence?.address = johnsAddress
</span><span class='line'>
</span><span class='line'>if let johnsStreet = john.residence?.address?.street {
</span><span class='line'>    print("John's street name is \(johnsStreet).")
</span><span class='line'>} else {
</span><span class='line'>    print("Unable to retrieve the address.")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's street name is Laurel Street.”</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子中，因为<code>john.residence</code>包含了一个有效的<code>Residence</code>实例，所以对<code>john.residence</code>的Address属性赋值将会成功。</p>

<h2>在方法的可选返回值上进行可选链式调用</h2>

<p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值，我们还可以在一个可选值上通过可选链式调用来调用方法，并且根据需要继续在方法的可选返回值上进行可选链式调用</p>

<p>在下面的例子中，通过可选链式调用<code>Address</code>的<code>buildingIdeneity()</code>方法，这个方法返回<code>String?</code>类型的值，如上所述，通过可选链式调用来调用该方法，最终的返回值依旧是 String?类型:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
</span><span class='line'>    print("John's building identifier is \(buildingIdentifier).")
</span><span class='line'>}
</span><span class='line'>// 打印 “John's building identifier is The Larches.”</span></code></pre></td></tr></table></div></figure>


<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if let beginsWithThe =
</span><span class='line'>    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
</span><span class='line'>        if beginsWithThe {
</span><span class='line'>            print("John's building identifier begins with \"The\".")
</span><span class='line'>        } else {
</span><span class='line'>            print("John's building identifier does not begin with \"The\".")
</span><span class='line'>        }
</span><span class='line'>}
</span><span class='line'>// 打印 “John's building identifier begins with "The".”</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-自动引用计数]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/18/swift-zi-dong-yin-yong-ji-shu/"/>
    <updated>2016-03-18T11:17:07+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/18/swift-zi-dong-yin-yong-ji-shu</id>
    <content type="html"><![CDATA[<p>swift使用自动引用计数(ARC)机制来跟踪和管理你的应用程序的内存。通常情况，Swift内存管理机制会一直起作用，你无需自己来考虑内存的管理。ARC会在类的实例不再需要时，自动释放其占用的内存。
然后在少数的情况下，为了能帮助你管理内存，ARC需要更多的代码之间关系的信息。</p>

<!--more-->


<blockquote><p><strong>注意:</strong>
引用计数仅仅应用于类的实例。结构体和枚举类型是属于值类型，不是引用类型，也不是通过引用的方式存储和传递.</p></blockquote>

<h2>自动引用计数的工作机制</h2>

<p>当你每次创建一个类的新的实例的时候，arc会分配一块内存来存储该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的属性的值。
此外，当实例不在被使用时，ARC释放实例所占用的内存。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<p>然而，当ARC回收和释放了正在被使用中的实例，该实例的属性和方法将不再被访问和调用。实际上，如果你还试图访问这个实例，你的应用程序很可能会崩溃。</p>

<p>为了确保使用中的实例不会被销毁，ARC会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>

<p>为了使上述成为可能，无论你将实例赋值给属性，常量或者变量，他们都会
创建此实例的<code>强</code>引用,之所以称为强引用，是因为它会将实例牢牢地包吃住，只要强引用还在，实例是不允许被销毁的。</p>

<h2>自动引用计数实践</h2>

<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        print("\(name) is being initialized")
</span><span class='line'>    }
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Person类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值，并打印一个消息表明初始化过程生效。<code>Person</code>类也拥有一个析构函数，这个析构函数在实例被销毁时打印一条消息。</p>

<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，为新的<code>Person</code>实例建立了多个引用。由于这些变量是被定义为可选类型，它们的值会被自动初始化为nil,目前还不会引用到<code>Person</code>类的实例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var reference1: Person?
</span><span class='line'>var reference2: Person?
</span><span class='line'>var reference3: Person?</span></code></pre></td></tr></table></div></figure>


<p>现在创建Person类的实例</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reference1 = Person(name: "John Appleseed")
</span><span class='line'>// prints "John Appleseed is being initialized”</span></code></pre></td></tr></table></div></figure>


<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，初始化的信息被打印出来。由此可以确定构造函数被执行。</p>

<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立一个强引用。正是因为这一个强引用，ARC会保证<code>Person</code>实例被保持在内存中不被销毁。</p>

<p>如果你将同一个<code>Person</code>实例也赋值给其它两个变量，该实例又会多出两个强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>reference2 = reference1
</span><span class='line'>reference3 = reference1</span></code></pre></td></tr></table></div></figure>


<p>现在这个 <code>Person</code>实例有三个强引用了。</p>

<p>如果你通过给其中两个变量赋值<code>nil</code>的方式断开两个强引用，只留下一个强引用，<code>Person</code>实例也不会被销毁。</p>

<pre><code>reference1 = nil
reference2 = nil
</code></pre>

<p> 在你清楚地表明不再使用这个Person实例时，第三个也就是最后一个强引用被断开时，ARC会销毁它:</p>

<pre><code> reference3 = nil
// 打印 “John Appleseed is being deinitialized”
</code></pre>

<h2>类实例之间的循环强引用</h2>

<p>在上面的例子中，ARC会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>

<p>然而，我们可能会写出一个类实例的强引用永远不能变成0的代码。如果两个类实例互相拥有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的强引用。</p>

<p>你可以通过定义类之间的关系为弱引用或者无主引用，来避免强引用。不管怎样，让我们先来了解下它是如何产生的。</p>

<p>下面展示一个不经意产生循环强引用的例子。例子定义了两个类:<code>person</code>和<code>Apartment</code>,用来建模公寓和它其中的居民:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Apartment {
</span><span class='line'>    let unit: String
</span><span class='line'>    init(unit: String) { self.unit = unit }
</span><span class='line'>    var tenant: Person?
</span><span class='line'>    deinit { print("Apartment \(unit) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>每一个<code>Person</code>实例有一个类型为<code>String</code>,名字为<code>name</code>的属性，并有一个可选的初始化为nil的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>

<p>类似的，每个<code>Apartment</code>实例有个叫<code>unit</code>,类型为String的属性，并有一个可选的初始化为nil的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>

<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这能让你知道<code>Person</code>和<code>Apartment</code>的实例是否像预期那样被销毁。</p>

<p>接下来的代码片段中定义了两个可选类型的变量<code>john</code>和<code>unit4A</code>,并分别被设定为下面的的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为nil:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Person?
</span><span class='line'>var unit4A: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>unit4A = Apartment(unit: "4A")</span></code></pre></td></tr></table></div></figure>


<p>在两个实例被创建和赋值后，下面表现了强引用的关系。变量<code>john</code>现在有个指向<code>Person</code>实例的强引用，而变量<code>unit4A</code>有一个指向<code>Apartment</code>实例的强引用:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle01_2x.png" alt="logo" />
现在，你能够将两个实例关联在一起了，这样人就能有公寓住了，而工具也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>unit4A</code>中的实例，这样实例的属性才能被赋值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john!.apartment = unit4A
</span><span class='line'>unit4A!.tenant = john</span></code></pre></td></tr></table></div></figure>


<p>在将两个实例联系在一起后，强引用的关系如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle02_2x.png" alt="logo" /></p>

<p>不幸的是，这两个实例关联后会产生一个循环强引用，<code>Person</code>类现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>的强引用，因此，当你断开<code>john</code>和<code>uni4A</code>变量所持有的强引用时，引用计数并不会降到0.实例也不会被销毁。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>unit4A = nil</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意:</strong>当你把这两个变量设置为nil时，没有任何一个析构函数被调用，循环强引用会一直阻止<code>Person</code>和<code>Apartment</code>类实例被销毁，这既是你应用程序中造成的内存泄露。</p></blockquote>

<p>在你将<code>john</code>和<code>unit4A</code>设置为nil后，强应用关系如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/referenceCycle03_2x.png" alt="logo" /></p>

<p>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>

<h2>解决实例之间的循环强引用</h2>

<p>swift提供了两种方法用来解决在你使用类的属性时遇到的循环强引用的问题：弱引用(weak refrence)和无主引用(unowned refrecnce).</p>

<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不包吃强引用。这样实例能够互相引用而不产生循环强引用。</p>

<p>对于生命周期中会变成nil的实例使用弱引用。相反地，对于初始化赋值后再也不会给赋值为nil的实例，使用无主引用。</p>

<h3>弱引用</h3>

<p>弱引用不会对其引用的实例保持强引用，因而不会阻止ARC销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>

<p>在实例的声明周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主易用。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有‘居民’的，因此适合使用弱引用来解决循环强引用。</p>

<blockquote><blockquote><p><em>注意</em>
弱引用必须被声明为变量，表明其值在运行时会被修改，若引用
不能被声明为常量。</p>

<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在Swift中，推荐使用可选类型描述可能没有值的类型。</p></blockquote></blockquote>

<p>因为弱引用不会曹植所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC会在引用的实例被销毁后自动将其赋值为nil.你可以像其他可选值一样，检查弱引用的值是否存在，你讲永远不会访问已销毁的实例的引用。</p>

<p>下面的例子跟上面 <code>person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>    属性被声明为弱引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Person {
</span><span class='line'>    let name: String
</span><span class='line'>    init(name: String) { self.name = name }
</span><span class='line'>    var apartment: Apartment?
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Apartment {
</span><span class='line'>    let unit: String
</span><span class='line'>    init(unit: String) { self.unit = unit }
</span><span class='line'>    weak var tenant: Person?
</span><span class='line'>    deinit { print("Apartment \(unit) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后跟之前一样，建立两个变量(john和unit4A)之间的强引用，并关联两个实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Person?
</span><span class='line'>var unit4A: Apartment?
</span><span class='line'>
</span><span class='line'>john = Person(name: "John Appleseed")
</span><span class='line'>unit4A = Apartment(unit: "4A")
</span><span class='line'>
</span><span class='line'>john!.apartment = unit4A
</span><span class='line'>unit4A!.tenant = john</span></code></pre></td></tr></table></div></figure>


<p>现在，两个关联在一起的实例的引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference01_2x.png" alt="logo" /></p>

<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只持有对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference02_2x.png" alt="logo" /></p>

<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// 打印 “John Appleseed is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>唯一剩下指向<code>Apartment</code>实例的强引用来自变量<code>unit4A</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/weakReference03_2x.png" alt="logo" />
由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>unit4A = nil
</span><span class='line'>// 打印 “Apartment 4A is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>上面的两段代码展示了变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出了“销毁”的信息。
这证明了引用循环被打破了。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型.你可以在声明属性或者变量时，在前面加上关键字 <code>unowned</code>表示这个一个无主引用。</p>

<p>由于无主引用是非可选类型，你不需要再使用它的时候将它展开。无主引用总是可以被直接访问。不过ARC无法再实例被销毁后将无主引用设为<code>nil</code>,因为非可选类型的变量不允许被赋值为<code>nil</code>.</p>

<blockquote><p><strong>注意:</strong>如果你试图在实例被销毁后，访问该实例的无主引用，会出发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。
还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>

<p>下面的例子定义两个类，<code>Customer</code>和<code>CrediCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p></blockquote>

<p><code>Customer</code>和<code>CrediCard</code>之间的关系与前面若引用例子中<code>Apartment</code>和<code>Person</code>的关系略为不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>Card</code>属性，但是<code>CreditCard</code>类有个一非可选类型的<code>Customer</code>属性。</p>

<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联.</p>

<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Customer {
</span><span class='line'>    let name: String
</span><span class='line'>    var card: CreditCard?
</span><span class='line'>    init(name: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>    }
</span><span class='line'>    deinit { print("\(name) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class CreditCard {
</span><span class='line'>    let number: UInt64
</span><span class='line'>    unowned let customer: Customer
</span><span class='line'>    init(number: UInt64, customer: Customer) {
</span><span class='line'>        self.number = number
</span><span class='line'>        self.customer = customer
</span><span class='line'>    }
</span><span class='line'>    deinit { print("Card #\(number) is being deinitialized") }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>下面的代码段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var john: Customer?</span></code></pre></td></tr></table></div></figure>


<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = Customer(name: "John Appleseed")
</span><span class='line'>john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)</span></code></pre></td></tr></table></div></figure>


<p>在你关联两个实例后，它们的引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/unownedReference01_2x.png" alt="logo" /></p>

<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。
由于<code>Customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/unownedReference02_2x.png" alt="logo" /></p>

<p>由于再也没有指向<code>Customer</code>实例的强引用了，该实例被销毁了，其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>john = nil
</span><span class='line'>// 打印 “John Appleseed is being deinitialized”
</span><span class='line'>// 打印 ”Card #1234567890123456 is being deinitialized”</span></code></pre></td></tr></table></div></figure>


<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了"销毁"的信息.</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。
<code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>,并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>,而另一个属性的值不允许为<code>nil</code>,这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p>然而，存在着第三种场景，在这种场景下，两个属性都必须有值，并且初始化完成永远不会为<code>nil</code>.在这种场景下，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>这使两个属性在初始化完成后能被直接访问,同时避免了循环了引用。</p>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>Country</code>属性:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Country {
</span><span class='line'>    let name: String
</span><span class='line'>    var capitalCity: City!
</span><span class='line'>    init(name: String, capitalName: String) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.capitalCity = City(name: capitalName, country: self)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class City {
</span><span class='line'>    let name: String
</span><span class='line'>    unowned let country: Country
</span><span class='line'>    init(name: String, country: Country) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.country = country
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了建了两个类的依赖关系，<code>City</code>的构造函数接受一个<code>Country</code>实例作为参数，并且将实例保存到<code>country</code>属性。</p>

<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。</p>

<p>为了满足这种需求，通过在类型结尾处加上感叹号 （City!） 的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>,但是不需要展开它的值就能访问它.</p>

<p>由于<code>capitalCity</code>默认值是nil,一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这意味着一旦<code>name</code>属性被赋值后，<code>Country</code>的构造函数就能引用并传递隐式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>

<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var country = Country(name: "Canada", capitalName: "Ottawa")
</span><span class='line'>print("\(country.name)'s capital city is called \(country.capitalCity.name)")
</span><span class='line'>// 打印 “Canada's capital city is called Ottawa”</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子中，使用隐式可选值意味着满足了类的构造函数的两个构造阶段的要求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>

<h2>闭包引起的循环强引用</h2>

<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些强引用。</p>

<p>循环强引用还会发生在你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>,或者闭包中调用了实例的某个方法，例如：<code>self.someMethod()</code>,这两种情况都会导致闭包'捕获'self,从而产生循环强引用。</p>

<p>循环强引用的产生，是闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性，实质上，这跟之前的问题是一样的，两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>

<p>Swift提供了一种优雅的方法来解决这个问题，称之为<code>闭包捕获列表</code>.同样地，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的。</p>

<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个<code>HtmlElement</code>的类，用一种简单的模型表示HTML文档中一个单独的元素:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>
</span><span class='line'>    lazy var asHTML: Void -&gt; String = {
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名字，例如代表段落的<code>p</code>,或者代表换行的<code>br</code>,<code>HTMLElement</code>还定义了一个可选属性<code>text</code>,用来设置HTML元素呈现的文本。</p>

<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个lazy属性<code>asHtml</code>,这个属性引用了一个将<code>name</code>和<code>text</code>组合成html字符串片段的闭包。该属性是<code>Void-&gt;String</code>类型，或者理解为'一个没有参数，返回<code>String</code>的函数'。</p>

<p>默认情况下，闭包赋值给了<code>asHtml</code>属性，这个闭包返回一个代表HTml标签的字符串。如果<code>text</code>值存在，该标签就包含<code>text</code>;如果不包含<code>text</code>,该标签就不包含文本，对于段落元素，根据<code>text</code>是否有值，闭包会返回<code>"&lt;p&gt;some text&lt;/p&gt;"</code>或者<code>"&lt;p /&gt;"</code></p>

<p>可以像实例方法那样去命名，使用<code>asHtml</code>属性。然而，由于<code>asHtml</code>是闭包而不是实例方法，如果你想改变特定html元素处理方式的话，可以使用自定义闭包来取代默认值。</p>

<p>例如，可以将一个闭包赋值给<code>asHtml</code> 属性，这个闭包能在<code>text</code>属性是<code>nil</code>时使用默认文本，这是为了避免返回一个空的HTML标签:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let heading = HTMLElement(name: "h1")
</span><span class='line'>let defaultText = "some default text"
</span><span class='line'>heading.asHTML = {
</span><span class='line'>    return "&lt;\(heading.name)&gt;\(heading.text ?? defaultText)&lt;/\(heading.name)&gt;"
</span><span class='line'>}
</span><span class='line'>print(heading.asHTML())
</span><span class='line'>// 打印 “&lt;h1&gt;some default text&lt;/h1&gt;”</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong>
asHtml声明为lazy属性，因为只有当元素确实需要被处理为HTML输出的字符串时，才需要使用<code>asHTML</code>.也就是说，在默认的闭包中可以使用<code>self</code>,
因为只有初始化完成以及<code>self</code>确实存在后，才能访问lazy属性。</p></blockquote>

<p>HTMLElement类只提供了构造函数，通过<code>name</code>和<code>text</code>参数来初始化一个新元素，该类也定义了一个析构函数，当 <code>HTMLElement</code>被销毁时，打印一条消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>print(paragraph!.asHTML())
</span><span class='line'>// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意</strong>
上面的paragraph是可选类型，因此我们可以赋值<code>nil</code>来演示循环强引用</p></blockquote>

<p>不幸的是，上面写的 <code>HTMLElement</code>类产生了类实例和作为<code>asHtml</code>默认是和闭包之间产生了循环强引用，循环强引用如下图所示:</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/closureReferenceCycle01_2x.png" alt="lgoo" /></p>

<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其体内使用了<code>self</code>(引用了<code>self.name</code>和<code>self.text</code>),因此捕获了<code>self</code>,这意味着闭包又反过来持有了<code>HtmlElement</code>实例的强引用。这样两个对象就产生了循环强引用。</p>

<blockquote><p><strong>注意</strong>
随让闭包多次使用了<code>self</code>,它只捕获<code>HTMLElemnt</code>实例的一个强引用。</p></blockquote>

<p>如果设置<code>paragraph</code>变量为<code>nil</code>,打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMlElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>

<pre><code>paragraph = nil
</code></pre>

<p>注意,<code>HTMLElement</code>的析构函数并没有被打印，证明了 <code>HTMLElement</code>实例并没有被销毁.</p>

<h2>解决闭包引起的循环强引用</h2>

<p>在定义闭包时同事定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类之间的循环强引用。捕获列表定义了闭包体内捕获了一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>

<blockquote><p><strong>注意</strong>
Swift有如下要求:只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod()</code>,（而不只是<code>someProperty,someMethod()</code>）,这提醒你可能会一不小心就捕获了<code>self</code></p></blockquote>

<h3>定义捕获列表</h3>

<p>捕获列表中的每一项都由一对元素组成，一个元素是<code>weak</code>或者<code>unowned</code>关键字，另一个元素是类实例的引用(例如self)或初始化过的变量(如 delegate=self.delegate!)</p>

<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var someClosure: (Int, String) -&gt; String = {
</span><span class='line'>    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
</span><span class='line'>    // 这里是闭包的函数体
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文判断，那么可以把捕获列表和关键字 <code>in</code>放在闭包最开始的地方:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lazy var someClosure: Void -&gt; String = {
</span><span class='line'>    [unowned self, weak delegate = self.delegate!] in
</span><span class='line'>    // 这里是闭包的函数体
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>弱引用和无主引用</h3>

<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为<code>无主引用</code>.</p>

<p>相反的，在被捕获的引用可能会变成<code>nil</code>时，将闭包内的捕获定义为<code>弱引用</code>.弱引用总是可选类型，并且当引用的类型被销毁后，弱引用的值会自动设置为<code>nil</code>.这使我们可以在闭包体内简单它们是否存在.</p>

<blockquote><p><strong>注意</strong>
如果被捕获的引用绝对不会变成<code>nil</code>,应该用无主引用，而不是弱引用</p></blockquote>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法，这样编写<code>HTMlElement</code>来避免循环强引用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class HTMLElement {
</span><span class='line'>
</span><span class='line'>    let name: String
</span><span class='line'>    let text: String?
</span><span class='line'>
</span><span class='line'>    lazy var asHTML: Void -&gt; String = {
</span><span class='line'>        [unowned self] in
</span><span class='line'>        if let text = self.text {
</span><span class='line'>            return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>        } else {
</span><span class='line'>            return "&lt;\(self.name) /&gt;"
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    init(name: String, text: String? = nil) {
</span><span class='line'>        self.name = name
</span><span class='line'>        self.text = text
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    deinit {
</span><span class='line'>        print("\(name) is being deinitialized")
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的<code>HTMLElement</code>实现和之前的实现一致，除了在<code>asHTML</code>闭包中多了一个捕获列表。这里捕获列表是<code>[unowded self]</code>,表示将<code>self</code>捕获为无主引用而不是强引用.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>print(paragraph!.asHTML())
</span><span class='line'>// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></code></pre></td></tr></table></div></figure>


<p>使用捕获列表后引用关系如下图所示:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/closureReferenceCycle02_2x.png" alt="logo" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>,并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为nil,<code>HTMLElement</code>实例将会被销毁，并能看到析构函数打印出消息;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>paragraph = nil
</span><span class='line'>// 打印 “p is being deinitialized”</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何用cocoaPod发布框架]]></title>
    <link href="http://andrew-anlu.github.io/blog/2016/03/15/ru-he-yong-cocoapodfa-bu-kuang-jia/"/>
    <updated>2016-03-15T14:54:27+08:00</updated>
    <id>http://andrew-anlu.github.io/blog/2016/03/15/ru-he-yong-cocoapodfa-bu-kuang-jia</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="https://cocoapods.org/">cocoapods</a>是一款强大的框架依赖构建的工具，类似于java中的maven,可以快速搭建你项目中需要的框架，并且它可以自动帮你关联好第三方库之间的依赖关系， 这个很像ubuntu下的apt安装软件，自动帮你下载需要的依赖。</p>

<!--more-->


<p>使用cocoapod可以轻松的创建框架，发布到github上，可以让全世界的开发者下载到你的框架，并且使用，如果能为全世界的开源社区做点贡献，也是一件非常兴奋的事情。</p>

<p>开发静态库有两种方法:</p>

<h2>手动创建框架</h2>

<p>手动创建比较繁琐，而且容易出现问题，大致步骤如下:</p>

<ol>
<li>在xcode中创建一个 <code>Cocoa Touch Static Library</code></li>
<li>创建 <code>Podfile</code>文件</li>
<li>执行 <code>pod install</code>完成整个项目的构建</li>
<li>如果需要demo,手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行 <code>pod install</code>来完成框架的构建</li>
</ol>


<h2>使用Pod创建框架</h2>

<p><code>要求你系统中安装的cocoapod的版本&gt;0.3</code>
电脑环境:</p>

<ol>
<li>OS X ElCapitan 10.11.1</li>
<li>cocoapod 0.39</li>
<li>xcode 7.2</li>
<li>ruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15]</li>
<li>Homebrew 0.9.5 (no git repository)</li>
</ol>


<p>可以通过pod官网提供的命令来创建，让我们快速开始:</p>

<pre><code>pod lib create podLib-Andrew
</code></pre>

<p>这行命令会自动从pod官网的仓库中下载模板
然后它会问你几个问题</p>

<ol>
<li>What language do you want to use?? [ ObjC / Swift ] =>看你需要</li>
<li>Would you like to include a demo application with your library? [ Yes / No ]=>是否包含一个demo，我一般Yes</li>
<li>Which testing frameworks will you use? [ Specta / Kiwi / None ] =>是否需要包含一个测试框架</li>
<li>Would you like to do view based testing? [ Yes / No ]</li>
<li>What is your class prefix? =>类的前缀是什么</li>
</ol>


<p>执行成功之后，会自动用xcode打开工程，如果你的pod版本太新，比如1.0beta版本，可能不会自动创建workspace工作目录，这是由于pod1.0有些语法变了，你要相应的更改Podfile文件中的语法，具体参考官方最新的语法。</p>

<p>最终生成的目录结构如下:
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-0.png" alt="logo" /></p>

<ol>
<li>Example 你的实例代码文件夹</li>
<li>.travis.yml -持续集成的配置文件 <a href="https://travis-ci.org/">travis-ci</a></li>
<li>_Pods.xcproject 工程的一个连接，类似快捷方式</li>
<li>LICENSE 默认是 <a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a></li>
<li>README.md 描述文件</li>
<li>pod 你存储源代码的地方</li>
</ol>


<h2>设置你的框架</h2>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/xcode.png" alt="logo" /></p>

<p>让我们看打开后的工程目录</p>

<ol>
<li>你可以编辑Podspec metadata，包括里面的版本号和介绍等</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#
</span><span class='line'># Be sure to run `pod lib lint podLib-Andrew.podspec' to ensure this is a
</span><span class='line'># valid spec before submitting.
</span><span class='line'>#
</span><span class='line'># Any lines starting with a # are optional, but their use is encouraged
</span><span class='line'># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
</span><span class='line'>#
</span><span class='line'>
</span><span class='line'>Pod::Spec.new do |s|
</span><span class='line'>  s.name             = "podLib-Andrew"
</span><span class='line'>  s.version          = "0.0.1"
</span><span class='line'>  s.summary          = "这是我的第一个框架，希望能够帮到你"
</span><span class='line'>
</span><span class='line'># This description is used to generate tags and improve search results.
</span><span class='line'>#   * Think: What does it do? Why did you write it? What is the focus?
</span><span class='line'>#   * Try to keep it short, snappy and to the point.
</span><span class='line'>#   * Write the description between the DESC delimiters below.
</span><span class='line'>#   * Finally, don't worry about the indent, CocoaPods strips it!  
</span><span class='line'>  s.description      = &lt;&lt;-DESC
</span><span class='line'>                        "这是我的第一个框架，希望能够帮到你"
</span><span class='line'>                       DESC
</span><span class='line'>
</span><span class='line'>  s.homepage         = "https://github.com/andrew-anlu/podLib-Andrew"
</span><span class='line'>  # s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"
</span><span class='line'>  s.license          = 'MIT'
</span><span class='line'>  s.author           = { "Andrew" =&gt; "anluanlu123@163.com" }
</span><span class='line'>  s.source           = { :git =&gt; "https://github.com/andrew-anlu/podLib-Andrew.git", :tag =&gt; s.version.to_s }
</span><span class='line'>  # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'
</span><span class='line'>
</span><span class='line'>  s.platform     = :ios, '7.0'
</span><span class='line'>  s.requires_arc = true
</span><span class='line'>
</span><span class='line'>  s.source_files = 'Pod/Classes/**/*'
</span><span class='line'>  s.resource_bundles = {
</span><span class='line'>    'podLib-Andrew' =&gt; ['Pod/Assets/*.png']
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  # s.public_header_files = 'Pod/Classes/**/*.h'
</span><span class='line'>  # s.frameworks = 'UIKit', 'MapKit'
</span><span class='line'>  # s.dependency 'AFNetworking', '~&gt; 2.3'
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>s.name是我们库的名称</li>
<li>s.version是库原代码版本号</li>
<li>s.summary是对我们库的一个简单的介绍</li>
<li>s.homepage声明库的主页</li>
<li>s.license是所采用的授权版本</li>
<li>s.author是库的作者</li>
<li>s.platform是我们库所支持的软件平台，这在我们最后提交进行编译 时有用</li>
<li>s.source声明原代码的地址.</li>
</ul>


<p>按照默认配置，类库的源文件将位于Pod/Classes文件夹下，资源文件位于Pod/Assets文件夹下，可以修改s.source_files和s.resource_bundles来更换存放目录。s.public_header_files用来指定头文件的搜索位置。
s.frameworks和s.libraries指定依赖的SDK中的framework和类库，需要注意，依赖项不仅要包含你自己类库的依赖，还要包括所有第三方类库的依赖，只有这样当你的类库打包成.a或.framework时才能让其他项目正常使用.</p>

<h2>建立远程版本库</h2>

<p>现在让我们去github上建立一个仓库，名字和工程的名字保持一致<code>podLib-Andrew</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-1.png" alt="pic" /></p>

<p>切换到终端，进入刚才的工程的根目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//添加到本地
</span><span class='line'>git add . 
</span><span class='line'>
</span><span class='line'>//提交到本地仓库
</span><span class='line'>git commit -m "initial commit"
</span><span class='line'>
</span><span class='line'>//和远程仓库建立关联关系
</span><span class='line'>git remote add origin git@github.com:andrew-anlu/podLib-Andrew.git
</span><span class='line'>
</span><span class='line'>//执行更细远程仓库的数据
</span><span class='line'>git pull origin master
</span><span class='line'>
</span><span class='line'>//重新执行添加
</span><span class='line'>git add .
</span><span class='line'>
</span><span class='line'>git commit -m "commit"
</span><span class='line'>
</span><span class='line'>//提交代码到远程仓库
</span><span class='line'>git push origin master
</span></code></pre></td></tr></table></div></figure>


<h2>编写源代码</h2>

<p>在Pod的classes文件夹中新建一个类 <code>StringUtils</code>
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-2.png" alt="logo" /></p>

<p>StringUtils.h</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt;
</span><span class='line'>
</span><span class='line'>@interface StringUtils : NSObject
</span><span class='line'>+(void)sayHello;
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>StringUtils.m</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "StringUtils.h"
</span><span class='line'>
</span><span class='line'>@implementation StringUtils
</span><span class='line'>+(void)sayHello{
</span><span class='line'>    NSLog(@"Hello world");
</span><span class='line'>}
</span><span class='line'>@end
</span></code></pre></td></tr></table></div></figure>


<p>注意源代码的存放位置一定要和 .podspec中的 s.source 路径要一致，不然不会起作用的。
运行 <code>pod install</code>,也许你也注意到了，每次添加或者修改类，或者添加图片等操作，都要执行 <code>pod install</code>或者<code>pod update</code>来更新应用。</p>

<blockquote><p><em>注意</em>
如果是生成swift功能，在Podfile文件中一定要有 <code>use_frameworks!</code> ，这行命令是指定框框是动态框架，因为swift要求要么依赖全部是动态框架，要么全部不是，所以如果注释掉，会报编译报错；</p>

<p>另外，swift工程中的源文件，如果想让外部调用的话，一定要声明成<strong><code>public</code></strong>,
这一点很重要。</p></blockquote>

<h3>Note</h3>

<p>添加完源代码之后，如果要在demo工程中引用，发现是引用不到的，原因就是你必须要把类库加入到demo工程中才行，默认在Podfile文件中生成的类库是动态类库，即 .framework的。
我尝试了好久，一直引用不了，于是就改成生成.a静态库的方式，完美引用。</p>

<p>修改成.a类库的方法就是在 Podfile中，把<code>#use_frameworks!</code> 注释掉就行了，这行代码默认就是生成动态类库的。
<img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160317-0.png" alt="logo" /></p>

<h3>加入持续集成(Travis CI)</h3>

<p>这个模板包含了一个 <code>.travis.yml</code>文件，加入你在Github上开关了你的框架，打开 <a href="https://travis-ci.org/">travis-ci官网</a>，并且用github账号登录并且同步，打开你要开源的项目，设置 on</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/travi.png" alt="lgogo" /></p>

<h3>提交本地代码库</h3>

<p>修改podLib-Andrew.podspec 中的 <code>s.source</code>,</p>

<pre><code>  s.source           = { :git =&gt; "https://github.com/andrew-anlu/podLib-Andrew.git", :tag =&gt; s.version.to_s }
</code></pre>

<p>提交代码，并要打上tag</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m "commit v0.0.1"
</span><span class='line'>git tag 0.0.1
</span><span class='line'>git tag -a 0.0.1 -m "v0.0.1"</span></code></pre></td></tr></table></div></figure>


<h3>验证类库</h3>

<p>开发完静态类库之后，需要运行 <code>pod lib lint</code>验证一下类库是否符合 pod的要求。<code>pod spec lint</code>也是用来验证是否有效，区别在于</p>

<ol>
<li>pod lib lint  不访问网络，只在本地验证</li>
<li>pod spec lint 检查远程仓库和远程的tag</li>
</ol>


<p>pod官方推荐用<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk">trunk</a>来发布框架，<a href="https://guides.cocoapods.org/making/getting-setup-with-trunk">trunk入门</a></p>

<p>假如你只想发布一个私人的框架，请看这个教程 <a href="https://guides.cocoapods.org/making/private-cocoapods">Private Specs Repos</a>,如果你想发布一个已经存在的私有框架，可以用下面的命令</p>

<pre><code>pod repo push SPEC_REPO *.podspec --verbose
</code></pre>

<h2>发布框架</h2>

<pre><code>pod trunk push podLib-Andrew.podspec
</code></pre>

<p>如果发布成功，执行 <code>pod search podLib</code>
就会搜到你的框架</p>

<p><img src="http://7xkxhx.com1.z0.glb.clouddn.com/QQ20160315-4.png" alt="logo" /></p>

<h1>Done</h1>

<p>👍</p>
]]></content>
  </entry>
  
</feed>
